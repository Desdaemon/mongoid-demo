# typed: strong
# A class which sends values to the database as Strings but returns them to the user as Symbols.
module Mongoid
  extend Mongoid
  extend Forwardable
  extend Mongoid::Loggable
  PLATFORM_DETAILS = T.let("mongoid-#{VERSION}".freeze, T.untyped)
  MONGODB_VERSION = T.let("2.6.0", T.untyped)
  VERSION = T.let("7.3.0.alpha", T.untyped)

  # Sets the Mongoid configuration options. Best used by passing a block.
  # 
  # _@return_ — The configuration object.
  # 
  # Set up configuration options.
  # ```ruby
  # Mongoid.configure do |config|
  #   config.connect_to("mongoid_test")
  # 
  #   config.clients.default = {
  #     hosts: ["localhost:27017"],
  #     database: "mongoid_test",
  #   }
  # end
  # ```
  sig { returns(Config) }
  def configure; end

  # sord warn - Mongo::Client wasn't able to be resolved to a constant in this project
  # Convenience method for getting the default client.
  # 
  # _@return_ — The default client.
  # 
  # Get the default client.
  # ```ruby
  # Mongoid.default_client
  # ```
  sig { returns(::Mongo::Client) }
  def default_client; end

  # Disconnect all active clients.
  # 
  # _@return_ — True.
  # 
  # Disconnect all active clients.
  # ```ruby
  # Mongoid.disconnect_clients
  # ```
  sig { returns(T::Boolean) }
  def disconnect_clients; end

    # sord warn - Mongo::Client wasn't able to be resolved to a constant in this project
  # Convenience method for getting a named client.
  # 
  # _@return_ — The named client.
  # 
  # Get a named client.
  # ```ruby
  # Mongoid.client(:default)
  # ```
  sig { params(name: T.untyped).returns(::Mongo::Client) }
  def client(name); end

  # Get the logger.
  # 
  # _@return_ — The logger.
  # 
  # Get the logger.
  # ```ruby
  # Loggable.logger
  # ```
  # 
  # _@note_ — Will try to grab Rails' logger first before creating a new logger
  # with stderr.
  sig { returns(Logger) }
  def self.logger; end

  # Set the logger.
  # 
  # _@param_ `logger` — The logger to set.
  # 
  # _@return_ — The new logger.
  # 
  # Set the logger.
  # ```ruby
  # Loggable.logger = Logger.new(STDERR)
  # ```
  sig { params(logger: Logger).returns(Logger) }
  def self.logger=(logger); end

  # Gets the default Mongoid logger - stderr.
  # 
  # _@return_ — The default logger.
  # 
  # Get the default logger.
  # ```ruby
  # Loggable.default_logger
  # ```
  sig { returns(Logger) }
  def self.default_logger; end

  # Get the Rails logger if loaded in a Rails application, otherwise nil.
  # 
  # _@return_ — The Rails logger.
  # 
  # Get Rails' logger.
  # ```ruby
  # Loggable.rails_logger
  # ```
  sig { returns(Logger) }
  def self.rails_logger; end

  # Sets the Mongoid configuration options. Best used by passing a block.
  # 
  # _@return_ — The configuration object.
  # 
  # Set up configuration options.
  # ```ruby
  # Mongoid.configure do |config|
  #   config.connect_to("mongoid_test")
  # 
  #   config.clients.default = {
  #     hosts: ["localhost:27017"],
  #     database: "mongoid_test",
  #   }
  # end
  # ```
  sig { returns(Config) }
  def self.configure; end

  # sord warn - Mongo::Client wasn't able to be resolved to a constant in this project
  # Convenience method for getting the default client.
  # 
  # _@return_ — The default client.
  # 
  # Get the default client.
  # ```ruby
  # Mongoid.default_client
  # ```
  sig { returns(::Mongo::Client) }
  def self.default_client; end

  # Disconnect all active clients.
  # 
  # _@return_ — True.
  # 
  # Disconnect all active clients.
  # ```ruby
  # Mongoid.disconnect_clients
  # ```
  sig { returns(T::Boolean) }
  def self.disconnect_clients; end

    # sord warn - Mongo::Client wasn't able to be resolved to a constant in this project
  # Convenience method for getting a named client.
  # 
  # _@return_ — The named client.
  # 
  # Get a named client.
  # ```ruby
  # Mongoid.client(:default)
  # ```
  sig { params(name: T.untyped).returns(::Mongo::Client) }
  def self.client(name); end

  # Module used to prepend the discriminator key assignment function to change
  # the value assigned to the discriminator key to a string.
  # 
  # @api private
  module GlobalDiscriminatorKeyAssignment
            sig { params(value: T.untyped).returns(T.untyped) }
    def discriminator_key=(value); end

    # This class is used for obtaining the method definition location for
    # Mongoid methods.
    class InvalidFieldHost
      include Mongoid::Document
      ILLEGAL_KEY = T.let(/(\A[$])|(\.)/.freeze, T.untyped)
      MODULES = T.let([
  Atomic,
  Attributes,
  Copyable,
  Changeable,
  Evolvable,
  Fields,
  Indexable,
  Interceptable,
  Matchable,
  Persistable,
  Association,
  Reloadable,
  Scopable,
  Serializable,
  Clients,
  Clients::Options,
  Shardable,
  Stateful,
  Cacheable,
  Threaded::Lifecycle,
  Traversable,
  Validatable,
  Equality,
  Association::Referenced::Syncable,
  Association::Macros,
  ActiveModel::Model,
  ActiveModel::Validations
], T.untyped)
      RESERVED_METHOD_NAMES = T.let([ :fields,
  :aliased_fields,
  :localized_fields,
  :index_specifications,
  :shard_key_fields,
  :nested_attributes,
  :readonly_attributes,
  :storage_options,
  :cascades,
  :cyclic,
  :cache_timestamp_format
], T.untyped)
      CALLBACKS = T.let([
  :after_build,
  :after_create,
  :after_destroy,
  :after_find,
  :after_initialize,
  :after_save,
  :after_touch,
  :after_update,
  :after_upsert,
  :after_validation,
  :around_create,
  :around_destroy,
  :around_save,
  :around_update,
  :around_upsert,
  :before_create,
  :before_destroy,
  :before_save,
  :before_update,
  :before_upsert,
  :before_validation
].freeze, T.untyped)
      MACRO_MAPPING = T.let({
    embeds_one: Association::Embedded::EmbedsOne,
    embeds_many: Association::Embedded::EmbedsMany,
    embedded_in: Association::Embedded::EmbeddedIn,
    has_one: Association::Referenced::HasOne,
    has_many: Association::Referenced::HasMany,
    has_and_belongs_to_many: Association::Referenced::HasAndBelongsToMany,
    belongs_to: Association::Referenced::BelongsTo,
}.freeze, T.untyped)
      STRATEGIES = T.let([
    :delete_all,
    :destroy,
    :nullify,
    :restrict_with_exception,
    :restrict_with_error
], T.untyped)
      LIST_OPERATIONS = T.let([ "$addToSet", "$push", "$pull", "$pullAll" ].freeze, T.untyped)
      StringifiedSymbol = T.let(Mongoid::StringifiedSymbol, T.untyped)
      Boolean = T.let(Mongoid::Boolean, T.untyped)
      TYPE_MAPPINGS = T.let({
  array: Array,
  big_decimal: BigDecimal,
  binary: BSON::Binary,
  boolean: Mongoid::Boolean,
  date: Date,
  date_time: DateTime,
  float: Float,
  hash: Hash,
  integer: Integer,
  object_id: BSON::ObjectId,
  range: Range,
  regexp: Regexp,
  set: Set,
  string: String,
  stringified_symbol: StringifiedSymbol,
  symbol: Symbol,
  time: Time
}.with_indifferent_access, T.untyped)
      IDS = T.let([ :_id, '_id', ].freeze, T.untyped)
      CREATE_LOCK = T.let(Mutex.new, T.untyped)
      UPDATES = T.let([
  :atomic_array_pushes,
  :atomic_array_pulls,
  :atomic_array_add_to_sets,
  :atomic_pulls,
  :delayed_atomic_sets,
  :delayed_atomic_pulls,
  :delayed_atomic_unsets
], T.untyped)

      # Freezes the internal attributes of the document.
      # 
      # _@return_ — The document.
      # 
      # Freeze the document
      # ```ruby
      # document.freeze
      # ```
      sig { returns(Document) }
      def freeze; end

      # Checks if the document is frozen
      # 
      # _@return_ — True if frozen, else false.
      # 
      # Check if frozen
      # ```ruby
      # document.frozen?
      # ```
      sig { returns(T::Boolean) }
      def frozen?; end

      # Delegates to identity in order to allow two records of the same identity
      # to work with something like:
      # 
      #   [ Person.find(1), Person.find(2), Person.find(3) ] &
      #   [ Person.find(1), Person.find(4) ] # => [ Person.find(1) ]
      # 
      # _@return_ — The hash of the document's identity.
      # 
      # Get the hash.
      # ```ruby
      # document.hash
      # ```
      sig { returns(Integer) }
      def hash; end

      # A Document's is identified absolutely by its class and database id:
      # 
      # Person.first.identity #=> [Person, BSON::ObjectId('4f775130a04745933a000003')]
      # 
      # _@return_ — An array containing [document.class, document._id]
      # 
      # Get the identity
      # ```ruby
      # document.identity
      # ```
      sig { returns(T::Array[T.untyped]) }
      def identity; end

      # Instantiate a new +Document+, setting the Document's attributes if
      # given. If no attributes are provided, they will be initialized with
      # an empty +Hash+.
      # 
      # If a primary key is defined, the document's id will be set to that key,
      # otherwise it will be set to a fresh +BSON::ObjectId+ string.
      # 
      # _@param_ `attrs` — The attributes to set up the document with.
      # 
      # _@return_ — A new document.
      # 
      # Create a new document.
      # ```ruby
      # Person.new(:title => "Sir")
      # ```
      sig { params(attrs: T.nilable(T::Hash[T.untyped, T.untyped])).void }
      def initialize(attrs = nil); end

      # Return the model name of the document.
      # 
      # _@return_ — The model name.
      # 
      # Return the model name.
      # ```ruby
      # document.model_name
      # ```
      sig { returns(String) }
      def model_name; end

      # Return the key value for the document.
      # 
      # _@return_ — The id of the document or nil if new.
      # 
      # Return the key.
      # ```ruby
      # document.to_key
      # ```
      sig { returns(String) }
      def to_key; end

      # Return an array with this +Document+ only in it.
      # 
      # _@return_ — An array with the document as its only item.
      # 
      # Return the document in an array.
      # ```ruby
      # document.to_a
      # ```
      sig { returns(T::Array[Document]) }
      def to_a; end

      # Return a hash of the entire document hierarchy from this document and
      # below. Used when the attributes are needed for everything and not just
      # the current document.
      # 
      # _@return_ — A hash of all attributes in the hierarchy.
      # 
      # Get the full hierarchy.
      # ```ruby
      # person.as_document
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def as_document; end

      # Calls #as_json on the document with additional, Mongoid-specific options.
      # 
      # _@param_ `options` — The options.
      # 
      # _@return_ — The document as json.
      # 
      # Get the document as json.
      # ```ruby
      # document.as_json(compact: true)
      # ```
      # 
      # _@note_ — Rails 6 changes return value of as_json for non-primitive types
      # such as BSON::ObjectId. In Rails <= 5, as_json returned these as
      # instances of the class. In Rails 6, these are returned serialized to
      # primitive types (e.g. {"$oid"=>"5bcfc40bde340b37feda98e9"}).
      # See https://github.com/rails/rails/commit/2e5cb980a448e7f4ab00df6e9ad4c1cc456616aa
      # for more information.
      sig { params(options: T.nilable(T::Hash[T.untyped, T.untyped])).returns(T::Hash[T.untyped, T.untyped]) }
      def as_json(options = nil); end

      # Returns an instance of the specified class with the attributes,
      # errors, and embedded documents of the current document.
      # 
      # _@param_ `klass` — The class to become.
      # 
      # _@return_ — An instance of the specified class.
      # 
      # Return a subclass document as a superclass instance.
      # ```ruby
      # manager.becomes(Person)
      # ```
      sig { params(klass: Class).returns(Document) }
      def becomes(klass); end

      # Implement this for calls to flatten on array.
      # 
      # _@return_ — Always nil.
      # 
      # Get the document as an array.
      # ```ruby
      # document.to_ary
      # ```
      sig { returns(T.nilable(T.any())) }
      def to_ary; end

      # Returns the logger
      # 
      # _@return_ — The configured logger or a default Logger instance.
      sig { returns(Logger) }
      def logger; end

      # Get the name of the model used in caching.
      # 
      # _@return_ — The model key.
      # 
      # Get the model key.
      # ```ruby
      # model.model_key
      # ```
      sig { returns(String) }
      def model_key; end

            sig { returns(T.untyped) }
      def as_attributes; end

      # Touch the document, in effect updating its updated_at timestamp and
      # optionally the provided field to the current time. If any belongs_to
      # associations exist with a touch option, they will be updated as well.
      # 
      # _@param_ `field` — The name of an additional field to update.
      # 
      # _@return_ — false if record is new_record otherwise true.
      # 
      # Update the updated_at timestamp.
      # ```ruby
      # document.touch
      # ```
      # 
      # Update the updated_at and provided timestamps.
      # ```ruby
      # document.touch(:audited)
      # ```
      # 
      # _@note_ — This will not autobuild associations if those options are set.
      sig { params(field: T.nilable(Symbol)).returns(T::Boolean) }
      def touch(field = nil); end

      # Default comparison is via the string version of the id.
      # 
      # _@param_ `other` — The document to compare with.
      # 
      # _@return_ — -1, 0, 1.
      # 
      # Compare two documents.
      # ```ruby
      # person <=> other_person
      # ```
      sig { params(other: Document).returns(Integer) }
      def <=>(other); end

      # Performs equality checking on the document ids. For more robust
      # equality checking please override this method.
      # 
      # _@param_ `other` — The other object to compare with.
      # 
      # _@return_ — True if the ids are equal, false if not.
      # 
      # Compare for equality.
      # ```ruby
      # document == other
      # ```
      sig { params(other: T.any(Document, Object)).returns(T::Boolean) }
      def ==(other); end

      # Performs class equality checking.
      # 
      # _@param_ `other` — The other object to compare with.
      # 
      # _@return_ — True if the classes are equal, false if not.
      # 
      # Compare the classes.
      # ```ruby
      # document === other
      # ```
      sig { params(other: T.any(Document, Object)).returns(T::Boolean) }
      def ===(other); end

      # Delegates to ==. Used when needing checks in hashes.
      # 
      # _@param_ `other` — The object to check against.
      # 
      # _@return_ — True if equal, false if not.
      # 
      # Perform equality checking.
      # ```ruby
      # document.eql?(other)
      # ```
      sig { params(other: T.any(Document, Object)).returns(T::Boolean) }
      def eql?(other); end

      # Clone or dup the current +Document+. This will return all attributes with
      # the exception of the document's id, and will reset all the
      # instance variables.
      # 
      # This clone also includes embedded documents.
      # 
      # _@return_ — The new document.
      # 
      # Clone the document.
      # ```ruby
      # document.clone
      # ```
      sig { returns(Document) }
      def clone; end

            # Clone the document attributes
      # 
      # clone document
      # ```ruby
      # model.clone_document
      # ```
      sig { returns(T.untyped) }
      def clone_document; end

                  # When cloning, if the document has localized fields we need to ensure they
      # are properly processed in the clone.
      # 
      # _@param_ `attrs` — The attributes.
      # 
      # Process localized attributes.
      # ```ruby
      # model.process_localized_attributes(attributes)
      # ```
      sig { params(klass: T.untyped, attrs: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
      def process_localized_attributes(klass, attrs); end

      # Is the provided type of callback executable by this document?
      # 
      # _@param_ `kind` — The type of callback.
      # 
      # _@return_ — If the callback can be executed.
      # 
      # Is the callback executable?
      # ```ruby
      # document.callback_executable?(:save)
      # ```
      sig { params(kind: Symbol).returns(T::Boolean) }
      def callback_executable?(kind); end

      # Is the document currently in a state that could potentially require
      # callbacks to be executed?
      # 
      # _@param_ `kind` — The callback kind.
      # 
      # _@return_ — If the document is in a callback state.
      # 
      # Is the document in a callback state?
      # ```ruby
      # document.in_callback_state?(:update)
      # ```
      sig { params(kind: Symbol).returns(T::Boolean) }
      def in_callback_state?(kind); end

      # Run only the after callbacks for the specific event.
      # 
      # _@param_ `kinds` — The events that are occurring.
      # 
      # _@return_ — The result of the chain executing.
      # 
      # Run only the after save callbacks.
      # ```ruby
      # model.run_after_callbacks(:save)
      # ```
      # 
      # _@note_ — ActiveSupport does not allow this type of behavior by default, so
      # Mongoid has to get around it and implement itself.
      sig { params(kinds: T::Array[Symbol]).returns(Object) }
      def run_after_callbacks(*kinds); end

      # Run only the before callbacks for the specific event.
      # 
      # _@param_ `kinds` — The events that are occurring.
      # 
      # _@return_ — The result of the chain executing.
      # 
      # Run only the before save callbacks.
      # ```ruby
      # model.run_before_callbacks(:save, :create)
      # ```
      # 
      # _@note_ — ActiveSupport does not allow this type of behavior by default, so
      # Mongoid has to get around it and implement itself.
      sig { params(kinds: T::Array[Symbol]).returns(Object) }
      def run_before_callbacks(*kinds); end

      # Run the callbacks for the document. This overrides active support's
      # functionality to cascade callbacks to embedded documents that have been
      # flagged as such.
      # 
      # _@param_ `kind` — The type of callback to execute.
      # 
      # _@param_ `args` — Any options.
      # 
      # _@return_ — The document
      # 
      # Run the callbacks.
      # ```ruby
      # run_callbacks :save do
      #   save!
      # end
      # ```
      sig { params(kind: Symbol, args: T::Array[T.untyped], block: T.untyped).returns(Document) }
      def run_callbacks(kind, *args, &block); end

      # We need to hook into this for autosave, since we don't want it firing if
      # the before callbacks were halted.
      # 
      # _@return_ — If a before callback was halted.
      # 
      # Was a before callback halted?
      # ```ruby
      # document.before_callback_halted?
      # ```
      sig { returns(T::Boolean) }
      def before_callback_halted?; end

            # Get all the child embedded documents that are flagged as cascadable.
      # 
      # _@param_ `kind` — The type of callback.
      # 
      # _@return_ — The children.
      # 
      # Get all the cascading children.
      # ```ruby
      # document.cascadable_children(:update)
      # ```
      sig { params(kind: Symbol, children: T.untyped).returns(T::Array[Document]) }
      def cascadable_children(kind, children = Set.new); end

            # Determine if the child should fire the callback.
      # 
      # _@param_ `kind` — The type of callback.
      # 
      # _@param_ `child` — The child document.
      # 
      # _@return_ — If the child should fire the callback.
      # 
      # Should the child fire the callback?
      # ```ruby
      # document.cascadable_child?(:update, doc)
      # ```
      sig { params(kind: Symbol, child: Document, association: T.untyped).returns(T::Boolean) }
      def cascadable_child?(kind, child, association); end

      # Get the name of the callback that the child should fire. This changes
      # depending on whether or not the child is new. A persisted parent with a
      # new child would fire :update from the parent, but needs to fire :create
      # on the child.
      # 
      # _@param_ `kind` — The type of callback.
      # 
      # _@param_ `child` — The child document
      # 
      # _@return_ — The name of the callback.
      # 
      # Get the callback type.
      # ```ruby
      # document.child_callback_type(:update, doc)
      # ```
      sig { params(kind: Symbol, child: Document).returns(Symbol) }
      def child_callback_type(kind, child); end

            # We need to hook into this for autosave, since we don't want it firing if
      # the before callbacks were halted.
      # 
      # _@param_ `filter` — The callback that halted.
      # 
      # _@param_ `name` — The name of the callback that was halted (requires Rails 6.1+)
      # 
      # Hook into the halt.
      # ```ruby
      # document.halted_callback_hook(filter)
      # ```
      sig { params(filter: Symbol, name: T.nilable(Symbol)).returns(T.untyped) }
      def halted_callback_hook(filter, name = nil); end

      # Run only the callbacks for the target location (before, after, around)
      # and kind (save, update, create).
      # 
      # _@param_ `place` — The time to run, :before, :after, :around.
      # 
      # _@param_ `kind` — The type of callback, :save, :create, :update.
      # 
      # _@return_ — The result of the chain execution.
      # 
      # Run the targeted callbacks.
      # ```ruby
      # model.run_targeted_callbacks(:before, :save)
      # ```
      sig { params(place: Symbol, kind: Symbol).returns(Object) }
      def run_targeted_callbacks(place, kind); end

            # Begin the associated validation.
      # 
      # Begin validation.
      # ```ruby
      # document.begin_validate
      # ```
      sig { returns(T.untyped) }
      def begin_validate; end

            # Exit the associated validation.
      # 
      # Exit validation.
      # ```ruby
      # document.exit_validate
      # ```
      sig { returns(T.untyped) }
      def exit_validate; end

      # Given the provided options, are we performing validations?
      # 
      # _@param_ `options` — The options to check.
      # 
      # _@return_ — If we are validating.
      # 
      # Are we performing validations?
      # ```ruby
      # document.performing_validations?(validate: true)
      # ```
      sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
      def performing_validations?(options = {}); end

      # Overrides the default ActiveModel behavior since we need to handle
      # validations of associations slightly different than just calling the
      # getter.
      # 
      # _@param_ `attr` — The name of the field or association.
      # 
      # _@return_ — The value of the field or the association.
      # 
      # Read the value.
      # ```ruby
      # person.read_attribute_for_validation(:addresses)
      # ```
      sig { params(attr: Symbol).returns(Object) }
      def read_attribute_for_validation(attr); end

      # Determine if the document is valid.
      # 
      # _@param_ `context` — The optional validation context.
      # 
      # _@return_ — True if valid, false if not.
      # 
      # Is the document valid?
      # ```ruby
      # person.valid?
      # ```
      # 
      # Is the document valid in a context?
      # ```ruby
      # person.valid?(:create)
      # ```
      sig { params(context: T.nilable(Symbol)).returns(T::Boolean) }
      def valid?(context = nil); end

      # Used to prevent infinite loops in associated validations.
      # 
      # _@return_ — Has the document already been validated?
      # 
      # Is the document validated?
      # ```ruby
      # document.validated?
      # ```
      sig { returns(T::Boolean) }
      def validated?; end

      # Are we currently performing a validation that has a query?
      # 
      # _@return_ — If we are validating with a query.
      # 
      # Are we validating with a query?
      # ```ruby
      # document.validating_with_query?
      # ```
      sig { returns(T::Boolean) }
      def validating_with_query?; end

            sig { returns(T.untyped) }
      def _parent; end

                  sig { params(p: T.untyped).returns(T.untyped) }
      def _parent=(p); end

      # Get all child +Documents+ to this +Document+, going n levels deep if
      # necessary. This is used when calling update persistence operations from
      # the root document, where changes in the entire tree need to be
      # determined. Note that persistence from the embedded documents will
      # always be preferred, since they are optimized calls... This operation
      # can get expensive in domains with large hierarchies.
      # 
      # _@return_ — All child documents in the hierarchy.
      # 
      # Get all the document's children.
      # ```ruby
      # person._children
      # ```
      sig { returns(T::Array[Document]) }
      def _children; end

      # Collect all the children of this document.
      # 
      # _@return_ — The children.
      # 
      # Collect all the children.
      # ```ruby
      # document.collect_children
      # ```
      sig { returns(T::Array[Document]) }
      def collect_children; end

      # Marks all children as being persisted.
      # 
      # _@return_ — The flagged children.
      # 
      # Flag all the children.
      # ```ruby
      # document.flag_children_persisted
      # ```
      sig { returns(T::Array[Document]) }
      def flag_children_persisted; end

      # Determines if the document is a subclass of another document.
      # 
      # _@return_ — True if hereditary, false if not.
      # 
      # Check if the document is a subclass
      # ```ruby
      # Square.new.hereditary?
      # ```
      sig { returns(T::Boolean) }
      def hereditary?; end

      # Sets up a child/parent association. This is used for newly created
      # objects so they can be properly added to the graph.
      # 
      # _@param_ `document` — The parent document.
      # 
      # _@return_ — The parent document.
      # 
      # Set the parent document.
      # ```ruby
      # document.parentize(parent)
      # ```
      sig { params(document: Document).returns(Document) }
      def parentize(document); end

            # Remove a child document from this parent. If an embeds one then set to
      # nil, otherwise remove from the embeds many.
      # 
      # This is called from the +RemoveEmbedded+ persistence command.
      # 
      # _@param_ `child` — The child (embedded) document to remove.
      # 
      # Remove the child.
      # ```ruby
      # document.remove_child(child)
      # ```
      sig { params(child: Document).returns(T.untyped) }
      def remove_child(child); end

      # After children are persisted we can call this to move all their changes
      # and flag them as persisted in one call.
      # 
      # _@return_ — The children.
      # 
      # Reset the children.
      # ```ruby
      # document.reset_persisted_children
      # ```
      sig { returns(T::Array[Document]) }
      def reset_persisted_children; end

      # Resets the memoized children on the object. Called internally when an
      # embedded array changes size.
      # 
      # _@return_ — nil.
      # 
      # Reset the memoized children.
      # ```ruby
      # document._reset_memoized_children!
      # ```
      sig { returns(T.nilable(T.any())) }
      def _reset_memoized_children!; end

      # Return the root document in the object graph. If the current document
      # is the root object in the graph it will return self.
      # 
      # _@return_ — The root document in the hierarchy.
      # 
      # Get the root document in the hierarchy.
      # ```ruby
      # document._root
      # ```
      sig { returns(Document) }
      def _root; end

      # Is this document the root document of the hierarchy?
      # 
      # _@return_ — If the document is the root.
      # 
      # Is the document the root?
      # ```ruby
      # document._root?
      # ```
      sig { returns(T::Boolean) }
      def _root?; end

      # Begin the assignment of attributes. While in this block embedded
      # documents will not autosave themselves in order to allow the document to
      # be in a valid state.
      # 
      # _@return_ — The yielded value.
      # 
      # Execute the assignment.
      # ```ruby
      # _assigning do
      #   person.attributes = { :addresses => [ address ] }
      # end
      # ```
      sig { returns(Object) }
      def _assigning; end

      # Is the current thread in assigning mode?
      # 
      # _@return_ — If the thread is assigning.
      # 
      # Is the current thread in assigning mode?
      # ```ruby
      # proxy._assigning?
      # ```
      sig { returns(T::Boolean) }
      def _assigning?; end

      # Execute a block in binding mode.
      # 
      # _@return_ — The return value of the block.
      # 
      # Execute in binding mode.
      # ```ruby
      # binding do
      #   relation.push(doc)
      # end
      # ```
      sig { returns(Object) }
      def _binding; end

      # Is the current thread in binding mode?
      # 
      # _@return_ — If the thread is binding.
      # 
      # Is the current thread in binding mode?
      # ```ruby
      # proxy.binding?
      # ```
      sig { returns(T::Boolean) }
      def _binding?; end

      # Execute a block in building mode.
      # 
      # _@return_ — The return value of the block.
      # 
      # Execute in building mode.
      # ```ruby
      # _building do
      #   relation.push(doc)
      # end
      # ```
      sig { returns(Object) }
      def _building; end

      # Is the current thread in building mode?
      # 
      # _@return_ — If the thread is building.
      # 
      # Is the current thread in building mode?
      # ```ruby
      # proxy._building?
      # ```
      sig { returns(T::Boolean) }
      def _building?; end

      # Is the current thread in creating mode?
      # 
      # _@return_ — If the thread is creating.
      # 
      # Is the current thread in creating mode?
      # ```ruby
      # proxy.creating?
      # ```
      sig { returns(T::Boolean) }
      def _creating?; end

      # Execute a block in loading mode.
      # 
      # _@return_ — The return value of the block.
      # 
      # Execute in loading mode.
      # ```ruby
      # _loading do
      #   relation.push(doc)
      # end
      # ```
      sig { returns(Object) }
      def _loading; end

      # Is the current thread in loading mode?
      # 
      # _@return_ — If the thread is loading.
      # 
      # Is the current thread in loading mode?
      # ```ruby
      # proxy._loading?
      # ```
      sig { returns(T::Boolean) }
      def _loading?; end

      # Print out the cache key. This will append different values on the
      # plural model name.
      # 
      # If new_record?     - will append /new
      # If not             - will append /id-updated_at.to_s(cache_timestamp_format)
      # Without updated_at - will append /id
      # 
      # This is usually called insode a cache() block
      # 
      # _@return_ — the string with or without updated_at
      # 
      # Returns the cache key
      # ```ruby
      # document.cache_key
      # ```
      sig { returns(String) }
      def cache_key; end

      # Returns true if the +Document+ has not been persisted to the database,
      # false if it has. This is determined by the variable @new_record
      # and NOT if the object has an id.
      # 
      # _@return_ — True if new, false if not.
      # 
      # Is the document new?
      # ```ruby
      # person.new_record?
      # ```
      sig { returns(T::Boolean) }
      def new_record?; end

      # Checks if the document has been saved to the database. Returns false
      # if the document has been destroyed.
      # 
      # _@return_ — True if persisted, false if not.
      # 
      # Is the document persisted?
      # ```ruby
      # person.persisted?
      # ```
      sig { returns(T::Boolean) }
      def persisted?; end

      # Returns whether or not the document has been flagged for deletion, but
      # not destroyed yet. Used for atomic pulls of child documents.
      # 
      # _@return_ — If the document is flagged.
      # 
      # Is the document flagged?
      # ```ruby
      # document.flagged_for_destroy?
      # ```
      sig { returns(T::Boolean) }
      def flagged_for_destroy?; end

      # Returns true if the +Document+ has been succesfully destroyed, and false
      # if it hasn't. This is determined by the variable @destroyed and NOT
      # by checking the database.
      # 
      # _@return_ — True if destroyed, false if not.
      # 
      # Is the document destroyed?
      # ```ruby
      # person.destroyed?
      # ```
      sig { returns(T::Boolean) }
      def destroyed?; end

      # Determine if the document can be pushed.
      # 
      # _@return_ — Is the document new and embedded?
      # 
      # Is this pushable?
      # ```ruby
      # person.pushable?
      # ```
      sig { returns(T::Boolean) }
      def pushable?; end

      # Is the document readonly?
      # 
      # _@return_ — If the document is readonly.
      # 
      # Is the document readonly?
      # ```ruby
      # document.readonly?
      # ```
      sig { returns(T::Boolean) }
      def readonly?; end

      # Determine if the document can be set.
      # 
      # _@return_ — Is this document a new embeds one?
      # 
      # Is this settable?
      # ```ruby
      # person.settable?
      # ```
      sig { returns(T::Boolean) }
      def settable?; end

      # Is the document updateable?
      # 
      # _@return_ — If the document is changed and persisted.
      # 
      # Is the document updateable?
      # ```ruby
      # person.updateable?
      # ```
      sig { returns(T::Boolean) }
      def updateable?; end

            sig { returns(T.untyped) }
      def reset_readonly; end

      # Get the shard key fields.
      # 
      # _@return_ — The shard key field names.
      # 
      # Get the shard key fields.
      # ```ruby
      # model.shard_key_fields
      # ```
      # 
      # _@note_ — Refactored from using delegate for class load performance.
      sig { returns(T::Array[String]) }
      def shard_key_fields; end

      # Get the document selector with the defined shard keys.
      # 
      # _@return_ — The shard key selector.
      # 
      # Get the selector for the shard keys.
      # ```ruby
      # person.shard_key_selector
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def shard_key_selector; end

      # Gets the document as a serializable hash, used by ActiveModel's JSON
      # serializer.
      # 
      # _@param_ `options` — The options to pass.
      # 
      # _@return_ — The document, ready to be serialized.
      # 
      # Get the serializable hash.
      # ```ruby
      # document.serializable_hash
      # ```
      # 
      # Get the serializable hash with options.
      # ```ruby
      # document.serializable_hash(:include => :addresses)
      # ```
      sig { params(options: T.nilable(T::Hash[T.untyped, T.untyped])).returns(T::Hash[T.untyped, T.untyped]) }
      def serializable_hash(options = nil); end

            # Get the names of all fields that will be serialized.
      # 
      # _@return_ — The names of the fields.
      # 
      # Get all the field names.
      # ```ruby
      # document.send(:field_names)
      # ```
      sig { params(options: T.untyped).returns(T::Array[String]) }
      def field_names(options); end

      # Serialize a single attribute. Handles associations, fields, and dynamic
      # attributes.
      # 
      # _@param_ `attrs` — The attributes.
      # 
      # _@param_ `name` — The attribute name.
      # 
      # _@param_ `names` — The names of all attributes.
      # 
      # _@param_ `options` — The options.
      # 
      # _@return_ — The attribute.
      # 
      # Serialize the attribute.
      # ```ruby
      # document.serialize_attribute({}, "id" , [ "id" ])
      # ```
      sig do
        params(
          attrs: T::Hash[T.untyped, T.untyped],
          name: String,
          names: T::Array[String],
          options: T::Hash[T.untyped, T.untyped]
        ).returns(Object)
      end
      def serialize_attribute(attrs, name, names, options); end

            # For each of the provided include options, get the association needed and
      # provide it in the hash.
      # 
      # _@param_ `attributes` — The attributes to serialize.
      # 
      # _@param_ `options` — The serialization options.
      # 
      # Serialize the included associations.
      # ```ruby
      # document.serialize_relations({}, :include => :addresses)
      # ```
      sig { params(attributes: T::Hash[T.untyped, T.untyped], options: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
      def serialize_relations(attributes = {}, options = {}); end

      # Since the inclusions can be a hash, symbol, or array of symbols, this is
      # provided as a convenience to parse out the names.
      # 
      # _@param_ `inclusions` — The inclusions.
      # 
      # _@return_ — The names of the included associations.
      # 
      # Get the association names.
      # ```ruby
      # document.relation_names(:include => [ :addresses ])
      # ```
      sig { params(inclusions: T.any(T::Hash[T.untyped, T.untyped], Symbol, T::Array[Symbol])).returns(T::Array[Symbol]) }
      def relation_names(inclusions); end

      # Since the inclusions can be a hash, symbol, or array of symbols, this is
      # provided as a convenience to parse out the options.
      # 
      # _@param_ `inclusions` — The inclusions.
      # 
      # _@param_ `options` — The options.
      # 
      # _@param_ `name` — The name of the association.
      # 
      # _@return_ — The options for the association.
      # 
      # Get the association options.
      # ```ruby
      # document.relation_names(:include => [ :addresses ])
      # ```
      sig { params(inclusions: T.any(T::Hash[T.untyped, T.untyped], Symbol, T::Array[Symbol]), options: T::Hash[T.untyped, T.untyped], name: Symbol).returns(T::Hash[T.untyped, T.untyped]) }
      def relation_options(inclusions, options, name); end

      # Get the atomic selector for the document. This is a hash in the simplest
      # case { "_id" => id }, but can become more complex for embedded documents
      # and documents that use a shard key.
      # 
      # _@return_ — The document's selector.
      # 
      # Get the document's atomic selector.
      # ```ruby
      # document.atomic_selector
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def atomic_selector; end

      # Get the atomic selector for an embedded document.
      # 
      # _@return_ — The embedded document selector.
      # 
      # Get the embedded atomic selector.
      # ```ruby
      # document.embedded_atomic_selector
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def embedded_atomic_selector; end

      # Get the atomic selector for a root document.
      # 
      # _@return_ — The root document selector.
      # 
      # Get the root atomic selector.
      # ```ruby
      # document.root_atomic_selector
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def root_atomic_selector; end

      # Apply the default scoping to the attributes of the document, as long as
      # they are not complex queries.
      # 
      # _@return_ — If default scoping was applied.
      # 
      # Apply the default scoping.
      # ```ruby
      # document.apply_default_scoping
      # ```
      sig { returns(T::Boolean) }
      def apply_default_scoping; end

      # Reloads the +Document+ attributes from the database. If the document has
      # not been saved then an error will get raised if the configuration option
      # was set. This can reload root documents or embedded documents.
      # 
      # _@return_ — The document, reloaded.
      # 
      # Reload the document.
      # ```ruby
      # person.reload
      # ```
      sig { returns(Document) }
      def reload; end

      # Reload the document, determining if it's embedded or not and what
      # behavior to use.
      # 
      # _@return_ — The reloaded attributes.
      # 
      # Reload the document.
      # ```ruby
      # document._reload
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def _reload; end

      # Reload the root document.
      # 
      # _@return_ — The reloaded attributes.
      # 
      # Reload the document.
      # ```ruby
      # document.reload_root_document
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def reload_root_document; end

      # Reload the embedded document.
      # 
      # _@return_ — The reloaded attributes.
      # 
      # Reload the document.
      # ```ruby
      # document.reload_embedded_document
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def reload_embedded_document; end

      # Extract only the desired embedded document from the attributes.
      # 
      # _@param_ `attributes` — The document in the db.
      # 
      # _@return_ — The document's extracted attributes.
      # 
      # Extract the embedded document.
      # ```ruby
      # document.extract_embedded_attributes(attributes)
      # ```
      sig { params(attributes: T::Hash[T.untyped, T.untyped]).returns(T::Hash[T.untyped, T.untyped]) }
      def extract_embedded_attributes(attributes); end

      # Determine if the document itself is embedded in another document via the
      # proper channels. (If it has a parent document.)
      # 
      # _@return_ — True if the document has a parent document.
      # 
      # Is the document embedded?
      # ```ruby
      # address.embedded?
      # ```
      sig { returns(T::Boolean) }
      def embedded?; end

      # Determine if the document is part of an embeds_many association.
      # 
      # _@return_ — True if in an embeds many.
      # 
      # Is the document in an embeds many?
      # ```ruby
      # address.embedded_many?
      # ```
      sig { returns(T::Boolean) }
      def embedded_many?; end

      # Determine if the document is part of an embeds_one association.
      # 
      # _@return_ — True if in an embeds one.
      # 
      # Is the document in an embeds one?
      # ```ruby
      # address.embedded_one?
      # ```
      sig { returns(T::Boolean) }
      def embedded_one?; end

      # Get the association name for this document. If no association was defined
      #   an error will be raised.
      # 
      # _@return_ — The association name.
      # 
      # Get the association name.
      # ```ruby
      # document.association_name
      # ```
      sig { returns(Symbol) }
      def association_name; end

      # Determine if the document is part of an references_many association.
      # 
      # _@return_ — True if in a references many.
      # 
      # Is the document in a references many?
      # ```ruby
      # post.referenced_many?
      # ```
      sig { returns(T::Boolean) }
      def referenced_many?; end

      # Determine if the document is part of an references_one association.
      # 
      # _@return_ — True if in a references one.
      # 
      # Is the document in a references one?
      # ```ruby
      # address.referenced_one?
      # ```
      sig { returns(T::Boolean) }
      def referenced_one?; end

      # Convenience method for iterating through the loaded associations and
      # reloading them.
      # 
      # _@return_ — The association metadata.
      # 
      # Reload the associations.
      # ```ruby
      # document.reload_relations
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def reload_relations; end

      # Returns the association metadata for the supplied name.
      # 
      # _@param_ `name` — The name of the association to find.
      # 
      # _@return_ — The matching association metadata.
      # 
      # Find association metadata by name.
      # ```ruby
      # person.reflect_on_association(:addresses)
      # ```
      sig { params(name: T.any(String, Symbol)).returns(Association) }
      def reflect_on_association(name); end

      # Returns all association metadata for the supplied macros.
      # 
      # _@param_ `macros` — The association macros.
      # 
      # _@return_ — The matching association metadata.
      # 
      # Find multiple association metadata by macro.
      # ```ruby
      # person.reflect_on_all_associations(:embeds_many)
      # ```
      sig { params(macros: T::Array[Symbol]).returns(T::Array[Association]) }
      def reflect_on_all_association(*macros); end

      # This is convenience for libraries still on the old API.
      # 
      # _@return_ — The associations.
      # 
      # Get the associations.
      # ```ruby
      # person.associations
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def associations; end

      # Parse out the attributes and the options from the args passed to a
      # build_ or create_ methods.
      # 
      # _@param_ `args` — The arguments.
      # 
      # _@return_ — The attributes and options.
      # 
      # Parse the args.
      # ```ruby
      # doc.parse_args(:name => "Joe")
      # ```
      sig { params(args: T::Array[T.untyped]).returns(T::Array[T::Hash[T.untyped, T.untyped]]) }
      def parse_args(*args); end

            # Perform all cascading deletes, destroys, or nullifies. Will delegate to
      # the appropriate strategy to perform the operation.
      # 
      # Execute cascades.
      # ```ruby
      # document.apply_delete_dependencies!
      # ```
      sig { returns(T.untyped) }
      def apply_delete_dependencies!; end

                  sig { params(association: T.untyped).returns(T.untyped) }
      def _dependent_delete_all!(association); end

                  sig { params(association: T.untyped).returns(T.untyped) }
      def _dependent_destroy!(association); end

                  sig { params(association: T.untyped).returns(T.untyped) }
      def _dependent_nullify!(association); end

                  sig { params(association: T.untyped).returns(T.untyped) }
      def _dependent_restrict_with_exception!(association); end

                  sig { params(association: T.untyped).returns(T.untyped) }
      def _dependent_restrict_with_error!(association); end

      # Builds the related document and creates the association unless the
      # document is nil, then sets the association on this document.
      # 
      # _@param_ `name` — The name of the association.
      # 
      # _@param_ `object` — The id or attributes to use.
      # 
      # _@param_ `association` — The association metadata.
      # 
      # _@param_ `selected_fields` — Fields which were retrieved via #only. If selected_fields is specified, fields not listed in it will not be accessible in the built document.
      # 
      # _@return_ — The association.
      # 
      # Build the association.
      # ```ruby
      # person.__build__(:addresses, { :_id => 1 }, association)
      # ```
      sig do
        params(
          name: T.any(String, Symbol),
          object: T.any(T::Hash[T.untyped, T.untyped], BSON::ObjectId),
          association: Association,
          selected_fields: T.nilable(T::Hash[T.untyped, T.untyped])
        ).returns(Proxy)
      end
      def __build__(name, object, association, selected_fields = nil); end

      # Create an association from an object and association metadata.
      # 
      # _@param_ `object` — The association target.
      # 
      # _@param_ `association` — The association metadata.
      # 
      # _@param_ `selected_fields` — Fields which were retrieved via #only. If selected_fields is specified, fields not listed in it will not be accessible in the created association document.
      # 
      # _@return_ — The association.
      # 
      # Create the association.
      # ```ruby
      # person.create_relation(document, association)
      # ```
      sig { params(object: T.any(Document, T::Array[Document]), association: Association, selected_fields: T.nilable(T::Hash[T.untyped, T.untyped])).returns(Proxy) }
      def create_relation(object, association, selected_fields = nil); end

            # Resets the criteria inside the association proxy. Used by many-to-many
      # associations to keep the underlying ids array in sync.
      # 
      # _@param_ `name` — The name of the association.
      # 
      # Reset the association criteria.
      # ```ruby
      # person.reset_relation_criteria(:preferences)
      # ```
      sig { params(name: Symbol).returns(T.untyped) }
      def reset_relation_criteria(name); end

      # Set the supplied association to an instance variable on the class with the
      # provided name. Used as a helper just for code cleanliness.
      # 
      # _@param_ `name` — The name of the association.
      # 
      # _@param_ `relation` — The association to set.
      # 
      # _@return_ — The association.
      # 
      # Set the proxy on the document.
      # ```ruby
      # person.set(:addresses, addresses)
      # ```
      sig { params(name: T.any(String, Symbol), relation: Proxy).returns(Proxy) }
      def set_relation(name, relation); end

      # Get the association. Extracted out from the getter method to avoid
      # infinite recursion when overriding the getter.
      # 
      # _@param_ `name` — The name of the association.
      # 
      # _@param_ `association` — The association metadata.
      # 
      # _@param_ `object` — The object used to build the association.
      # 
      # _@param_ `reload` — If the association is to be reloaded.
      # 
      # _@return_ — The association.
      # 
      # Get the association.
      # ```ruby
      # document.get_relation(:name, association)
      # ```
      sig do
        params(
          name: Symbol,
          association: Association,
          object: Object,
          reload: T::Boolean
        ).returns(Proxy)
      end
      def get_relation(name, association, object, reload = false); end

      # Returns a subset of __selected_fields attribute applicable to the
      # (embedded) association with the given key, or nil if no projection
      # is to be performed.
      # 
      # For example, if __selected_fields is {'a' => 1, 'b.c' => 2, 'b.c.f' => 3},
      # and assoc_key is 'b', return value would be {'c' => 2, 'c.f' => 3}.
      # 
      # _@param_ `assoc_key`
      sig { params(assoc_key: String).returns(T.nilable(T::Hash[T.untyped, T.untyped])) }
      def _mongoid_filter_selected_fields(assoc_key); end

                  sig { params(object: T.untyped, association: T.untyped).returns(T::Boolean) }
      def needs_no_database_query?(object, association); end

      # Is the current code executing without autobuild functionality?
      # 
      # _@return_ — If autobuild is disabled.
      # 
      # Is autobuild disabled?
      # ```ruby
      # document.without_autobuild?
      # ```
      sig { returns(T::Boolean) }
      def without_autobuild?; end

      # Yield to the block with autobuild functionality turned off.
      # 
      # _@return_ — The result of the yield.
      # 
      # Execute without autobuild.
      # ```ruby
      # document.without_autobuild do
      #   document.name
      # end
      # ```
      sig { returns(Object) }
      def without_autobuild; end

      # Is the document able to be synced on the inverse side? This is only if
      # the key has changed and the association bindings have not been run.
      # 
      # _@param_ `association` — The association metadata.
      # 
      # _@return_ — If we can sync.
      # 
      # Are the foreign keys syncable?
      # ```ruby
      # document._syncable?(association)
      # ```
      sig { params(association: Association).returns(T::Boolean) }
      def _syncable?(association); end

      # Get the synced foreign keys.
      # 
      # _@return_ — The synced foreign keys.
      # 
      # Get the synced foreign keys.
      # ```ruby
      # document._synced
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def _synced; end

      # Has the document been synced for the foreign key?
      # 
      # _@param_ `foreign_key` — The foreign key.
      # 
      # _@return_ — If we can sync.
      # 
      # Has the document been synced?
      # ```ruby
      # document._synced?
      # ```
      sig { params(foreign_key: String).returns(T::Boolean) }
      def _synced?(foreign_key); end

      # Update the inverse keys on destroy.
      # 
      # _@param_ `association` — The association.
      # 
      # _@return_ — The updated values.
      # 
      # Update the inverse keys.
      # ```ruby
      # document.remove_inverse_keys(association)
      # ```
      sig { params(association: Association).returns(Object) }
      def remove_inverse_keys(association); end

      # Update the inverse keys for the association.
      # 
      # _@param_ `association` — The document association.
      # 
      # _@return_ — The updated values.
      # 
      # Update the inverse keys
      # ```ruby
      # document.update_inverse_keys(association)
      # ```
      sig { params(association: Association).returns(Object) }
      def update_inverse_keys(association); end

            # Reset the given counter using the .count() query from the
      # db. This method is usuful in case that a counter got
      # corrupted, or a new counter was added to the collection.
      # 
      # _@param_ `counters` — One or more counter caches to reset
      # 
      # Reset the given counter cache
      # ```ruby
      # post.reset_counters(:comments)
      # ```
      sig { params(counters: T.any(Symbol, T::Array[T.untyped])).returns(T.untyped) }
      def reset_counters(*counters); end

      # Used to prevent infinite loops in associated autosaves.
      # 
      # _@return_ — Has the document already been autosaved?
      # 
      # Is the document autosaved?
      # ```ruby
      # document.autosaved?
      # ```
      sig { returns(T::Boolean) }
      def autosaved?; end

            # Begin the associated autosave.
      # 
      # Begin autosave.
      # ```ruby
      # document.__autosaving__
      # ```
      sig { returns(T.untyped) }
      def __autosaving__; end

            # Check if there is changes for auto-saving
      # 
      #   document.changed_for_autosave?
      # 
      # Return true if there is changes on self or in
      # ```ruby
      # autosaved associations.
      # ```
      sig { params(doc: T.untyped).returns(T::Boolean) }
      def changed_for_autosave?(doc); end

      # Execute operations atomically (in a single database call) for everything
      # that would happen inside the block. This method supports nesting further
      # calls to atomically, which will behave according to the options described
      # below.
      # 
      # An option join_context can be given which, when true, will merge the
      # operations declared by the given block with the atomically block wrapping
      # the current invocation for the same document, if one exists. If this
      # block or any other block sharing the same context raises before
      # persisting, then all the operations of that context will not be
      # persisted, and will also be reset in memory.
      # 
      # When join_context is false, the given block of operations will be
      # persisted independently of other contexts. Failures in other contexts will
      # not affect this one, so long as this block was able to run and persist
      # changes.
      # 
      # The default value of join_context is set by the global configuration
      # option join_contexts, whose own default is false.
      # 
      # _@param_ `join_context` — Join the context (i.e. merge declared atomic operations) of the atomically block wrapping this one for the same document, if one exists.
      # 
      # _@return_ — If the operation succeeded.
      # 
      # Execute the operations atomically.
      # ```ruby
      # document.atomically do
      #   document.set(name: "Tool").inc(likes: 10)
      # end
      # ```
      # 
      # Execute some inner operations atomically, but independently from the outer operations.
      # ```ruby
      # 
      # document.atomically do
      #   document.inc likes: 10
      #   document.atomically join_context: false do
      #     # The following is persisted to the database independently.
      #     document.unset :origin
      #   end
      #   document.atomically join_context: true do
      #     # The following is persisted along with the other outer operations.
      #     document.inc member_count: 3
      #   end
      #   document.set name: "Tool"
      # end
      # ```
      sig { params(join_context: T.nilable(T::Boolean)).returns(T::Boolean) }
      def atomically(join_context: nil); end

            # Raise an error if validation failed.
      # 
      # Raise the validation error.
      # ```ruby
      # Person.fail_due_to_validation!(person)
      # ```
      sig { returns(T.untyped) }
      def fail_due_to_validation!; end

            # Raise an error if a callback failed.
      # 
      # _@param_ `method` — The method being called.
      # 
      # Raise the callback error.
      # ```ruby
      # Person.fail_due_to_callback!(person, :create!)
      # ```
      sig { params(method: Symbol).returns(T.untyped) }
      def fail_due_to_callback!(method); end

      # Are we executing an atomically block on the current document?
      # 
      # _@return_ — If we are current executing atomically.
      # 
      # Are we executing atomically?
      # ```ruby
      # document.executing_atomically?
      # ```
      sig { returns(T::Boolean) }
      def executing_atomically?; end

      # Post process the persistence operation.
      # 
      # _@param_ `result` — The result of the operation.
      # 
      # _@param_ `options` — The options.
      # 
      # _@return_ — true.
      # 
      # Post process the persistence operation.
      # ```ruby
      # document.post_process_persist(true)
      # ```
      sig { params(result: Object, options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
      def post_process_persist(result, options = {}); end

      # Prepare an atomic persistence operation. Yields an empty hash to be sent
      # to the update.
      # 
      # _@return_ — The result of the operation.
      # 
      # Prepare the atomic operation.
      # ```ruby
      # document.prepare_atomic_operation do |coll, selector, opts|
      #   ...
      # end
      # ```
      sig { returns(Object) }
      def prepare_atomic_operation; end

      # Process the atomic operations - this handles the common behavior of
      # iterating through each op, getting the aliased field name, and removing
      # appropriate dirty changes.
      # 
      # _@param_ `operations` — The atomic operations.
      # 
      # _@return_ — The operations.
      # 
      # Process the atomic operations.
      # ```ruby
      # document.process_atomic_operations(pulls) do |field, value|
      #   ...
      # end
      # ```
      sig { params(operations: T::Hash[T.untyped, T.untyped]).returns(T::Hash[T.untyped, T.untyped]) }
      def process_atomic_operations(operations); end

            # Remove the dirty changes for all fields changed in the current atomic
      # context.
      # 
      # Remove the current atomic context's dirty changes.
      # ```ruby
      # document._mongoid_remove_atomic_context_changes
      # ```
      sig { returns(T.untyped) }
      def _mongoid_remove_atomic_context_changes; end

            # Reset the attributes for all fields changed in the current atomic
      # context.
      # 
      # Reset the current atomic context's changed attributes.
      # ```ruby
      # document._mongoid_reset_atomic_context_changes!
      # ```
      sig { returns(T.untyped) }
      def _mongoid_reset_atomic_context_changes!; end

            # Push a new atomic context onto the stack.
      # 
      # Push a new atomic context onto the stack.
      # ```ruby
      # document._mongoid_push_atomic_context
      # ```
      sig { returns(T.untyped) }
      def _mongoid_push_atomic_context; end

            # Pop an atomic context off the stack.
      # 
      # Pop an atomic context off the stack.
      # ```ruby
      # document._mongoid_pop_atomic_context
      # ```
      sig { returns(T.untyped) }
      def _mongoid_pop_atomic_context; end

      # Return the current atomic context's changed fields.
      # 
      # _@return_ — The changed fields.
      # 
      # Return the current atomic context's changed fields.
      # ```ruby
      # document._mongoid_atomic_context_changed_fields
      # ```
      sig { returns(T::Array[T.untyped]) }
      def _mongoid_atomic_context_changed_fields; end

            # If we are in an atomically block, add the operations to the delayed group,
      # otherwise persist immediately.
      # 
      # _@param_ `operation` — The operation.
      # 
      # Persist immediately or delay the operations.
      # ```ruby
      # document.persist_or_delay_atomic_operation(ops)
      # ```
      sig { params(operation: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
      def persist_or_delay_atomic_operation(operation); end

            # Persist the atomic operations.
      # 
      # _@param_ `operations` — The atomic operations.
      # 
      # Persist the atomic operations.
      # ```ruby
      # persist_atomic_operations(ops)
      # ```
      sig { params(operations: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
      def persist_atomic_operations(operations); end

      # Perform an $unset operation on the provided fields and in the
      # values in the document in memory.
      # 
      # _@param_ `fields` — The names of the fields to unset.
      # 
      # _@return_ — The document.
      # 
      # Unset the values.
      # ```ruby
      # document.unset(:first_name, :last_name, :middle)
      # ```
      sig { params(fields: T::Array[T.any(String, Symbol)]).returns(Document) }
      def unset(*fields); end

      # Perform an upsert of the document. If the document does not exist in the
      # database, then Mongo will insert a new one, otherwise the fields will get
      # overwritten with new values on the existing document.
      # 
      # _@param_ `options` — The validation options.
      # 
      # _@return_ — True.
      # 
      # Upsert the document.
      # ```ruby
      # document.upsert
      # ```
      sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
      def upsert(options = {}); end

      # Prepare the upsert for execution.
      # 
      # _@param_ `options` — The options hash.
      # 
      # _@return_ — If the operation succeeded.
      # 
      # Prepare the upsert
      # ```ruby
      # document.prepare_upsert do
      #   collection.find(selector).update(as_document)
      # end
      # ```
      sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
      def prepare_upsert(options = {}); end

      # Update a single attribute and persist the entire document.
      # This skips validation but fires the callbacks.
      # 
      # _@param_ `name` — The name of the attribute.
      # 
      # _@param_ `value` — The new value of the attribute.a
      # 
      # _@return_ — True if save was successfull, false if not.
      # 
      # Update the attribute.
      # ```ruby
      # person.update_attribute(:title, "Sir")
      # ```
      sig { params(name: T.any(Symbol, String), value: Object).returns(T::Boolean) }
      def update_attribute(name, value); end

      # Update the document attributes in the database.
      # 
      # _@param_ `attributes` — The attributes to update.
      # 
      # _@return_ — True if validation passed, false if not.
      # 
      # Update the document's attributes
      # ```ruby
      # document.update(:title => "Sir")
      # ```
      sig { params(attributes: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
      def update(attributes = {}); end

      # Update the document attributes in the database and raise an error if
      # validation failed.
      # 
      # _@param_ `attributes` — The attributes to update.
      # 
      # _@return_ — True if validation passed.
      # 
      # Update the document's attributes.
      # ```ruby
      # document.update!(:title => "Sir")
      # ```
      sig { params(attributes: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
      def update!(attributes = {}); end

      # Initialize the atomic updates.
      # 
      # _@return_ — The updates and conflicts.
      # 
      # Initialize the atomic updates.
      # ```ruby
      # document.init_atomic_updates
      # ```
      sig { returns(T::Array[T::Hash[T.untyped, T.untyped]]) }
      def init_atomic_updates; end

      # Prepare the update for execution. Validates and runs callbacks, etc.
      # 
      # _@param_ `options` — The options.
      # 
      # _@return_ — The result of the update.
      # 
      # Prepare for update.
      # ```ruby
      # document.prepare_update do
      #   collection.update(atomic_selector)
      # end
      # ```
      sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
      def prepare_update(options = {}); end

      # Update the document in the database.
      # 
      # _@param_ `options` — Options to pass to update.
      # 
      # _@return_ — True if succeeded, false if not.
      # 
      # Update an existing document.
      # ```ruby
      # document.update
      # ```
      sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
      def update_document(options = {}); end

      # Perform a $set operation on the provided field/value pairs and set the
      # values in the document in memory.
      # 
      # The key can be a dotted sequence of keys, in which case the
      # top level field is treated as a nested hash and any missing keys
      # are created automatically:
      # 
      # Performing a nested set like this merges values of intermediate keys:
      # 
      # If the top level field was not a hash, its original value is discarded
      # and the field is replaced with a hash.
      # 
      # Note that unlike MongoDB's $set, Mongoid's set writes out the entire
      # field even when setting a subset of the field via the nested hash
      # semantics. This means performing a $set with nested hash semantics
      # can overwrite other hash keys within the top level field in the database.
      # 
      # _@param_ `setters` — The field/value pairs to set.
      # 
      # _@return_ — The document.
      # 
      # Set the values.
      # ```ruby
      # document.set(title: "sir", dob: Date.new(1970, 1, 1))
      # ```
      # 
      # Set the values using nested hash semantics.
      # ```ruby
      # document.set('author.title' => 'Sir')
      # # => document.author == {'title' => 'Sir'}
      # ```
      # 
      # Nested hash value merging.
      # ```ruby
      # document.set('author.title' => 'Sir')
      # document.set('author.name' => 'Linus Torvalds')
      # # => document.author == {'title' => 'Sir', 'name' => 'Linus Torvalds'}
      # ```
      # 
      # Nested hash overwriting a non-hash value.
      # ```ruby
      # document.set('author' => 'John Doe')
      # document.set('author.title' => 'Sir')
      # # => document.author == {'title' => 'Sir'}
      # ```
      sig { params(setters: T::Hash[T.untyped, T.untyped]).returns(Document) }
      def set(setters); end

      # Save the document - will perform an insert if the document is new, and
      # update if not.
      # 
      # _@param_ `options` — Options to pass to the save.
      # 
      # _@return_ — True is success, false if not.
      # 
      # Save the document.
      # ```ruby
      # document.save
      # ```
      sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
      def save(options = {}); end

      # Save the document - will perform an insert if the document is new, and
      # update if not. If a validation error occurs an error will get raised.
      # 
      # _@param_ `options` — Options to pass to the save.
      # 
      # _@return_ — True if validation passed.
      # 
      # Save the document.
      # ```ruby
      # document.save!
      # ```
      sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
      def save!(options = {}); end

      # Rename fields from one value to another via $rename.
      # 
      # _@param_ `renames` — The rename pairs of old name/new name.
      # 
      # _@return_ — The document.
      # 
      # Rename the fields.
      # ```ruby
      # document.rename(title: "salutation", name: "nombre")
      # ```
      # 
      # _@note_ — This does not work for fields in embeds many associations.
      sig { params(renames: T::Hash[T.untyped, T.untyped]).returns(Document) }
      def rename(renames); end

      # Add the single values to the arrays only if the value does not already
      # exist in the array.
      # 
      # _@param_ `adds` — The field/value pairs to add.
      # 
      # _@return_ — The document.
      # 
      # Add the values to the sets.
      # ```ruby
      # document.add_to_set(names: "James", aliases: "Bond")
      # ```
      sig { params(adds: T::Hash[T.untyped, T.untyped]).returns(Document) }
      def add_to_set(adds); end

      # Push a single value or multiple values onto arrays.
      # 
      # _@param_ `pushes` — The $push operations.
      # 
      # _@return_ — The document.
      # 
      # Push a single value onto arrays.
      # ```ruby
      # document.push(names: "James", aliases: "007")
      # ```
      # 
      # Push multiple values onto arrays.
      # ```ruby
      # document.push(names: [ "James", "Bond" ])
      # ```
      sig { params(pushes: T::Hash[T.untyped, T.untyped]).returns(Document) }
      def push(pushes); end

      # Pull single values from the provided arrays.
      # 
      # _@param_ `pulls` — The field/value pull pairs.
      # 
      # _@return_ — The document.
      # 
      # Pull a value from the array.
      # ```ruby
      # document.pull(names: "Jeff", levels: 5)
      # ```
      # 
      # _@note_ — If duplicate values are found they will all be pulled.
      sig { params(pulls: T::Hash[T.untyped, T.untyped]).returns(Document) }
      def pull(pulls); end

      # Pull multiple values from the provided array fields.
      # 
      # _@param_ `pulls` — The pull all operations.
      # 
      # _@return_ — The document.
      # 
      # Pull values from the arrays.
      # ```ruby
      # document.pull_all(names: [ "Jeff", "Bob" ], levels: [ 5, 6 ])
      # ```
      sig { params(pulls: T::Hash[T.untyped, T.untyped]).returns(Document) }
      def pull_all(pulls); end

      # Takes the provided selector and atomic operations and replaces the
      # indexes of the embedded documents with the positional operator when
      # needed.
      # 
      # _@param_ `selector` — The selector.
      # 
      # _@param_ `operations` — The update operations.
      # 
      # _@param_ `processed` — The processed update operations.
      # 
      # _@return_ — The new operations.
      # 
      # Process the operations.
      # ```ruby
      # positionally(
      #   { "_id" => 1, "addresses._id" => 2 },
      #   { "$set" => { "addresses.0.street" => "hobrecht" }}
      # )
      # ```
      # 
      # _@note_ — The only time we can accurately know when to use the positional
      # operator is at the exact time we are going to persist something. So
      # we can tell by the selector that we are sending if it is actually
      # possible to use the positional operator at all. For example, if the
      # selector is: { "_id" => 1 }, then we could not use the positional
      # operator for updating embedded documents since there would never be a
      # match - we base whether we can based on the number of levels deep the
      # selector goes, and if the id values are not nil.
      sig { params(selector: T::Hash[T.untyped, T.untyped], operations: T::Hash[T.untyped, T.untyped], processed: T::Hash[T.untyped, T.untyped]).returns(T::Hash[T.untyped, T.untyped]) }
      def positionally(selector, operations, processed = {}); end

                              sig { params(keys: T.untyped, operations: T.untyped, processed: T.untyped).returns(T.untyped) }
      def process_operations(keys, operations, processed); end

                              sig { params(keys: T.untyped, update: T.untyped, updates: T.untyped).returns(T.untyped) }
      def process_updates(keys, update, updates = {}); end

                        sig { params(keys: T.untyped, position: T.untyped).returns(T.untyped) }
      def replace_index(keys, position); end

      # Pop or shift items from arrays using the $pop operator.
      # 
      # _@param_ `pops` — The field/value pop operations.
      # 
      # _@return_ — The document.
      # 
      # Pop items from an array.
      # ```ruby
      # document.pop(aliases: 1)
      # ```
      # 
      # Shift items in the array.
      # ```ruby
      # document.pop(aliases: -1)
      # ```
      # 
      # Multiple pops in one call.
      # ```ruby
      # document.pop(names: 1, aliases: 1)
      # ```
      sig { params(pops: T::Hash[T.untyped, T.untyped]).returns(Document) }
      def pop(pops); end

      # Performs an atomic $bit operation on the field with the provided hash
      # of bitwise ops to execute in order.
      # 
      # _@param_ `operations` — The bitwise operations.
      # 
      # _@return_ — The document.
      # 
      # Execute the bitwise operations.
      # ```ruby
      # person.bit(age: { :and => 12 }, val: { and: 10, or: 12 })
      # ```
      sig { params(operations: T::Hash[T.untyped, T.untyped]).returns(Document) }
      def bit(operations); end

      # Increment the provided fields by the corresponding values. Values can
      # be positive or negative, and if no value exists for the field it will
      # be set with the provided value.
      # 
      # _@param_ `increments` — The field/inc increment pairs.
      # 
      # _@return_ — The document.
      # 
      # Increment the fields.
      # ```ruby
      # document.inc(score: 10, place: 1, lives: -10)
      # ```
      sig { params(increments: T::Hash[T.untyped, T.untyped]).returns(Document) }
      def inc(increments); end

      # Remove the document from the database with callbacks.
      # 
      # _@param_ `options` — Options to pass to destroy.
      # 
      # _@return_ — True if successful, false if not.
      # 
      # Destroy a document.
      # ```ruby
      # document.destroy
      # ```
      sig { params(options: T.nilable(T::Hash[T.untyped, T.untyped])).returns(T::Boolean) }
      def destroy(options = nil); end

                  sig { params(options: T.untyped).returns(T.untyped) }
      def destroy!(options = {}); end

      # Remove the document from the database.
      # 
      # _@param_ `options` — Options to pass to remove.
      # 
      # _@return_ — True.
      # 
      # Remove the document.
      # ```ruby
      # document.remove
      # ```
      sig { params(options: T::Hash[T.untyped, T.untyped]).returns(TrueClass) }
      def delete(options = {}); end

      # Get the atomic deletes for the operation.
      # 
      # _@return_ — The atomic deletes.
      # 
      # Get the atomic deletes.
      # ```ruby
      # document.atomic_deletes
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def atomic_deletes; end

      # Delete the embedded document.
      # 
      # _@param_ `options` — The deletion options.
      # 
      # _@return_ — If the operation succeeded.
      # 
      # Delete the embedded document.
      # ```ruby
      # document.delete_as_embedded
      # ```
      sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
      def delete_as_embedded(options = {}); end

      # Delete the root document.
      # 
      # _@return_ — If the document was removed.
      # 
      # Delete the root document.
      # ```ruby
      # document.delete_as_root
      # ```
      sig { returns(T::Boolean) }
      def delete_as_root; end

      # Are we needing to notify the parent document of the deletion.
      # 
      # _@param_ `options` — The delete options.
      # 
      # _@return_ — If the parent should be notified.
      # 
      # Are we notifying the parent.
      # ```ruby
      # document.notifying_parent?(suppress: true)
      # ```
      sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
      def notifying_parent?(options = {}); end

      # Prepare the delete operation.
      # 
      # _@return_ — The result of the block.
      # 
      # Prepare the delete operation.
      # ```ruby
      # document.prepare_delete do
      #   collection.find(atomic_selector).remove
      # end
      # ```
      sig { returns(Object) }
      def prepare_delete; end

      # Insert a new document into the database. Will return the document
      # itself whether or not the save was successful.
      # 
      # _@param_ `options` — Options to pass to insert.
      # 
      # _@return_ — The persisted document.
      # 
      # Insert a document.
      # ```ruby
      # document.insert
      # ```
      sig { params(options: T::Hash[T.untyped, T.untyped]).returns(Document) }
      def insert(options = {}); end

      # Get the atomic insert for embedded documents, either a push or set.
      # 
      # _@return_ — The insert ops.
      # 
      # Get the inserts.
      # ```ruby
      # document.inserts
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def atomic_inserts; end

      # Insert the embedded document.
      # 
      # _@return_ — The document.
      # 
      # Insert the document as embedded.
      # ```ruby
      # document.insert_as_embedded
      # ```
      sig { returns(Document) }
      def insert_as_embedded; end

      # Insert the root document.
      # 
      # _@return_ — The document.
      # 
      # Insert the document as root.
      # ```ruby
      # document.insert_as_root
      # ```
      sig { returns(Document) }
      def insert_as_root; end

      # Post process an insert, which sets the new record attribute to false
      # and flags all the children as persisted.
      # 
      # _@return_ — true.
      # 
      # Post process the insert.
      # ```ruby
      # document.post_process_insert
      # ```
      sig { returns(T::Boolean) }
      def post_process_insert; end

      # Prepare the insert for execution. Validates and runs callbacks, etc.
      # 
      # _@param_ `options` — The options.
      # 
      # _@return_ — The document.
      # 
      # Prepare for insertion.
      # ```ruby
      # document.prepare_insert do
      #   collection.insert(as_document)
      # end
      # ```
      sig { params(options: T::Hash[T.untyped, T.untyped]).returns(Document) }
      def prepare_insert(options = {}); end

      # Determines if this document has the attributes to match the supplied
      # MongoDB selector. Used for matching on embedded associations.
      # 
      # _@param_ `selector` — The MongoDB selector.
      # 
      # _@return_ — True if matches, false if not.
      # 
      # Does the document match?
      # ```ruby
      # document._matches?(:title => { "$in" => [ "test" ] })
      # ```
      sig { params(selector: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
      def _matches?(selector); end

      # Apply all default values to the document which are not procs.
      # 
      # _@return_ — The names of the non-proc defaults.
      # 
      # Apply all the non-proc defaults.
      # ```ruby
      # model.apply_pre_processed_defaults
      # ```
      sig { returns(T::Array[String]) }
      def apply_pre_processed_defaults; end

      # Apply all default values to the document which are procs.
      # 
      # _@return_ — The names of the proc defaults.
      # 
      # Apply all the proc defaults.
      # ```ruby
      # model.apply_post_processed_defaults
      # ```
      sig { returns(T::Array[String]) }
      def apply_post_processed_defaults; end

            # Applies a single default value for the given name.
      # 
      # _@param_ `name` — The name of the field.
      # 
      # Apply a single default.
      # ```ruby
      # model.apply_default("name")
      # ```
      sig { params(name: String).returns(T.untyped) }
      def apply_default(name); end

            # Apply all the defaults at once.
      # 
      # Apply all the defaults.
      # ```ruby
      # model.apply_defaults
      # ```
      sig { returns(T.untyped) }
      def apply_defaults; end

      # Returns an array of names for the attributes available on this object.
      # 
      # Provides the field names in an ORM-agnostic way. Rails v3.1+ uses this
      # method to automatically wrap params in JSON requests.
      # 
      # _@return_ — The field names
      # 
      # Get the field names
      # ```ruby
      # docment.attribute_names
      # ```
      sig { returns(T::Array[String]) }
      def attribute_names; end

      # Get the name of the provided field as it is stored in the database.
      # Used in determining if the field is aliased or not.
      # 
      # _@param_ `name` — The name to get.
      # 
      # _@return_ — The name of the field as it's stored in the db.
      # 
      # Get the database field name.
      # ```ruby
      # model.database_field_name(:authorization)
      # ```
      sig { params(name: T.any(String, Symbol)).returns(String) }
      def database_field_name(name); end

      # Is the provided field a lazy evaluation?
      # 
      # _@param_ `field` — The field.
      # 
      # _@param_ `value` — The current value.
      # 
      # _@return_ — If we set the field lazily.
      # 
      # If the field is lazy settable.
      # ```ruby
      # doc.lazy_settable?(field, nil)
      # ```
      sig { params(field: T.any(Standard, ForeignKey), value: Object).returns(T::Boolean) }
      def lazy_settable?(field, value); end

      # Is the document using object ids?
      # 
      # _@return_ — Using object ids.
      # 
      # Is the document using object ids?
      # ```ruby
      # model.using_object_ids?
      # ```
      # 
      # _@note_ — Refactored from using delegate for class load performance.
      sig { returns(T::Boolean) }
      def using_object_ids?; end

      # Evolve the document into an object id.
      # 
      # _@return_ — The document's id.
      # 
      # Evolve the document.
      # ```ruby
      # document.__evolve_object_id__
      # ```
      sig { returns(Object) }
      def __evolve_object_id__; end

      # Determine if an attribute is present.
      # 
      # _@param_ `name` — The name of the attribute.
      # 
      # _@return_ — True if present, false if not.
      # 
      # Is the attribute present?
      # ```ruby
      # person.attribute_present?("title")
      # ```
      sig { params(name: T.any(String, Symbol)).returns(T::Boolean) }
      def attribute_present?(name); end

      # Get the attributes that have not been cast.
      # 
      # _@return_ — The uncast attributes.
      # 
      # Get the attributes before type cast.
      # ```ruby
      # document.attributes_before_type_cast
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def attributes_before_type_cast; end

      # Does the document have the provided attribute?
      # 
      # _@param_ `name` — The name of the attribute.
      # 
      # _@return_ — If the key is present in the attributes.
      # 
      # Does the document have the attribute?
      # ```ruby
      # model.has_attribute?(:name)
      # ```
      sig { params(name: T.any(String, Symbol)).returns(T::Boolean) }
      def has_attribute?(name); end

      # Does the document have the provided attribute before it was assigned
      # and type cast?
      # 
      # _@param_ `name` — The name of the attribute.
      # 
      # _@return_ — If the key is present in the
      # attributes_before_type_cast.
      # 
      # Does the document have the attribute before it was assigned?
      # ```ruby
      # model.has_attribute_before_type_cast?(:name)
      # ```
      sig { params(name: T.any(String, Symbol)).returns(T::Boolean) }
      def has_attribute_before_type_cast?(name); end

      # Read a value from the document attributes. If the value does not exist
      # it will return nil.
      # 
      # _@param_ `name` — The name of the attribute to get.
      # 
      # _@return_ — The value of the attribute.
      # 
      # Read an attribute.
      # ```ruby
      # person.read_attribute(:title)
      # ```
      # 
      # Read an attribute (alternate syntax.)
      # ```ruby
      # person[:title]
      # ```
      sig { params(name: T.any(String, Symbol)).returns(Object) }
      def read_attribute(name); end

      # Read a value from the attributes before type cast. If the value has not
      # yet been assigned then this will return the attribute's existing value
      # using read_raw_attribute.
      # 
      # _@param_ `name` — The name of the attribute to get.
      # 
      # _@return_ — The value of the attribute before type cast, if
      # available. Otherwise, the value of the attribute.
      # 
      # Read an attribute before type cast.
      # ```ruby
      # person.read_attribute_before_type_cast(:price)
      # ```
      sig { params(name: T.any(String, Symbol)).returns(Object) }
      def read_attribute_before_type_cast(name); end

            # Remove a value from the +Document+ attributes. If the value does not exist
      # it will fail gracefully.
      # 
      # _@param_ `name` — The name of the attribute to remove.
      # 
      # Remove the attribute.
      # ```ruby
      # person.remove_attribute(:title)
      # ```
      sig { params(name: T.any(String, Symbol)).returns(T.untyped) }
      def remove_attribute(name); end

            # Write a single attribute to the document attribute hash. This will
      # also fire the before and after update callbacks, and perform any
      # necessary typecasting.
      # 
      # _@param_ `name` — The name of the attribute to update.
      # 
      # _@param_ `value` — The value to set for the attribute.
      # 
      # Write the attribute.
      # ```ruby
      # person.write_attribute(:title, "Mr.")
      # ```
      # 
      # Write the attribute (alternate syntax.)
      # ```ruby
      # person[:title] = "Mr."
      # ```
      sig { params(name: T.any(String, Symbol), value: Object).returns(T.untyped) }
      def write_attribute(name, value); end

            # Allows you to set all the attributes for a particular mass-assignment security role
      # by passing in a hash of attributes with keys matching the attribute names
      # (which again matches the column names)  and the role name using the :as option.
      # To bypass mass-assignment security you can use the :without_protection => true option.
      # 
      # _@param_ `attrs` — The new attributes to set.
      # 
      # Assign the attributes.
      # ```ruby
      # person.assign_attributes(:title => "Mr.")
      # ```
      # 
      # Assign the attributes (with a role).
      # ```ruby
      # person.assign_attributes({ :title => "Mr." }, :as => :admin)
      # ```
      sig { params(attrs: T.nilable(T::Hash[T.untyped, T.untyped])).returns(T.untyped) }
      def assign_attributes(attrs = nil); end

            # Writes the supplied attributes hash to the document. This will only
      # overwrite existing attributes if they are present in the new +Hash+, all
      # others will be preserved.
      # 
      # _@param_ `attrs` — The new attributes to set.
      # 
      # Write the attributes.
      # ```ruby
      # person.write_attributes(:title => "Mr.")
      # ```
      # 
      # Write the attributes (alternate syntax.)
      # ```ruby
      # person.attributes = { :title => "Mr." }
      # ```
      sig { params(attrs: T.nilable(T::Hash[T.untyped, T.untyped])).returns(T.untyped) }
      def write_attributes(attrs = nil); end

      # Determine if the attribute is missing from the document, due to loading
      # it from the database with missing fields.
      # 
      # _@param_ `name` — The name of the attribute.
      # 
      # _@return_ — If the attribute is missing.
      # 
      # Is the attribute missing?
      # ```ruby
      # document.attribute_missing?("test")
      # ```
      sig { params(name: String).returns(T::Boolean) }
      def attribute_missing?(name); end

      # Return type-casted attributes.
      # 
      # _@return_ — The hash with keys and values of the type-casted attributes.
      # 
      # Type-casted attributes.
      # ```ruby
      # document.typed_attributes
      # ```
      sig { returns(Object) }
      def typed_attributes; end

                        sig { params(name: T.untyped, selection: T.untyped, field: T.untyped).returns(T::Boolean) }
      def selection_excluded?(name, selection, field); end

                        sig { params(name: T.untyped, selection: T.untyped, field: T.untyped).returns(T::Boolean) }
      def selection_included?(name, selection, field); end

            # Does the string contain dot syntax for accessing hashes?
      # 
      # _@return_ — If the string contains a "."
      # 
      # Is the string in dot syntax.
      # ```ruby
      # model.hash_dot_syntax?
      # ```
      sig { params(string: T.untyped).returns(T::Boolean) }
      def hash_dot_syntax?(string); end

      # Return the typecasted value for a field.
      # 
      # _@param_ `key` — The field name.
      # 
      # _@param_ `value` — The uncast value.
      # 
      # _@return_ — The cast value.
      # 
      # Get the value typecasted.
      # ```ruby
      # person.typed_value_for(:title, :sir)
      # ```
      sig { params(key: T.any(String, Symbol), value: Object).returns(Object) }
      def typed_value_for(key, value); end

                  sig { params(name: T.untyped).returns(T.untyped) }
      def read_raw_attribute(name); end

            # Validates an attribute value as being assignable to the specified field.
      # 
      # For now, only Hash and Array fields are validated, and the value is
      # being checked to be of an appropriate type (i.e. either Hash or Array,
      # respectively, or nil).
      # 
      # This method takes the name of the field as stored in the document
      # in the database, not (necessarily) the Ruby method name used to read/write
      # the said field.
      # 
      # _@param_ `field_name` — The name of the field.
      # 
      # _@param_ `value` — The value to be validated.
      sig { params(field_name: T.any(String, Symbol), value: Object).returns(T.untyped) }
      def validate_attribute_value(field_name, value); end

                        sig { params(name: T.untyped, value: T.untyped).returns(T.untyped) }
      def lookup_attribute_presence(name, value); end

      # Are we able to write the attribute with the provided name?
      # 
      # _@param_ `name` — The name of the field.
      # 
      # _@return_ — If the document is new, or if the field is not
      # readonly.
      # 
      # Can we write the attribute?
      # ```ruby
      # model.attribute_writable?(:title)
      # ```
      sig { params(name: T.any(String, Symbol)).returns(T::Boolean) }
      def attribute_writable?(name); end

                        sig { params(name: T.untyped, value: T.untyped).returns(T.untyped) }
      def as_writable_attribute!(name, value = :nil); end

            sig { params(name: T.untyped).returns(T::Boolean) }
      def _loaded?(name); end

            sig { params(name: T.untyped).returns(T::Boolean) }
      def projected_field?(name); end

            # Process the provided attributes casting them to their proper values if a
      # field exists for them on the document. This will be limited to only the
      # attributes provided in the suppied +Hash+ so that no extra nil values get
      # put into the document's attributes.
      # 
      # _@param_ `attrs` — The attributes to set.
      # 
      # Process the attributes.
      # ```ruby
      # person.process_attributes(:title => "sir", :age => 40)
      # ```
      sig { params(attrs: T.nilable(T::Hash[T.untyped, T.untyped])).returns(T.untyped) }
      def process_attributes(attrs = nil); end

      # If the key provided is the name of an association or a nested attribute, we
      # need to wait until all other attributes are set before processing
      # these.
      # 
      # _@param_ `key` — The name of the attribute.
      # 
      # _@param_ `value` — The value of the attribute.
      # 
      # _@return_ — True if pending, false if not.
      # 
      # Is the attribute pending?
      # ```ruby
      # document.pending_attribute?(:name, "Durran")
      # ```
      sig { params(key: Symbol, value: Object).returns(T::Boolean) }
      def pending_attribute?(key, value); end

      # Get all the pending associations that need to be set.
      # 
      # _@return_ — The pending associations in key/value pairs.
      # 
      # Get the pending associations.
      # ```ruby
      # document.pending_relations
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def pending_relations; end

      # Get all the pending nested attributes that need to be set.
      # 
      # _@return_ — The pending nested attributes in key/value pairs.
      # 
      # Get the pending nested attributes.
      # ```ruby
      # document.pending_nested
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def pending_nested; end

            # If the attribute is dynamic, add a field for it with a type of object
      # and then either way set the value.
      # 
      # _@param_ `name` — The name of the field.
      # 
      # _@param_ `value` — The value of the field.
      # 
      # Process the attribute.
      # ```ruby
      # document.process_attribute(name, value)
      # ```
      sig { params(name: Symbol, value: Object).returns(T.untyped) }
      def process_attribute(name, value); end

            # Process all the pending nested attributes that needed to wait until
      # ids were set to fire off.
      # 
      # Process the nested attributes.
      # ```ruby
      # document.process_nested
      # ```
      sig { returns(T.untyped) }
      def process_nested; end

            # Process all the pending items, then clear them out.
      # 
      # Process the pending items.
      # ```ruby
      # document.process_pending
      # ```
      sig { returns(T.untyped) }
      def process_pending; end

            # Process all the pending associations that needed to wait until ids were set
      # to fire off.
      # 
      # Process the associations.
      # ```ruby
      # document.process_relations
      # ```
      sig { returns(T.untyped) }
      def process_relations; end

      # Execute a block within the context of a session.
      # 
      # _@param_ `options` — The session options. Please see the driver documentation for the available session options.
      # 
      # _@return_ — The result of calling the block.
      # 
      # Execute some operations in the context of a session.
      # ```ruby
      # band.with_session(causal_consistency: true) do
      #   band.records << Record.create
      #   band.name = 'FKA Twigs'
      #   band.save
      #   band.reload
      # end
      # ```
      # 
      # _@note_ — You cannot do any operations in the block using models or objects
      # that use a different client; the block will execute all operations
      # in the context of the implicit session and operations on any models using
      # another client will fail. For example, if you set a client using store_in on a
      # particular model and execute an operation on it in the session context block,
      # that operation can't use the block's session and an error will be raised.
      # An error will also be raised if sessions are nested.
      sig { params(options: T::Hash[T.untyped, T.untyped]).returns(Object) }
      def with_session(options = {}); end

            sig { returns(T.untyped) }
      def _session; end

            # Change the persistence context for this object during the block.
      # 
      # _@param_ `options_or_context` — The storage options or a persistence context.
      # 
      # Save the current document to a different collection.
      # ```ruby
      # model.with(collection: "bands") do |m|
      #   m.save
      # end
      # ```
      sig { params(options_or_context: T.any(T::Hash[T.untyped, T.untyped], Mongoid::PersistenceContext), block: T.untyped).returns(T.untyped) }
      def with(options_or_context, &block); end

                  sig { params(parent: T.untyped).returns(T.untyped) }
      def collection(parent = nil); end

            sig { returns(T.untyped) }
      def collection_name; end

            sig { returns(T.untyped) }
      def mongo_client; end

            sig { returns(T.untyped) }
      def persistence_context; end

                  sig { params(options_or_context: T.untyped).returns(T.untyped) }
      def set_persistence_context(options_or_context); end

                        sig { params(original_cluster: T.untyped, context: T.untyped).returns(T.untyped) }
      def clear_persistence_context(original_cluster = nil, context = nil); end

      # Get the changed attributes for the document.
      # 
      # _@return_ — The changed attributes.
      # 
      # Get the changed attributes.
      # ```ruby
      # model.changed
      # ```
      sig { returns(T::Array[String]) }
      def changed; end

      # Has the document changed?
      # 
      # _@return_ — If the document is changed.
      # 
      # Has the document changed?
      # ```ruby
      # model.changed?
      # ```
      sig { returns(T::Boolean) }
      def changed?; end

      # Have any children (embedded documents) of this document changed?
      # 
      # _@return_ — If any children have changed.
      # 
      # Have any children changed?
      # ```ruby
      # model.children_changed?
      # ```
      sig { returns(T::Boolean) }
      def children_changed?; end

      # Get the attribute changes.
      # 
      # _@return_ — The attribute changes.
      # 
      # Get the attribute changes.
      # ```ruby
      # model.changed_attributes
      # ```
      sig { returns(T::Hash[String, Object]) }
      def changed_attributes; end

      # Get all the changes for the document.
      # 
      # _@return_ — The changes.
      # 
      # Get all the changes.
      # ```ruby
      # model.changes
      # ```
      sig { returns(T::Hash[String, T::Array[T.any(Object, Object)]]) }
      def changes; end

            # Call this method after save, so the changes can be properly switched.
      # 
      # This will unset the memoized children array, set new record to
      # false, set the document as validated, and move the dirty changes.
      # 
      # Move the changes to previous.
      # ```ruby
      # person.move_changes
      # ```
      sig { returns(T.untyped) }
      def move_changes; end

            # Things that need to execute after a document has been persisted.
      # 
      # Handle post persistence.
      # ```ruby
      # document.post_persist
      # ```
      sig { returns(T.untyped) }
      def post_persist; end

      # Get the previous changes on the document.
      # 
      # _@return_ — The previous changes.
      # 
      # Get the previous changes.
      # ```ruby
      # model.previous_changes
      # ```
      sig { returns(T::Hash[String, T::Array[T.any(Object, Object)]]) }
      def previous_changes; end

            # Remove a change from the dirty attributes hash. Used by the single field
      # atomic updators.
      # 
      # _@param_ `name` — The name of the field.
      # 
      # Remove a flagged change.
      # ```ruby
      # model.remove_change(:field)
      # ```
      sig { params(name: T.any(Symbol, String)).returns(T.untyped) }
      def remove_change(name); end

      # Gets all the new values for each of the changed fields, to be passed to
      # a MongoDB $set modifier.
      # 
      # _@return_ — A +Hash+ of atomic setters.
      # 
      # Get the setters for the atomic updates.
      # ```ruby
      # person = Person.new(:title => "Sir")
      # person.title = "Madam"
      # person.setters # returns { "title" => "Madam" }
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def setters; end

      # Get the old and new value for the provided attribute.
      # 
      # _@param_ `attr` — The name of the attribute.
      # 
      # _@return_ — The old and new values.
      # 
      # Get the attribute change.
      # ```ruby
      # model.attribute_change("name")
      # ```
      sig { params(attr: String).returns(T::Array[Object]) }
      def attribute_change(attr); end

      # Determine if a specific attribute has changed.
      # 
      # _@param_ `attr` — The name of the attribute.
      # 
      # _@return_ — Whether the attribute has changed.
      # 
      # Has the attribute changed?
      # ```ruby
      # model.attribute_changed?("name")
      # ```
      sig { params(attr: String).returns(T::Boolean) }
      def attribute_changed?(attr); end

      # Get whether or not the field has a different value from the default.
      # 
      # _@param_ `attr` — The name of the attribute.
      # 
      # _@return_ — If the attribute differs.
      # 
      # Is the field different from the default?
      # ```ruby
      # model.attribute_changed_from_default?
      # ```
      sig { params(attr: String).returns(T::Boolean) }
      def attribute_changed_from_default?(attr); end

            # Get the previous value for the attribute.
      # 
      # _@param_ `attr` — The attribute name.
      # 
      # Get the previous value.
      # ```ruby
      # model.attribute_was("name")
      # ```
      sig { params(attr: String).returns(T.untyped) }
      def attribute_was(attr); end

      # Flag an attribute as going to change.
      # 
      # _@param_ `attr` — The name of the attribute.
      # 
      # _@return_ — The old value.
      # 
      # Flag the attribute.
      # ```ruby
      # model.attribute_will_change!("name")
      # ```
      sig { params(attr: String).returns(Object) }
      def attribute_will_change!(attr); end

      # Set the attribute back to its old value.
      # 
      # _@param_ `attr` — The name of the attribute.
      # 
      # _@return_ — The old value.
      # 
      # Reset the attribute.
      # ```ruby
      # model.reset_attribute!("name")
      # ```
      sig { params(attr: String).returns(Object) }
      def reset_attribute!(attr); end

                  sig { params(attr: T.untyped).returns(T.untyped) }
      def reset_attribute_to_default!(attr); end

            # Add the document as an atomic pull.
      # 
      # _@param_ `document` — The embedded document to pull.
      # 
      # Add the atomic pull.
      # ```ruby
      # person.add_atomic_pull(address)
      # ```
      sig { params(document: Document).returns(T.untyped) }
      def add_atomic_pull(document); end

      # Add an atomic unset for the document.
      # 
      # _@param_ `document` — The child document.
      # 
      # _@return_ — The children.
      # 
      # Add an atomic unset.
      # ```ruby
      # document.add_atomic_unset(doc)
      # ```
      sig { params(document: Document).returns(T::Array[Document]) }
      def add_atomic_unset(document); end

            # Returns path of the attribute for modification
      # 
      # _@return_ — The path to the document attribute in the database
      # 
      # Get path of the attribute
      # ```ruby
      # address.atomic_attribute_name(:city)
      # ```
      sig { params(name: T.untyped).returns(String) }
      def atomic_attribute_name(name); end

      # For array fields these are the pushes that need to happen.
      # 
      # _@return_ — The array pushes.
      # 
      # Get the array pushes.
      # ```ruby
      # person.atomic_array_pushes
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def atomic_array_pushes; end

      # For array fields these are the pulls that need to happen.
      # 
      # _@return_ — The array pulls.
      # 
      # Get the array pulls.
      # ```ruby
      # person.atomic_array_pulls
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def atomic_array_pulls; end

      # For array fields these are the unique adds that need to happen.
      # 
      # _@return_ — The array add_to_sets.
      # 
      # Get the array unique adds.
      # ```ruby
      # person.atomic_array_add_to_sets
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def atomic_array_add_to_sets; end

            # Get all the atomic updates that need to happen for the current
      # +Document+. This includes all changes that need to happen in the
      # entire hierarchy that exists below where the save call was made.
      # 
      # _@return_ — The updates and their modifiers.
      # 
      # Get the updates that need to occur.
      # ```ruby
      # person.atomic_updates(children)
      # ```
      # 
      # _@note_ — MongoDB does not allow "conflicting modifications" to be
      # performed in a single operation. Conflicting modifications are
      # detected by the 'haveConflictingMod' function in MongoDB.
      # Examination of the code suggests that two modifications (a $set
      # and a $push with $each, for example) conflict if:
      #   (1) the key paths being modified are equal.
      #   (2) one key path is a prefix of the other.
      # So a $set of 'addresses.0.street' will conflict with a $push and $each
      # to 'addresses', and we will need to split our update into two
      # pieces. We do not, however, attempt to match MongoDB's logic
      # exactly. Instead, we assume that two updates conflict if the
      # first component of the two key paths matches.
      sig { params(_use_indexes: T.untyped).returns(T::Hash[T.untyped, T.untyped]) }
      def atomic_updates(_use_indexes = false); end

      # Get the removal modifier for the document. Will be nil on root
      # documents, $unset on embeds_one, $set on embeds_many.
      # 
      # _@return_ — The pull or unset operation.
      # 
      # Get the removal operator.
      # ```ruby
      # name.atomic_delete_modifier
      # ```
      sig { returns(String) }
      def atomic_delete_modifier; end

      # Get the insertion modifier for the document. Will be nil on root
      # documents, $set on embeds_one, $push on embeds_many.
      # 
      # _@return_ — The pull or set operator.
      # 
      # Get the insert operation.
      # ```ruby
      # name.atomic_insert_modifier
      # ```
      sig { returns(String) }
      def atomic_insert_modifier; end

      # Return the path to this +Document+ in JSON notation, used for atomic
      # updates via $set in MongoDB.
      # 
      # _@return_ — The path to the document in the database.
      # 
      # Get the path to this document.
      # ```ruby
      # address.atomic_path
      # ```
      sig { returns(String) }
      def atomic_path; end

      # Returns the positional operator of this document for modification.
      # 
      # _@return_ — The positional operator with indexes.
      # 
      # Get the positional operator.
      # ```ruby
      # address.atomic_position
      # ```
      sig { returns(String) }
      def atomic_position; end

      # Get the atomic paths utility for this document.
      # 
      # _@return_ — The associated path.
      # 
      # Get the atomic paths.
      # ```ruby
      # document.atomic_paths
      # ```
      sig { returns(Object) }
      def atomic_paths; end

      # Get all the attributes that need to be pulled.
      # 
      # _@return_ — The $pullAll operations.
      # 
      # Get the pulls.
      # ```ruby
      # person.atomic_pulls
      # ```
      sig { returns(T::Array[T::Hash[T.untyped, T.untyped]]) }
      def atomic_pulls; end

      # Get all the push attributes that need to occur.
      # 
      # _@return_ — The $push and $each operations.
      # 
      # Get the pushes.
      # ```ruby
      # person.atomic_pushes
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def atomic_pushes; end

      # Get all the attributes that need to be set.
      # 
      # _@return_ — The $set operations.
      # 
      # Get the sets.
      # ```ruby
      # person.atomic_sets
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def atomic_sets; end

      # Get all the attributes that need to be unset.
      # 
      # _@return_ — The $unset operations.
      # 
      # Get the unsets.
      # ```ruby
      # person.atomic_unsets
      # ```
      sig { returns(T::Array[T::Hash[T.untyped, T.untyped]]) }
      def atomic_unsets; end

      # Get all the atomic sets that have had their saves delayed.
      # 
      # _@return_ — The delayed $sets.
      # 
      # Get the delayed atomic sets.
      # ```ruby
      # person.delayed_atomic_sets
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def delayed_atomic_sets; end

      # Get a hash of atomic pulls that are pending.
      # 
      # _@return_ — name/document pairs.
      # 
      # Get the atomic pulls.
      # ```ruby
      # document.delayed_atomic_pulls
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def delayed_atomic_pulls; end

      # Get the delayed atomic unsets.
      # 
      # _@return_ — The atomic unsets
      # 
      # Get the delayed atomic unsets.
      # ```ruby
      # document.delayed_atomic_unsets
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def delayed_atomic_unsets; end

      # Flag the document as destroyed and return the atomic path.
      # 
      # _@return_ — The atomic path.
      # 
      # Flag destroyed and return path.
      # ```ruby
      # document.flag_as_destroyed
      # ```
      sig { returns(String) }
      def flag_as_destroyed; end

      # Get the flagged destroys.
      # 
      # _@return_ — The flagged destroys.
      # 
      # Get the flagged destroy.
      # ```ruby
      # document.flagged_destroys
      # ```
      sig { returns(T::Array[Proc]) }
      def flagged_destroys; end

      # Process all the pending flagged destroys from nested attributes.
      # 
      # _@return_ — The cleared array.
      # 
      # Process all the pending flagged destroys.
      # ```ruby
      # document.process_flagged_destroys
      # ```
      sig { returns(T::Array[T.untyped]) }
      def process_flagged_destroys; end

            # Generates the atomic updates in the correct order.
      # 
      # _@param_ `mods` — The atomic modifications.
      # 
      # _@param_ `doc` — The document to update for.
      # 
      # Generate the updates.
      # ```ruby
      # model.generate_atomic_updates(mods, doc)
      # ```
      sig { params(mods: Modifiers, doc: Document).returns(T.untyped) }
      def generate_atomic_updates(mods, doc); end

      # Get the atomic updates for a touch operation. Should only include the
      # updated_at field and the optional extra field.
      # 
      # _@param_ `field` — The optional field.
      # 
      # _@return_ — The atomic updates.
      # 
      # Get the touch atomic updates.
      # ```ruby
      # document.touch_atomic_updates
      # ```
      sig { params(field: T.nilable(Symbol)).returns(T::Hash[T.untyped, T.untyped]) }
      def touch_atomic_updates(field = nil); end
    end
  end

  # This module contains the logic for supporting atomic operations against the
  # database.
  module Atomic
    extend ActiveSupport::Concern
    UPDATES = T.let([
  :atomic_array_pushes,
  :atomic_array_pulls,
  :atomic_array_add_to_sets,
  :atomic_pulls,
  :delayed_atomic_sets,
  :delayed_atomic_pulls,
  :delayed_atomic_unsets
], T.untyped)

        # Add the document as an atomic pull.
    # 
    # _@param_ `document` — The embedded document to pull.
    # 
    # Add the atomic pull.
    # ```ruby
    # person.add_atomic_pull(address)
    # ```
    sig { params(document: Document).returns(T.untyped) }
    def add_atomic_pull(document); end

    # Add an atomic unset for the document.
    # 
    # _@param_ `document` — The child document.
    # 
    # _@return_ — The children.
    # 
    # Add an atomic unset.
    # ```ruby
    # document.add_atomic_unset(doc)
    # ```
    sig { params(document: Document).returns(T::Array[Document]) }
    def add_atomic_unset(document); end

        # Returns path of the attribute for modification
    # 
    # _@return_ — The path to the document attribute in the database
    # 
    # Get path of the attribute
    # ```ruby
    # address.atomic_attribute_name(:city)
    # ```
    sig { params(name: T.untyped).returns(String) }
    def atomic_attribute_name(name); end

    # For array fields these are the pushes that need to happen.
    # 
    # _@return_ — The array pushes.
    # 
    # Get the array pushes.
    # ```ruby
    # person.atomic_array_pushes
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def atomic_array_pushes; end

    # For array fields these are the pulls that need to happen.
    # 
    # _@return_ — The array pulls.
    # 
    # Get the array pulls.
    # ```ruby
    # person.atomic_array_pulls
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def atomic_array_pulls; end

    # For array fields these are the unique adds that need to happen.
    # 
    # _@return_ — The array add_to_sets.
    # 
    # Get the array unique adds.
    # ```ruby
    # person.atomic_array_add_to_sets
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def atomic_array_add_to_sets; end

        # Get all the atomic updates that need to happen for the current
    # +Document+. This includes all changes that need to happen in the
    # entire hierarchy that exists below where the save call was made.
    # 
    # _@return_ — The updates and their modifiers.
    # 
    # Get the updates that need to occur.
    # ```ruby
    # person.atomic_updates(children)
    # ```
    # 
    # _@note_ — MongoDB does not allow "conflicting modifications" to be
    # performed in a single operation. Conflicting modifications are
    # detected by the 'haveConflictingMod' function in MongoDB.
    # Examination of the code suggests that two modifications (a $set
    # and a $push with $each, for example) conflict if:
    #   (1) the key paths being modified are equal.
    #   (2) one key path is a prefix of the other.
    # So a $set of 'addresses.0.street' will conflict with a $push and $each
    # to 'addresses', and we will need to split our update into two
    # pieces. We do not, however, attempt to match MongoDB's logic
    # exactly. Instead, we assume that two updates conflict if the
    # first component of the two key paths matches.
    sig { params(_use_indexes: T.untyped).returns(T::Hash[T.untyped, T.untyped]) }
    def atomic_updates(_use_indexes = false); end

    # Get the removal modifier for the document. Will be nil on root
    # documents, $unset on embeds_one, $set on embeds_many.
    # 
    # _@return_ — The pull or unset operation.
    # 
    # Get the removal operator.
    # ```ruby
    # name.atomic_delete_modifier
    # ```
    sig { returns(String) }
    def atomic_delete_modifier; end

    # Get the insertion modifier for the document. Will be nil on root
    # documents, $set on embeds_one, $push on embeds_many.
    # 
    # _@return_ — The pull or set operator.
    # 
    # Get the insert operation.
    # ```ruby
    # name.atomic_insert_modifier
    # ```
    sig { returns(String) }
    def atomic_insert_modifier; end

    # Return the path to this +Document+ in JSON notation, used for atomic
    # updates via $set in MongoDB.
    # 
    # _@return_ — The path to the document in the database.
    # 
    # Get the path to this document.
    # ```ruby
    # address.atomic_path
    # ```
    sig { returns(String) }
    def atomic_path; end

    # Returns the positional operator of this document for modification.
    # 
    # _@return_ — The positional operator with indexes.
    # 
    # Get the positional operator.
    # ```ruby
    # address.atomic_position
    # ```
    sig { returns(String) }
    def atomic_position; end

    # Get the atomic paths utility for this document.
    # 
    # _@return_ — The associated path.
    # 
    # Get the atomic paths.
    # ```ruby
    # document.atomic_paths
    # ```
    sig { returns(Object) }
    def atomic_paths; end

    # Get all the attributes that need to be pulled.
    # 
    # _@return_ — The $pullAll operations.
    # 
    # Get the pulls.
    # ```ruby
    # person.atomic_pulls
    # ```
    sig { returns(T::Array[T::Hash[T.untyped, T.untyped]]) }
    def atomic_pulls; end

    # Get all the push attributes that need to occur.
    # 
    # _@return_ — The $push and $each operations.
    # 
    # Get the pushes.
    # ```ruby
    # person.atomic_pushes
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def atomic_pushes; end

    # Get all the attributes that need to be set.
    # 
    # _@return_ — The $set operations.
    # 
    # Get the sets.
    # ```ruby
    # person.atomic_sets
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def atomic_sets; end

    # Get all the attributes that need to be unset.
    # 
    # _@return_ — The $unset operations.
    # 
    # Get the unsets.
    # ```ruby
    # person.atomic_unsets
    # ```
    sig { returns(T::Array[T::Hash[T.untyped, T.untyped]]) }
    def atomic_unsets; end

    # Get all the atomic sets that have had their saves delayed.
    # 
    # _@return_ — The delayed $sets.
    # 
    # Get the delayed atomic sets.
    # ```ruby
    # person.delayed_atomic_sets
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def delayed_atomic_sets; end

    # Get a hash of atomic pulls that are pending.
    # 
    # _@return_ — name/document pairs.
    # 
    # Get the atomic pulls.
    # ```ruby
    # document.delayed_atomic_pulls
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def delayed_atomic_pulls; end

    # Get the delayed atomic unsets.
    # 
    # _@return_ — The atomic unsets
    # 
    # Get the delayed atomic unsets.
    # ```ruby
    # document.delayed_atomic_unsets
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def delayed_atomic_unsets; end

    # Flag the document as destroyed and return the atomic path.
    # 
    # _@return_ — The atomic path.
    # 
    # Flag destroyed and return path.
    # ```ruby
    # document.flag_as_destroyed
    # ```
    sig { returns(String) }
    def flag_as_destroyed; end

    # Get the flagged destroys.
    # 
    # _@return_ — The flagged destroys.
    # 
    # Get the flagged destroy.
    # ```ruby
    # document.flagged_destroys
    # ```
    sig { returns(T::Array[Proc]) }
    def flagged_destroys; end

    # Process all the pending flagged destroys from nested attributes.
    # 
    # _@return_ — The cleared array.
    # 
    # Process all the pending flagged destroys.
    # ```ruby
    # document.process_flagged_destroys
    # ```
    sig { returns(T::Array[T.untyped]) }
    def process_flagged_destroys; end

        # Generates the atomic updates in the correct order.
    # 
    # _@param_ `mods` — The atomic modifications.
    # 
    # _@param_ `doc` — The document to update for.
    # 
    # Generate the updates.
    # ```ruby
    # model.generate_atomic_updates(mods, doc)
    # ```
    sig { params(mods: Modifiers, doc: Document).returns(T.untyped) }
    def generate_atomic_updates(mods, doc); end

    # Get the atomic updates for a touch operation. Should only include the
    # updated_at field and the optional extra field.
    # 
    # _@param_ `field` — The optional field.
    # 
    # _@return_ — The atomic updates.
    # 
    # Get the touch atomic updates.
    # ```ruby
    # document.touch_atomic_updates
    # ```
    sig { params(field: T.nilable(Symbol)).returns(T::Hash[T.untyped, T.untyped]) }
    def touch_atomic_updates(field = nil); end

    # This class contains the logic for supporting atomic operations against the
    # database.
    class Modifiers < Hash
            # Add the atomic $addToSet modifiers to the hash.
      # 
      # _@param_ `modifications` — The add to set modifiers.
      # 
      # Add the $addToSet modifiers.
      # ```ruby
      # modifiers.add_to_set({ "preference_ids" => [ "one" ] })
      # ```
      sig { params(modifications: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
      def add_to_set(modifications); end

            # Adds pull all modifiers to the modifiers hash.
      # 
      # _@param_ `modifications` — The pull all modifiers.
      # 
      # Add pull all operations.
      # ```ruby
      # modifiers.pull_all({ "addresses" => { "street" => "Bond" }})
      # ```
      sig { params(modifications: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
      def pull_all(modifications); end

            # Adds pull all modifiers to the modifiers hash.
      # 
      # _@param_ `modifications` — The pull all modifiers.
      # 
      # Add pull all operations.
      # ```ruby
      # modifiers.pull({ "addresses" => { "_id" => { "$in" => [ 1, 2, 3 ]}}})
      # ```
      sig { params(modifications: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
      def pull(modifications); end

            # Adds push modifiers to the modifiers hash.
      # 
      # _@param_ `modifications` — The push modifiers.
      # 
      # Add push operations.
      # ```ruby
      # modifiers.push({ "addresses" => { "street" => "Bond" }})
      # ```
      sig { params(modifications: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
      def push(modifications); end

            # Adds set operations to the modifiers hash.
      # 
      # _@param_ `modifications` — The set modifiers.
      # 
      # Add set operations.
      # ```ruby
      # modifiers.set({ "title" => "sir" })
      # ```
      sig { params(modifications: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
      def set(modifications); end

            # Adds unset operations to the modifiers hash.
      # 
      # _@param_ `modifications` — The unset association names.
      # 
      # Add unset operations.
      # ```ruby
      # modifiers.unset([ "addresses" ])
      # ```
      sig { params(modifications: T::Array[String]).returns(T.untyped) }
      def unset(modifications); end

            # Add the operation to the modifications, either appending or creating a
      # new one.
      # 
      # _@param_ `mods` — The modifications.
      # 
      # _@param_ `field` — The field.
      # 
      # _@param_ `value` — The atomic op.
      # 
      # Add the operation.
      # ```ruby
      # modifications.add_operation(mods, field, value)
      # ```
      sig { params(mods: T::Hash[T.untyped, T.untyped], field: String, value: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
      def add_operation(mods, field, value); end

            # Adds or appends an array operation with the $each specifier used
      # in conjuction with $push.
      # 
      # _@param_ `mods` — The modifications.
      # 
      # _@param_ `field` — The field.
      # 
      # _@param_ `value` — The atomic op.
      # 
      # Add the operation.
      # ```ruby
      # modifications.add_operation(mods, field, value)
      # ```
      sig { params(mods: T::Hash[T.untyped, T.untyped], field: String, value: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
      def add_each_operation(mods, field, value); end

      # Get the $addToSet operations or intialize a new one.
      # 
      # _@return_ — The $addToSet operations.
      # 
      # Get the $addToSet operations.
      # ```ruby
      # modifiers.add_to_sets
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def add_to_sets; end

      # Is the operation going to be a conflict for a $set?
      # 
      # _@param_ `field` — The field.
      # 
      # _@return_ — If this field is a conflict.
      # 
      # Is this a conflict for a set?
      # ```ruby
      # modifiers.set_conflict?(field)
      # ```
      sig { params(field: String).returns(T::Boolean) }
      def set_conflict?(field); end

      # Is the operation going to be a conflict for a $push?
      # 
      # _@param_ `field` — The field.
      # 
      # _@return_ — If this field is a conflict.
      # 
      # Is this a conflict for a push?
      # ```ruby
      # modifiers.push_conflict?(field)
      # ```
      sig { params(field: String).returns(T::Boolean) }
      def push_conflict?(field); end

      # Get the conflicting pull modifications.
      # 
      # _@return_ — The conflicting pull operations.
      # 
      # Get the conflicting pulls.
      # ```ruby
      # modifiers.conflicting_pulls
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def conflicting_pulls; end

      # Get the conflicting push modifications.
      # 
      # _@return_ — The conflicting push operations.
      # 
      # Get the conflicting pushs.
      # ```ruby
      # modifiers.conflicting_pushs
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def conflicting_pushes; end

      # Get the conflicting set modifications.
      # 
      # _@return_ — The conflicting set operations.
      # 
      # Get the conflicting sets.
      # ```ruby
      # modifiers.conflicting_sets
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def conflicting_sets; end

      # Get the push operations that would have conflicted with the sets.
      # 
      # _@return_ — The conflicting modifications.
      # 
      # Get the conflicts.
      # ```ruby
      # modifiers.conflicts
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def conflicts; end

      # Get the names of the fields that need to be pulled.
      # 
      # _@return_ — The pull fields.
      # 
      # Get the pull fields.
      # ```ruby
      # modifiers.pull_fields
      # ```
      sig { returns(T::Array[String]) }
      def pull_fields; end

      # Get the names of the fields that need to be pushed.
      # 
      # _@return_ — The push fields.
      # 
      # Get the push fields.
      # ```ruby
      # modifiers.push_fields
      # ```
      sig { returns(T::Array[String]) }
      def push_fields; end

      # Get the names of the fields that need to be set.
      # 
      # _@return_ — The set fields.
      # 
      # Get the set fields.
      # ```ruby
      # modifiers.set_fields
      # ```
      sig { returns(T::Array[String]) }
      def set_fields; end

      # Get the $pullAll operations or intialize a new one.
      # 
      # _@return_ — The $pullAll operations.
      # 
      # Get the $pullAll operations.
      # ```ruby
      # modifiers.pull_alls
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def pull_alls; end

      # Get the $pull operations or intialize a new one.
      # 
      # _@return_ — The $pull operations.
      # 
      # Get the $pull operations.
      # ```ruby
      # modifiers.pulls
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def pulls; end

      # Get the $push/$each operations or initialize a new one.
      # 
      # _@return_ — The $push/$each operations.
      # 
      # Get the $push/$each operations.
      # ```ruby
      # modifiers.pushes
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def pushes; end

      # Get the $set operations or intialize a new one.
      # 
      # _@return_ — The $set operations.
      # 
      # Get the $set operations.
      # ```ruby
      # modifiers.sets
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def sets; end

      # Get the $unset operations or initialize a new one.
      # 
      # _@return_ — The $unset operations.
      # 
      # Get the $unset operations.
      # ```ruby
      # modifiers.unsets
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def unsets; end
    end

    module Paths
      # This class encapsulates behavior for locating and updating root
      # documents atomically.
      class Root
        # Create the new root path utility.
        # 
        # _@param_ `document` — The document to generate the paths for.
        # 
        # Create the root path util.
        # ```ruby
        # Root.new(document)
        # ```
        sig { params(document: Document).void }
        def initialize(document); end

                # Asking for the insert modifier on a document with a root path
        # indicates a mixed association most likely happened.
        # 
        # Attempt to get the insert modifier.
        # ```ruby
        # root.insert_modifier
        # ```
        sig { returns(T.untyped) }
        def insert_modifier; end

                # Returns the value of attribute document.
        sig { returns(T.untyped) }
        attr_reader :document

                # Returns the value of attribute path.
        sig { returns(T.untyped) }
        attr_reader :path

                # Returns the value of attribute position.
        sig { returns(T.untyped) }
        attr_reader :position
      end

      # Common functionality between the two different embedded paths.
      module Embedded
        # Get the path to the document in the hierarchy.
        # 
        # _@return_ — The path to the document.
        # 
        # Get the path.
        # ```ruby
        # many.path
        # ```
        sig { returns(String) }
        def path; end

                # Returns the value of attribute delete_modifier.
        sig { returns(T.untyped) }
        attr_reader :delete_modifier

                # Returns the value of attribute document.
        sig { returns(T.untyped) }
        attr_reader :document

                # Returns the value of attribute insert_modifier.
        sig { returns(T.untyped) }
        attr_reader :insert_modifier

                # Returns the value of attribute parent.
        sig { returns(T.untyped) }
        attr_reader :parent

        # This class encapsulates behavior for locating and updating
        # documents that are defined as an embedded 1-1.
        class One
          include Mongoid::Atomic::Paths::Embedded

          # Create the new path utility.
          # 
          # _@param_ `document` — The document to generate the paths for.
          # 
          # Create the path util.
          # ```ruby
          # One.new(document)
          # ```
          sig { params(document: Document).void }
          def initialize(document); end

          # Get the position of the document in the hierarchy. This will
          # include indexes of 1-n embedded associations that may sit above the
          # embedded one.
          # 
          # _@return_ — The position of the document.
          # 
          # Get the position.
          # ```ruby
          # one.position
          # ```
          sig { returns(String) }
          def position; end

          # Get the path to the document in the hierarchy.
          # 
          # _@return_ — The path to the document.
          # 
          # Get the path.
          # ```ruby
          # many.path
          # ```
          sig { returns(String) }
          def path; end
        end

        # This class encapsulates behavior for locating and updating
        # documents that are defined as an embedded 1-n.
        class Many
          include Mongoid::Atomic::Paths::Embedded

          # Create the new path utility.
          # 
          # _@param_ `document` — The document to generate the paths for.
          # 
          # Create the path util.
          # ```ruby
          # Many.new(document)
          # ```
          sig { params(document: Document).void }
          def initialize(document); end

          # Get the position of the document in the hierarchy. This will
          # include indexes of 1-n embedded associations that may sit above the
          # embedded many.
          # 
          # _@return_ — The position of the document.
          # 
          # Get the position.
          # ```ruby
          # many.position
          # ```
          sig { returns(String) }
          def position; end

          # Get the path to the document in the hierarchy.
          # 
          # _@return_ — The path to the document.
          # 
          # Get the path.
          # ```ruby
          # many.path
          # ```
          sig { returns(String) }
          def path; end
        end
      end
    end
  end

  # This module defines all the configuration options for Mongoid, including
  # the database connections.
  module Config
    extend Mongoid::Config
    extend Forwardable
    extend Mongoid::Config::Options
    LOCK = T.let(Mutex.new, T.untyped)

    # Has Mongoid been configured? This is checking that at least a valid
    # client config exists.
    # 
    # _@return_ — If Mongoid is configured.
    # 
    # Is Mongoid configured?
    # ```ruby
    # config.configured?
    # ```
    sig { returns(T::Boolean) }
    def configured?; end

            # Connect to the provided database name on the default client.
    # 
    # _@param_ `name` — The database name.
    # 
    # Set the database to connect to.
    # ```ruby
    # config.connect_to("mongoid_test")
    # ```
    # 
    # _@note_ — Use only in development or test environments for convenience.
    sig { params(name: String, options: T.untyped).returns(T.untyped) }
    def connect_to(name, options = { read: { mode: :primary }}); end

    # Return field names that could cause destructive things to happen if
    # defined in a Mongoid::Document.
    # 
    # _@return_ — An array of bad field names.
    # 
    # Get the destructive fields.
    # ```ruby
    # config.destructive_fields
    # ```
    sig { returns(T::Array[String]) }
    def destructive_fields; end

        # Load the settings from a compliant mongoid.yml file. This can be used for
    # easy setup with frameworks other than Rails.
    # 
    # _@param_ `path` — The path to the file.
    # 
    # _@param_ `environment` — The environment to load.
    # 
    # Configure Mongoid.
    # ```ruby
    # Mongoid.load!("/path/to/mongoid.yml")
    # ```
    sig { params(path: String, environment: T.nilable(T.any(String, Symbol))).returns(T.untyped) }
    def load!(path, environment = nil); end

    # Get all the models in the application - this is everything that includes
    # Mongoid::Document.
    # 
    # _@return_ — All the models in the application.
    # 
    # Get all the models.
    # ```ruby
    # config.models
    # ```
    sig { returns(T::Array[Class]) }
    def models; end

        # Register a model in the application with Mongoid.
    # 
    # _@param_ `klass` — The model to register.
    # 
    # Register a model.
    # ```ruby
    # config.register_model(Band)
    # ```
    sig { params(klass: Class).returns(T.untyped) }
    def register_model(klass); end

        # From a hash of settings, load all the configuration.
    # 
    # _@param_ `settings` — The configuration settings.
    # 
    # Load the configuration.
    # ```ruby
    # config.load_configuration(settings)
    # ```
    sig { params(settings: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
    def load_configuration(settings); end

    # Override the database to use globally.
    # 
    # _@param_ `name` — The name of the database.
    # 
    # _@return_ — The global override.
    # 
    # Override the database globally.
    # ```ruby
    # config.override_database(:optional)
    # ```
    sig { params(name: T.any(String, Symbol)).returns(T.any(String, Symbol)) }
    def override_database(name); end

    # Override the client to use globally.
    # 
    # _@param_ `name` — The name of the client.
    # 
    # _@return_ — The global override.
    # 
    # Override the client globally.
    # ```ruby
    # config.override_client(:optional)
    # ```
    sig { params(name: T.any(String, Symbol)).returns(T.any(String, Symbol)) }
    def override_client(name); end

    # Purge all data in all collections, including indexes.
    # 
    # _@return_ — true.
    # 
    # Purge all data.
    # ```ruby
    # Mongoid::Config.purge!
    # ```
    # 
    # _@note_ — This is the fastest way to drop all data.
    sig { returns(T::Boolean) }
    def purge!; end

    # Truncate all data in all collections, but not the indexes.
    # 
    # _@return_ — true.
    # 
    # Truncate all collection data.
    # ```ruby
    # Mongoid::Config.truncate!
    # ```
    # 
    # _@note_ — This will be slower than purge!
    sig { returns(T::Boolean) }
    def truncate!; end

        # Set the configuration options. Will validate each one individually.
    # 
    # _@param_ `options` — The configuration options.
    # 
    # Set the options.
    # ```ruby
    # config.options = { raise_not_found_error: true }
    # ```
    sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
    def options=(options); end

    # Get the client configuration or an empty hash.
    # 
    # _@return_ — The clients configuration.
    # 
    # Get the clients configuration.
    # ```ruby
    # config.clients
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def clients; end

    # Get the time zone to use.
    # 
    # _@return_ — The time zone.
    # 
    # Get the time zone.
    # ```ruby
    # Config.time_zone
    # ```
    sig { returns(String) }
    def time_zone; end

    # Is the application running under passenger?
    # 
    # _@return_ — If the app is deployed on Passenger.
    # 
    # Is the application using passenger?
    # ```ruby
    # config.running_with_passenger?
    # ```
    sig { returns(T::Boolean) }
    def running_with_passenger?; end

        sig { returns(T.untyped) }
    def set_log_levels; end

    # sord infer - inferred type of parameter "clients" as T::Hash[T.untyped, T.untyped] using getter's return type
        sig { params(clients: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
    def clients=(clients); end

    # Get the defaults or initialize a new empty hash.
    # 
    # _@return_ — The default options.
    # 
    # Get the defaults.
    # ```ruby
    # options.defaults
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def self.defaults; end

        # Define a configuration option with a default.
    # 
    # _@param_ `name` — The name of the configuration option.
    # 
    # _@param_ `options` — Extras for the option.
    # 
    # Define the option.
    # ```ruby
    # Options.option(:logger, :default => Logger.new(STDERR, :warn))
    # ```
    sig { params(name: Symbol, options: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
    def self.option(name, options = {}); end

    # Reset the configuration options to the defaults.
    # 
    # _@return_ — The defaults.
    # 
    # Reset the configuration options.
    # ```ruby
    # config.reset
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def self.reset; end

    # Get the settings or initialize a new empty hash.
    # 
    # _@return_ — The setting options.
    # 
    # Get the settings.
    # ```ruby
    # options.settings
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def self.settings; end

    # Get the log level.
    # 
    # _@return_ — The log level.
    # 
    # Get the log level.
    # ```ruby
    # config.log_level
    # ```
    sig { returns(Integer) }
    def self.log_level; end

    # Has Mongoid been configured? This is checking that at least a valid
    # client config exists.
    # 
    # _@return_ — If Mongoid is configured.
    # 
    # Is Mongoid configured?
    # ```ruby
    # config.configured?
    # ```
    sig { returns(T::Boolean) }
    def self.configured?; end

            # Connect to the provided database name on the default client.
    # 
    # _@param_ `name` — The database name.
    # 
    # Set the database to connect to.
    # ```ruby
    # config.connect_to("mongoid_test")
    # ```
    # 
    # _@note_ — Use only in development or test environments for convenience.
    sig { params(name: String, options: T.untyped).returns(T.untyped) }
    def self.connect_to(name, options = { read: { mode: :primary }}); end

    # Return field names that could cause destructive things to happen if
    # defined in a Mongoid::Document.
    # 
    # _@return_ — An array of bad field names.
    # 
    # Get the destructive fields.
    # ```ruby
    # config.destructive_fields
    # ```
    sig { returns(T::Array[String]) }
    def self.destructive_fields; end

        # Load the settings from a compliant mongoid.yml file. This can be used for
    # easy setup with frameworks other than Rails.
    # 
    # _@param_ `path` — The path to the file.
    # 
    # _@param_ `environment` — The environment to load.
    # 
    # Configure Mongoid.
    # ```ruby
    # Mongoid.load!("/path/to/mongoid.yml")
    # ```
    sig { params(path: String, environment: T.nilable(T.any(String, Symbol))).returns(T.untyped) }
    def self.load!(path, environment = nil); end

    # Get all the models in the application - this is everything that includes
    # Mongoid::Document.
    # 
    # _@return_ — All the models in the application.
    # 
    # Get all the models.
    # ```ruby
    # config.models
    # ```
    sig { returns(T::Array[Class]) }
    def self.models; end

        # Register a model in the application with Mongoid.
    # 
    # _@param_ `klass` — The model to register.
    # 
    # Register a model.
    # ```ruby
    # config.register_model(Band)
    # ```
    sig { params(klass: Class).returns(T.untyped) }
    def self.register_model(klass); end

        # From a hash of settings, load all the configuration.
    # 
    # _@param_ `settings` — The configuration settings.
    # 
    # Load the configuration.
    # ```ruby
    # config.load_configuration(settings)
    # ```
    sig { params(settings: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
    def self.load_configuration(settings); end

    # Override the database to use globally.
    # 
    # _@param_ `name` — The name of the database.
    # 
    # _@return_ — The global override.
    # 
    # Override the database globally.
    # ```ruby
    # config.override_database(:optional)
    # ```
    sig { params(name: T.any(String, Symbol)).returns(T.any(String, Symbol)) }
    def self.override_database(name); end

    # Override the client to use globally.
    # 
    # _@param_ `name` — The name of the client.
    # 
    # _@return_ — The global override.
    # 
    # Override the client globally.
    # ```ruby
    # config.override_client(:optional)
    # ```
    sig { params(name: T.any(String, Symbol)).returns(T.any(String, Symbol)) }
    def self.override_client(name); end

    # Purge all data in all collections, including indexes.
    # 
    # _@return_ — true.
    # 
    # Purge all data.
    # ```ruby
    # Mongoid::Config.purge!
    # ```
    # 
    # _@note_ — This is the fastest way to drop all data.
    sig { returns(T::Boolean) }
    def self.purge!; end

    # Truncate all data in all collections, but not the indexes.
    # 
    # _@return_ — true.
    # 
    # Truncate all collection data.
    # ```ruby
    # Mongoid::Config.truncate!
    # ```
    # 
    # _@note_ — This will be slower than purge!
    sig { returns(T::Boolean) }
    def self.truncate!; end

        # Set the configuration options. Will validate each one individually.
    # 
    # _@param_ `options` — The configuration options.
    # 
    # Set the options.
    # ```ruby
    # config.options = { raise_not_found_error: true }
    # ```
    sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
    def self.options=(options); end

    # Get the client configuration or an empty hash.
    # 
    # _@return_ — The clients configuration.
    # 
    # Get the clients configuration.
    # ```ruby
    # config.clients
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def self.clients; end

    # Get the time zone to use.
    # 
    # _@return_ — The time zone.
    # 
    # Get the time zone.
    # ```ruby
    # Config.time_zone
    # ```
    sig { returns(String) }
    def self.time_zone; end

    # Is the application running under passenger?
    # 
    # _@return_ — If the app is deployed on Passenger.
    # 
    # Is the application using passenger?
    # ```ruby
    # config.running_with_passenger?
    # ```
    sig { returns(T::Boolean) }
    def self.running_with_passenger?; end

        sig { returns(T.untyped) }
    def self.set_log_levels; end

    # sord infer - inferred type of parameter "clients" as T::Hash[T.untyped, T.untyped] using getter's return type
        sig { params(clients: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
    def self.clients=(clients); end

    # Encapsulates logic for setting options.
    module Options
      # Get the defaults or initialize a new empty hash.
      # 
      # _@return_ — The default options.
      # 
      # Get the defaults.
      # ```ruby
      # options.defaults
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def defaults; end

            # Define a configuration option with a default.
      # 
      # _@param_ `name` — The name of the configuration option.
      # 
      # _@param_ `options` — Extras for the option.
      # 
      # Define the option.
      # ```ruby
      # Options.option(:logger, :default => Logger.new(STDERR, :warn))
      # ```
      sig { params(name: Symbol, options: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
      def option(name, options = {}); end

      # Reset the configuration options to the defaults.
      # 
      # _@return_ — The defaults.
      # 
      # Reset the configuration options.
      # ```ruby
      # config.reset
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def reset; end

      # Get the settings or initialize a new empty hash.
      # 
      # _@return_ — The setting options.
      # 
      # Get the settings.
      # ```ruby
      # options.settings
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def settings; end

      # Get the log level.
      # 
      # _@return_ — The log level.
      # 
      # Get the log level.
      # ```ruby
      # config.log_level
      # ```
      sig { returns(Integer) }
      def log_level; end
    end

    # Encapsulates logic for getting environment information.
    module Environment
      extend Mongoid::Config::Environment

      # Get the name of the environment that Mongoid is running under.
      # 
      # Uses the following sources in order:
      # - If +::Rails+ is defined, +Rails.env+.
      # - If +::Sinatra+ is defined, +Sinatra::Base.environment+.
      # - +RACK_ENV+
      # - +MONGOID_ENV*
      # 
      # _@return_ — The name of the current environment.
      # 
      # Get the env name.
      # ```ruby
      # Environment.env_name
      # ```
      sig { returns(String) }
      def env_name; end

      # Load the yaml from the provided path and return the settings for the
      # specified environment, or for the current Mongoid environment.
      # 
      # _@param_ `path` — The location of the file.
      # 
      # _@param_ `environment` — Optional environment name to override the current Mongoid environment.
      # 
      # _@return_ — The settings.
      # 
      # Load the yaml.
      # ```ruby
      # Environment.load_yaml("/work/mongoid.yml")
      # ```
      sig { params(path: String, environment: T.nilable(T.any(String, Symbol))).returns(T::Hash[T.untyped, T.untyped]) }
      def load_yaml(path, environment = nil); end

      # Get the name of the environment that Mongoid is running under.
      # 
      # Uses the following sources in order:
      # - If +::Rails+ is defined, +Rails.env+.
      # - If +::Sinatra+ is defined, +Sinatra::Base.environment+.
      # - +RACK_ENV+
      # - +MONGOID_ENV*
      # 
      # _@return_ — The name of the current environment.
      # 
      # Get the env name.
      # ```ruby
      # Environment.env_name
      # ```
      sig { returns(String) }
      def self.env_name; end

      # Load the yaml from the provided path and return the settings for the
      # specified environment, or for the current Mongoid environment.
      # 
      # _@param_ `path` — The location of the file.
      # 
      # _@param_ `environment` — Optional environment name to override the current Mongoid environment.
      # 
      # _@return_ — The settings.
      # 
      # Load the yaml.
      # ```ruby
      # Environment.load_yaml("/work/mongoid.yml")
      # ```
      sig { params(path: String, environment: T.nilable(T.any(String, Symbol))).returns(T::Hash[T.untyped, T.untyped]) }
      def self.load_yaml(path, environment = nil); end
    end

    module Validators
      # Validator for client specific configuration.
      module Client
        extend Mongoid::Config::Validators::Client
        STANDARD = T.let([ :database, :hosts, :username, :password ].freeze, T.untyped)

                # Validate the client configuration.
        # 
        # _@param_ `clients` — The clients config.
        # 
        # Validate the client config.
        # ```ruby
        # Client.validate({ default: { hosts: [ "localhost:27017" ] }})
        # ```
        sig { params(clients: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
        def validate(clients); end

                # Validate that the client config has database.
        # 
        # _@param_ `name` — The config key.
        # 
        # _@param_ `config` — The configuration.
        # 
        # Validate the client has database.
        # ```ruby
        # validator.validate_client_database(:default, {})
        # ```
        sig { params(name: T.any(String, Symbol), config: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
        def validate_client_database(name, config); end

                # Validate that the client config has hosts.
        # 
        # _@param_ `name` — The config key.
        # 
        # _@param_ `config` — The configuration.
        # 
        # Validate the client has hosts.
        # ```ruby
        # validator.validate_client_hosts(:default, {})
        # ```
        sig { params(name: T.any(String, Symbol), config: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
        def validate_client_hosts(name, config); end

                # Validate that not both a uri and standard options are provided for a
        # single client.
        # 
        # _@param_ `name` — The config key.
        # 
        # _@param_ `config` — The configuration.
        # 
        # Validate the uri and options.
        # ```ruby
        # validator.validate_client_uri(:default, {})
        # ```
        sig { params(name: T.any(String, Symbol), config: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
        def validate_client_uri(name, config); end

        # Return true if the configuration has no database or uri option
        # defined.
        # 
        # _@param_ `config` — The configuration options.
        # 
        # _@return_ — If no database or uri is defined.
        # 
        # Validate the options.
        # ```ruby
        # validator.no_database_or_uri?(config)
        # ```
        sig { params(config: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
        def no_database_or_uri?(config); end

        # Return true if the configuration has no hosts or uri option
        # defined.
        # 
        # _@param_ `config` — The configuration options.
        # 
        # _@return_ — If no hosts or uri is defined.
        # 
        # Validate the options.
        # ```ruby
        # validator.no_hosts_or_uri?(config)
        # ```
        sig { params(config: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
        def no_hosts_or_uri?(config); end

        # Return true if the configuration has both standard options and a uri
        # defined.
        # 
        # _@param_ `config` — The configuration options.
        # 
        # _@return_ — If both standard and uri are defined.
        # 
        # Validate the options.
        # ```ruby
        # validator.no_database_or_uri?(config)
        # ```
        sig { params(config: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
        def both_uri_and_standard?(config); end

                # Validate the client configuration.
        # 
        # _@param_ `clients` — The clients config.
        # 
        # Validate the client config.
        # ```ruby
        # Client.validate({ default: { hosts: [ "localhost:27017" ] }})
        # ```
        sig { params(clients: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
        def self.validate(clients); end

                # Validate that the client config has database.
        # 
        # _@param_ `name` — The config key.
        # 
        # _@param_ `config` — The configuration.
        # 
        # Validate the client has database.
        # ```ruby
        # validator.validate_client_database(:default, {})
        # ```
        sig { params(name: T.any(String, Symbol), config: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
        def self.validate_client_database(name, config); end

                # Validate that the client config has hosts.
        # 
        # _@param_ `name` — The config key.
        # 
        # _@param_ `config` — The configuration.
        # 
        # Validate the client has hosts.
        # ```ruby
        # validator.validate_client_hosts(:default, {})
        # ```
        sig { params(name: T.any(String, Symbol), config: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
        def self.validate_client_hosts(name, config); end

                # Validate that not both a uri and standard options are provided for a
        # single client.
        # 
        # _@param_ `name` — The config key.
        # 
        # _@param_ `config` — The configuration.
        # 
        # Validate the uri and options.
        # ```ruby
        # validator.validate_client_uri(:default, {})
        # ```
        sig { params(name: T.any(String, Symbol), config: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
        def self.validate_client_uri(name, config); end

        # Return true if the configuration has no database or uri option
        # defined.
        # 
        # _@param_ `config` — The configuration options.
        # 
        # _@return_ — If no database or uri is defined.
        # 
        # Validate the options.
        # ```ruby
        # validator.no_database_or_uri?(config)
        # ```
        sig { params(config: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
        def self.no_database_or_uri?(config); end

        # Return true if the configuration has no hosts or uri option
        # defined.
        # 
        # _@param_ `config` — The configuration options.
        # 
        # _@return_ — If no hosts or uri is defined.
        # 
        # Validate the options.
        # ```ruby
        # validator.no_hosts_or_uri?(config)
        # ```
        sig { params(config: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
        def self.no_hosts_or_uri?(config); end

        # Return true if the configuration has both standard options and a uri
        # defined.
        # 
        # _@param_ `config` — The configuration options.
        # 
        # _@return_ — If both standard and uri are defined.
        # 
        # Validate the options.
        # ```ruby
        # validator.no_database_or_uri?(config)
        # ```
        sig { params(config: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
        def self.both_uri_and_standard?(config); end
      end

      # Validator for configuration options.
      module Option
        extend Mongoid::Config::Validators::Option

                # Validate a configuration option.
        # 
        # _@param_ `option` — The name of the option.
        # 
        # Validate a configuration option.
        # ```ruby
        # ```
        sig { params(option: String).returns(T.untyped) }
        def validate(option); end

                # Validate a configuration option.
        # 
        # _@param_ `option` — The name of the option.
        # 
        # Validate a configuration option.
        # ```ruby
        # ```
        sig { params(option: String).returns(T.untyped) }
        def self.validate(option); end
      end
    end
  end

  # This module defines behavior for fields.
  module Fields
    extend ActiveSupport::Concern
    StringifiedSymbol = T.let(Mongoid::StringifiedSymbol, T.untyped)
    Boolean = T.let(Mongoid::Boolean, T.untyped)
    TYPE_MAPPINGS = T.let({
  array: Array,
  big_decimal: BigDecimal,
  binary: BSON::Binary,
  boolean: Mongoid::Boolean,
  date: Date,
  date_time: DateTime,
  float: Float,
  hash: Hash,
  integer: Integer,
  object_id: BSON::ObjectId,
  range: Range,
  regexp: Regexp,
  set: Set,
  string: String,
  stringified_symbol: StringifiedSymbol,
  symbol: Symbol,
  time: Time
}.with_indifferent_access, T.untyped)
    IDS = T.let([ :_id, '_id', ].freeze, T.untyped)

    # Apply all default values to the document which are not procs.
    # 
    # _@return_ — The names of the non-proc defaults.
    # 
    # Apply all the non-proc defaults.
    # ```ruby
    # model.apply_pre_processed_defaults
    # ```
    sig { returns(T::Array[String]) }
    def apply_pre_processed_defaults; end

    # Apply all default values to the document which are procs.
    # 
    # _@return_ — The names of the proc defaults.
    # 
    # Apply all the proc defaults.
    # ```ruby
    # model.apply_post_processed_defaults
    # ```
    sig { returns(T::Array[String]) }
    def apply_post_processed_defaults; end

        # Applies a single default value for the given name.
    # 
    # _@param_ `name` — The name of the field.
    # 
    # Apply a single default.
    # ```ruby
    # model.apply_default("name")
    # ```
    sig { params(name: String).returns(T.untyped) }
    def apply_default(name); end

        # Apply all the defaults at once.
    # 
    # Apply all the defaults.
    # ```ruby
    # model.apply_defaults
    # ```
    sig { returns(T.untyped) }
    def apply_defaults; end

    # Returns an array of names for the attributes available on this object.
    # 
    # Provides the field names in an ORM-agnostic way. Rails v3.1+ uses this
    # method to automatically wrap params in JSON requests.
    # 
    # _@return_ — The field names
    # 
    # Get the field names
    # ```ruby
    # docment.attribute_names
    # ```
    sig { returns(T::Array[String]) }
    def attribute_names; end

    # Get the name of the provided field as it is stored in the database.
    # Used in determining if the field is aliased or not.
    # 
    # _@param_ `name` — The name to get.
    # 
    # _@return_ — The name of the field as it's stored in the db.
    # 
    # Get the database field name.
    # ```ruby
    # model.database_field_name(:authorization)
    # ```
    sig { params(name: T.any(String, Symbol)).returns(String) }
    def database_field_name(name); end

    # Is the provided field a lazy evaluation?
    # 
    # _@param_ `field` — The field.
    # 
    # _@param_ `value` — The current value.
    # 
    # _@return_ — If we set the field lazily.
    # 
    # If the field is lazy settable.
    # ```ruby
    # doc.lazy_settable?(field, nil)
    # ```
    sig { params(field: T.any(Standard, ForeignKey), value: Object).returns(T::Boolean) }
    def lazy_settable?(field, value); end

    # Is the document using object ids?
    # 
    # _@return_ — Using object ids.
    # 
    # Is the document using object ids?
    # ```ruby
    # model.using_object_ids?
    # ```
    # 
    # _@note_ — Refactored from using delegate for class load performance.
    sig { returns(T::Boolean) }
    def using_object_ids?; end

        # Stores the provided block to be run when the option name specified is
    # defined on a field.
    # 
    # No assumptions are made about what sort of work the handler might
    # perform, so it will always be called if the `option_name` key is
    # provided in the field definition -- even if it is false or nil.
    # 
    # _@param_ `option_name` — the option name to match against
    # 
    # _@param_ `block` — the handler to execute when the option is provided.
    # 
    # ```ruby
    # Mongoid::Fields.option :required do |model, field, value|
    #   model.validates_presence_of field if value
    # end
    # ```
    sig { params(option_name: Symbol, block: T.untyped).returns(T.untyped) }
    def self.option(option_name, &block); end

    # Return a map of custom option names to their handlers.
    # 
    # _@return_ — the option map
    # 
    # ```ruby
    # Mongoid::Fields.options
    # # => { :required => #<Proc:0x00000100976b38> }
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def self.options; end

    module ClassMethods
      # Returns the list of id fields for this model class, as both strings
      # and symbols.
      # 
      # _@return_ — List of id fields.
      sig { returns(T::Array[T.any(Symbol, String)]) }
      def id_fields; end

      # Extracts the id field from the specified attributes hash based on
      # aliases defined in this class.
      # 
      # _@param_ `attributes` — The attributes to inspect.
      # 
      # _@return_ — The id value.
      sig { params(attributes: T::Hash[T.untyped, T.untyped]).returns(Object) }
      def extract_id_field(attributes); end

      # Returns an array of names for the attributes available on this object.
      # 
      # Provides the field names in an ORM-agnostic way. Rails v3.1+ uses this
      # method to automatically wrap params in JSON requests.
      # 
      # _@return_ — The field names
      # 
      # Get the field names
      # ```ruby
      # Model.attribute_names
      # ```
      sig { returns(T::Array[String]) }
      def attribute_names; end

      # Get the name of the provided field as it is stored in the database.
      # Used in determining if the field is aliased or not.
      # 
      # _@param_ `name` — The name to get.
      # 
      # _@return_ — The name of the field as it's stored in the db.
      # 
      # Get the database field name.
      # ```ruby
      # Model.database_field_name(:authorization)
      # ```
      sig { params(name: T.any(String, Symbol)).returns(String) }
      def database_field_name(name); end

      # Defines all the fields that are accessible on the Document
      # For each field that is defined, a getter and setter will be
      # added as an instance method to the Document.
      # 
      # _@param_ `name` — The name of the field.
      # 
      # _@param_ `options` — The options to pass to the field.
      # 
      # _@return_ — The generated field
      # 
      # Define a field.
      # ```ruby
      # field :score, :type => Integer, :default => 0
      # ```
      sig { params(name: Symbol, options: T::Hash[T.untyped, T.untyped]).returns(T.any(Standard, ForeignKey)) }
      def field(name, options = {}); end

      # Replace a field with a new type.
      # 
      # _@param_ `name` — The name of the field.
      # 
      # _@param_ `type` — The new type of field.
      # 
      # _@return_ — The new field.
      # 
      # Replace the field.
      # ```ruby
      # Model.replace_field("_id", String)
      # ```
      sig { params(name: String, type: Class).returns(Serializable) }
      def replace_field(name, type); end

      # Convenience method for determining if we are using +BSON::ObjectIds+ as
      # our id.
      # 
      # _@return_ — If the class uses BSON::ObjectIds for the id.
      # 
      # Does this class use object ids?
      # ```ruby
      # person.using_object_ids?
      # ```
      sig { returns(T::Boolean) }
      def using_object_ids?; end

            # Add the defaults to the model. This breaks them up between ones that
      # are procs and ones that are not.
      # 
      # _@param_ `field` — The field to add for.
      # 
      # Add to the defaults.
      # ```ruby
      # Model.add_defaults(field)
      # ```
      sig { params(field: T.any(Standard, ForeignKey)).returns(T.untyped) }
      def add_defaults(field); end

            # Define a field attribute for the +Document+.
      # 
      # _@param_ `name` — The name of the field.
      # 
      # _@param_ `options` — The hash of options.
      # 
      # Set the field.
      # ```ruby
      # Person.add_field(:name, :default => "Test")
      # ```
      sig { params(name: Symbol, options: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
      def add_field(name, options = {}); end

            # Run through all custom options stored in Mongoid::Fields.options and
      # execute the handler if the option is provided.
      # 
      # _@param_ `field` — the field to process
      # 
      # ```ruby
      # Mongoid::Fields.option :custom do
      #   puts "called"
      # end
      # 
      # field = Mongoid::Fields.new(:test, :custom => true)
      # Person.process_options(field)
      # # => "called"
      # ```
      sig { params(field: T.any(Standard, ForeignKey)).returns(T.untyped) }
      def process_options(field); end

            # Create the field accessors.
      # 
      # _@param_ `name` — The name of the field.
      # 
      # _@param_ `meth` — The name of the accessor.
      # 
      # _@param_ `options` — The options.
      # 
      # Generate the accessors.
      # ```ruby
      # Person.create_accessors(:name, "name")
      # person.name #=> returns the field
      # person.name = "" #=> sets the field
      # person.name? #=> Is the field present?
      # person.name_before_type_cast #=> returns the field before type cast
      # ```
      sig { params(name: Symbol, meth: Symbol, options: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
      def create_accessors(name, meth, options = {}); end

            # Create the getter method for the provided field.
      # 
      # _@param_ `name` — The name of the attribute.
      # 
      # _@param_ `meth` — The name of the method.
      # 
      # _@param_ `field` — The field.
      # 
      # Create the getter.
      # ```ruby
      # Model.create_field_getter("name", "name", field)
      # ```
      sig { params(name: String, meth: String, field: T.any(Standard, ForeignKey)).returns(T.untyped) }
      def create_field_getter(name, meth, field); end

            # Create the getter_before_type_cast method for the provided field. If
      # the attribute has been assigned, return the attribute before it was
      # type cast. Otherwise, delegate to the getter.
      # 
      # _@param_ `name` — The name of the attribute.
      # 
      # _@param_ `meth` — The name of the method.
      # 
      # Create the getter_before_type_cast.
      # ```ruby
      # Model.create_field_getter_before_type_cast("name", "name")
      # ```
      sig { params(name: String, meth: String).returns(T.untyped) }
      def create_field_getter_before_type_cast(name, meth); end

            # Create the setter method for the provided field.
      # 
      # _@param_ `name` — The name of the attribute.
      # 
      # _@param_ `meth` — The name of the method.
      # 
      # _@param_ `field` — The field.
      # 
      # Create the setter.
      # ```ruby
      # Model.create_field_setter("name", "name")
      # ```
      sig { params(name: String, meth: String, field: T.any(Standard, ForeignKey)).returns(T.untyped) }
      def create_field_setter(name, meth, field); end

            # Create the check method for the provided field.
      # 
      # _@param_ `name` — The name of the attribute.
      # 
      # _@param_ `meth` — The name of the method.
      # 
      # Create the check.
      # ```ruby
      # Model.create_field_check("name", "name")
      # ```
      sig { params(name: String, meth: String).returns(T.untyped) }
      def create_field_check(name, meth); end

            # Create the translation getter method for the provided field.
      # 
      # _@param_ `name` — The name of the attribute.
      # 
      # _@param_ `meth` — The name of the method.
      # 
      # Create the translation getter.
      # ```ruby
      # Model.create_translations_getter("name", "name")
      # ```
      sig { params(name: String, meth: String).returns(T.untyped) }
      def create_translations_getter(name, meth); end

            # Create the translation setter method for the provided field.
      # 
      # _@param_ `name` — The name of the attribute.
      # 
      # _@param_ `meth` — The name of the method.
      # 
      # _@param_ `field` — The field.
      # 
      # Create the translation setter.
      # ```ruby
      # Model.create_translations_setter("name", "name")
      # ```
      sig { params(name: String, meth: String, field: T.any(Standard, ForeignKey)).returns(T.untyped) }
      def create_translations_setter(name, meth, field); end

      # Include the field methods as a module, so they can be overridden.
      # 
      # _@return_ — The module of generated methods.
      # 
      # Include the fields.
      # ```ruby
      # Person.generated_methods
      # ```
      sig { returns(Module) }
      def generated_methods; end

            # Remove the default keys for the provided name.
      # 
      # _@param_ `name` — The field name.
      # 
      # Remove the default keys.
      # ```ruby
      # Model.remove_defaults(name)
      # ```
      sig { params(name: String).returns(T.untyped) }
      def remove_defaults(name); end

                        sig { params(name: T.untyped, options: T.untyped).returns(T.untyped) }
      def field_for(name, options); end

                  sig { params(options: T.untyped).returns(T.untyped) }
      def unmapped_type(options); end
    end

    class Standard
      extend Forwardable

            # Adds the atomic changes for this type of resizable field.
      # 
      # field.add_atomic_changes(doc, "key", {}, [], [])
      # 
      # _@param_ `document` — The document to add to.
      # 
      # _@param_ `name` — The name of the field.
      # 
      # _@param_ `key` — The atomic location of the field.
      # 
      # _@param_ `mods` — The current modifications.
      # 
      # _@param_ `new` — The new elements to add.
      # 
      # _@param_ `old` — The old elements getting removed.
      # 
      # Add the atomic changes.
      # ```ruby
      # ```
      sig do
        params(
          document: Document,
          name: String,
          key: String,
          mods: T::Hash[T.untyped, T.untyped],
          new: T::Array[T.untyped],
          old: T::Array[T.untyped]
        ).returns(T.untyped)
      end
      def add_atomic_changes(document, name, key, mods, new, old); end

      # Evaluate the default value and return it. Will handle the
      # serialization, proc calls, and duplication if necessary.
      # 
      # _@param_ `doc` — The document the field belongs to.
      # 
      # _@return_ — The serialized default value.
      # 
      # Evaluate the default value.
      # ```ruby
      # field.eval_default(document)
      # ```
      sig { params(doc: Document).returns(Object) }
      def eval_default(doc); end

      # Is this field a foreign key?
      # 
      # _@return_ — If the field is a foreign key.
      # 
      # Is the field a foreign key?
      # ```ruby
      # field.foreign_key?
      # ```
      sig { returns(T::Boolean) }
      def foreign_key?; end

            # Create the new field with a name and optional additional options.
      # 
      # _@param_ `options` — The field options.
      # 
      # Create the new field.
      # ```ruby
      # Field.new(:name, :type => String)
      # ```
      sig { params(name: T.untyped, options: T::Hash[T.untyped, T.untyped]).void }
      def initialize(name, options = {}); end

      # Does this field do lazy default evaluation?
      # 
      # _@return_ — If the field is lazy.
      # 
      # Is the field lazy?
      # ```ruby
      # field.lazy?
      # ```
      sig { returns(T::Boolean) }
      def lazy?; end

      # Is the field localized or not?
      # 
      # _@return_ — If the field is localized.
      # 
      # Is the field localized?
      # ```ruby
      # field.localized?
      # ```
      sig { returns(T::Boolean) }
      def localized?; end

      # Get the metadata for the field if its a foreign key.
      # 
      # _@return_ — The association metadata.
      # 
      # Get the metadata.
      # ```ruby
      # field.metadata
      # ```
      sig { returns(Association) }
      def association; end

      # Is the field a BSON::ObjectId?
      # 
      # _@return_ — If the field is a BSON::ObjectId.
      # 
      # Is the field a BSON::ObjectId?
      # ```ruby
      # field.object_id_field?
      # ```
      sig { returns(T::Boolean) }
      def object_id_field?; end

      # Does the field pre-process its default value?
      # 
      # _@return_ — If the field's default is pre-processed.
      # 
      # Does the field pre-process the default?
      # ```ruby
      # field.pre_processed?
      # ```
      sig { returns(T::Boolean) }
      def pre_processed?; end

      # Get the type of this field - inferred from the class name.
      # 
      # _@return_ — The name of the class.
      # 
      # Get the type.
      # ```ruby
      # field.type
      # ```
      sig { returns(Class) }
      def type; end

      # Get the name of the default method for this field.
      # 
      # _@return_ — The method name.
      # 
      # Get the default name.
      # ```ruby
      # field.default_name
      # ```
      sig { returns(String) }
      def default_name; end

            # Define the method for getting the default on the document.
      # 
      # _@param_ `object` — The class or module the field is defined on.
      # 
      # Define the method.
      # ```ruby
      # field.define_default_method(doc)
      # ```
      # 
      # _@note_ — Ruby's instance_exec was just too slow.
      sig { params(object: T.any(Class, Module)).returns(T.untyped) }
      def define_default_method(object); end

      # Is the field included in the fields that were returned from the
      # database? We can apply the default if:
      #   1. The field is included in an only limitation (field: 1)
      #   2. The field is not excluded in a without limitation (field: 0)
      # 
      # _@param_ `fields` — The field limitations.
      # 
      # _@return_ — If the field was included.
      # 
      # Is the field included?
      # ```ruby
      # field.included?(fields)
      # ```
      sig { params(fields: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
      def included?(fields); end

      # Get the evaluated default.
      # 
      # _@param_ `doc` — The doc being applied to.
      # 
      # _@return_ — The default value.
      # 
      # Get the evaluated default.
      # ```ruby
      # field.evaluated_default.
      # ```
      sig { params(doc: Document).returns(Object) }
      def evaluated_default(doc); end

      # Evaluate the default proc. In some cases we need to instance exec,
      # in others we don't.
      # 
      # _@param_ `doc` — The document.
      # 
      # _@return_ — The called proc.
      # 
      # Eval the default proc.
      # ```ruby
      # field.evaluate_default_proc(band)
      # ```
      sig { params(doc: Document).returns(Object) }
      def evaluate_default_proc(doc); end

      # This is used when default values need to be serialized. Most of the
      # time just return the object.
      # 
      # _@param_ `object` — The default.
      # 
      # _@return_ — The serialized default.
      # 
      # Serialize the default value.
      # ```ruby
      # field.serialize_default(obj)
      # ```
      sig { params(object: Object).returns(Object) }
      def serialize_default(object); end

            # Defines the behavior for defined fields in the document.
      # Set readers for the instance variables.
      sig { returns(T.untyped) }
      attr_accessor :default_val

            # Defines the behavior for defined fields in the document.
      # Set readers for the instance variables.
      sig { returns(T.untyped) }
      attr_accessor :label

            # Defines the behavior for defined fields in the document.
      # Set readers for the instance variables.
      sig { returns(T.untyped) }
      attr_accessor :name

            # Defines the behavior for defined fields in the document.
      # Set readers for the instance variables.
      sig { returns(T.untyped) }
      attr_accessor :options
    end

    class Localized < Mongoid::Fields::Standard
      # Demongoize the object based on the current locale. Will look in the
      # hash for the current locale.
      # 
      # _@param_ `object` — The hash of translations.
      # 
      # _@return_ — The value for the current locale.
      # 
      # Get the demongoized value.
      # ```ruby
      # field.demongoize({ "en" => "testing" })
      # ```
      sig { params(object: T::Hash[T.untyped, T.untyped]).returns(Object) }
      def demongoize(object); end

      # Is the field localized or not?
      # 
      # _@return_ — If the field is localized.
      # 
      # Is the field localized?
      # ```ruby
      # field.localized?
      # ```
      sig { returns(T::Boolean) }
      def localized?; end

      # Convert the provided string into a hash for the locale.
      # 
      # _@param_ `object` — The string to convert.
      # 
      # _@return_ — The locale with string translation.
      # 
      # Serialize the value.
      # ```ruby
      # field.mongoize("testing")
      # ```
      sig { params(object: String).returns(T::Hash[T.untyped, T.untyped]) }
      def mongoize(object); end

      # Are fallbacks being used for this localized field.
      # 
      # _@return_ — If fallbacks should be used.
      # 
      # Should fallbacks be used.
      # ```ruby
      # field.fallbacks?
      # ```
      sig { returns(T::Boolean) }
      def fallbacks?; end

      # Lookup the value from the provided object.
      # 
      # _@param_ `object` — The localized object.
      # 
      # _@return_ — The object for the locale.
      # 
      # Lookup the value.
      # ```ruby
      # field.lookup({ "en" => "test" })
      # ```
      sig { params(object: T::Hash[T.untyped, T.untyped]).returns(Object) }
      def lookup(object); end
    end

    class ForeignKey < Mongoid::Fields::Standard
            # Adds the atomic changes for this type of resizable field.
      # 
      # @todo: Durran: Refactor, big time.
      # 
      # _@param_ `document` — The document to add to.
      # 
      # _@param_ `name` — The name of the field.
      # 
      # _@param_ `key` — The atomic location of the field.
      # 
      # _@param_ `mods` — The current modifications.
      # 
      # _@param_ `new_elements` — The new elements to add.
      # 
      # _@param_ `old_elements` — The old elements getting removed.
      # 
      # Add the atomic changes.
      # ```ruby
      # field.add_atomic_changes(doc, "key", {}, [], [])
      # ```
      sig do
        params(
          document: Document,
          name: String,
          key: String,
          mods: T::Hash[T.untyped, T.untyped],
          new_elements: T::Array[T.untyped],
          old_elements: T::Array[T.untyped]
        ).returns(T.untyped)
      end
      def add_atomic_changes(document, name, key, mods, new_elements, old_elements); end

      # Is this field a foreign key?
      # 
      # _@return_ — If the field is a foreign key.
      # 
      # Is the field a foreign key?
      # ```ruby
      # field.foreign_key?
      # ```
      sig { returns(T::Boolean) }
      def foreign_key?; end

      # Evolve the object into an id compatible object.
      # 
      # _@param_ `object` — The object to evolve.
      # 
      # _@return_ — The evolved object.
      # 
      # Evolve the object.
      # ```ruby
      # field.evolve(object)
      # ```
      sig { params(object: Object).returns(Object) }
      def evolve(object); end

      # Does this field do lazy default evaluation?
      # 
      # _@return_ — If the field is lazy.
      # 
      # Is the field lazy?
      # ```ruby
      # field.lazy?
      # ```
      sig { returns(T::Boolean) }
      def lazy?; end

      # Mongoize the object into the Mongo friendly value.
      # 
      # _@param_ `object` — The object to Mongoize.
      # 
      # _@return_ — The mongoized object.
      # 
      # Mongoize the object.
      # ```ruby
      # field.mongoize(object)
      # ```
      sig { params(object: Object).returns(Object) }
      def mongoize(object); end

      # Is the field a BSON::ObjectId?
      # 
      # _@return_ — If the field is a BSON::ObjectId.
      # 
      # Is the field a BSON::ObjectId?
      # ```ruby
      # field.object_id_field?
      # ```
      sig { returns(T::Boolean) }
      def object_id_field?; end

      # Returns true if an array, false if not.
      # 
      # _@return_ — If the field is resizable.
      # 
      # Is the field resizable?
      # ```ruby
      # field.resizable?
      # ```
      sig { returns(T::Boolean) }
      def resizable?; end

      # Evaluate the default proc. In some cases we need to instance exec,
      # in others we don't.
      # 
      # _@param_ `doc` — The document.
      # 
      # _@return_ — The called proc.
      # 
      # Eval the default proc.
      # ```ruby
      # field.evaluate_default_proc(band)
      # ```
      sig { params(doc: Document).returns(Object) }
      def evaluate_default_proc(doc); end

      # Get the id field of the association.
      # 
      # _@return_ — The field.
      # 
      # Get the related id field.
      # ```ruby
      # field.related_id_field
      # ```
      sig { returns(Fields::Standard) }
      def related_id_field; end

      # This is used when default values need to be serialized. Most of the
      # time just return the object.
      # 
      # _@param_ `object` — The default.
      # 
      # _@return_ — The serialized default.
      # 
      # Serialize the default value.
      # ```ruby
      # field.serialize_default(obj)
      # ```
      sig { params(object: Object).returns(Object) }
      def serialize_default(object); end
    end

    module Validators
      # Validates the params passed to the field macro.
      module Macro
        extend Mongoid::Fields::Validators::Macro
        FIELD_TYPE_IS_SYMBOL = T.let('The BSON symbol type is deprecated; use String instead'.freeze, T.untyped)
        OPTIONS = T.let([
  :as,
  :default,
  :identity,
  :label,
  :localize,
  :fallbacks,
  :association,
  :pre_processed,
  :subtype,
  :type,
  :overwrite
], T.untyped)

                # Validate the field definition.
        # 
        # _@param_ `klass` — The model class.
        # 
        # _@param_ `name` — The field name.
        # 
        # _@param_ `options` — The provided options.
        # 
        # Validate the field definition.
        # ```ruby
        # Macro.validate(Model, :name, { localized: true })
        # ```
        sig { params(klass: Class, name: Symbol, options: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
        def validate(klass, name, options); end

                # Validate the association definition.
        # 
        # _@param_ `klass` — The model class.
        # 
        # _@param_ `name` — The field name.
        # 
        # _@param_ `options` — The provided options.
        # 
        # Validate the association definition.
        # ```ruby
        # Macro.validate(Model, :name)
        # ```
        sig { params(klass: Class, name: Symbol, options: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
        def validate_relation(klass, name, options = {}); end

                # Determine if the field name is valid, if not raise an error.
        # 
        # _@param_ `klass` — The model class.
        # 
        # _@param_ `name` — The field name.
        # 
        # Check the field name.
        # ```ruby
        # Macro.validate_field_name(Model, :name)
        # ```
        sig { params(klass: Class, name: Symbol).returns(T.untyped) }
        def validate_field_name(klass, name); end

                # Determine if the field name is unique, if not raise an error.
        # 
        # _@param_ `klass` — The model class.
        # 
        # _@param_ `name` — The field name.
        # 
        # _@param_ `options` — The provided options.
        # 
        # Check the field name.
        # ```ruby
        # Macro.validate_name_uniqueness(Model, :name, {})
        # ```
        sig { params(klass: Class, name: Symbol, options: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
        def validate_name_uniqueness(klass, name, options); end

                # Validate that the field options are allowed.
        # 
        # _@param_ `klass` — The model class.
        # 
        # _@param_ `name` — The field name.
        # 
        # _@param_ `options` — The provided options.
        # 
        # Validate the field options.
        # ```ruby
        # Macro.validate_options(Model, :name, { localized: true })
        # ```
        sig { params(klass: Class, name: Symbol, options: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
        def validate_options(klass, name, options); end

                # Validate the field definition.
        # 
        # _@param_ `klass` — The model class.
        # 
        # _@param_ `name` — The field name.
        # 
        # _@param_ `options` — The provided options.
        # 
        # Validate the field definition.
        # ```ruby
        # Macro.validate(Model, :name, { localized: true })
        # ```
        sig { params(klass: Class, name: Symbol, options: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
        def self.validate(klass, name, options); end

                # Validate the association definition.
        # 
        # _@param_ `klass` — The model class.
        # 
        # _@param_ `name` — The field name.
        # 
        # _@param_ `options` — The provided options.
        # 
        # Validate the association definition.
        # ```ruby
        # Macro.validate(Model, :name)
        # ```
        sig { params(klass: Class, name: Symbol, options: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
        def self.validate_relation(klass, name, options = {}); end

                # Determine if the field name is valid, if not raise an error.
        # 
        # _@param_ `klass` — The model class.
        # 
        # _@param_ `name` — The field name.
        # 
        # Check the field name.
        # ```ruby
        # Macro.validate_field_name(Model, :name)
        # ```
        sig { params(klass: Class, name: Symbol).returns(T.untyped) }
        def self.validate_field_name(klass, name); end

                # Determine if the field name is unique, if not raise an error.
        # 
        # _@param_ `klass` — The model class.
        # 
        # _@param_ `name` — The field name.
        # 
        # _@param_ `options` — The provided options.
        # 
        # Check the field name.
        # ```ruby
        # Macro.validate_name_uniqueness(Model, :name, {})
        # ```
        sig { params(klass: Class, name: Symbol, options: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
        def self.validate_name_uniqueness(klass, name, options); end

                # Validate that the field options are allowed.
        # 
        # _@param_ `klass` — The model class.
        # 
        # _@param_ `name` — The field name.
        # 
        # _@param_ `options` — The provided options.
        # 
        # Validate the field options.
        # ```ruby
        # Macro.validate_options(Model, :name, { localized: true })
        # ```
        sig { params(klass: Class, name: Symbol, options: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
        def self.validate_options(klass, name, options); end
      end
    end
  end

  module Clients
    include Mongoid::Clients::StorageOptions
    include Mongoid::Clients::Options
    include Mongoid::Clients::Sessions
    extend ActiveSupport::Concern
    CREATE_LOCK = T.let(Mutex.new, T.untyped)

    # Clear all clients from the current thread.
    # 
    # _@return_ — The empty clients.
    # 
    # Clear all clients.
    # ```ruby
    # Mongoid::Clients.clear
    # ```
    sig { returns(T::Array[T.untyped]) }
    def self.clear; end

    # sord warn - Mongo::Client wasn't able to be resolved to a constant in this project
    # Get the default client.
    # 
    # _@return_ — The default client.
    # 
    # Get the default client.
    # ```ruby
    # Mongoid::Clients.default
    # ```
    sig { returns(::Mongo::Client) }
    def self.default; end

    # Disconnect all active clients.
    # 
    # _@return_ — True.
    # 
    # Disconnect all active clients.
    # ```ruby
    # Mongoid::Clients.disconnect
    # ```
    sig { returns(T::Boolean) }
    def self.disconnect; end

    # sord warn - Mongo::Client wasn't able to be resolved to a constant in this project
    # Get a client with the provided name.
    # 
    # _@param_ `name` — The name of the client.
    # 
    # _@return_ — The named client.
    # 
    # Get a client with the name.
    # ```ruby
    # Mongoid::Clients.with_name(:replica)
    # ```
    sig { params(name: Symbol).returns(::Mongo::Client) }
    def self.with_name(name); end

                sig { params(name: T.untyped, client: T.untyped).returns(T.untyped) }
    def self.set(name, client); end

        sig { returns(T.untyped) }
    def self.clients; end

    # Execute a block within the context of a session.
    # 
    # _@param_ `options` — The session options. Please see the driver documentation for the available session options.
    # 
    # _@return_ — The result of calling the block.
    # 
    # Execute some operations in the context of a session.
    # ```ruby
    # band.with_session(causal_consistency: true) do
    #   band.records << Record.create
    #   band.name = 'FKA Twigs'
    #   band.save
    #   band.reload
    # end
    # ```
    # 
    # _@note_ — You cannot do any operations in the block using models or objects
    # that use a different client; the block will execute all operations
    # in the context of the implicit session and operations on any models using
    # another client will fail. For example, if you set a client using store_in on a
    # particular model and execute an operation on it in the session context block,
    # that operation can't use the block's session and an error will be raised.
    # An error will also be raised if sessions are nested.
    sig { params(options: T::Hash[T.untyped, T.untyped]).returns(Object) }
    def with_session(options = {}); end

        sig { returns(T.untyped) }
    def _session; end

        # Change the persistence context for this object during the block.
    # 
    # _@param_ `options_or_context` — The storage options or a persistence context.
    # 
    # Save the current document to a different collection.
    # ```ruby
    # model.with(collection: "bands") do |m|
    #   m.save
    # end
    # ```
    sig { params(options_or_context: T.any(T::Hash[T.untyped, T.untyped], Mongoid::PersistenceContext), block: T.untyped).returns(T.untyped) }
    def with(options_or_context, &block); end

            sig { params(parent: T.untyped).returns(T.untyped) }
    def collection(parent = nil); end

        sig { returns(T.untyped) }
    def collection_name; end

        sig { returns(T.untyped) }
    def mongo_client; end

        sig { returns(T.untyped) }
    def persistence_context; end

            sig { params(options_or_context: T.untyped).returns(T.untyped) }
    def set_persistence_context(options_or_context); end

                sig { params(original_cluster: T.untyped, context: T.untyped).returns(T.untyped) }
    def clear_persistence_context(original_cluster = nil, context = nil); end

    module Factory
      extend Mongoid::Clients::Factory
      MONGOID_WRAPPING_LIBRARY = T.let({
  name: 'Mongoid',
  version: VERSION,
}.freeze, T.untyped)

      # sord warn - Mongo::Client wasn't able to be resolved to a constant in this project
      # Create a new client given the named configuration. If no name is
      # provided, return a new client with the default configuration. If a
      # name is provided for which no configuration exists, an error will be
      # raised.
      # 
      # _@param_ `name` — The named client configuration.
      # 
      # _@return_ — The new client.
      # 
      # Create the client.
      # ```ruby
      # Factory.create(:analytics)
      # ```
      sig { params(name: T.nilable(T.any(String, Symbol))).returns(::Mongo::Client) }
      def create(name = nil); end

      # sord warn - Mongo::Client wasn't able to be resolved to a constant in this project
      # Get the default client.
      # 
      # _@return_ — The default client.
      # 
      # Get the default client.
      # ```ruby
      # Factory.default
      # ```
      sig { returns(::Mongo::Client) }
      def default; end

      # sord warn - Mongo::Client wasn't able to be resolved to a constant in this project
      # Create the client for the provided config.
      # 
      # _@param_ `configuration` — The client config.
      # 
      # _@return_ — The client.
      # 
      # Create the client.
      # ```ruby
      # Factory.create_client(config)
      # ```
      sig { params(configuration: T::Hash[T.untyped, T.untyped]).returns(::Mongo::Client) }
      def create_client(configuration); end

            sig { returns(T.untyped) }
      def driver_version; end

                  sig { params(configuration: T.untyped).returns(T.untyped) }
      def options(configuration); end

      # sord warn - Mongo::Client wasn't able to be resolved to a constant in this project
      # Create a new client given the named configuration. If no name is
      # provided, return a new client with the default configuration. If a
      # name is provided for which no configuration exists, an error will be
      # raised.
      # 
      # _@param_ `name` — The named client configuration.
      # 
      # _@return_ — The new client.
      # 
      # Create the client.
      # ```ruby
      # Factory.create(:analytics)
      # ```
      sig { params(name: T.nilable(T.any(String, Symbol))).returns(::Mongo::Client) }
      def self.create(name = nil); end

      # sord warn - Mongo::Client wasn't able to be resolved to a constant in this project
      # Get the default client.
      # 
      # _@return_ — The default client.
      # 
      # Get the default client.
      # ```ruby
      # Factory.default
      # ```
      sig { returns(::Mongo::Client) }
      def self.default; end

      # sord warn - Mongo::Client wasn't able to be resolved to a constant in this project
      # Create the client for the provided config.
      # 
      # _@param_ `configuration` — The client config.
      # 
      # _@return_ — The client.
      # 
      # Create the client.
      # ```ruby
      # Factory.create_client(config)
      # ```
      sig { params(configuration: T::Hash[T.untyped, T.untyped]).returns(::Mongo::Client) }
      def self.create_client(configuration); end

            sig { returns(T.untyped) }
      def self.driver_version; end

                  sig { params(configuration: T.untyped).returns(T.untyped) }
      def self.options(configuration); end
    end

    module Options
      extend ActiveSupport::Concern

            # Change the persistence context for this object during the block.
      # 
      # _@param_ `options_or_context` — The storage options or a persistence context.
      # 
      # Save the current document to a different collection.
      # ```ruby
      # model.with(collection: "bands") do |m|
      #   m.save
      # end
      # ```
      sig { params(options_or_context: T.any(T::Hash[T.untyped, T.untyped], Mongoid::PersistenceContext), block: T.untyped).returns(T.untyped) }
      def with(options_or_context, &block); end

                  sig { params(parent: T.untyped).returns(T.untyped) }
      def collection(parent = nil); end

            sig { returns(T.untyped) }
      def collection_name; end

            sig { returns(T.untyped) }
      def mongo_client; end

            sig { returns(T.untyped) }
      def persistence_context; end

                  sig { params(options_or_context: T.untyped).returns(T.untyped) }
      def set_persistence_context(options_or_context); end

                        sig { params(original_cluster: T.untyped, context: T.untyped).returns(T.untyped) }
      def clear_persistence_context(original_cluster = nil, context = nil); end

      module ClassMethods
                sig { returns(T.untyped) }
        def client_name; end

                sig { returns(T.untyped) }
        def collection_name; end

                sig { returns(T.untyped) }
        def database_name; end

                sig { returns(T.untyped) }
        def collection; end

                sig { returns(T.untyped) }
        def mongo_client; end

                # Change the persistence context for this class during the block.
        # 
        # _@param_ `options` — The storage options.
        # 
        # Save the current document to a different collection.
        # ```ruby
        # Model.with(collection: "bands") do |m|
        #   m.create
        # end
        # ```
        sig { params(options: T::Hash[T.untyped, T.untyped], block: T.untyped).returns(T.untyped) }
        def with(options, &block); end

                sig { returns(T.untyped) }
        def persistence_context; end
      end
    end

    # Encapsulates behavior for getting a session from the client of a model class or instance,
    # setting the session on the current thread, and yielding to a block.
    # The session will be closed after the block completes or raises an error.
    # 
    # @since 6.4.0
    module Sessions
      # Execute a block within the context of a session.
      # 
      # _@param_ `options` — The session options. Please see the driver documentation for the available session options.
      # 
      # _@return_ — The result of calling the block.
      # 
      # Execute some operations in the context of a session.
      # ```ruby
      # band.with_session(causal_consistency: true) do
      #   band.records << Record.create
      #   band.name = 'FKA Twigs'
      #   band.save
      #   band.reload
      # end
      # ```
      # 
      # _@note_ — You cannot do any operations in the block using models or objects
      # that use a different client; the block will execute all operations
      # in the context of the implicit session and operations on any models using
      # another client will fail. For example, if you set a client using store_in on a
      # particular model and execute an operation on it in the session context block,
      # that operation can't use the block's session and an error will be raised.
      # An error will also be raised if sessions are nested.
      sig { params(options: T::Hash[T.untyped, T.untyped]).returns(Object) }
      def with_session(options = {}); end

            sig { returns(T.untyped) }
      def _session; end

      module ClassMethods
        # Execute a block within the context of a session.
        # 
        # _@param_ `options` — The session options. Please see the driver documentation for the available session options.
        # 
        # _@return_ — The result of calling the block.
        # 
        # Execute some operations in the context of a session.
        # ```ruby
        # Band.with_session(causal_consistency: true) do
        #   band = Band.create
        #   band.records << Record.new
        #   band.save
        #   band.reload.records
        # end
        # ```
        # 
        # _@note_ — You cannot do any operations in the block using models or objects
        # that use a different client; the block will execute all operations
        # in the context of the implicit session and operations on any models using
        # another client will fail. For example, if you set a client using store_in on a
        # particular model and execute an operation on it in the session context block,
        # that operation can't use the block's session and an error will be raised.
        # You also cannot nest sessions.
        sig { params(options: T::Hash[T.untyped, T.untyped]).returns(Object) }
        def with_session(options = {}); end

                sig { returns(T.untyped) }
        def _session; end
      end
    end

    module StorageOptions
      extend ActiveSupport::Concern

      module ClassMethods
        # Give this model specific custom default storage options.
        # 
        # _@param_ `options` — The storage options.
        # 
        # _@return_ — The model class.
        # 
        # Store this model by default in "artists"
        # ```ruby
        # class Band
        #   include Mongoid::Document
        #   store_in collection: "artists"
        # end
        # ```
        # 
        # Store this model by default in the sharded db.
        # ```ruby
        # class Band
        #   include Mongoid::Document
        #   store_in database: "echo_shard"
        # end
        # ```
        # 
        # Store this model by default in a different client.
        # ```ruby
        # class Band
        #   include Mongoid::Document
        #   store_in client: "analytics"
        # end
        # ```
        # 
        # Store this model with a combination of options.
        # ```ruby
        # class Band
        #   include Mongoid::Document
        #   store_in collection: "artists", database: "music"
        # end
        # ```
        sig { params(options: T::Hash[T.untyped, T.untyped]).returns(Class) }
        def store_in(options); end

                # Reset the store_in options
        # 
        # Reset the store_in options
        # ```ruby
        # Model.reset_storage_options!
        # ```
        sig { returns(T.untyped) }
        def reset_storage_options!; end

        # Get the default storage options.
        # 
        # _@return_ — Default storage options.
        # 
        # Get the default storage options.
        # ```ruby
        # Model.storage_options_defaults
        # ```
        sig { returns(T::Hash[T.untyped, T.untyped]) }
        def storage_options_defaults; end
      end
    end

    module Validators
      # Validates the options passed to :store_in.
      module Storage
        extend Mongoid::Clients::Validators::Storage
        VALID_OPTIONS = T.let([ :collection, :database, :client ].freeze, T.untyped)

                # Validate the options provided to :store_in.
        # 
        # _@param_ `klass` — The model class.
        # 
        # _@param_ `options` — The provided options.
        # 
        # Validate the options.
        # ```ruby
        # Storage.validate(:collection_name)
        # ```
        sig { params(klass: Class, options: T.any(T::Hash[T.untyped, T.untyped], String, Symbol)).returns(T.untyped) }
        def validate(klass, options); end

        # Determine if the current klass is valid to change store_in
        # options
        # 
        # _@param_ `klass`
        # 
        # _@return_ — If the class is valid
        sig { params(klass: Class).returns(T::Boolean) }
        def valid_parent?(klass); end

        # Determine if all keys in the options hash are valid.
        # 
        # _@param_ `options` — The options hash.
        # 
        # _@return_ — If all keys are valid.
        # 
        # Are all keys valid?
        # ```ruby
        # validator.valid_keys?({ collection: "name" })
        # ```
        sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
        def valid_keys?(options); end

                # Validate the options provided to :store_in.
        # 
        # _@param_ `klass` — The model class.
        # 
        # _@param_ `options` — The provided options.
        # 
        # Validate the options.
        # ```ruby
        # Storage.validate(:collection_name)
        # ```
        sig { params(klass: Class, options: T.any(T::Hash[T.untyped, T.untyped], String, Symbol)).returns(T.untyped) }
        def self.validate(klass, options); end

        # Determine if the current klass is valid to change store_in
        # options
        # 
        # _@param_ `klass`
        # 
        # _@return_ — If the class is valid
        sig { params(klass: Class).returns(T::Boolean) }
        def self.valid_parent?(klass); end

        # Determine if all keys in the options hash are valid.
        # 
        # _@param_ `options` — The options hash.
        # 
        # _@return_ — If all keys are valid.
        # 
        # Are all keys valid?
        # ```ruby
        # validator.valid_keys?({ collection: "name" })
        # ```
        sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
        def self.valid_keys?(options); end
      end
    end
  end

  # Instantiates documents that came from the database.
  module Factory
    extend Mongoid::Factory
    TYPE = T.let("_type".freeze, T.untyped)

    # Builds a new +Document+ from the supplied attributes.
    # 
    # This method either instantiats klass or a descendant of klass if the attributes include
    # klass' discriminator key.
    # 
    # If the attributes contain the discriminator key (which is _type by default) and the
    # discriminator value does not correspond to a descendant of klass then this method
    # would create an instance of klass.
    # 
    # _@param_ `klass` — The class to instantiate from if _type is not present.
    # 
    # _@param_ `attributes` — The document attributes.
    # 
    # _@return_ — The instantiated document.
    # 
    # Build the document.
    # ```ruby
    # Mongoid::Factory.build(Person, { "name" => "Durran" })
    # ```
    sig { params(klass: Class, attributes: T.nilable(T::Hash[T.untyped, T.untyped])).returns(Document) }
    def build(klass, attributes = nil); end

    # Builds a new +Document+ from the supplied attributes loaded from the
    # database.
    # 
    # If the attributes contain the discriminator key (which is _type by default) and the
    # discriminator value does not correspond to a descendant of klass then this method
    # raises an UnknownModel error.
    # 
    # If a criteria object is given, it is used in two ways:
    # 1. If the criteria has a list of fields specified via #only,
    #    only those fields are populated in the returned document.
    # 2. If the criteria has a referencing association (i.e., this document
    #    is being instantiated as an association of another document),
    #    the other document is also populated in the returned document's
    #    reverse association, if one exists.
    # 
    # _@param_ `klass` — The class to instantiate from if _type is not present.
    # 
    # _@param_ `attributes` — The document attributes.
    # 
    # _@param_ `criteria` — Optional criteria object.
    # 
    # _@param_ `selected_fields` — Fields which were retrieved via #only. If selected_fields are specified, fields not listed in it will not be accessible in the returned document.
    # 
    # _@return_ — The instantiated document.
    # 
    # Build the document.
    # ```ruby
    # Mongoid::Factory.from_db(Person, { "name" => "Durran" })
    # ```
    sig do
      params(
        klass: Class,
        attributes: T.nilable(T::Hash[T.untyped, T.untyped]),
        criteria: T.nilable(Criteria),
        selected_fields: T.nilable(T::Hash[T.untyped, T.untyped])
      ).returns(Document)
    end
    def from_db(klass, attributes = nil, criteria = nil, selected_fields = nil); end

    # Builds a new +Document+ from the supplied attributes.
    # 
    # This method either instantiats klass or a descendant of klass if the attributes include
    # klass' discriminator key.
    # 
    # If the attributes contain the discriminator key (which is _type by default) and the
    # discriminator value does not correspond to a descendant of klass then this method
    # would create an instance of klass.
    # 
    # _@param_ `klass` — The class to instantiate from if _type is not present.
    # 
    # _@param_ `attributes` — The document attributes.
    # 
    # _@return_ — The instantiated document.
    # 
    # Build the document.
    # ```ruby
    # Mongoid::Factory.build(Person, { "name" => "Durran" })
    # ```
    sig { params(klass: Class, attributes: T.nilable(T::Hash[T.untyped, T.untyped])).returns(Document) }
    def self.build(klass, attributes = nil); end

    # Builds a new +Document+ from the supplied attributes loaded from the
    # database.
    # 
    # If the attributes contain the discriminator key (which is _type by default) and the
    # discriminator value does not correspond to a descendant of klass then this method
    # raises an UnknownModel error.
    # 
    # If a criteria object is given, it is used in two ways:
    # 1. If the criteria has a list of fields specified via #only,
    #    only those fields are populated in the returned document.
    # 2. If the criteria has a referencing association (i.e., this document
    #    is being instantiated as an association of another document),
    #    the other document is also populated in the returned document's
    #    reverse association, if one exists.
    # 
    # _@param_ `klass` — The class to instantiate from if _type is not present.
    # 
    # _@param_ `attributes` — The document attributes.
    # 
    # _@param_ `criteria` — Optional criteria object.
    # 
    # _@param_ `selected_fields` — Fields which were retrieved via #only. If selected_fields are specified, fields not listed in it will not be accessible in the returned document.
    # 
    # _@return_ — The instantiated document.
    # 
    # Build the document.
    # ```ruby
    # Mongoid::Factory.from_db(Person, { "name" => "Durran" })
    # ```
    sig do
      params(
        klass: Class,
        attributes: T.nilable(T::Hash[T.untyped, T.untyped]),
        criteria: T.nilable(Criteria),
        selected_fields: T.nilable(T::Hash[T.untyped, T.untyped])
      ).returns(Document)
    end
    def self.from_db(klass, attributes = nil, criteria = nil, selected_fields = nil); end
  end

  # @api private
  module Matcher
        sig { returns(T.untyped) }
    def as_attributes; end

        sig { returns(T.untyped) }
    def self.as_attributes; end

    # @api private
    module Eq
    end

    # @api private
    module Gt
            sig { returns(T.untyped) }
      def >; end

            sig { returns(T.untyped) }
      def self.>; end
    end

    # @api private
    module In
    end

    # @api private
    module Lt
            sig { returns(T.untyped) }
      def <; end

            sig { returns(T.untyped) }
      def self.<; end
    end

    # @api private
    module Ne
    end

    # @api private
    module Or
    end

    # @api private
    module All
    end

    # @api private
    module And
    end

    # @api private
    module Gte
            sig { returns(T.untyped) }
      def >=; end

            sig { returns(T.untyped) }
      def self.>=; end
    end

    # @api private
    module Lte
            sig { returns(T.untyped) }
      def <=; end

            sig { returns(T.untyped) }
      def self.<=; end
    end

    # @api private
    module Mod
    end

    # @api private
    module Nin
    end

    # @api private
    module Nor
    end

    # @api private
    module Not
    end

    # @api private
    module Bits
                        sig { params(exists: T.untyped, value: T.untyped, condition: T.untyped).returns(T::Boolean) }
      def matches?(exists, value, condition); end
    end

    # @api private
    module Size
    end

    # @see https://docs.mongodb.com/manual/reference/operator/query/type/
    # 
    # @api private
    module Type
    end

    # @api private
    module Regex
    end

    # @api private
    module Exists
    end

    # This module is used by $eq and other operators that need to perform
    # the matching that $eq performs (for example, $ne which negates the result
    # of $eq). Unlike $eq this module takes an original operator as an
    # additional argument to +matches?+ to provide the correct exception
    # messages reflecting the operator that was first invoked.
    # 
    # @api private
    module EqImpl
    end

    # @api private
    module ElemMatch
    end

    # @api private
    module Expression
    end

    # @api private
    module BitsAllSet
      include Mongoid::Matcher::Bits
      extend Mongoid::Matcher::BitsAllSet

                  sig { params(value: T.untyped, condition: T.untyped).returns(T::Boolean) }
      def array_matches?(value, condition); end

                  sig { params(value: T.untyped, condition: T.untyped).returns(T::Boolean) }
      def int_matches?(value, condition); end

                  sig { params(value: T.untyped, condition: T.untyped).returns(T::Boolean) }
      def self.array_matches?(value, condition); end

                  sig { params(value: T.untyped, condition: T.untyped).returns(T::Boolean) }
      def self.int_matches?(value, condition); end

                        sig { params(exists: T.untyped, value: T.untyped, condition: T.untyped).returns(T::Boolean) }
      def self.matches?(exists, value, condition); end

                        sig { params(exists: T.untyped, value: T.untyped, condition: T.untyped).returns(T::Boolean) }
      def matches?(exists, value, condition); end
    end

    # @api private
    module BitsAnySet
      include Mongoid::Matcher::Bits
      extend Mongoid::Matcher::BitsAnySet

                  sig { params(value: T.untyped, condition: T.untyped).returns(T::Boolean) }
      def array_matches?(value, condition); end

                  sig { params(value: T.untyped, condition: T.untyped).returns(T::Boolean) }
      def int_matches?(value, condition); end

                  sig { params(value: T.untyped, condition: T.untyped).returns(T::Boolean) }
      def self.array_matches?(value, condition); end

                  sig { params(value: T.untyped, condition: T.untyped).returns(T::Boolean) }
      def self.int_matches?(value, condition); end

                        sig { params(exists: T.untyped, value: T.untyped, condition: T.untyped).returns(T::Boolean) }
      def self.matches?(exists, value, condition); end

                        sig { params(exists: T.untyped, value: T.untyped, condition: T.untyped).returns(T::Boolean) }
      def matches?(exists, value, condition); end
    end

    # @api private
    module BitsAllClear
      include Mongoid::Matcher::Bits
      extend Mongoid::Matcher::BitsAllClear

                  sig { params(value: T.untyped, condition: T.untyped).returns(T::Boolean) }
      def array_matches?(value, condition); end

                  sig { params(value: T.untyped, condition: T.untyped).returns(T::Boolean) }
      def int_matches?(value, condition); end

                  sig { params(value: T.untyped, condition: T.untyped).returns(T::Boolean) }
      def self.array_matches?(value, condition); end

                  sig { params(value: T.untyped, condition: T.untyped).returns(T::Boolean) }
      def self.int_matches?(value, condition); end

                        sig { params(exists: T.untyped, value: T.untyped, condition: T.untyped).returns(T::Boolean) }
      def self.matches?(exists, value, condition); end

                        sig { params(exists: T.untyped, value: T.untyped, condition: T.untyped).returns(T::Boolean) }
      def matches?(exists, value, condition); end
    end

    # @api private
    module BitsAnyClear
      include Mongoid::Matcher::Bits
      extend Mongoid::Matcher::BitsAnyClear

                  sig { params(value: T.untyped, condition: T.untyped).returns(T::Boolean) }
      def array_matches?(value, condition); end

                  sig { params(value: T.untyped, condition: T.untyped).returns(T::Boolean) }
      def int_matches?(value, condition); end

                  sig { params(value: T.untyped, condition: T.untyped).returns(T::Boolean) }
      def self.array_matches?(value, condition); end

                  sig { params(value: T.untyped, condition: T.untyped).returns(T::Boolean) }
      def self.int_matches?(value, condition); end

                        sig { params(exists: T.untyped, value: T.untyped, condition: T.untyped).returns(T::Boolean) }
      def self.matches?(exists, value, condition); end

                        sig { params(exists: T.untyped, value: T.untyped, condition: T.untyped).returns(T::Boolean) }
      def matches?(exists, value, condition); end
    end

    # @api private
    module FieldOperator
      MAP = T.let({
  '$all' => All,
  '$bitsAllClear' => BitsAllClear,
  '$bitsAllSet' => BitsAllSet,
  '$bitsAnyClear' => BitsAnyClear,
  '$bitsAnySet' => BitsAnySet,
  '$elemMatch' => ElemMatch,
  '$eq' => Eq,
  '$exists' => Exists,
  '$gt' => Gt,
  '$gte' => Gte,
  '$in' => In,
  '$lt' => Lt,
  '$lte' => Lte,
  '$mod' => Mod,
  '$nin' => Nin,
  '$ne' => Ne,
  '$not' => Not,
  '$regex' => Regex,
  '$size' => Size,
  '$type' => Type,
}.freeze, T.untyped)
    end

    # @api private
    module FieldExpression
    end

    # This is an internal equality implementation that performs exact
    # comparisons and regular expression matches.
    # 
    # @api private
    module EqImplWithRegexp
    end

    # @api private
    module ExpressionOperator
      MAP = T.let({
  '$and' => And,
  '$nor' => Nor,
  '$or' => Or,
}.freeze, T.untyped)
    end

    # $elemMatch argument can be a top-level expression and some specific
    # operator combinations like $not with a regular expression.
    # 
    # @api private
    module ElemMatchExpression
    end
  end

  # This module contains the behavior of Mongoid's clone/dup of documents.
  module Copyable
    extend ActiveSupport::Concern

    # Clone or dup the current +Document+. This will return all attributes with
    # the exception of the document's id, and will reset all the
    # instance variables.
    # 
    # This clone also includes embedded documents.
    # 
    # _@return_ — The new document.
    # 
    # Clone the document.
    # ```ruby
    # document.clone
    # ```
    sig { returns(Document) }
    def clone; end

        # Clone the document attributes
    # 
    # clone document
    # ```ruby
    # model.clone_document
    # ```
    sig { returns(T.untyped) }
    def clone_document; end

            # When cloning, if the document has localized fields we need to ensure they
    # are properly processed in the clone.
    # 
    # _@param_ `attrs` — The attributes.
    # 
    # Process localized attributes.
    # ```ruby
    # model.process_localized_attributes(attributes)
    # ```
    sig { params(klass: T.untyped, attrs: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
    def process_localized_attributes(klass, attrs); end
  end

  # The +Criteria+ class is the core object needed in Mongoid to retrieve
  # objects from the database. It is a DSL that essentially sets up the
  # selector and options arguments that get passed on to a Mongo::Collection
  # in the Ruby driver. Each method on the +Criteria+ returns self to they
  # can be chained in order to create a readable criterion to be executed
  # against the database.
  class Criteria
    include Enumerable
    include Mongoid::Contextual
    include Mongoid::Criteria::Queryable
    include Mongoid::Criteria::Findable
    include Mongoid::Criteria::Includable
    include Mongoid::Criteria::Marshalable
    include Mongoid::Criteria::Modifiable
    include Mongoid::Criteria::Scopable
    include Mongoid::Clients::Options
    include Mongoid::Clients::Sessions
    include Mongoid::Criteria::Options
    CHECK = T.let([], T.untyped)

        sig { returns(T.untyped) }
    def _enumerable_find; end

        sig { returns(T.untyped) }
    def _findable_find; end

    # Returns true if the supplied +Enumerable+ or +Criteria+ is equal to the results
    # of this +Criteria+ or the criteria itself.
    # 
    # _@param_ `other` — The other +Enumerable+ or +Criteria+ to compare to.
    # 
    # _@return_ — If the objects are equal.
    # 
    # _@note_ — This will force a database load when called if an enumerable is passed.
    sig { params(other: Object).returns(T::Boolean) }
    def ==(other); end

        # Finds one or many documents given the provided _id values, or filters
    # the documents in the current scope in the application process space
    # after loading them if needed.
    # 
    # If this method is not given a block, it delegates to +Findable#find+
    # and finds one or many documents for the provided _id values.
    # 
    # If this method is given a block, it delegates to +Enumerable#find+ and
    # returns the first document of those found by the current Crieria object
    # for which the block returns a truthy value.
    # 
    # Note that the "default proc" argument of Enumerable is not specially
    # treated by Mongoid - the decision between delegating to +Findable+ vs
    # +Enumerable+ is made solely based on whether +find+ is passed a block.
    # 
    # _@return_ — A document or matching documents.
    # 
    # Finds a document by its _id, invokes Findable#find.
    # ```ruby
    # critera.find("1234")
    # ```
    # 
    # Finds the first matching document using a block, invokes Enumerable#find.
    # ```ruby
    # criteria.find { |item| item.name == "Depeche Mode" }
    # ```
    # 
    # Finds the first matching document using a block using the default Proc, invokes Enumerable#find.
    # ```ruby
    # criteria.find(-> { "Default Band" }) { |item| item.name == "Milwaukee Mode" }
    # ```
    # 
    # Tries to find a document whose _id is the stringification of the provided Proc, typically failing.
    # ```ruby
    # enumerator = criteria.find(-> { "Default Band" })
    # ```
    # 
    # _@see_ `https://ruby-doc.org/core/Enumerable.html#method-i-find`
    sig { params(args: T.untyped, block: T.untyped).returns(T.nilable(T.any(Document, T::Array[Document]))) }
    def find(*args, &block); end

    # Needed to properly get a criteria back as json
    # 
    # _@param_ `options` — Options to pass through to the serializer.
    # 
    # _@return_ — The JSON string.
    # 
    # Get the criteria as json.
    # ```ruby
    # Person.where(:title => "Sir").as_json
    # ```
    sig { params(options: T.nilable(T::Hash[T.untyped, T.untyped])).returns(String) }
    def as_json(options = nil); end

    # Tells the criteria that the cursor that gets returned needs to be
    # cached. This is so multiple iterations don't hit the database multiple
    # times, however this is not advisable when working with large data sets
    # as the entire results will get stored in memory.
    # 
    # _@return_ — The cloned criteria.
    # 
    # Flag the criteria as cached.
    # ```ruby
    # criteria.cache
    # ```
    sig { returns(Criteria) }
    def cache; end

    # Will return true if the cache option has been set.
    # 
    # _@return_ — If the criteria is flagged as cached.
    # 
    # Is the criteria cached?
    # ```ruby
    # criteria.cached?
    # ```
    sig { returns(T::Boolean) }
    def cached?; end

    # Get the documents from the embedded criteria.
    # 
    # _@return_ — The documents.
    # 
    # Get the documents.
    # ```ruby
    # criteria.documents
    # ```
    sig { returns(T::Array[Document]) }
    def documents; end

    # Set the embedded documents on the criteria.
    # 
    # _@param_ `docs` — The embedded documents.
    # 
    # _@return_ — The embedded documents.
    # 
    # Set the documents.
    # ```ruby
    # ```
    sig { params(docs: T::Array[Document]).returns(T::Array[Document]) }
    def documents=(docs); end

    # Is the criteria for embedded documents?
    # 
    # _@return_ — If the criteria is embedded.
    # 
    # Is the criteria for embedded documents?
    # ```ruby
    # criteria.embedded?
    # ```
    sig { returns(T::Boolean) }
    def embedded?; end

    # Extract a single id from the provided criteria. Could be in an $and
    # query or a straight _id query.
    # 
    # _@return_ — The id.
    # 
    # Extract the id.
    # ```ruby
    # criteria.extract_id
    # ```
    sig { returns(Object) }
    def extract_id; end

    # Adds a criterion to the +Criteria+ that specifies additional options
    # to be passed to the Ruby driver, in the exact format for the driver.
    # 
    # criteria.extras(:limit => 20, :skip => 40)
    # 
    # _@param_ `extras` — The extra driver options.
    # 
    # _@return_ — The cloned criteria.
    # 
    # Add extra params to the criteria.
    # ```ruby
    # ```
    sig { params(extras: T::Hash[T.untyped, T.untyped]).returns(Criteria) }
    def extras(extras); end

    # Get the list of included fields.
    # 
    # _@return_ — The fields.
    # 
    # Get the field list.
    # ```ruby
    # criteria.field_list
    # ```
    sig { returns(T::Array[String]) }
    def field_list; end

    # When freezing a criteria we need to initialize the context first
    # otherwise the setting of the context on attempted iteration will raise a
    # runtime error.
    # 
    # _@return_ — The frozen criteria.
    # 
    # Freeze the criteria.
    # ```ruby
    # criteria.freeze
    # ```
    sig { returns(Criteria) }
    def freeze; end

    # Initialize the new criteria.
    # 
    # _@param_ `klass` — The model class.
    # 
    # Init the new criteria.
    # ```ruby
    # Criteria.new(Band)
    # ```
    sig { params(klass: Class).void }
    def initialize(klass); end

    # Merges another object with this +Criteria+ and returns a new criteria.
    # The other object may be a +Criteria+ or a +Hash+. This is used to
    # combine multiple scopes together, where a chained scope situation
    # may be desired.
    # 
    # _@param_ `other` — The other criterion to merge with.
    # 
    # _@return_ — A cloned self.
    # 
    # Merge the criteria with another criteria.
    # ```ruby
    # criteri.merge(other_criteria)
    # ```
    # 
    # Merge the criteria with a hash. The hash must contain a klass
    # ```ruby
    # key and the key/value pairs correspond to method names/args.
    # 
    # criteria.merge({
    #   klass: Band,
    #   where: { name: "Depeche Mode" },
    #   order_by: { name: 1 }
    # })
    # ```
    sig { params(other: Criteria).returns(Criteria) }
    def merge(other); end

    # Merge the other criteria into this one.
    # 
    # _@param_ `other` — The criteria to merge in.
    # 
    # _@return_ — The merged criteria.
    # 
    # Merge another criteria into this criteria.
    # ```ruby
    # criteria.merge(Person.where(name: "bob"))
    # ```
    sig { params(other: Criteria).returns(Criteria) }
    def merge!(other); end

    # Returns a criteria that will always contain zero results and never hits
    # the database.
    # 
    # _@return_ — The none criteria.
    # 
    # Return a none criteria.
    # ```ruby
    # criteria.none
    # ```
    sig { returns(Criteria) }
    def none; end

    # Is the criteria an empty but chainable criteria?
    # 
    # _@return_ — If the criteria is a none.
    # 
    # Is the criteria a none criteria?
    # ```ruby
    # criteria.empty_and_chainable?
    # ```
    sig { returns(T::Boolean) }
    def empty_and_chainable?; end

    # Overriden to include _type in the fields.
    # 
    # _@param_ `args` — The names of the fields.
    # 
    # _@return_ — The cloned criteria.
    # 
    # Limit the fields returned from the database.
    # ```ruby
    # Band.only(:name)
    # ```
    sig { params(args: T::Array[Symbol]).returns(Criteria) }
    def only(*args); end

    # Set the read preference for the criteria.
    # 
    # _@param_ `value` — The mode preference.
    # 
    # _@return_ — The cloned criteria.
    # 
    # Set the read preference.
    # ```ruby
    # criteria.read(mode: :primary_preferred)
    # ```
    sig { params(value: T.nilable(T::Hash[T.untyped, T.untyped])).returns(Criteria) }
    def read(value = nil); end

    # Overriden to exclude _id from the fields.
    # 
    # _@param_ `args` — The names of the fields.
    # 
    # _@return_ — The cloned criteria.
    # 
    # Exclude fields returned from the database.
    # ```ruby
    # Band.without(:name)
    # ```
    sig { params(args: T::Array[Symbol]).returns(Criteria) }
    def without(*args); end

    # Returns true if criteria responds to the given method.
    # 
    # _@param_ `name` — The name of the class method on the +Document+.
    # 
    # _@param_ `include_private` — Whether to include privates.
    # 
    # _@return_ — If the criteria responds to the method.
    # 
    # Does the criteria respond to the method?
    # ```ruby
    # crtiteria.respond_to?(:each)
    # ```
    sig { params(name: Symbol, include_private: T::Boolean).returns(T::Boolean) }
    def respond_to?(name, include_private = false); end

    # Convenience for objects that want to be merged into a criteria.
    # 
    # _@return_ — self.
    # 
    # Convert to a criteria.
    # ```ruby
    # criteria.to_criteria
    # ```
    sig { returns(Criteria) }
    def to_criteria; end

    # Convert the criteria to a proc.
    # 
    # _@return_ — The wrapped criteria.
    # 
    # Convert the criteria to a proc.
    # ```ruby
    # criteria.to_proc
    # ```
    sig { returns(Proc) }
    def to_proc; end

    # Adds a criterion to the +Criteria+ that specifies a type or an Array of
    # types that must be matched.
    # 
    # _@param_ `types` — The types to match against.
    # 
    # _@return_ — The cloned criteria.
    # 
    # Match only specific models.
    # ```ruby
    # criteria.type('Browser')
    # criteria.type(['Firefox', 'Browser'])
    # ```
    sig { params(types: T::Array[String]).returns(Criteria) }
    def type(types); end

    # sord infer - argument name in single @param inferred as "*args"
    # This is the general entry point for most MongoDB queries. This either
    # creates a standard field: value selection, and expanded selection with
    # the use of hash methods, or a $where selection if a string is provided.
    # 
    # _@param_ `expression` — The javascript or standard selection.
    # 
    # _@return_ — The cloned selectable.
    # 
    # Add a standard selection.
    # ```ruby
    # criteria.where(name: "syd")
    # ```
    # 
    # Add a javascript selection.
    # ```ruby
    # criteria.where("this.name == 'syd'")
    # ```
    sig { params(args: T.any(String, T::Hash[T.untyped, T.untyped])).returns(Criteria) }
    def where(*args); end

    # Get a version of this criteria without the options.
    # 
    # _@return_ — The cloned criteria.
    # 
    # Get the criteria without options.
    # ```ruby
    # criteria.without_options
    # ```
    sig { returns(Criteria) }
    def without_options; end

    # Find documents by the provided javascript and scope. Uses a $where but is
    # different from +Criteria#where+ in that it will pass a code object to the
    # query instead of a pure string. Safe against Javascript injection
    # attacks.
    # 
    # _@param_ `javascript` — The javascript to execute in the $where.
    # 
    # _@param_ `scope` — The scope for the code.
    # 
    # _@return_ — The criteria.
    # 
    # Find by javascript.
    # ```ruby
    # Band.for_js("this.name = param", param: "Tool")
    # ```
    sig { params(javascript: String, scope: T::Hash[T.untyped, T.untyped]).returns(Criteria) }
    def for_js(javascript, scope = {}); end

        # Are documents in the query missing, and are we configured to raise an
    # error?
    # 
    # _@param_ `result` — The result.
    # 
    # _@param_ `ids` — The ids.
    # 
    # Check for missing documents.
    # ```ruby
    # criteria.check_for_missing_documents!([], [ 1 ])
    # ```
    sig { params(result: T::Array[Document], ids: T::Array[Object]).returns(T.untyped) }
    def check_for_missing_documents!(result, ids); end

    # Clone or dup the current +Criteria+. This will return a new criteria with
    # the selector, options, klass, embedded options, etc intact.
    # 
    # _@param_ `other` — The criteria getting cloned.
    # 
    # _@return_ — nil.
    # 
    # Clone a criteria.
    # ```ruby
    # criteria.clone
    # ```
    # 
    # Dup a criteria.
    # ```ruby
    # criteria.dup
    # ```
    sig { params(other: Criteria).returns(T.nilable(T.any())) }
    def initialize_copy(other); end

    # Used for chaining +Criteria+ scopes together in the for of class methods
    # on the +Document+ the criteria is for.
    # 
    # _@param_ `name` — The method name.
    # 
    # _@param_ `args` — The arguments.
    # 
    # _@return_ — The result of the method call.
    # 
    # Handle method missing.
    # ```ruby
    # criteria.method_missing(:name)
    # ```
    sig { params(name: Symbol, args: T::Array[T.untyped], block: T.untyped).returns(Object) }
    def method_missing(name, *args, &block); end

    # For models where inheritance is at play we need to add the type
    # selection.
    # 
    # _@return_ — If type selection was added.
    # 
    # Add the type selection.
    # ```ruby
    # criteria.merge_type_selection
    # ```
    sig { returns(T::Boolean) }
    def merge_type_selection; end

    # Is the criteria type selectable?
    # 
    # _@return_ — If type selection should be added.
    # 
    # If the criteria type selectable?
    # ```ruby
    # criteria.type_selectable?
    # ```
    sig { returns(T::Boolean) }
    def type_selectable?; end

    # Get the selector for type selection.
    # 
    # _@return_ — The type selection.
    # 
    # Get a type selection hash.
    # ```ruby
    # criteria.type_selection
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def type_selection; end

    # Get a new selector with type selection in it.
    # 
    # _@return_ — The selector.
    # 
    # Get a selector with type selection.
    # ```ruby
    # criteria.selector_with_type_selection
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def selector_with_type_selection; end

        sig { returns(T.untyped) }
    def persistence_context; end

            sig { params(options: T.untyped).returns(T.untyped) }
    def set_persistence_context(options); end

                sig { params(original_cluster: T.untyped, original_context: T.untyped).returns(T.untyped) }
    def clear_persistence_context(original_cluster, original_context); end

    # Execute a block within the context of a session.
    # 
    # _@param_ `options` — The session options. Please see the driver documentation for the available session options.
    # 
    # _@return_ — The result of calling the block.
    # 
    # Execute some operations in the context of a session.
    # ```ruby
    # band.with_session(causal_consistency: true) do
    #   band.records << Record.create
    #   band.name = 'FKA Twigs'
    #   band.save
    #   band.reload
    # end
    # ```
    # 
    # _@note_ — You cannot do any operations in the block using models or objects
    # that use a different client; the block will execute all operations
    # in the context of the implicit session and operations on any models using
    # another client will fail. For example, if you set a client using store_in on a
    # particular model and execute an operation on it in the session context block,
    # that operation can't use the block's session and an error will be raised.
    # An error will also be raised if sessions are nested.
    sig { params(options: T::Hash[T.untyped, T.untyped]).returns(Object) }
    def with_session(options = {}); end

        sig { returns(T.untyped) }
    def _session; end

        # Change the persistence context for this object during the block.
    # 
    # _@param_ `options_or_context` — The storage options or a persistence context.
    # 
    # Save the current document to a different collection.
    # ```ruby
    # model.with(collection: "bands") do |m|
    #   m.save
    # end
    # ```
    sig { params(options_or_context: T.any(T::Hash[T.untyped, T.untyped], Mongoid::PersistenceContext), block: T.untyped).returns(T.untyped) }
    def with(options_or_context, &block); end

            sig { params(parent: T.untyped).returns(T.untyped) }
    def collection(parent = nil); end

        sig { returns(T.untyped) }
    def collection_name; end

        sig { returns(T.untyped) }
    def mongo_client; end

    # Applies the default scope to the criteria.
    # 
    # _@return_ — The criteria.
    # 
    # Apply the default scope.
    # ```ruby
    # criteria.apply_default_scope
    # ```
    sig { returns(Criteria) }
    def apply_default_scope; end

    # Given another criteria, remove the other criteria's scoping from this
    # criteria.
    # 
    # _@param_ `other` — The other criteria.
    # 
    # _@return_ — The criteria with scoping removed.
    # 
    # Remove the scoping.
    # ```ruby
    # criteria.remove_scoping(other)
    # ```
    sig { params(other: Criteria).returns(Criteria) }
    def remove_scoping(other); end

    # Forces the criteria to be scoped, unless its inside an unscoped block.
    # 
    # _@param_ `options` — Additional query options.
    # 
    # _@return_ — The scoped criteria.
    # 
    # Force the criteria to be scoped.
    # ```ruby
    # criteria.scoped(skip: 10)
    # ```
    sig { params(options: T.nilable(T::Hash[T.untyped, T.untyped])).returns(Criteria) }
    def scoped(options = nil); end

    # Has the criteria had the default scope applied?
    # 
    # _@return_ — If the default scope is applied.
    # 
    # Is the default scope applied?
    # ```ruby
    # criteria.scoped?
    # ```
    sig { returns(T::Boolean) }
    def scoped?; end

    # Clears all scoping from the criteria.
    # 
    # _@return_ — The unscoped criteria.
    # 
    # Clear all scoping from the criteria.
    # ```ruby
    # criteria.unscoped
    # ```
    sig { returns(Criteria) }
    def unscoped; end

    # Is the criteria unscoped?
    # 
    # _@return_ — If the criteria is force unscoped.
    # 
    # Is the criteria unscoped?
    # ```ruby
    # criteria.unscoped?
    # ```
    sig { returns(T::Boolean) }
    def unscoped?; end

    # Get the criteria scoping options, as a pair (scoped, unscoped).
    # 
    # _@return_ — Scoped, unscoped.
    # 
    # Get the scoping options.
    # ```ruby
    # criteria.scoping_options
    # ```
    sig { returns(T::Array[T.untyped]) }
    def scoping_options; end

    # Set the criteria scoping options, as a pair (scoped, unscoped).
    # 
    # _@param_ `options` — Scoped, unscoped.
    # 
    # _@return_ — The new scoping options.
    # 
    # Set the scoping options.
    # ```ruby
    # criteria.scoping_options = true, false
    # ```
    sig { params(options: T::Array[T.untyped]).returns(T::Array[T.untyped]) }
    def scoping_options=(options); end

    # Get the criteria with the default scope applied, if the default scope
    # is able to be applied. Cases in which it cannot are: If we are in an
    # unscoped block, if the criteria is already forced unscoped, or the
    # default scope has already been applied.
    # 
    # _@return_ — The criteria.
    # 
    # Get the criteria with the default scope.
    # ```ruby
    # criteria.with_default_scope
    # ```
    sig { returns(Criteria) }
    def with_default_scope; end

                sig { params(other: T.untyped, methods: T.untyped).returns(T.untyped) }
    def reject_matching(other, *methods); end

        # Build a document given the selector and return it.
    # Complex criteria, such as $in and $or operations will get ignored.
    # 
    # _@return_ — A non-persisted document.
    # 
    # build the document.
    # ```ruby
    # Person.where(:title => "Sir").build
    # ```
    # 
    # Build with selectors getting ignored.
    # ```ruby
    # Person.where(:age.gt => 5).build
    # ```
    sig { params(attrs: T.untyped, block: T.untyped).returns(Document) }
    def build(attrs = {}, &block); end

        # Create a document in the database given the selector and return it.
    # Complex criteria, such as $in and $or operations will get ignored.
    # 
    # _@return_ — A newly created document.
    # 
    # Create the document.
    # ```ruby
    # Person.where(:title => "Sir").create
    # ```
    # 
    # Create with selectors getting ignored.
    # ```ruby
    # Person.where(:age.gt => 5).create
    # ```
    sig { params(attrs: T.untyped, block: T.untyped).returns(Document) }
    def create(attrs = {}, &block); end

        # Create a document in the database given the selector and return it.
    # Complex criteria, such as $in and $or operations will get ignored.
    # If validation fails, an error will be raised.
    # 
    # _@return_ — A newly created document.
    # 
    # Create the document.
    # ```ruby
    # Person.where(:title => "Sir").create
    # ```
    # 
    # Create with selectors getting ignored.
    # ```ruby
    # Person.where(:age.gt => 5).create
    # ```
    sig { params(attrs: T.untyped, block: T.untyped).returns(Document) }
    def create!(attrs = {}, &block); end

        # Define attributes with which new documents will be created.
    # 
    # Note that if `find_or_create_by` is called after this in a method chain, the attributes in
    # the query will override those from this method.
    # 
    # _@return_ — A criteria.
    # 
    # Define attributes to be used when a new document is created.
    # ```ruby
    # Person.create_with(job: 'Engineer').find_or_create_by(employer: 'MongoDB')
    # ```
    sig { params(attrs: T.untyped).returns(Mongoid::Criteria) }
    def create_with(attrs = {}); end

    # Find the first +Document+ given the conditions, or creates a new document
    # with the conditions that were supplied.
    # 
    # _@param_ `attrs` — The attributes to check.
    # 
    # _@return_ — A matching or newly created document.
    # 
    # Find or create the document.
    # ```ruby
    # Person.find_or_create_by(:attribute => "value")
    # ```
    sig { params(attrs: T::Hash[T.untyped, T.untyped], block: T.untyped).returns(Document) }
    def find_or_create_by(attrs = {}, &block); end

    # Find the first +Document+ given the conditions, or creates a new document
    # with the conditions that were supplied. If validation fails an
    # exception will be raised.
    # 
    # _@param_ `attrs` — The attributes to check.
    # 
    # _@return_ — A matching or newly created document.
    # 
    # Find or create the document.
    # ```ruby
    # Person.find_or_create_by!(:attribute => "value")
    # ```
    sig { params(attrs: T::Hash[T.untyped, T.untyped], block: T.untyped).returns(Document) }
    def find_or_create_by!(attrs = {}, &block); end

    # Find the first +Document+ given the conditions, or initializes a new document
    # with the conditions that were supplied.
    # 
    # _@param_ `attrs` — The attributes to check.
    # 
    # _@return_ — A matching or newly initialized document.
    # 
    # Find or initialize the document.
    # ```ruby
    # Person.find_or_initialize_by(:attribute => "value")
    # ```
    sig { params(attrs: T::Hash[T.untyped, T.untyped], block: T.untyped).returns(Document) }
    def find_or_initialize_by(attrs = {}, &block); end

    # Find the first +Document+, or creates a new document
    # with the conditions that were supplied plus attributes.
    # 
    # _@param_ `attrs` — The additional attributes to add.
    # 
    # _@return_ — A matching or newly created document.
    # 
    # First or create the document.
    # ```ruby
    # Person.where(name: "Jon").first_or_create(attribute: "value")
    # ```
    sig { params(attrs: T.nilable(T::Hash[T.untyped, T.untyped]), block: T.untyped).returns(Document) }
    def first_or_create(attrs = nil, &block); end

    # Find the first +Document+, or creates a new document
    # with the conditions that were supplied plus attributes and will
    # raise an error if validation fails.
    # 
    # _@param_ `attrs` — The additional attributes to add.
    # 
    # _@return_ — A matching or newly created document.
    # 
    # First or create the document.
    # ```ruby
    # Person.where(name: "Jon").first_or_create!(attribute: "value")
    # ```
    sig { params(attrs: T.nilable(T::Hash[T.untyped, T.untyped]), block: T.untyped).returns(Document) }
    def first_or_create!(attrs = nil, &block); end

    # Find the first +Document+, or initializes a new document
    # with the conditions that were supplied plus attributes.
    # 
    # _@param_ `attrs` — The additional attributes to add.
    # 
    # _@return_ — A matching or newly initialized document.
    # 
    # First or initialize the document.
    # ```ruby
    # Person.where(name: "Jon").first_or_initialize(attribute: "value")
    # ```
    sig { params(attrs: T.nilable(T::Hash[T.untyped, T.untyped]), block: T.untyped).returns(Document) }
    def first_or_initialize(attrs = nil, &block); end

    # Create a document given the provided method and attributes from the
    # existing selector.
    # 
    # _@param_ `method` — Either :new or :create.
    # 
    # _@param_ `attrs` — Additional attributes to use.
    # 
    # _@return_ — The new or saved document.
    # 
    # Create a new document.
    # ```ruby
    # criteria.create_document(:new, {})
    # ```
    sig { params(method: Symbol, attrs: T.nilable(T::Hash[T.untyped, T.untyped]), block: T.untyped).returns(Document) }
    def create_document(method, attrs = nil, &block); end

    # Find the first object or create/initialize it.
    # 
    # _@param_ `method` — The method to invoke.
    # 
    # _@param_ `attrs` — The attributes to query or set.
    # 
    # _@return_ — The first or new document.
    # 
    # Find or perform an action.
    # ```ruby
    # Person.find_or(:create, :name => "Dev")
    # ```
    sig { params(method: Symbol, attrs: T::Hash[T.untyped, T.untyped], block: T.untyped).returns(Document) }
    def find_or(method, attrs = {}, &block); end

    # Find the first document or create/initialize it.
    # 
    # _@param_ `method` — The method to invoke.
    # 
    # _@param_ `attrs` — The attributes to query or set.
    # 
    # _@return_ — The first or new document.
    # 
    # First or perform an action.
    # ```ruby
    # Person.first_or(:create, :name => "Dev")
    # ```
    sig { params(method: Symbol, attrs: T::Hash[T.untyped, T.untyped], block: T.untyped).returns(Document) }
    def first_or(method, attrs = {}, &block); end

            sig { params(hash: T.untyped, key: T.untyped).returns(T::Boolean) }
    def invalid_key?(hash, key); end

        sig { params(value: T.untyped).returns(T::Boolean) }
    def invalid_embedded_doc?(value); end

    # Provides the data needed to Marshal.dump a criteria.
    # 
    # _@return_ — The dumped data.
    # 
    # Dump the criteria.
    # ```ruby
    # Marshal.dump(criteria)
    # ```
    sig { returns(T::Array[Object]) }
    def marshal_dump; end

        # Resets the criteria object after a Marshal.load
    # 
    # _@param_ `data` — The raw data.
    # 
    # Load the criteria.
    # ```ruby
    # Marshal.load(criteria)
    # ```
    sig { params(data: T::Array[T.untyped]).returns(T.untyped) }
    def marshal_load(data); end

            sig { params(name: T.untyped).returns(T.untyped) }
    def dump_hash(name); end

                sig { params(hash_class: T.untyped, raw: T.untyped).returns(T.untyped) }
    def load_hash(hash_class, raw); end

    # Eager loads all the provided associations. Will load all the documents
    # into the identity map whose ids match based on the extra query for the
    # ids.
    # 
    # _@param_ `relations` — The names of the associations to eager load.
    # 
    # _@return_ — The cloned criteria.
    # 
    # Eager load the provided associations.
    # ```ruby
    # Person.includes(:posts, :game)
    # ```
    # 
    # _@note_ — This will work for embedded associations that reference another
    # collection via belongs_to as well.
    # 
    # _@note_ — Eager loading brings all the documents into memory, so there is a
    # sweet spot on the performance gains. Internal benchmarks show that
    # eager loading becomes slower around 100k documents, but this will
    # naturally depend on the specific application.
    sig { params(relations: T.any(T::Array[Symbol], T::Array[T::Hash[T.untyped, T.untyped]])).returns(Criteria) }
    def includes(*relations); end

    # Get a list of criteria that are to be executed for eager loading.
    # 
    # _@return_ — The inclusions.
    # 
    # Get the eager loading inclusions.
    # ```ruby
    # Person.includes(:game).inclusions
    # ```
    sig { returns(T::Array[Association]) }
    def inclusions; end

    # Set the inclusions for the criteria.
    # 
    # _@param_ `value` — The inclusions.
    # 
    # _@return_ — The new inclusions.
    # 
    # Set the inclusions.
    # ```ruby
    # criteria.inclusions = [ association ]
    # ```
    sig { params(value: T::Array[Association]).returns(T::Array[Association]) }
    def inclusions=(value); end

        # Add an inclusion definition to the list of inclusions for the criteria.
    # 
    # _@param_ `_klass` — The class or string/symbol of the class name.
    # 
    # _@param_ `association` — The association.
    # 
    # Add an inclusion.
    # ```ruby
    # criteria.add_inclusion(Person, :posts)
    # ```
    sig { params(_klass: T.any(Class, String, Symbol), association: Symbol).returns(T.untyped) }
    def add_inclusion(_klass, association); end

                sig { params(_parent_class: T.untyped, relations_list: T.untyped).returns(T.untyped) }
    def extract_includes_list(_parent_class, *relations_list); end

    # Execute the criteria or raise an error if no documents found.
    # 
    # _@param_ `ids` — The arguments passed.
    # 
    # _@param_ `multi` — Whether there arguments were a list.
    # 
    # _@return_ — The document(s).
    # 
    # Execute or raise
    # ```ruby
    # criteria.execute_or_raise(id)
    # ```
    sig { params(ids: Object, multi: T::Boolean).returns(T.any(Document, T::Array[Document])) }
    def execute_or_raise(ids, multi); end

    # Adds a criterion to the +Criteria+ that specifies an id that must be matched.
    # 
    # _@param_ `ids` — The array of ids.
    # 
    # _@return_ — The cloned criteria.
    # 
    # Add a single id criteria.
    # ```ruby
    # criteria.for_ids([ 1 ])
    # ```
    # 
    # Add multiple id criteria.
    # ```ruby
    # criteria.for_ids([ 1, 2 ])
    # ```
    sig { params(ids: T::Array[T.untyped]).returns(Criteria) }
    def for_ids(ids); end

    # Get the documents from the identity map, and if not found hit the
    # database.
    # 
    # _@param_ `ids` — The searched ids.
    # 
    # _@return_ — The found documents.
    # 
    # Get the documents from the map or criteria.
    # ```ruby
    # criteria.multiple_from_map_or_db(ids)
    # ```
    sig { params(ids: T::Array[Object]).returns(T::Array[Document]) }
    def multiple_from_db(ids); end

    # Get the finder used to generate the id query.
    # 
    # _@return_ — The name of the finder method.
    # 
    # Get the id finder.
    # ```ruby
    # criteria.id_finder
    # ```
    sig { returns(Symbol) }
    def id_finder; end

    # Get documents from the database only.
    # 
    # _@param_ `ids` — The ids to fetch with.
    # 
    # _@return_ — The matching documents.
    # 
    # Get documents from the database.
    # ```ruby
    # criteria.from_database(ids)
    # ```
    sig { params(ids: T::Array[Object]).returns(T::Array[Document]) }
    def from_database(ids); end

            sig { params(ids: T.untyped).returns(T.untyped) }
    def from_database_selector(ids); end

    # Convert all the ids to their proper types.
    # 
    # _@param_ `ids` — The ids to convert.
    # 
    # _@return_ — The converted ids.
    # 
    # Convert the ids.
    # ```ruby
    # criteria.mongoize_ids(ids)
    # ```
    sig { params(ids: T::Array[Object]).returns(T::Array[Object]) }
    def mongoize_ids(ids); end

        # Convenience method of raising an invalid options error.
    # 
    # Raise the error.
    # ```ruby
    # criteria.raise_invalid
    # ```
    sig { returns(T.untyped) }
    def raise_invalid; end

    # Add ascending sorting options for all the provided fields.
    # 
    # _@param_ `fields` — The fields to sort.
    # 
    # _@return_ — The cloned optional.
    # 
    # Add ascending sorting.
    # ```ruby
    # optional.ascending(:first_name, :last_name)
    # ```
    sig { params(fields: T::Array[Symbol]).returns(Optional) }
    def ascending(*fields); end

    # Adds the option for telling MongoDB how many documents to retrieve in
    # it's batching.
    # 
    # _@param_ `value` — The batch size.
    # 
    # _@return_ — The cloned optional.
    # 
    # Apply the batch size options.
    # ```ruby
    # optional.batch_size(500)
    # ```
    sig { params(value: T.nilable(Integer)).returns(Optional) }
    def batch_size(value = nil); end

    # Add descending sorting options for all the provided fields.
    # 
    # _@param_ `fields` — The fields to sort.
    # 
    # _@return_ — The cloned optional.
    # 
    # Add descending sorting.
    # ```ruby
    # optional.descending(:first_name, :last_name)
    # ```
    sig { params(fields: T::Array[Symbol]).returns(Optional) }
    def descending(*fields); end

    # Add an index hint to the query options.
    # 
    # _@param_ `value` — The index hint.
    # 
    # _@return_ — The cloned optional.
    # 
    # Add an index hint.
    # ```ruby
    # optional.hint("$natural" => 1)
    # ```
    sig { params(value: T.nilable(T::Hash[T.untyped, T.untyped])).returns(Optional) }
    def hint(value = nil); end

    # Add the number of documents to limit in the returned results.
    # 
    # _@param_ `value` — The number of documents to return.
    # 
    # _@return_ — The cloned optional.
    # 
    # Limit the number of returned documents.
    # ```ruby
    # optional.limit(20)
    # ```
    sig { params(value: T.nilable(Integer)).returns(Optional) }
    def limit(value = nil); end

    # Adds the option to limit the number of documents scanned in the
    # collection.
    # 
    # _@param_ `value` — The max number of documents to scan.
    # 
    # _@return_ — The cloned optional.
    # 
    # Add the max scan limit.
    # ```ruby
    # optional.max_scan(1000)
    # ```
    sig { params(value: T.nilable(Integer)).returns(Optional) }
    def max_scan(value = nil); end

    # Adds a cumulative time limit in milliseconds for processing operations on a cursor.
    # 
    # _@param_ `value` — The max time in milliseconds for processing operations on a cursor.
    # 
    # _@return_ — The cloned optional.
    # 
    # Add the max time ms option.
    # ```ruby
    # optional.max_time_ms(200)
    # ```
    sig { params(value: T.nilable(Integer)).returns(Optional) }
    def max_time_ms(value = nil); end

    # Tell the query not to timeout.
    # 
    # _@return_ — The cloned optional.
    # 
    # Tell the query not to timeout.
    # ```ruby
    # optional.no_timeout
    # ```
    sig { returns(Optional) }
    def no_timeout; end

    # Adds sorting criterion to the options.
    # 
    # _@param_ `spec` — The sorting specification.
    # 
    # _@return_ — The cloned optional.
    # 
    # Add sorting options via a hash with integer directions.
    # ```ruby
    # optional.order_by(name: 1, dob: -1)
    # ```
    # 
    # Add sorting options via a hash with symbol directions.
    # ```ruby
    # optional.order_by(name: :asc, dob: :desc)
    # ```
    # 
    # Add sorting options via a hash with string directions.
    # ```ruby
    # optional.order_by(name: "asc", dob: "desc")
    # ```
    # 
    # Add sorting options via an array with integer directions.
    # ```ruby
    # optional.order_by([[ name, 1 ], [ dob, -1 ]])
    # ```
    # 
    # Add sorting options via an array with symbol directions.
    # ```ruby
    # optional.order_by([[ :name, :asc ], [ :dob, :desc ]])
    # ```
    # 
    # Add sorting options via an array with string directions.
    # ```ruby
    # optional.order_by([[ "name", "asc" ], [ "dob", "desc" ]])
    # ```
    # 
    # Add sorting options with keys.
    # ```ruby
    # optional.order_by(:name.asc, :dob.desc)
    # ```
    # 
    # Add sorting options via a string.
    # ```ruby
    # optional.order_by("name ASC, dob DESC")
    # ```
    sig { params(spec: T.any(T::Array[T.untyped], T::Hash[T.untyped, T.untyped], String)).returns(Optional) }
    def order_by(*spec); end

    # Instead of merging the order criteria, use this method to completely
    # replace the existing ordering with the provided.
    # 
    # _@param_ `spec` — The sorting specification.
    # 
    # _@return_ — The cloned optional.
    # 
    # Replace the ordering.
    # ```ruby
    # optional.reorder(name: :asc)
    # ```
    sig { params(spec: T.any(T::Array[T.untyped], T::Hash[T.untyped, T.untyped], String)).returns(Optional) }
    def reorder(*spec); end

    # Add the number of documents to skip.
    # 
    # _@param_ `value` — The number to skip.
    # 
    # _@return_ — The cloned optional.
    # 
    # Add the number to skip.
    # ```ruby
    # optional.skip(100)
    # ```
    sig { params(value: T.nilable(Integer)).returns(Optional) }
    def skip(value = nil); end

    # Limit the returned results via slicing embedded arrays.
    # 
    # _@param_ `criterion` — The slice options.
    # 
    # _@return_ — The cloned optional.
    # 
    # Slice the returned results.
    # ```ruby
    # optional.slice(aliases: [ 0, 5 ])
    # ```
    sig { params(criterion: T.nilable(T::Hash[T.untyped, T.untyped])).returns(Optional) }
    def slice(criterion = nil); end

    # Tell the query to operate in snapshot mode.
    # 
    # _@return_ — The cloned optional.
    # 
    # Add the snapshot option.
    # ```ruby
    # optional.snapshot
    # ```
    sig { returns(Optional) }
    def snapshot; end

    # Associate a comment with the query.
    # 
    # _@param_ `comment` — The comment to be associated with the query.
    # 
    # _@return_ — The cloned optional.
    # 
    # Add a comment.
    # ```ruby
    # optional.comment('slow query')
    # ```
    # 
    # _@note_ — Set profilingLevel to 2 and the comment will be logged in the profile
    # collection along with the query.
    sig { params(comment: T.nilable(String)).returns(Optional) }
    def comment(comment = nil); end

    # Set the cursor type.
    # 
    # _@param_ `type` — The type of cursor to create.
    # 
    # _@return_ — The cloned optional.
    # 
    # Set the cursor type.
    # ```ruby
    # optional.cursor_type(:tailable)
    # optional.cursor_type(:tailable_await)
    # ```
    # 
    # _@note_ — The cursor can be type :tailable or :tailable_await.
    sig { params(type: Symbol).returns(Optional) }
    def cursor_type(type); end

    # Set the collation.
    # 
    # _@param_ `collation_doc` — The document describing the collation to use.
    # 
    # _@return_ — The cloned optional.
    # 
    # Set the collation.
    # ```ruby
    # optional.collation(locale: 'fr', strength: 2)
    # ```
    sig { params(collation_doc: T::Hash[T.untyped, T.untyped]).returns(Optional) }
    def collation(collation_doc); end

    # Add a single sort option.
    # 
    # _@param_ `options` — The options.
    # 
    # _@param_ `field` — The field name.
    # 
    # _@param_ `direction` — The sort direction.
    # 
    # _@return_ — The cloned optional.
    # 
    # Add a single sort option.
    # ```ruby
    # optional.add_sort_option({}, :name, 1)
    # ```
    sig { params(options: T::Hash[T.untyped, T.untyped], field: String, direction: Integer).returns(Optional) }
    def add_sort_option(options, field, direction); end

    # Take the provided criterion and store it as an option in the query
    # options.
    # 
    # _@param_ `args` — The options.
    # 
    # _@return_ — The cloned queryable.
    # 
    # Store the option.
    # ```ruby
    # optional.option({ skip: 10 })
    # ```
    sig { params(args: T::Array[T.untyped]).returns(Queryable) }
    def option(*args); end

    # Add multiple sort options at once.
    # 
    # _@param_ `fields` — The field names.
    # 
    # _@param_ `direction` — The sort direction.
    # 
    # _@return_ — The cloned optional.
    # 
    # Add multiple sort options.
    # ```ruby
    # optional.sort_with_list(:name, :dob, 1)
    # ```
    sig { params(fields: T::Array[String], direction: Integer).returns(Optional) }
    def sort_with_list(*fields, direction); end

    # Get the atomic selector for the document. This is a hash in the simplest
    # case { "_id" => id }, but can become more complex for embedded documents
    # and documents that use a shard key.
    # 
    # _@return_ — The document's selector.
    # 
    # Get the document's atomic selector.
    # ```ruby
    # document.atomic_selector
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def atomic_selector; end

    # Get the atomic selector for an embedded document.
    # 
    # _@return_ — The embedded document selector.
    # 
    # Get the embedded atomic selector.
    # ```ruby
    # document.embedded_atomic_selector
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def embedded_atomic_selector; end

    # Get the atomic selector for a root document.
    # 
    # _@return_ — The root document selector.
    # 
    # Get the root atomic selector.
    # ```ruby
    # document.root_atomic_selector
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def root_atomic_selector; end

    # Has the aggregable enter an aggregation state. Ie, are only aggregation
    # operations allowed at this point on.
    # 
    # _@return_ — If the aggregable is aggregating.
    # 
    # Is the aggregable aggregating?
    # ```ruby
    # aggregable.aggregating?
    # ```
    sig { returns(T::Boolean) }
    def aggregating?; end

    # Add a group ($group) operation to the aggregation pipeline.
    # 
    # _@param_ `operation` — The group operation.
    # 
    # _@return_ — The aggregable.
    # 
    # Add a group operation being verbose.
    # ```ruby
    # aggregable.group(count: { "$sum" => 1 }, max: { "$max" => "likes" })
    # ```
    # 
    # Add a group operation using symbol shortcuts.
    # ```ruby
    # aggregable.group(:count.sum => 1, :max.max => "likes")
    # ```
    sig { params(operation: T::Hash[T.untyped, T.untyped]).returns(Aggregable) }
    def group(operation); end

    # Add a projection ($project) to the aggregation pipeline.
    # 
    # _@param_ `operation` — The projection to make.
    # 
    # _@return_ — The aggregable.
    # 
    # Add a projection to the pipeline.
    # ```ruby
    # aggregable.project(author: 1, name: 0)
    # ```
    sig { params(operation: T.nilable(T::Hash[T.untyped, T.untyped])).returns(Aggregable) }
    def project(operation = nil); end

    # Add an unwind ($unwind) to the aggregation pipeline.
    # 
    # _@param_ `field` — The name of the field to unwind.
    # 
    # _@return_ — The aggregable.
    # 
    # Add an unwind to the pipeline.
    # ```ruby
    # aggregable.unwind(:field)
    # ```
    sig { params(field: T.any(String, Symbol)).returns(Aggregable) }
    def unwind(field); end

    # Add the aggregation operation.
    # 
    # _@param_ `operation` — The operation for the pipeline.
    # 
    # _@return_ — The cloned aggregable.
    # 
    # Aggregate on the operation.
    # ```ruby
    # aggregation(operation) do |pipeline|
    #   pipeline.push("$project" => operation)
    # end
    # ```
    sig { params(operation: T::Hash[T.untyped, T.untyped]).returns(Aggregable) }
    def aggregation(operation); end

    # Instruct the next mergeable call to use intersection.
    # 
    # _@return_ — The intersect flagged mergeable.
    # 
    # Use intersection on the next call.
    # ```ruby
    # mergeable.intersect.in(field: [ 1, 2, 3 ])
    # ```
    sig { returns(Mergeable) }
    def intersect; end

    # Instruct the next mergeable call to use override.
    # 
    # _@return_ — The override flagged mergeable.
    # 
    # Use override on the next call.
    # ```ruby
    # mergeable.override.in(field: [ 1, 2, 3 ])
    # ```
    sig { returns(Mergeable) }
    def override; end

    # Instruct the next mergeable call to use union.
    # 
    # _@return_ — The union flagged mergeable.
    # 
    # Use union on the next call.
    # ```ruby
    # mergeable.union.in(field: [ 1, 2, 3 ])
    # ```
    sig { returns(Mergeable) }
    def union; end

    # Clear the current strategy and negating flag, used after cloning.
    # 
    # _@return_ — self.
    # 
    # Reset the strategies.
    # ```ruby
    # mergeable.reset_strategies!
    # ```
    sig { returns(Criteria) }
    def reset_strategies!; end

    # Adds the criterion to the existing selection.
    # 
    # _@param_ `criterion` — The criteria.
    # 
    # _@param_ `operator` — The MongoDB operator.
    # 
    # _@return_ — The new mergeable.
    # 
    # Add the criterion.
    # ```ruby
    # mergeable.__add__({ name: 1 }, "$in")
    # ```
    sig { params(criterion: T::Hash[T.untyped, T.untyped], operator: String).returns(Mergeable) }
    def __add__(criterion, operator); end

    # Adds the criterion to the existing selection.
    # 
    # _@param_ `criterion` — The criteria.
    # 
    # _@param_ `outer` — The outer MongoDB operator.
    # 
    # _@param_ `inner` — The inner MongoDB operator.
    # 
    # _@return_ — The new mergeable.
    # 
    # Add the criterion.
    # ```ruby
    # mergeable.__expanded__([ 1, 10 ], "$within", "$center")
    # ```
    sig { params(criterion: T::Hash[T.untyped, T.untyped], outer: String, inner: String).returns(Mergeable) }
    def __expanded__(criterion, outer, inner); end

    # Perform a straight merge of the criterion into the selection and let the
    # symbol overrides do all the work.
    # 
    # _@param_ `criterion` — The criteria.
    # 
    # _@return_ — The cloned object.
    # 
    # Straight merge the expanded criterion.
    # ```ruby
    # mergeable.__merge__(location: [ 1, 10 ])
    # ```
    sig { params(criterion: T::Hash[T.untyped, T.untyped]).returns(Mergeable) }
    def __merge__(criterion); end

    # Adds the criterion to the existing selection.
    # 
    # _@param_ `criterion` — The criteria.
    # 
    # _@param_ `operator` — The MongoDB operator.
    # 
    # _@return_ — The new mergeable.
    # 
    # Add the criterion.
    # ```ruby
    # mergeable.__intersect__([ 1, 2 ], "$in")
    # ```
    sig { params(criterion: T::Hash[T.untyped, T.untyped], operator: String).returns(Mergeable) }
    def __intersect__(criterion, operator); end

    # Adds $and/$or/$nor criteria to a copy of this selection.
    # 
    # Each of the criteria can be a Hash of key/value pairs or MongoDB
    # operators (keys beginning with $), or a Selectable object
    # (which typically will be a Criteria instance).
    # 
    # _@param_ `criteria` — Multiple key/value pair matches or Criteria objects.
    # 
    # _@param_ `operator` — The MongoDB operator.
    # 
    # _@return_ — The new mergeable.
    # 
    # Add the criterion.
    # ```ruby
    # mergeable.__multi__([ 1, 2 ], "$in")
    # ```
    sig { params(criteria: T::Array[T.any(T::Hash[T.untyped, T.untyped], Criteria)], operator: String).returns(Mergeable) }
    def __multi__(criteria, operator); end

                # Combines criteria into a MongoDB selector.
    # 
    # Criteria is an array of criterions which will be flattened.
    # 
    # Each criterion can be:
    # - A hash
    # - A Criteria instance
    # - nil, in which case it is ignored
    sig { params(operator: T.untyped, criteria: T.untyped).returns(T.untyped) }
    def _mongoid_add_top_level_operation(operator, criteria); end

            # Calling .flatten on an array which includes a Criteria instance
    # evaluates the criteria, which we do not want. Hence this method
    # explicitly only expands Array objects and Array subclasses.
    sig { params(array: T.untyped).returns(T.untyped) }
    def _mongoid_flatten_arrays(array); end

    # Takes a criteria hash and expands Key objects into hashes containing
    # MQL corresponding to said key objects. Also converts the input to
    # BSON::Document to permit indifferent access.
    # 
    # The argument must be a hash containing key-value pairs of the
    # following forms:
    # - {field_name: value}
    # - {'field_name' => value}
    # - {key_instance: value}
    # - {:$operator => operator_value_expression}
    # - {'$operator' => operator_value_expression}
    # 
    # Ruby does not permit multiple symbol operators. For example,
    # {:foo.gt => 1, :foo.gt => 2} is collapsed to {:foo.gt => 2} by the
    # language. Therefore this method never has to deal with multiple
    # identical operators.
    # 
    # Similarly, this method should never need to expand a literal value
    # and an operator at the same time.
    # 
    # This method effectively converts symbol keys to string keys in
    # the input +expr+, such that the downstream code can assume that
    # conditions always contain string keys.
    # 
    # _@param_ `expr` — Criteria including Key instances.
    # 
    # _@return_ — The expanded criteria.
    sig { params(expr: T::Hash[T.untyped, T.untyped]).returns(BSON::Document) }
    def _mongoid_expand_keys(expr); end

    # Adds the criterion to the existing selection.
    # 
    # _@param_ `criterion` — The criteria.
    # 
    # _@param_ `operator` — The MongoDB operator.
    # 
    # _@return_ — The new mergeable.
    # 
    # Add the criterion.
    # ```ruby
    # mergeable.__override__([ 1, 2 ], "$in")
    # ```
    sig { params(criterion: T.any(T::Hash[T.untyped, T.untyped], Criteria), operator: String).returns(Mergeable) }
    def __override__(criterion, operator); end

    # Adds the criterion to the existing selection.
    # 
    # _@param_ `criterion` — The criteria.
    # 
    # _@param_ `operator` — The MongoDB operator.
    # 
    # _@return_ — The new mergeable.
    # 
    # Add the criterion.
    # ```ruby
    # mergeable.__union__([ 1, 2 ], "$in")
    # ```
    sig { params(criterion: T::Hash[T.untyped, T.untyped], operator: String).returns(Mergeable) }
    def __union__(criterion, operator); end

    # Use the named strategy for the next operation.
    # 
    # _@param_ `strategy` — The strategy to use.
    # 
    # _@return_ — The existing mergeable.
    # 
    # Use intersection.
    # ```ruby
    # mergeable.use(:__intersect__)
    # ```
    sig { params(strategy: Symbol).returns(Mergeable) }
    def use(strategy); end

    # Add criterion to the selection with the named strategy.
    # 
    # _@param_ `strategy` — The name of the strategy method.
    # 
    # _@param_ `criterion` — The criterion to add.
    # 
    # _@param_ `operator` — The MongoDB operator.
    # 
    # _@return_ — The cloned query.
    # 
    # Add criterion with a strategy.
    # ```ruby
    # mergeable.with_strategy(:__union__, {field_name: [ 1, 2, 3 ]}, "$in")
    # ```
    sig { params(strategy: Symbol, criterion: Object, operator: String).returns(Mergeable) }
    def with_strategy(strategy, criterion, operator); end

        # Prepare the value for merging.
    # 
    # _@param_ `field` — The name of the field.
    # 
    # _@param_ `value` — The value.
    # 
    # _@return_ — The serialized value.
    # 
    # Prepare the value.
    # ```ruby
    # mergeable.prepare("field", "$gt", 10)
    # ```
    sig { params(field: String, operator: T.untyped, value: Object).returns(Object) }
    def prepare(field, operator, value); end

    # Expands the specified condition to MongoDB syntax.
    # 
    # This method is meant to be called when processing the items of
    # a condition hash and the key and the value of each item are
    # already available separately.
    # 
    # The following parameter forms are accepted:
    # 
    # - field is a string or symbol; value is the field query expresision
    # - field is a Key instance; value is the field query expression
    # - field is a string corresponding to a MongoDB operator; value is
    #   the operator value expression.
    # 
    # This method expands the field-value combination to the MongoDB
    # selector syntax and returns an array of
    # [expanded key, expanded value]. The expanded key is converted to
    # a string if it wasn't already a string.
    # 
    # _@param_ `field` — The field to expand.
    # 
    # _@param_ `value` — The field's value.
    # 
    # _@return_ — The expanded field and value.
    sig { params(field: T.any(String, Symbol, Key), value: Object).returns(T::Array[T.any(String, Object)]) }
    def expand_one_condition(field, value); end

    # Expand criterion values to arrays, to be used with operators that
    # take an array as argument such as $in.
    # 
    # _@param_ `criterion` — The criterion.
    # 
    # _@return_ — The $in friendly criterion with array values.
    # 
    # Convert all the values to arrays.
    # ```ruby
    # selectable.with_array_values({ key: 1...4 })
    # ```
    sig { params(criterion: T::Hash[T.untyped, T.untyped]).returns(T::Hash[T.untyped, T.untyped]) }
    def expand_condition_to_array_values(criterion); end

    # Adds a field expression to the query.
    # 
    # +field+ must be a field name, and it must be a string. The upstream
    # code must have converted other field/key types to the simple string
    # form by the time this method is invoked.
    # 
    # +value+ can be of any type, it is written into the selector unchanged.
    # 
    # This method performs no processing on the provided field value.
    # 
    # Mutates the receiver.
    # 
    # _@param_ `field` — The field name.
    # 
    # _@param_ `value` — The field value.
    # 
    # _@return_ — self.
    sig { params(field: String, value: Object).returns(Storable) }
    def add_field_expression(field, value); end

    # Adds a logical operator expression to the selector.
    # 
    # This method only handles logical operators ($and, $nor and $or).
    # It raises ArgumentError if called with another operator. Note that
    # in MQL, $not is a field-level operator and not a query-level one,
    # and therefore $not is not handled by this method.
    # 
    # This method takes the operator and the operator value expression
    # separately for callers' convenience. It can be considered to
    # handle storing the hash +{operator => op_expr}+.
    # 
    # If the selector consists of a single condition which is the specified
    # operator (on the top level), the new condition given in op_expr is
    # added to the existing conditions for the specified operator.
    # For example, if the selector is currently:
    # 
    #     {'$or' => [{'hello' => 'world'}]}
    # 
    # ... and operator is '$or' and op_expr is `[{'test' => 123'}]`,
    # the resulting selector will be:
    # 
    #     {'$or' => [{'hello' => 'world'}, {'test' => 123}]}
    # 
    # This method always adds the new conditions as additional requirements;
    # in other words, it does not implement the ActiveRecord or/nor behavior
    # where the receiver becomes one of the operands. It is expected that
    # code upstream of this method implements such behavior.
    # 
    # This method does not simplify values (i.e. if the selector is
    # currently empty and operator is $and, op_expr is written to the
    # selector with $and even if the $and can in principle be elided).
    # Such simplification is also expected to have already been performed
    # by the upstream code.
    # 
    # This method mutates the receiver.
    # 
    # _@param_ `operator` — The operator to add.
    # 
    # _@param_ `op_expr` — Operator value to add.
    # 
    # _@return_ — self.
    sig { params(operator: String, op_expr: T::Array[T::Hash[T.untyped, T.untyped]]).returns(Storable) }
    def add_logical_operator_expression(operator, op_expr); end

    # Adds an operator expression to the selector.
    # 
    # This method takes the operator and the operator value expression
    # separately for callers' convenience. It can be considered to
    # handle storing the hash +{operator => op_expr}+.
    # 
    # The operator value can be of any type.
    # 
    # If the selector already has the specified operator in it (on the
    # top level), the new condition given in op_expr is added to the
    # existing conditions for the specified operator. This is
    # straightforward for $and; for other logical operators, the behavior
    # of this method is to add the new conditions to the existing operator.
    # For example, if the selector is currently:
    # 
    #     {'foo' => 'bar', '$or' => [{'hello' => 'world'}]}
    # 
    # ... and operator is '$or' and op_expr is `{'test' => 123'}`,
    # the resulting selector will be:
    # 
    #     {'foo' => 'bar', '$or' => [{'hello' => 'world'}, {'test' => 123}]}
    # 
    # This does not implement an OR between the existing selector and the
    # new operator expression - handling this is the job of upstream
    # methods. This method simply stores op_expr into the selector on the
    # assumption that the existing selector is the correct left hand side
    # of the operation already.
    # 
    # For non-logical query-level operators like $where and $text, if
    # there already is a top-level operator with the same name, the
    # op_expr is added to the selector via a top-level $and operator,
    # thus producing a selector having both operator values.
    # 
    # This method does not simplify values (i.e. if the selector is
    # currently empty and operator is $and, op_expr is written to the
    # selector with $and even if the $and can in principle be elided).
    # 
    # This method mutates the receiver.
    # 
    # _@param_ `operator` — The operator to add.
    # 
    # _@param_ `op_expr` — Operator value to add.
    # 
    # _@return_ — self.
    sig { params(operator: String, op_expr: Object).returns(Storable) }
    def add_operator_expression(operator, op_expr); end

    # Adds an arbitrary expression to the query.
    # 
    # Field can either be a field name or an operator.
    # 
    # Mutates the receiver.
    # 
    # _@param_ `field` — Field name or operator name.
    # 
    # _@param_ `value` — Field value or operator expression.
    # 
    # _@return_ — self.
    sig { params(field: String, value: Object).returns(Storable) }
    def add_one_expression(field, value); end

    # Get the context in which criteria queries should execute. This is either
    # in memory (for embedded documents) or mongo (for root level documents.)
    # 
    # _@return_ — The context.
    # 
    # Get the context.
    # ```ruby
    # criteria.context
    # ```
    sig { returns(T.any(Memory, Mongo)) }
    def context; end

    # Create the context for the queries to execute. Will be memory for
    # embedded documents and mongo for root documents.
    # 
    # _@return_ — The context.
    # 
    # Create the context.
    # ```ruby
    # contextual.create_context
    # ```
    sig { returns(T.any(Mongo, Memory)) }
    def create_context; end

    # Returns the value of attribute embedded.
    sig { returns(T.untyped) }
    attr_accessor :embedded

    # Returns the value of attribute klass.
    sig { returns(T.untyped) }
    attr_accessor :klass

    # Returns the value of attribute parent_document.
    sig { returns(T.untyped) }
    attr_accessor :parent_document

    # Returns the value of attribute association.
    sig { returns(T.untyped) }
    attr_accessor :association

    # Module containing functionality for getting options on a Criteria object.
    # 
    # @since 6.0.0
    module Options
            sig { returns(T.untyped) }
      def persistence_context; end

                  sig { params(options: T.untyped).returns(T.untyped) }
      def set_persistence_context(options); end

                        sig { params(original_cluster: T.untyped, original_context: T.untyped).returns(T.untyped) }
      def clear_persistence_context(original_cluster, original_context); end
    end

    module Findable
      # Execute the criteria or raise an error if no documents found.
      # 
      # _@param_ `ids` — The arguments passed.
      # 
      # _@param_ `multi` — Whether there arguments were a list.
      # 
      # _@return_ — The document(s).
      # 
      # Execute or raise
      # ```ruby
      # criteria.execute_or_raise(id)
      # ```
      sig { params(ids: Object, multi: T::Boolean).returns(T.any(Document, T::Array[Document])) }
      def execute_or_raise(ids, multi); end

      # Find the matchind document(s) in the criteria for the provided ids.
      # 
      # _@param_ `args` — The ids to search for.
      # 
      # _@return_ — The matching document(s).
      # 
      # Find by an id.
      # ```ruby
      # criteria.find(BSON::ObjectId.new)
      # ```
      # 
      # Find by multiple ids.
      # ```ruby
      # criteria.find([ BSON::ObjectId.new, BSON::ObjectId.new ])
      # ```
      sig { params(args: T::Array[BSON::ObjectId]).returns(T.any(T::Array[Document], Document)) }
      def find(*args); end

      # Adds a criterion to the +Criteria+ that specifies an id that must be matched.
      # 
      # _@param_ `ids` — The array of ids.
      # 
      # _@return_ — The cloned criteria.
      # 
      # Add a single id criteria.
      # ```ruby
      # criteria.for_ids([ 1 ])
      # ```
      # 
      # Add multiple id criteria.
      # ```ruby
      # criteria.for_ids([ 1, 2 ])
      # ```
      sig { params(ids: T::Array[T.untyped]).returns(Criteria) }
      def for_ids(ids); end

      # Get the documents from the identity map, and if not found hit the
      # database.
      # 
      # _@param_ `ids` — The searched ids.
      # 
      # _@return_ — The found documents.
      # 
      # Get the documents from the map or criteria.
      # ```ruby
      # criteria.multiple_from_map_or_db(ids)
      # ```
      sig { params(ids: T::Array[Object]).returns(T::Array[Document]) }
      def multiple_from_db(ids); end

      # Get the finder used to generate the id query.
      # 
      # _@return_ — The name of the finder method.
      # 
      # Get the id finder.
      # ```ruby
      # criteria.id_finder
      # ```
      sig { returns(Symbol) }
      def id_finder; end

      # Get documents from the database only.
      # 
      # _@param_ `ids` — The ids to fetch with.
      # 
      # _@return_ — The matching documents.
      # 
      # Get documents from the database.
      # ```ruby
      # criteria.from_database(ids)
      # ```
      sig { params(ids: T::Array[Object]).returns(T::Array[Document]) }
      def from_database(ids); end

                  sig { params(ids: T.untyped).returns(T.untyped) }
      def from_database_selector(ids); end

      # Convert all the ids to their proper types.
      # 
      # _@param_ `ids` — The ids to convert.
      # 
      # _@return_ — The converted ids.
      # 
      # Convert the ids.
      # ```ruby
      # criteria.mongoize_ids(ids)
      # ```
      sig { params(ids: T::Array[Object]).returns(T::Array[Object]) }
      def mongoize_ids(ids); end

            # Convenience method of raising an invalid options error.
      # 
      # Raise the error.
      # ```ruby
      # criteria.raise_invalid
      # ```
      sig { returns(T.untyped) }
      def raise_invalid; end
    end

    module Scopable
      # Applies the default scope to the criteria.
      # 
      # _@return_ — The criteria.
      # 
      # Apply the default scope.
      # ```ruby
      # criteria.apply_default_scope
      # ```
      sig { returns(Criteria) }
      def apply_default_scope; end

      # Given another criteria, remove the other criteria's scoping from this
      # criteria.
      # 
      # _@param_ `other` — The other criteria.
      # 
      # _@return_ — The criteria with scoping removed.
      # 
      # Remove the scoping.
      # ```ruby
      # criteria.remove_scoping(other)
      # ```
      sig { params(other: Criteria).returns(Criteria) }
      def remove_scoping(other); end

      # Forces the criteria to be scoped, unless its inside an unscoped block.
      # 
      # _@param_ `options` — Additional query options.
      # 
      # _@return_ — The scoped criteria.
      # 
      # Force the criteria to be scoped.
      # ```ruby
      # criteria.scoped(skip: 10)
      # ```
      sig { params(options: T.nilable(T::Hash[T.untyped, T.untyped])).returns(Criteria) }
      def scoped(options = nil); end

      # Has the criteria had the default scope applied?
      # 
      # _@return_ — If the default scope is applied.
      # 
      # Is the default scope applied?
      # ```ruby
      # criteria.scoped?
      # ```
      sig { returns(T::Boolean) }
      def scoped?; end

      # Clears all scoping from the criteria.
      # 
      # _@return_ — The unscoped criteria.
      # 
      # Clear all scoping from the criteria.
      # ```ruby
      # criteria.unscoped
      # ```
      sig { returns(Criteria) }
      def unscoped; end

      # Is the criteria unscoped?
      # 
      # _@return_ — If the criteria is force unscoped.
      # 
      # Is the criteria unscoped?
      # ```ruby
      # criteria.unscoped?
      # ```
      sig { returns(T::Boolean) }
      def unscoped?; end

      # Get the criteria scoping options, as a pair (scoped, unscoped).
      # 
      # _@return_ — Scoped, unscoped.
      # 
      # Get the scoping options.
      # ```ruby
      # criteria.scoping_options
      # ```
      sig { returns(T::Array[T.untyped]) }
      def scoping_options; end

      # Set the criteria scoping options, as a pair (scoped, unscoped).
      # 
      # _@param_ `options` — Scoped, unscoped.
      # 
      # _@return_ — The new scoping options.
      # 
      # Set the scoping options.
      # ```ruby
      # criteria.scoping_options = true, false
      # ```
      sig { params(options: T::Array[T.untyped]).returns(T::Array[T.untyped]) }
      def scoping_options=(options); end

      # Get the criteria with the default scope applied, if the default scope
      # is able to be applied. Cases in which it cannot are: If we are in an
      # unscoped block, if the criteria is already forced unscoped, or the
      # default scope has already been applied.
      # 
      # _@return_ — The criteria.
      # 
      # Get the criteria with the default scope.
      # ```ruby
      # criteria.with_default_scope
      # ```
      sig { returns(Criteria) }
      def with_default_scope; end

                        sig { params(other: T.untyped, methods: T.untyped).returns(T.untyped) }
      def reject_matching(other, *methods); end
    end

    # A queryable is any object that needs queryable's dsl injected into it to build
    # MongoDB queries. For example, a Mongoid::Criteria is an Queryable.
    # 
    # @example Include queryable functionality.
    #   class Criteria
    #     include Queryable
    #   end
    module Queryable
      include Mongoid::Criteria::Queryable::Storable
      include Mongoid::Criteria::Queryable::Expandable
      include Mongoid::Criteria::Queryable::Mergeable
      include Mongoid::Criteria::Queryable::Aggregable
      include Mongoid::Selectable
      include Mongoid::Criteria::Queryable::Optional

      # Is this queryable equal to another object? Is true if the selector and
      # options are equal.
      # 
      # _@param_ `other` — The object to compare against.
      # 
      # _@return_ — If the objects are equal.
      # 
      # Are the objects equal?
      # ```ruby
      # queryable == criteria
      # ```
      sig { params(other: Object).returns(T::Boolean) }
      def ==(other); end

      # Initialize the new queryable. Will yield itself to the block if a block
      # is provided for objects that need additional behavior.
      # 
      # _@param_ `aliases` — The optional field aliases.
      # 
      # _@param_ `serializers` — The optional field serializers.
      # 
      # _@param_ `driver` — The driver being used.
      # 
      # Initialize the queryable.
      # ```ruby
      # Queryable.new
      # ```
      sig { params(aliases: T::Hash[T.untyped, T.untyped], serializers: T::Hash[T.untyped, T.untyped], driver: Symbol).void }
      def initialize(aliases = {}, serializers = {}, driver = :mongo); end

            # Handle the creation of a copy via #clone or #dup.
      # 
      # _@param_ `other` — The original copy.
      # 
      # Handle copy initialization.
      # ```ruby
      # queryable.initialize_copy(criteria)
      # ```
      sig { params(other: Queryable).returns(T.untyped) }
      def initialize_copy(other); end

      # Add ascending sorting options for all the provided fields.
      # 
      # _@param_ `fields` — The fields to sort.
      # 
      # _@return_ — The cloned optional.
      # 
      # Add ascending sorting.
      # ```ruby
      # optional.ascending(:first_name, :last_name)
      # ```
      sig { params(fields: T::Array[Symbol]).returns(Optional) }
      def ascending(*fields); end

      # Adds the option for telling MongoDB how many documents to retrieve in
      # it's batching.
      # 
      # _@param_ `value` — The batch size.
      # 
      # _@return_ — The cloned optional.
      # 
      # Apply the batch size options.
      # ```ruby
      # optional.batch_size(500)
      # ```
      sig { params(value: T.nilable(Integer)).returns(Optional) }
      def batch_size(value = nil); end

      # Add descending sorting options for all the provided fields.
      # 
      # _@param_ `fields` — The fields to sort.
      # 
      # _@return_ — The cloned optional.
      # 
      # Add descending sorting.
      # ```ruby
      # optional.descending(:first_name, :last_name)
      # ```
      sig { params(fields: T::Array[Symbol]).returns(Optional) }
      def descending(*fields); end

      # Add an index hint to the query options.
      # 
      # _@param_ `value` — The index hint.
      # 
      # _@return_ — The cloned optional.
      # 
      # Add an index hint.
      # ```ruby
      # optional.hint("$natural" => 1)
      # ```
      sig { params(value: T.nilable(T::Hash[T.untyped, T.untyped])).returns(Optional) }
      def hint(value = nil); end

      # Add the number of documents to limit in the returned results.
      # 
      # _@param_ `value` — The number of documents to return.
      # 
      # _@return_ — The cloned optional.
      # 
      # Limit the number of returned documents.
      # ```ruby
      # optional.limit(20)
      # ```
      sig { params(value: T.nilable(Integer)).returns(Optional) }
      def limit(value = nil); end

      # Adds the option to limit the number of documents scanned in the
      # collection.
      # 
      # _@param_ `value` — The max number of documents to scan.
      # 
      # _@return_ — The cloned optional.
      # 
      # Add the max scan limit.
      # ```ruby
      # optional.max_scan(1000)
      # ```
      sig { params(value: T.nilable(Integer)).returns(Optional) }
      def max_scan(value = nil); end

      # Adds a cumulative time limit in milliseconds for processing operations on a cursor.
      # 
      # _@param_ `value` — The max time in milliseconds for processing operations on a cursor.
      # 
      # _@return_ — The cloned optional.
      # 
      # Add the max time ms option.
      # ```ruby
      # optional.max_time_ms(200)
      # ```
      sig { params(value: T.nilable(Integer)).returns(Optional) }
      def max_time_ms(value = nil); end

      # Tell the query not to timeout.
      # 
      # _@return_ — The cloned optional.
      # 
      # Tell the query not to timeout.
      # ```ruby
      # optional.no_timeout
      # ```
      sig { returns(Optional) }
      def no_timeout; end

      # Limits the results to only contain the fields provided.
      # 
      # _@param_ `args` — The fields to return.
      # 
      # _@return_ — The cloned optional.
      # 
      # Limit the results to the provided fields.
      # ```ruby
      # optional.only(:name, :dob)
      # ```
      sig { params(args: T::Array[Symbol]).returns(Optional) }
      def only(*args); end

      # Adds sorting criterion to the options.
      # 
      # _@param_ `spec` — The sorting specification.
      # 
      # _@return_ — The cloned optional.
      # 
      # Add sorting options via a hash with integer directions.
      # ```ruby
      # optional.order_by(name: 1, dob: -1)
      # ```
      # 
      # Add sorting options via a hash with symbol directions.
      # ```ruby
      # optional.order_by(name: :asc, dob: :desc)
      # ```
      # 
      # Add sorting options via a hash with string directions.
      # ```ruby
      # optional.order_by(name: "asc", dob: "desc")
      # ```
      # 
      # Add sorting options via an array with integer directions.
      # ```ruby
      # optional.order_by([[ name, 1 ], [ dob, -1 ]])
      # ```
      # 
      # Add sorting options via an array with symbol directions.
      # ```ruby
      # optional.order_by([[ :name, :asc ], [ :dob, :desc ]])
      # ```
      # 
      # Add sorting options via an array with string directions.
      # ```ruby
      # optional.order_by([[ "name", "asc" ], [ "dob", "desc" ]])
      # ```
      # 
      # Add sorting options with keys.
      # ```ruby
      # optional.order_by(:name.asc, :dob.desc)
      # ```
      # 
      # Add sorting options via a string.
      # ```ruby
      # optional.order_by("name ASC, dob DESC")
      # ```
      sig { params(spec: T.any(T::Array[T.untyped], T::Hash[T.untyped, T.untyped], String)).returns(Optional) }
      def order_by(*spec); end

      # Instead of merging the order criteria, use this method to completely
      # replace the existing ordering with the provided.
      # 
      # _@param_ `spec` — The sorting specification.
      # 
      # _@return_ — The cloned optional.
      # 
      # Replace the ordering.
      # ```ruby
      # optional.reorder(name: :asc)
      # ```
      sig { params(spec: T.any(T::Array[T.untyped], T::Hash[T.untyped, T.untyped], String)).returns(Optional) }
      def reorder(*spec); end

      # Add the number of documents to skip.
      # 
      # _@param_ `value` — The number to skip.
      # 
      # _@return_ — The cloned optional.
      # 
      # Add the number to skip.
      # ```ruby
      # optional.skip(100)
      # ```
      sig { params(value: T.nilable(Integer)).returns(Optional) }
      def skip(value = nil); end

      # Limit the returned results via slicing embedded arrays.
      # 
      # _@param_ `criterion` — The slice options.
      # 
      # _@return_ — The cloned optional.
      # 
      # Slice the returned results.
      # ```ruby
      # optional.slice(aliases: [ 0, 5 ])
      # ```
      sig { params(criterion: T.nilable(T::Hash[T.untyped, T.untyped])).returns(Optional) }
      def slice(criterion = nil); end

      # Tell the query to operate in snapshot mode.
      # 
      # _@return_ — The cloned optional.
      # 
      # Add the snapshot option.
      # ```ruby
      # optional.snapshot
      # ```
      sig { returns(Optional) }
      def snapshot; end

      # Limits the results to only contain the fields not provided.
      # 
      # _@param_ `args` — The fields to ignore.
      # 
      # _@return_ — The cloned optional.
      # 
      # Limit the results to the fields not provided.
      # ```ruby
      # optional.without(:name, :dob)
      # ```
      sig { params(args: T::Array[Symbol]).returns(Optional) }
      def without(*args); end

      # Associate a comment with the query.
      # 
      # _@param_ `comment` — The comment to be associated with the query.
      # 
      # _@return_ — The cloned optional.
      # 
      # Add a comment.
      # ```ruby
      # optional.comment('slow query')
      # ```
      # 
      # _@note_ — Set profilingLevel to 2 and the comment will be logged in the profile
      # collection along with the query.
      sig { params(comment: T.nilable(String)).returns(Optional) }
      def comment(comment = nil); end

      # Set the cursor type.
      # 
      # _@param_ `type` — The type of cursor to create.
      # 
      # _@return_ — The cloned optional.
      # 
      # Set the cursor type.
      # ```ruby
      # optional.cursor_type(:tailable)
      # optional.cursor_type(:tailable_await)
      # ```
      # 
      # _@note_ — The cursor can be type :tailable or :tailable_await.
      sig { params(type: Symbol).returns(Optional) }
      def cursor_type(type); end

      # Set the collation.
      # 
      # _@param_ `collation_doc` — The document describing the collation to use.
      # 
      # _@return_ — The cloned optional.
      # 
      # Set the collation.
      # ```ruby
      # optional.collation(locale: 'fr', strength: 2)
      # ```
      sig { params(collation_doc: T::Hash[T.untyped, T.untyped]).returns(Optional) }
      def collation(collation_doc); end

      # Add a single sort option.
      # 
      # _@param_ `options` — The options.
      # 
      # _@param_ `field` — The field name.
      # 
      # _@param_ `direction` — The sort direction.
      # 
      # _@return_ — The cloned optional.
      # 
      # Add a single sort option.
      # ```ruby
      # optional.add_sort_option({}, :name, 1)
      # ```
      sig { params(options: T::Hash[T.untyped, T.untyped], field: String, direction: Integer).returns(Optional) }
      def add_sort_option(options, field, direction); end

      # Take the provided criterion and store it as an option in the query
      # options.
      # 
      # _@param_ `args` — The options.
      # 
      # _@return_ — The cloned queryable.
      # 
      # Store the option.
      # ```ruby
      # optional.option({ skip: 10 })
      # ```
      sig { params(args: T::Array[T.untyped]).returns(Queryable) }
      def option(*args); end

      # Add multiple sort options at once.
      # 
      # _@param_ `fields` — The field names.
      # 
      # _@param_ `direction` — The sort direction.
      # 
      # _@return_ — The cloned optional.
      # 
      # Add multiple sort options.
      # ```ruby
      # optional.sort_with_list(:name, :dob, 1)
      # ```
      sig { params(fields: T::Array[String], direction: Integer).returns(Optional) }
      def sort_with_list(*fields, direction); end

      # Get the atomic selector for the document. This is a hash in the simplest
      # case { "_id" => id }, but can become more complex for embedded documents
      # and documents that use a shard key.
      # 
      # _@return_ — The document's selector.
      # 
      # Get the document's atomic selector.
      # ```ruby
      # document.atomic_selector
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def atomic_selector; end

      # Get the atomic selector for an embedded document.
      # 
      # _@return_ — The embedded document selector.
      # 
      # Get the embedded atomic selector.
      # ```ruby
      # document.embedded_atomic_selector
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def embedded_atomic_selector; end

      # Get the atomic selector for a root document.
      # 
      # _@return_ — The root document selector.
      # 
      # Get the root atomic selector.
      # ```ruby
      # document.root_atomic_selector
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def root_atomic_selector; end

      # Has the aggregable enter an aggregation state. Ie, are only aggregation
      # operations allowed at this point on.
      # 
      # _@return_ — If the aggregable is aggregating.
      # 
      # Is the aggregable aggregating?
      # ```ruby
      # aggregable.aggregating?
      # ```
      sig { returns(T::Boolean) }
      def aggregating?; end

      # Add a group ($group) operation to the aggregation pipeline.
      # 
      # _@param_ `operation` — The group operation.
      # 
      # _@return_ — The aggregable.
      # 
      # Add a group operation being verbose.
      # ```ruby
      # aggregable.group(count: { "$sum" => 1 }, max: { "$max" => "likes" })
      # ```
      # 
      # Add a group operation using symbol shortcuts.
      # ```ruby
      # aggregable.group(:count.sum => 1, :max.max => "likes")
      # ```
      sig { params(operation: T::Hash[T.untyped, T.untyped]).returns(Aggregable) }
      def group(operation); end

      # Add a projection ($project) to the aggregation pipeline.
      # 
      # _@param_ `operation` — The projection to make.
      # 
      # _@return_ — The aggregable.
      # 
      # Add a projection to the pipeline.
      # ```ruby
      # aggregable.project(author: 1, name: 0)
      # ```
      sig { params(operation: T.nilable(T::Hash[T.untyped, T.untyped])).returns(Aggregable) }
      def project(operation = nil); end

      # Add an unwind ($unwind) to the aggregation pipeline.
      # 
      # _@param_ `field` — The name of the field to unwind.
      # 
      # _@return_ — The aggregable.
      # 
      # Add an unwind to the pipeline.
      # ```ruby
      # aggregable.unwind(:field)
      # ```
      sig { params(field: T.any(String, Symbol)).returns(Aggregable) }
      def unwind(field); end

      # Add the aggregation operation.
      # 
      # _@param_ `operation` — The operation for the pipeline.
      # 
      # _@return_ — The cloned aggregable.
      # 
      # Aggregate on the operation.
      # ```ruby
      # aggregation(operation) do |pipeline|
      #   pipeline.push("$project" => operation)
      # end
      # ```
      sig { params(operation: T::Hash[T.untyped, T.untyped]).returns(Aggregable) }
      def aggregation(operation); end

      # Instruct the next mergeable call to use intersection.
      # 
      # _@return_ — The intersect flagged mergeable.
      # 
      # Use intersection on the next call.
      # ```ruby
      # mergeable.intersect.in(field: [ 1, 2, 3 ])
      # ```
      sig { returns(Mergeable) }
      def intersect; end

      # Instruct the next mergeable call to use override.
      # 
      # _@return_ — The override flagged mergeable.
      # 
      # Use override on the next call.
      # ```ruby
      # mergeable.override.in(field: [ 1, 2, 3 ])
      # ```
      sig { returns(Mergeable) }
      def override; end

      # Instruct the next mergeable call to use union.
      # 
      # _@return_ — The union flagged mergeable.
      # 
      # Use union on the next call.
      # ```ruby
      # mergeable.union.in(field: [ 1, 2, 3 ])
      # ```
      sig { returns(Mergeable) }
      def union; end

      # Clear the current strategy and negating flag, used after cloning.
      # 
      # _@return_ — self.
      # 
      # Reset the strategies.
      # ```ruby
      # mergeable.reset_strategies!
      # ```
      sig { returns(Criteria) }
      def reset_strategies!; end

      # Adds the criterion to the existing selection.
      # 
      # _@param_ `criterion` — The criteria.
      # 
      # _@param_ `operator` — The MongoDB operator.
      # 
      # _@return_ — The new mergeable.
      # 
      # Add the criterion.
      # ```ruby
      # mergeable.__add__({ name: 1 }, "$in")
      # ```
      sig { params(criterion: T::Hash[T.untyped, T.untyped], operator: String).returns(Mergeable) }
      def __add__(criterion, operator); end

      # Adds the criterion to the existing selection.
      # 
      # _@param_ `criterion` — The criteria.
      # 
      # _@param_ `outer` — The outer MongoDB operator.
      # 
      # _@param_ `inner` — The inner MongoDB operator.
      # 
      # _@return_ — The new mergeable.
      # 
      # Add the criterion.
      # ```ruby
      # mergeable.__expanded__([ 1, 10 ], "$within", "$center")
      # ```
      sig { params(criterion: T::Hash[T.untyped, T.untyped], outer: String, inner: String).returns(Mergeable) }
      def __expanded__(criterion, outer, inner); end

      # Perform a straight merge of the criterion into the selection and let the
      # symbol overrides do all the work.
      # 
      # _@param_ `criterion` — The criteria.
      # 
      # _@return_ — The cloned object.
      # 
      # Straight merge the expanded criterion.
      # ```ruby
      # mergeable.__merge__(location: [ 1, 10 ])
      # ```
      sig { params(criterion: T::Hash[T.untyped, T.untyped]).returns(Mergeable) }
      def __merge__(criterion); end

      # Adds the criterion to the existing selection.
      # 
      # _@param_ `criterion` — The criteria.
      # 
      # _@param_ `operator` — The MongoDB operator.
      # 
      # _@return_ — The new mergeable.
      # 
      # Add the criterion.
      # ```ruby
      # mergeable.__intersect__([ 1, 2 ], "$in")
      # ```
      sig { params(criterion: T::Hash[T.untyped, T.untyped], operator: String).returns(Mergeable) }
      def __intersect__(criterion, operator); end

      # Adds $and/$or/$nor criteria to a copy of this selection.
      # 
      # Each of the criteria can be a Hash of key/value pairs or MongoDB
      # operators (keys beginning with $), or a Selectable object
      # (which typically will be a Criteria instance).
      # 
      # _@param_ `criteria` — Multiple key/value pair matches or Criteria objects.
      # 
      # _@param_ `operator` — The MongoDB operator.
      # 
      # _@return_ — The new mergeable.
      # 
      # Add the criterion.
      # ```ruby
      # mergeable.__multi__([ 1, 2 ], "$in")
      # ```
      sig { params(criteria: T::Array[T.any(T::Hash[T.untyped, T.untyped], Criteria)], operator: String).returns(Mergeable) }
      def __multi__(criteria, operator); end

                        # Combines criteria into a MongoDB selector.
      # 
      # Criteria is an array of criterions which will be flattened.
      # 
      # Each criterion can be:
      # - A hash
      # - A Criteria instance
      # - nil, in which case it is ignored
      sig { params(operator: T.untyped, criteria: T.untyped).returns(T.untyped) }
      def _mongoid_add_top_level_operation(operator, criteria); end

                  # Calling .flatten on an array which includes a Criteria instance
      # evaluates the criteria, which we do not want. Hence this method
      # explicitly only expands Array objects and Array subclasses.
      sig { params(array: T.untyped).returns(T.untyped) }
      def _mongoid_flatten_arrays(array); end

      # Takes a criteria hash and expands Key objects into hashes containing
      # MQL corresponding to said key objects. Also converts the input to
      # BSON::Document to permit indifferent access.
      # 
      # The argument must be a hash containing key-value pairs of the
      # following forms:
      # - {field_name: value}
      # - {'field_name' => value}
      # - {key_instance: value}
      # - {:$operator => operator_value_expression}
      # - {'$operator' => operator_value_expression}
      # 
      # Ruby does not permit multiple symbol operators. For example,
      # {:foo.gt => 1, :foo.gt => 2} is collapsed to {:foo.gt => 2} by the
      # language. Therefore this method never has to deal with multiple
      # identical operators.
      # 
      # Similarly, this method should never need to expand a literal value
      # and an operator at the same time.
      # 
      # This method effectively converts symbol keys to string keys in
      # the input +expr+, such that the downstream code can assume that
      # conditions always contain string keys.
      # 
      # _@param_ `expr` — Criteria including Key instances.
      # 
      # _@return_ — The expanded criteria.
      sig { params(expr: T::Hash[T.untyped, T.untyped]).returns(BSON::Document) }
      def _mongoid_expand_keys(expr); end

      # Adds the criterion to the existing selection.
      # 
      # _@param_ `criterion` — The criteria.
      # 
      # _@param_ `operator` — The MongoDB operator.
      # 
      # _@return_ — The new mergeable.
      # 
      # Add the criterion.
      # ```ruby
      # mergeable.__override__([ 1, 2 ], "$in")
      # ```
      sig { params(criterion: T.any(T::Hash[T.untyped, T.untyped], Criteria), operator: String).returns(Mergeable) }
      def __override__(criterion, operator); end

      # Adds the criterion to the existing selection.
      # 
      # _@param_ `criterion` — The criteria.
      # 
      # _@param_ `operator` — The MongoDB operator.
      # 
      # _@return_ — The new mergeable.
      # 
      # Add the criterion.
      # ```ruby
      # mergeable.__union__([ 1, 2 ], "$in")
      # ```
      sig { params(criterion: T::Hash[T.untyped, T.untyped], operator: String).returns(Mergeable) }
      def __union__(criterion, operator); end

      # Use the named strategy for the next operation.
      # 
      # _@param_ `strategy` — The strategy to use.
      # 
      # _@return_ — The existing mergeable.
      # 
      # Use intersection.
      # ```ruby
      # mergeable.use(:__intersect__)
      # ```
      sig { params(strategy: Symbol).returns(Mergeable) }
      def use(strategy); end

      # Add criterion to the selection with the named strategy.
      # 
      # _@param_ `strategy` — The name of the strategy method.
      # 
      # _@param_ `criterion` — The criterion to add.
      # 
      # _@param_ `operator` — The MongoDB operator.
      # 
      # _@return_ — The cloned query.
      # 
      # Add criterion with a strategy.
      # ```ruby
      # mergeable.with_strategy(:__union__, {field_name: [ 1, 2, 3 ]}, "$in")
      # ```
      sig { params(strategy: Symbol, criterion: Object, operator: String).returns(Mergeable) }
      def with_strategy(strategy, criterion, operator); end

            # Prepare the value for merging.
      # 
      # _@param_ `field` — The name of the field.
      # 
      # _@param_ `value` — The value.
      # 
      # _@return_ — The serialized value.
      # 
      # Prepare the value.
      # ```ruby
      # mergeable.prepare("field", "$gt", 10)
      # ```
      sig { params(field: String, operator: T.untyped, value: Object).returns(Object) }
      def prepare(field, operator, value); end

      # Expands the specified condition to MongoDB syntax.
      # 
      # This method is meant to be called when processing the items of
      # a condition hash and the key and the value of each item are
      # already available separately.
      # 
      # The following parameter forms are accepted:
      # 
      # - field is a string or symbol; value is the field query expresision
      # - field is a Key instance; value is the field query expression
      # - field is a string corresponding to a MongoDB operator; value is
      #   the operator value expression.
      # 
      # This method expands the field-value combination to the MongoDB
      # selector syntax and returns an array of
      # [expanded key, expanded value]. The expanded key is converted to
      # a string if it wasn't already a string.
      # 
      # _@param_ `field` — The field to expand.
      # 
      # _@param_ `value` — The field's value.
      # 
      # _@return_ — The expanded field and value.
      sig { params(field: T.any(String, Symbol, Key), value: Object).returns(T::Array[T.any(String, Object)]) }
      def expand_one_condition(field, value); end

      # Expand criterion values to arrays, to be used with operators that
      # take an array as argument such as $in.
      # 
      # _@param_ `criterion` — The criterion.
      # 
      # _@return_ — The $in friendly criterion with array values.
      # 
      # Convert all the values to arrays.
      # ```ruby
      # selectable.with_array_values({ key: 1...4 })
      # ```
      sig { params(criterion: T::Hash[T.untyped, T.untyped]).returns(T::Hash[T.untyped, T.untyped]) }
      def expand_condition_to_array_values(criterion); end

      # Adds a field expression to the query.
      # 
      # +field+ must be a field name, and it must be a string. The upstream
      # code must have converted other field/key types to the simple string
      # form by the time this method is invoked.
      # 
      # +value+ can be of any type, it is written into the selector unchanged.
      # 
      # This method performs no processing on the provided field value.
      # 
      # Mutates the receiver.
      # 
      # _@param_ `field` — The field name.
      # 
      # _@param_ `value` — The field value.
      # 
      # _@return_ — self.
      sig { params(field: String, value: Object).returns(Storable) }
      def add_field_expression(field, value); end

      # Adds a logical operator expression to the selector.
      # 
      # This method only handles logical operators ($and, $nor and $or).
      # It raises ArgumentError if called with another operator. Note that
      # in MQL, $not is a field-level operator and not a query-level one,
      # and therefore $not is not handled by this method.
      # 
      # This method takes the operator and the operator value expression
      # separately for callers' convenience. It can be considered to
      # handle storing the hash +{operator => op_expr}+.
      # 
      # If the selector consists of a single condition which is the specified
      # operator (on the top level), the new condition given in op_expr is
      # added to the existing conditions for the specified operator.
      # For example, if the selector is currently:
      # 
      #     {'$or' => [{'hello' => 'world'}]}
      # 
      # ... and operator is '$or' and op_expr is `[{'test' => 123'}]`,
      # the resulting selector will be:
      # 
      #     {'$or' => [{'hello' => 'world'}, {'test' => 123}]}
      # 
      # This method always adds the new conditions as additional requirements;
      # in other words, it does not implement the ActiveRecord or/nor behavior
      # where the receiver becomes one of the operands. It is expected that
      # code upstream of this method implements such behavior.
      # 
      # This method does not simplify values (i.e. if the selector is
      # currently empty and operator is $and, op_expr is written to the
      # selector with $and even if the $and can in principle be elided).
      # Such simplification is also expected to have already been performed
      # by the upstream code.
      # 
      # This method mutates the receiver.
      # 
      # _@param_ `operator` — The operator to add.
      # 
      # _@param_ `op_expr` — Operator value to add.
      # 
      # _@return_ — self.
      sig { params(operator: String, op_expr: T::Array[T::Hash[T.untyped, T.untyped]]).returns(Storable) }
      def add_logical_operator_expression(operator, op_expr); end

      # Adds an operator expression to the selector.
      # 
      # This method takes the operator and the operator value expression
      # separately for callers' convenience. It can be considered to
      # handle storing the hash +{operator => op_expr}+.
      # 
      # The operator value can be of any type.
      # 
      # If the selector already has the specified operator in it (on the
      # top level), the new condition given in op_expr is added to the
      # existing conditions for the specified operator. This is
      # straightforward for $and; for other logical operators, the behavior
      # of this method is to add the new conditions to the existing operator.
      # For example, if the selector is currently:
      # 
      #     {'foo' => 'bar', '$or' => [{'hello' => 'world'}]}
      # 
      # ... and operator is '$or' and op_expr is `{'test' => 123'}`,
      # the resulting selector will be:
      # 
      #     {'foo' => 'bar', '$or' => [{'hello' => 'world'}, {'test' => 123}]}
      # 
      # This does not implement an OR between the existing selector and the
      # new operator expression - handling this is the job of upstream
      # methods. This method simply stores op_expr into the selector on the
      # assumption that the existing selector is the correct left hand side
      # of the operation already.
      # 
      # For non-logical query-level operators like $where and $text, if
      # there already is a top-level operator with the same name, the
      # op_expr is added to the selector via a top-level $and operator,
      # thus producing a selector having both operator values.
      # 
      # This method does not simplify values (i.e. if the selector is
      # currently empty and operator is $and, op_expr is written to the
      # selector with $and even if the $and can in principle be elided).
      # 
      # This method mutates the receiver.
      # 
      # _@param_ `operator` — The operator to add.
      # 
      # _@param_ `op_expr` — Operator value to add.
      # 
      # _@return_ — self.
      sig { params(operator: String, op_expr: Object).returns(Storable) }
      def add_operator_expression(operator, op_expr); end

      # Adds an arbitrary expression to the query.
      # 
      # Field can either be a field name or an operator.
      # 
      # Mutates the receiver.
      # 
      # _@param_ `field` — Field name or operator name.
      # 
      # _@param_ `value` — Field value or operator expression.
      # 
      # _@return_ — self.
      sig { params(field: String, value: Object).returns(Storable) }
      def add_one_expression(field, value); end

            # Returns the value of attribute aliases.
      sig { returns(T.untyped) }
      attr_reader :aliases

            sig { returns(T.untyped) }
      attr_reader :aliases

            sig { returns(T.untyped) }
      attr_reader :driver

            sig { returns(T.untyped) }
      attr_reader :serializers

            # Returns the value of attribute driver.
      sig { returns(T.untyped) }
      attr_reader :driver

            # Returns the value of attribute serializers.
      sig { returns(T.untyped) }
      attr_reader :serializers

      # Key objects represent specifications for building query expressions
      # utilizing MongoDB selectors.
      # 
      # Simple key-value conditions are translated directly into expression
      # hashes by Mongoid without utilizing Key objects. For example, the
      # following condition:
      # 
      #   Foo.where(price: 1)
      # 
      # ... is translated to the following simple expression:
      # 
      #   {price: 1}
      # 
      # More complex conditions would start involving Key objects. For example:
      # 
      #   Foo.where(:price.gt => 1)
      # 
      # ... causes a Key instance to be created thusly:
      # 
      #   Key.new(:price, :__override__, '$gt')
      # 
      # This Key instance utilizes +operator+ but not +expanded+ nor +block+.
      # The corresponding MongoDB query expression is:
      # 
      #    {price: {'$gt' => 1}}
      # 
      # A yet more more complex example is the following condition:
      # 
      #   Foo.geo_spatial(:boundary.intersects_point => [1, 10])
      # 
      # Processing this condition will cause a Key instance to be created as
      # follows:
      # 
      #   Key.new(:location, :__override__, '$geoIntersects', '$geometry') do |value|
      #     { "type" => POINT, "coordinates" => value }
      #   end
      # 
      # ... eventually producing the following MongoDB query expression:
      # 
      # {
      #   boundary: {
      #     '$geoIntersects' => {
      #       '$geometry' => {
      #         type: "Point" ,
      #         coordinates: [ 1, 10 ]
      #       }
      #     }
      #   }
      # }
      # 
      # Key instances can be thought of as procs that map a value to the
      # MongoDB query expression required to obtain the key's condition,
      # given the value.
      class Key
        # Does the key equal another object?
        # 
        # _@param_ `other` — The object to compare to.
        # 
        # _@return_ — If the objects are equal.
        # 
        # Is the key equal to another?
        # ```ruby
        # key == other
        # key.eql? other
        # ```
        sig { params(other: Object).returns(T::Boolean) }
        def ==(other); end

        # Calculate the hash code for a key.
        # 
        # _@return_ — The hash code for the key.
        sig { returns(Fixnum) }
        def hash; end

        # Instantiate the new key.
        # 
        # _@param_ `name` — The field name.
        # 
        # _@param_ `strategy` — The name of the merge strategy.
        # 
        # _@param_ `operator` — The MongoDB operator, or sort direction (1 or -1).
        # 
        # _@param_ `expanded` — The Mongo expanded operator.
        # 
        # Instantiate a key.
        # ```ruby
        # Key.new("age", :__override__, "$gt")
        # ```
        # 
        # Instantiate a key for sorting.
        # ```ruby
        # Key.new(:field, :__override__, 1)
        # ```
        sig do
          params(
            name: T.any(String, Symbol),
            strategy: Symbol,
            operator: T.any(String, Integer),
            expanded: T.nilable(String),
            block: T.untyped
          ).void
        end
        def initialize(name, strategy, operator, expanded = nil, &block); end

        # Gets the raw selector that would be passed to Mongo from this key.
        # 
        # _@param_ `object` — The value to be included.
        # 
        # _@param_ `negating` — If the selection should be negated.
        # 
        # _@return_ — The raw MongoDB selector.
        # 
        # Specify the raw selector.
        # ```ruby
        # key.__expr_part__(50)
        # ```
        sig { params(object: Object, negating: T::Boolean).returns(T::Hash[T.untyped, T.untyped]) }
        def __expr_part__(object, negating = false); end

                                sig { params(value: T.untyped, negating: T.untyped).returns(T.untyped) }
        def transform_value(value, negating = false); end

        # Get the key as raw Mongo sorting options.
        # 
        # _@return_ — The field/direction pair.
        # 
        # Get the key as a sort.
        # ```ruby
        # key.__sort_option__
        # ```
        sig { returns(T::Hash[T.untyped, T.untyped]) }
        def __sort_option__; end

        # Convert the key to a string.
        # 
        # _@return_ — The key as a string.
        # 
        # Convert the key to a string.
        # ```ruby
        # key.to_s
        # ```
        sig { returns(String) }
        def to_s; end

        # _@return_ — The name of the field.
        sig { returns(T.any(String, Symbol)) }
        attr_reader :name

        # _@return_ — The MongoDB query operator.
        sig { returns(String) }
        attr_reader :operator

        # _@return_ — The MongoDB expanded query operator.
        sig { returns(String) }
        attr_reader :expanded

        # _@return_ — The name of the merge strategy.
        sig { returns(Symbol) }
        attr_reader :strategy

        # _@return_ — The optional block to transform values.
        sig { returns(Proc) }
        attr_reader :block
      end

      # This is a smart hash for use with options and selectors.
      class Smash < Hash
        # Perform a deep copy of the smash.
        # 
        # _@return_ — The copied hash.
        # 
        # Perform a deep copy.
        # ```ruby
        # smash.__deep_copy__
        # ```
        sig { returns(Smash) }
        def __deep_copy__; end

        # Initialize the new selector.
        # 
        # _@param_ `aliases` — A hash of mappings from aliases to the actual field names in the database.
        # 
        # _@param_ `serializers` — An optional hash of objects that are responsible for serializing values. The keys of the hash must be strings that match the field name, and the values must respond to #localized? and #evolve(object).
        # 
        # Initialize the new selector.
        # ```ruby
        # Queryable::Smash.new(aliases, serializers)
        # ```
        sig { params(aliases: T::Hash[T.untyped, T.untyped], serializers: T::Hash[T.untyped, T.untyped]).void }
        def initialize(aliases = {}, serializers = {}); end

        # Get an item from the smart hash by the provided key.
        # 
        # _@param_ `key` — The key.
        # 
        # _@return_ — The found object.
        # 
        # Get an item by the key.
        # ```ruby
        # smash["test"]
        # ```
        sig { params(key: String).returns(Object) }
        def [](key); end

        # Get the localized value for the key if needed. If the field uses
        # localization the current locale will be appended to the key in
        # MongoDB dot notation.
        # 
        # _@param_ `name` — The name of the field.
        # 
        # _@param_ `serializer` — The optional field serializer.
        # 
        # _@return_ — The normalized key.
        # 
        # Get the normalized key name.
        # ```ruby
        # smash.localized_key("field", serializer)
        # ```
        sig { params(name: String, serializer: Object).returns(String) }
        def localized_key(name, serializer); end

        # Get the pair of objects needed to store the value in a hash by the
        # provided key. This is the database field name and the serializer.
        # 
        # _@param_ `key` — The key provided to the selection.
        # 
        # _@return_ — The name of the db field and
        # serializer.
        # 
        # Get the name and serializer.
        # ```ruby
        # smash.storage_pair("id")
        # ```
        sig { params(key: T.any(Symbol, String)).returns(T::Array[T.any(String, Object)]) }
        def storage_pair(key); end

                # Returns the value of attribute aliases.
        sig { returns(T.untyped) }
        attr_reader :aliases

                sig { returns(T.untyped) }
        attr_reader :aliases

                sig { returns(T.untyped) }
        attr_reader :serializers

                # Returns the value of attribute serializers.
        sig { returns(T.untyped) }
        attr_reader :serializers
      end

      # The options is a hash representation of options passed to MongoDB queries,
      # such as skip, limit, and sorting criteria.
      class Options < Mongoid::Criteria::Queryable::Smash
        # Convenience method for getting the field options.
        # 
        # _@return_ — The fields options.
        # 
        # Get the fields options.
        # ```ruby
        # options.fields
        # ```
        sig { returns(T::Hash[T.untyped, T.untyped]) }
        def fields; end

        # Convenience method for getting the limit option.
        # 
        # _@return_ — The limit option.
        # 
        # Get the limit option.
        # ```ruby
        # options.limit
        # ```
        sig { returns(Integer) }
        def limit; end

        # Convenience method for getting the skip option.
        # 
        # _@return_ — The skip option.
        # 
        # Get the skip option.
        # ```ruby
        # options.skip
        # ```
        sig { returns(Integer) }
        def skip; end

        # Convenience method for getting the sort options.
        # 
        # _@return_ — The sort options.
        # 
        # Get the sort options.
        # ```ruby
        # options.sort
        # ```
        sig { returns(T::Hash[T.untyped, T.untyped]) }
        def sort; end

                # Store the value in the options for the provided key. The options will
        # handle all necessary serialization and localization in this step.
        # 
        # _@param_ `key` — The name of the attribute.
        # 
        # _@param_ `value` — The value to add.
        # 
        # _@return_ — The stored object.
        # 
        # Store a value in the options.
        # ```ruby
        # options.store(:key, "testing")
        # ```
        sig { params(key: T.any(String, Symbol), value: Object, localize: T.untyped).returns(Object) }
        def store(key, value, localize = true); end

        # Convert the options to aggregation pipeline friendly options.
        # 
        # _@return_ — The options in pipeline form.
        # 
        # Convert the options to a pipeline.
        # ```ruby
        # options.to_pipeline
        # ```
        sig { returns(T::Array[T::Hash[T.untyped, T.untyped]]) }
        def to_pipeline; end

        # Perform a deep copy of the options.
        # 
        # _@return_ — The copied options.
        # 
        # Perform a deep copy.
        # ```ruby
        # options.__deep_copy__
        # ```
        sig { returns(Options) }
        def __deep_copy__; end

                # Evolve a single key selection with various types of values.
        # 
        # _@param_ `value` — The value to serialize.
        # 
        # _@return_ — The serialized object.
        # 
        # Evolve a simple selection.
        # ```ruby
        # options.evolve(field, 5)
        # ```
        sig { params(value: Object, localize: T.untyped).returns(Object) }
        def evolve(value, localize = true); end

                # Evolve a single key selection with hash values.
        # 
        # _@param_ `value` — The hash to serialize.
        # 
        # _@return_ — The serialized hash.
        # 
        # Evolve a simple selection.
        # ```ruby
        # options.evolve(field, { "$gt" => 5 })
        # ```
        sig { params(value: T::Hash[T.untyped, T.untyped], localize: T.untyped).returns(Object) }
        def evolve_hash(value, localize = true); end
      end

      # The optional module includes all behavior that has to do with extra
      # options surrounding queries, like skip, limit, sorting, etc.
      module Optional
        extend Mongoid::Criteria::Queryable::Macroable

        # Add ascending sorting options for all the provided fields.
        # 
        # _@param_ `fields` — The fields to sort.
        # 
        # _@return_ — The cloned optional.
        # 
        # Add ascending sorting.
        # ```ruby
        # optional.ascending(:first_name, :last_name)
        # ```
        sig { params(fields: T::Array[Symbol]).returns(Optional) }
        def ascending(*fields); end

        # Adds the option for telling MongoDB how many documents to retrieve in
        # it's batching.
        # 
        # _@param_ `value` — The batch size.
        # 
        # _@return_ — The cloned optional.
        # 
        # Apply the batch size options.
        # ```ruby
        # optional.batch_size(500)
        # ```
        sig { params(value: T.nilable(Integer)).returns(Optional) }
        def batch_size(value = nil); end

        # Add descending sorting options for all the provided fields.
        # 
        # _@param_ `fields` — The fields to sort.
        # 
        # _@return_ — The cloned optional.
        # 
        # Add descending sorting.
        # ```ruby
        # optional.descending(:first_name, :last_name)
        # ```
        sig { params(fields: T::Array[Symbol]).returns(Optional) }
        def descending(*fields); end

        # Add an index hint to the query options.
        # 
        # _@param_ `value` — The index hint.
        # 
        # _@return_ — The cloned optional.
        # 
        # Add an index hint.
        # ```ruby
        # optional.hint("$natural" => 1)
        # ```
        sig { params(value: T.nilable(T::Hash[T.untyped, T.untyped])).returns(Optional) }
        def hint(value = nil); end

        # Add the number of documents to limit in the returned results.
        # 
        # _@param_ `value` — The number of documents to return.
        # 
        # _@return_ — The cloned optional.
        # 
        # Limit the number of returned documents.
        # ```ruby
        # optional.limit(20)
        # ```
        sig { params(value: T.nilable(Integer)).returns(Optional) }
        def limit(value = nil); end

        # Adds the option to limit the number of documents scanned in the
        # collection.
        # 
        # _@param_ `value` — The max number of documents to scan.
        # 
        # _@return_ — The cloned optional.
        # 
        # Add the max scan limit.
        # ```ruby
        # optional.max_scan(1000)
        # ```
        sig { params(value: T.nilable(Integer)).returns(Optional) }
        def max_scan(value = nil); end

        # Adds a cumulative time limit in milliseconds for processing operations on a cursor.
        # 
        # _@param_ `value` — The max time in milliseconds for processing operations on a cursor.
        # 
        # _@return_ — The cloned optional.
        # 
        # Add the max time ms option.
        # ```ruby
        # optional.max_time_ms(200)
        # ```
        sig { params(value: T.nilable(Integer)).returns(Optional) }
        def max_time_ms(value = nil); end

        # Tell the query not to timeout.
        # 
        # _@return_ — The cloned optional.
        # 
        # Tell the query not to timeout.
        # ```ruby
        # optional.no_timeout
        # ```
        sig { returns(Optional) }
        def no_timeout; end

        # Limits the results to only contain the fields provided.
        # 
        # _@param_ `args` — The fields to return.
        # 
        # _@return_ — The cloned optional.
        # 
        # Limit the results to the provided fields.
        # ```ruby
        # optional.only(:name, :dob)
        # ```
        sig { params(args: T::Array[Symbol]).returns(Optional) }
        def only(*args); end

        # Adds sorting criterion to the options.
        # 
        # _@param_ `spec` — The sorting specification.
        # 
        # _@return_ — The cloned optional.
        # 
        # Add sorting options via a hash with integer directions.
        # ```ruby
        # optional.order_by(name: 1, dob: -1)
        # ```
        # 
        # Add sorting options via a hash with symbol directions.
        # ```ruby
        # optional.order_by(name: :asc, dob: :desc)
        # ```
        # 
        # Add sorting options via a hash with string directions.
        # ```ruby
        # optional.order_by(name: "asc", dob: "desc")
        # ```
        # 
        # Add sorting options via an array with integer directions.
        # ```ruby
        # optional.order_by([[ name, 1 ], [ dob, -1 ]])
        # ```
        # 
        # Add sorting options via an array with symbol directions.
        # ```ruby
        # optional.order_by([[ :name, :asc ], [ :dob, :desc ]])
        # ```
        # 
        # Add sorting options via an array with string directions.
        # ```ruby
        # optional.order_by([[ "name", "asc" ], [ "dob", "desc" ]])
        # ```
        # 
        # Add sorting options with keys.
        # ```ruby
        # optional.order_by(:name.asc, :dob.desc)
        # ```
        # 
        # Add sorting options via a string.
        # ```ruby
        # optional.order_by("name ASC, dob DESC")
        # ```
        sig { params(spec: T.any(T::Array[T.untyped], T::Hash[T.untyped, T.untyped], String)).returns(Optional) }
        def order_by(*spec); end

        # Instead of merging the order criteria, use this method to completely
        # replace the existing ordering with the provided.
        # 
        # _@param_ `spec` — The sorting specification.
        # 
        # _@return_ — The cloned optional.
        # 
        # Replace the ordering.
        # ```ruby
        # optional.reorder(name: :asc)
        # ```
        sig { params(spec: T.any(T::Array[T.untyped], T::Hash[T.untyped, T.untyped], String)).returns(Optional) }
        def reorder(*spec); end

        # Add the number of documents to skip.
        # 
        # _@param_ `value` — The number to skip.
        # 
        # _@return_ — The cloned optional.
        # 
        # Add the number to skip.
        # ```ruby
        # optional.skip(100)
        # ```
        sig { params(value: T.nilable(Integer)).returns(Optional) }
        def skip(value = nil); end

        # Limit the returned results via slicing embedded arrays.
        # 
        # _@param_ `criterion` — The slice options.
        # 
        # _@return_ — The cloned optional.
        # 
        # Slice the returned results.
        # ```ruby
        # optional.slice(aliases: [ 0, 5 ])
        # ```
        sig { params(criterion: T.nilable(T::Hash[T.untyped, T.untyped])).returns(Optional) }
        def slice(criterion = nil); end

        # Tell the query to operate in snapshot mode.
        # 
        # _@return_ — The cloned optional.
        # 
        # Add the snapshot option.
        # ```ruby
        # optional.snapshot
        # ```
        sig { returns(Optional) }
        def snapshot; end

        # Limits the results to only contain the fields not provided.
        # 
        # _@param_ `args` — The fields to ignore.
        # 
        # _@return_ — The cloned optional.
        # 
        # Limit the results to the fields not provided.
        # ```ruby
        # optional.without(:name, :dob)
        # ```
        sig { params(args: T::Array[Symbol]).returns(Optional) }
        def without(*args); end

        # Associate a comment with the query.
        # 
        # _@param_ `comment` — The comment to be associated with the query.
        # 
        # _@return_ — The cloned optional.
        # 
        # Add a comment.
        # ```ruby
        # optional.comment('slow query')
        # ```
        # 
        # _@note_ — Set profilingLevel to 2 and the comment will be logged in the profile
        # collection along with the query.
        sig { params(comment: T.nilable(String)).returns(Optional) }
        def comment(comment = nil); end

        # Set the cursor type.
        # 
        # _@param_ `type` — The type of cursor to create.
        # 
        # _@return_ — The cloned optional.
        # 
        # Set the cursor type.
        # ```ruby
        # optional.cursor_type(:tailable)
        # optional.cursor_type(:tailable_await)
        # ```
        # 
        # _@note_ — The cursor can be type :tailable or :tailable_await.
        sig { params(type: Symbol).returns(Optional) }
        def cursor_type(type); end

        # Set the collation.
        # 
        # _@param_ `collation_doc` — The document describing the collation to use.
        # 
        # _@return_ — The cloned optional.
        # 
        # Set the collation.
        # ```ruby
        # optional.collation(locale: 'fr', strength: 2)
        # ```
        sig { params(collation_doc: T::Hash[T.untyped, T.untyped]).returns(Optional) }
        def collation(collation_doc); end

        # Add a single sort option.
        # 
        # _@param_ `options` — The options.
        # 
        # _@param_ `field` — The field name.
        # 
        # _@param_ `direction` — The sort direction.
        # 
        # _@return_ — The cloned optional.
        # 
        # Add a single sort option.
        # ```ruby
        # optional.add_sort_option({}, :name, 1)
        # ```
        sig { params(options: T::Hash[T.untyped, T.untyped], field: String, direction: Integer).returns(Optional) }
        def add_sort_option(options, field, direction); end

        # Take the provided criterion and store it as an option in the query
        # options.
        # 
        # _@param_ `args` — The options.
        # 
        # _@return_ — The cloned queryable.
        # 
        # Store the option.
        # ```ruby
        # optional.option({ skip: 10 })
        # ```
        sig { params(args: T::Array[T.untyped]).returns(Queryable) }
        def option(*args); end

        # Add multiple sort options at once.
        # 
        # _@param_ `fields` — The field names.
        # 
        # _@param_ `direction` — The sort direction.
        # 
        # _@return_ — The cloned optional.
        # 
        # Add multiple sort options.
        # ```ruby
        # optional.sort_with_list(:name, :dob, 1)
        # ```
        sig { params(fields: T::Array[String], direction: Integer).returns(Optional) }
        def sort_with_list(*fields, direction); end

        # Get the methods on the optional that can be forwarded to from a model.
        # 
        # _@return_ — The names of the forwardable methods.
        # 
        # Get the forwardable methods.
        # ```ruby
        # Optional.forwardables
        # ```
        sig { returns(T::Array[Symbol]) }
        def self.forwardables; end

                # Adds a method on Symbol for convenience in where queries for the
        # provided operators.
        # 
        # _@param_ `name` — The name of the method.
        # 
        # _@param_ `strategy` — The merge strategy.
        # 
        # _@param_ `operator` — The MongoDB operator.
        # 
        # _@param_ `additional` — The additional MongoDB operator.
        # 
        # Add a symbol key.
        # ```ruby
        # key :all, "$all
        # ```
        sig do
          params(
            name: Symbol,
            strategy: Symbol,
            operator: String,
            additional: T.nilable(String),
            block: T.untyped
          ).returns(T.untyped)
        end
        def self.key(name, strategy, operator, additional = nil, &block); end

        # Returns the value of attribute options.
        sig { returns(T.untyped) }
        attr_accessor :options

                sig { returns(T.untyped) }
        attr_accessor :options
      end

      # Represents an aggregation pipeline.
      # 
      # @since 2.0.0
      class Pipeline < Array
        # Deep copy the aggregation pipeline. Will clone all the values in the
        # pipeline as well as the pipeline itself.
        # 
        # _@return_ — The cloned pipeline.
        # 
        # Deep copy the pipeline.
        # ```ruby
        # pipeline.__deep_copy__
        # ```
        sig { returns(Pipeline) }
        def __deep_copy__; end

        # Add a group operation to the aggregation pipeline.
        # 
        # _@param_ `entry` — The group entry.
        # 
        # _@return_ — The pipeline.
        # 
        # Add a group operation.
        # ```ruby
        # pipeline.group(:_id => "foo", :count.sum => 1, :max.max => "likes")
        # ```
        sig { params(entry: T::Hash[T.untyped, T.untyped]).returns(Pipeline) }
        def group(entry); end

        # Initialize the new pipeline.
        # 
        # _@param_ `aliases` — A hash of mappings from aliases to the actual field names in the database.
        # 
        # Initialize the new pipeline.
        # ```ruby
        # Queryable::Pipeline.new(aliases)
        # ```
        sig { params(aliases: T::Hash[T.untyped, T.untyped]).void }
        def initialize(aliases = {}); end

        # Adds a $project entry to the aggregation pipeline.
        # 
        # _@param_ `entry` — The projection.
        # 
        # _@return_ — The pipeline.
        # 
        # Add the projection.
        # ```ruby
        # pipeline.project(name: 1)
        # ```
        sig { params(entry: T::Hash[T.untyped, T.untyped]).returns(Pipeline) }
        def project(entry); end

        # Add the $unwind entry to the pipeline.
        # 
        # _@param_ `field_or_doc` — A field name or a document.
        # 
        # _@return_ — The pipeline.
        # 
        # Add the unwind.
        # ```ruby
        # pipeline.unwind(:field)
        # pipeline.unwind(document)
        # ```
        sig { params(field_or_doc: T.any(String, Symbol, T::Hash[T.untyped, T.untyped])).returns(Pipeline) }
        def unwind(field_or_doc); end

        # Evolve the entry using the aliases.
        # 
        # _@param_ `entry` — The entry to evolve.
        # 
        # _@return_ — The evolved entry.
        # 
        # Evolve the entry.
        # ```ruby
        # pipeline.evolve(name: 1)
        # ```
        sig { params(entry: T::Hash[T.untyped, T.untyped]).returns(T::Hash[T.untyped, T.untyped]) }
        def evolve(entry); end

                sig { returns(T.untyped) }
        attr_reader :aliases

                sig { returns(T.untyped) }
        attr_reader :aliases
      end

      # The selector is a special kind of hash that knows how to serialize values
      # coming into it as well as being alias and locale aware for key names.
      class Selector < Mongoid::Criteria::Queryable::Smash
        # Merges another selector into this one.
        # 
        # _@param_ `other` — The object to merge in.
        # 
        # _@return_ — The selector.
        # 
        # Merge in another selector.
        # ```ruby
        # selector.merge!(name: "test")
        # ```
        sig { params(other: T.any(T::Hash[T.untyped, T.untyped], Selector)).returns(Selector) }
        def merge!(other); end

        # Store the value in the selector for the provided key. The selector will
        # handle all necessary serialization and localization in this step.
        # 
        # _@param_ `key` — The name of the attribute.
        # 
        # _@param_ `value` — The value to add.
        # 
        # _@return_ — The stored object.
        # 
        # Store a value in the selector.
        # ```ruby
        # selector.store(:key, "testing")
        # ```
        sig { params(key: T.any(String, Symbol), value: Object).returns(Object) }
        def store(key, value); end

        # Convert the selector to an aggregation pipeline entry.
        # 
        # _@return_ — The pipeline entry for the selector.
        # 
        # Convert the selector to a pipeline.
        # ```ruby
        # selector.to_pipeline
        # ```
        sig { returns(T::Array[T::Hash[T.untyped, T.untyped]]) }
        def to_pipeline; end

        # Evolves a multi-list selection, like an $and or $or criterion, and
        # performs the necessary serialization.
        # 
        # _@param_ `specs` — The multi-selection.
        # 
        # _@return_ — The serialized values.
        # 
        # Evolve the multi-selection.
        # ```ruby
        # selector.evolve_multi([{ field: "value" }])
        # ```
        sig { params(specs: T::Array[T::Hash[T.untyped, T.untyped]]).returns(T::Array[T::Hash[T.untyped, T.untyped]]) }
        def evolve_multi(specs); end

        # Evolve a single key selection with various types of values.
        # 
        # _@param_ `serializer` — The optional serializer for the field.
        # 
        # _@param_ `value` — The value to serialize.
        # 
        # _@return_ — The serialized object.
        # 
        # Evolve a simple selection.
        # ```ruby
        # selector.evolve(field, 5)
        # ```
        sig { params(serializer: Object, value: Object).returns(Object) }
        def evolve(serializer, value); end

        # Evolve a single key selection with array values.
        # 
        # _@param_ `serializer` — The optional serializer for the field.
        # 
        # _@param_ `value` — The array to serialize.
        # 
        # _@return_ — The serialized array.
        # 
        # Evolve a simple selection.
        # ```ruby
        # selector.evolve(field, [ 1, 2, 3 ])
        # ```
        sig { params(serializer: Object, value: T::Array[Object]).returns(Object) }
        def evolve_array(serializer, value); end

        # Evolve a single key selection with hash values.
        # 
        # _@param_ `serializer` — The optional serializer for the field.
        # 
        # _@param_ `value` — The hash to serialize.
        # 
        # _@return_ — The serialized hash.
        # 
        # Evolve a simple selection.
        # ```ruby
        # selector.evolve(field, { "$gt" => 5 })
        # ```
        sig { params(serializer: Object, value: T::Hash[T.untyped, T.untyped]).returns(Object) }
        def evolve_hash(serializer, value); end

        # Determines if the selection is a multi-select, like an $and or $or or $nor
        # selection.
        # 
        # _@param_ `key` — The key to check.
        # 
        # _@return_ — If the key is for a multi-select.
        # 
        # Is the selection a multi-select?
        # ```ruby
        # selector.multi_selection?("$and")
        # ```
        sig { params(key: String).returns(T::Boolean) }
        def multi_selection?(key); end
      end

      # This module encapsulates methods that write query expressions into
      # the Criteria's selector.
      # 
      # The query expressions must have already been expanded as necessary.
      # The methods of this module do not perform processing on expression
      # values.
      # 
      # Methods in this module do not handle negation - if negation is needed,
      # it must have already been handled upstream of these methods.
      # 
      # @api private
      module Storable
        # Adds a field expression to the query.
        # 
        # +field+ must be a field name, and it must be a string. The upstream
        # code must have converted other field/key types to the simple string
        # form by the time this method is invoked.
        # 
        # +value+ can be of any type, it is written into the selector unchanged.
        # 
        # This method performs no processing on the provided field value.
        # 
        # Mutates the receiver.
        # 
        # _@param_ `field` — The field name.
        # 
        # _@param_ `value` — The field value.
        # 
        # _@return_ — self.
        sig { params(field: String, value: Object).returns(Storable) }
        def add_field_expression(field, value); end

        # Adds a logical operator expression to the selector.
        # 
        # This method only handles logical operators ($and, $nor and $or).
        # It raises ArgumentError if called with another operator. Note that
        # in MQL, $not is a field-level operator and not a query-level one,
        # and therefore $not is not handled by this method.
        # 
        # This method takes the operator and the operator value expression
        # separately for callers' convenience. It can be considered to
        # handle storing the hash +{operator => op_expr}+.
        # 
        # If the selector consists of a single condition which is the specified
        # operator (on the top level), the new condition given in op_expr is
        # added to the existing conditions for the specified operator.
        # For example, if the selector is currently:
        # 
        #     {'$or' => [{'hello' => 'world'}]}
        # 
        # ... and operator is '$or' and op_expr is `[{'test' => 123'}]`,
        # the resulting selector will be:
        # 
        #     {'$or' => [{'hello' => 'world'}, {'test' => 123}]}
        # 
        # This method always adds the new conditions as additional requirements;
        # in other words, it does not implement the ActiveRecord or/nor behavior
        # where the receiver becomes one of the operands. It is expected that
        # code upstream of this method implements such behavior.
        # 
        # This method does not simplify values (i.e. if the selector is
        # currently empty and operator is $and, op_expr is written to the
        # selector with $and even if the $and can in principle be elided).
        # Such simplification is also expected to have already been performed
        # by the upstream code.
        # 
        # This method mutates the receiver.
        # 
        # _@param_ `operator` — The operator to add.
        # 
        # _@param_ `op_expr` — Operator value to add.
        # 
        # _@return_ — self.
        sig { params(operator: String, op_expr: T::Array[T::Hash[T.untyped, T.untyped]]).returns(Storable) }
        def add_logical_operator_expression(operator, op_expr); end

        # Adds an operator expression to the selector.
        # 
        # This method takes the operator and the operator value expression
        # separately for callers' convenience. It can be considered to
        # handle storing the hash +{operator => op_expr}+.
        # 
        # The operator value can be of any type.
        # 
        # If the selector already has the specified operator in it (on the
        # top level), the new condition given in op_expr is added to the
        # existing conditions for the specified operator. This is
        # straightforward for $and; for other logical operators, the behavior
        # of this method is to add the new conditions to the existing operator.
        # For example, if the selector is currently:
        # 
        #     {'foo' => 'bar', '$or' => [{'hello' => 'world'}]}
        # 
        # ... and operator is '$or' and op_expr is `{'test' => 123'}`,
        # the resulting selector will be:
        # 
        #     {'foo' => 'bar', '$or' => [{'hello' => 'world'}, {'test' => 123}]}
        # 
        # This does not implement an OR between the existing selector and the
        # new operator expression - handling this is the job of upstream
        # methods. This method simply stores op_expr into the selector on the
        # assumption that the existing selector is the correct left hand side
        # of the operation already.
        # 
        # For non-logical query-level operators like $where and $text, if
        # there already is a top-level operator with the same name, the
        # op_expr is added to the selector via a top-level $and operator,
        # thus producing a selector having both operator values.
        # 
        # This method does not simplify values (i.e. if the selector is
        # currently empty and operator is $and, op_expr is written to the
        # selector with $and even if the $and can in principle be elided).
        # 
        # This method mutates the receiver.
        # 
        # _@param_ `operator` — The operator to add.
        # 
        # _@param_ `op_expr` — Operator value to add.
        # 
        # _@return_ — self.
        sig { params(operator: String, op_expr: Object).returns(Storable) }
        def add_operator_expression(operator, op_expr); end

        # Adds an arbitrary expression to the query.
        # 
        # Field can either be a field name or an operator.
        # 
        # Mutates the receiver.
        # 
        # _@param_ `field` — Field name or operator name.
        # 
        # _@param_ `value` — Field value or operator expression.
        # 
        # _@return_ — self.
        sig { params(field: String, value: Object).returns(Storable) }
        def add_one_expression(field, value); end
      end

      # Adds macro behavior for adding symbol methods.
      module Macroable
                # Adds a method on Symbol for convenience in where queries for the
        # provided operators.
        # 
        # _@param_ `name` — The name of the method.
        # 
        # _@param_ `strategy` — The merge strategy.
        # 
        # _@param_ `operator` — The MongoDB operator.
        # 
        # _@param_ `additional` — The additional MongoDB operator.
        # 
        # Add a symbol key.
        # ```ruby
        # key :all, "$all
        # ```
        sig do
          params(
            name: Symbol,
            strategy: Symbol,
            operator: String,
            additional: T.nilable(String),
            block: T.untyped
          ).returns(T.untyped)
        end
        def key(name, strategy, operator, additional = nil, &block); end
      end

      # Contains behavior for merging existing selection with new selection.
      module Mergeable
        # Instruct the next mergeable call to use intersection.
        # 
        # _@return_ — The intersect flagged mergeable.
        # 
        # Use intersection on the next call.
        # ```ruby
        # mergeable.intersect.in(field: [ 1, 2, 3 ])
        # ```
        sig { returns(Mergeable) }
        def intersect; end

        # Instruct the next mergeable call to use override.
        # 
        # _@return_ — The override flagged mergeable.
        # 
        # Use override on the next call.
        # ```ruby
        # mergeable.override.in(field: [ 1, 2, 3 ])
        # ```
        sig { returns(Mergeable) }
        def override; end

        # Instruct the next mergeable call to use union.
        # 
        # _@return_ — The union flagged mergeable.
        # 
        # Use union on the next call.
        # ```ruby
        # mergeable.union.in(field: [ 1, 2, 3 ])
        # ```
        sig { returns(Mergeable) }
        def union; end

        # Clear the current strategy and negating flag, used after cloning.
        # 
        # _@return_ — self.
        # 
        # Reset the strategies.
        # ```ruby
        # mergeable.reset_strategies!
        # ```
        sig { returns(Criteria) }
        def reset_strategies!; end

        # Adds the criterion to the existing selection.
        # 
        # _@param_ `criterion` — The criteria.
        # 
        # _@param_ `operator` — The MongoDB operator.
        # 
        # _@return_ — The new mergeable.
        # 
        # Add the criterion.
        # ```ruby
        # mergeable.__add__({ name: 1 }, "$in")
        # ```
        sig { params(criterion: T::Hash[T.untyped, T.untyped], operator: String).returns(Mergeable) }
        def __add__(criterion, operator); end

        # Adds the criterion to the existing selection.
        # 
        # _@param_ `criterion` — The criteria.
        # 
        # _@param_ `outer` — The outer MongoDB operator.
        # 
        # _@param_ `inner` — The inner MongoDB operator.
        # 
        # _@return_ — The new mergeable.
        # 
        # Add the criterion.
        # ```ruby
        # mergeable.__expanded__([ 1, 10 ], "$within", "$center")
        # ```
        sig { params(criterion: T::Hash[T.untyped, T.untyped], outer: String, inner: String).returns(Mergeable) }
        def __expanded__(criterion, outer, inner); end

        # Perform a straight merge of the criterion into the selection and let the
        # symbol overrides do all the work.
        # 
        # _@param_ `criterion` — The criteria.
        # 
        # _@return_ — The cloned object.
        # 
        # Straight merge the expanded criterion.
        # ```ruby
        # mergeable.__merge__(location: [ 1, 10 ])
        # ```
        sig { params(criterion: T::Hash[T.untyped, T.untyped]).returns(Mergeable) }
        def __merge__(criterion); end

        # Adds the criterion to the existing selection.
        # 
        # _@param_ `criterion` — The criteria.
        # 
        # _@param_ `operator` — The MongoDB operator.
        # 
        # _@return_ — The new mergeable.
        # 
        # Add the criterion.
        # ```ruby
        # mergeable.__intersect__([ 1, 2 ], "$in")
        # ```
        sig { params(criterion: T::Hash[T.untyped, T.untyped], operator: String).returns(Mergeable) }
        def __intersect__(criterion, operator); end

        # Adds $and/$or/$nor criteria to a copy of this selection.
        # 
        # Each of the criteria can be a Hash of key/value pairs or MongoDB
        # operators (keys beginning with $), or a Selectable object
        # (which typically will be a Criteria instance).
        # 
        # _@param_ `criteria` — Multiple key/value pair matches or Criteria objects.
        # 
        # _@param_ `operator` — The MongoDB operator.
        # 
        # _@return_ — The new mergeable.
        # 
        # Add the criterion.
        # ```ruby
        # mergeable.__multi__([ 1, 2 ], "$in")
        # ```
        sig { params(criteria: T::Array[T.any(T::Hash[T.untyped, T.untyped], Criteria)], operator: String).returns(Mergeable) }
        def __multi__(criteria, operator); end

                                # Combines criteria into a MongoDB selector.
        # 
        # Criteria is an array of criterions which will be flattened.
        # 
        # Each criterion can be:
        # - A hash
        # - A Criteria instance
        # - nil, in which case it is ignored
        sig { params(operator: T.untyped, criteria: T.untyped).returns(T.untyped) }
        def _mongoid_add_top_level_operation(operator, criteria); end

                        # Calling .flatten on an array which includes a Criteria instance
        # evaluates the criteria, which we do not want. Hence this method
        # explicitly only expands Array objects and Array subclasses.
        sig { params(array: T.untyped).returns(T.untyped) }
        def _mongoid_flatten_arrays(array); end

        # Takes a criteria hash and expands Key objects into hashes containing
        # MQL corresponding to said key objects. Also converts the input to
        # BSON::Document to permit indifferent access.
        # 
        # The argument must be a hash containing key-value pairs of the
        # following forms:
        # - {field_name: value}
        # - {'field_name' => value}
        # - {key_instance: value}
        # - {:$operator => operator_value_expression}
        # - {'$operator' => operator_value_expression}
        # 
        # Ruby does not permit multiple symbol operators. For example,
        # {:foo.gt => 1, :foo.gt => 2} is collapsed to {:foo.gt => 2} by the
        # language. Therefore this method never has to deal with multiple
        # identical operators.
        # 
        # Similarly, this method should never need to expand a literal value
        # and an operator at the same time.
        # 
        # This method effectively converts symbol keys to string keys in
        # the input +expr+, such that the downstream code can assume that
        # conditions always contain string keys.
        # 
        # _@param_ `expr` — Criteria including Key instances.
        # 
        # _@return_ — The expanded criteria.
        sig { params(expr: T::Hash[T.untyped, T.untyped]).returns(BSON::Document) }
        def _mongoid_expand_keys(expr); end

        # Adds the criterion to the existing selection.
        # 
        # _@param_ `criterion` — The criteria.
        # 
        # _@param_ `operator` — The MongoDB operator.
        # 
        # _@return_ — The new mergeable.
        # 
        # Add the criterion.
        # ```ruby
        # mergeable.__override__([ 1, 2 ], "$in")
        # ```
        sig { params(criterion: T.any(T::Hash[T.untyped, T.untyped], Criteria), operator: String).returns(Mergeable) }
        def __override__(criterion, operator); end

        # Adds the criterion to the existing selection.
        # 
        # _@param_ `criterion` — The criteria.
        # 
        # _@param_ `operator` — The MongoDB operator.
        # 
        # _@return_ — The new mergeable.
        # 
        # Add the criterion.
        # ```ruby
        # mergeable.__union__([ 1, 2 ], "$in")
        # ```
        sig { params(criterion: T::Hash[T.untyped, T.untyped], operator: String).returns(Mergeable) }
        def __union__(criterion, operator); end

        # Use the named strategy for the next operation.
        # 
        # _@param_ `strategy` — The strategy to use.
        # 
        # _@return_ — The existing mergeable.
        # 
        # Use intersection.
        # ```ruby
        # mergeable.use(:__intersect__)
        # ```
        sig { params(strategy: Symbol).returns(Mergeable) }
        def use(strategy); end

        # Add criterion to the selection with the named strategy.
        # 
        # _@param_ `strategy` — The name of the strategy method.
        # 
        # _@param_ `criterion` — The criterion to add.
        # 
        # _@param_ `operator` — The MongoDB operator.
        # 
        # _@return_ — The cloned query.
        # 
        # Add criterion with a strategy.
        # ```ruby
        # mergeable.with_strategy(:__union__, {field_name: [ 1, 2, 3 ]}, "$in")
        # ```
        sig { params(strategy: Symbol, criterion: Object, operator: String).returns(Mergeable) }
        def with_strategy(strategy, criterion, operator); end

                # Prepare the value for merging.
        # 
        # _@param_ `field` — The name of the field.
        # 
        # _@param_ `value` — The value.
        # 
        # _@return_ — The serialized value.
        # 
        # Prepare the value.
        # ```ruby
        # mergeable.prepare("field", "$gt", 10)
        # ```
        sig { params(field: String, operator: T.untyped, value: Object).returns(Object) }
        def prepare(field, operator, value); end

        # Returns the value of attribute strategy.
        sig { returns(T.untyped) }
        attr_accessor :strategy

                sig { returns(T.untyped) }
        attr_accessor :strategy
      end

      # Provides a DSL around crafting aggregation framework commands.
      # 
      # @since 2.0.0
      module Aggregable
        extend Mongoid::Criteria::Queryable::Macroable

        # Has the aggregable enter an aggregation state. Ie, are only aggregation
        # operations allowed at this point on.
        # 
        # _@return_ — If the aggregable is aggregating.
        # 
        # Is the aggregable aggregating?
        # ```ruby
        # aggregable.aggregating?
        # ```
        sig { returns(T::Boolean) }
        def aggregating?; end

        # Add a group ($group) operation to the aggregation pipeline.
        # 
        # _@param_ `operation` — The group operation.
        # 
        # _@return_ — The aggregable.
        # 
        # Add a group operation being verbose.
        # ```ruby
        # aggregable.group(count: { "$sum" => 1 }, max: { "$max" => "likes" })
        # ```
        # 
        # Add a group operation using symbol shortcuts.
        # ```ruby
        # aggregable.group(:count.sum => 1, :max.max => "likes")
        # ```
        sig { params(operation: T::Hash[T.untyped, T.untyped]).returns(Aggregable) }
        def group(operation); end

        # Add a projection ($project) to the aggregation pipeline.
        # 
        # _@param_ `operation` — The projection to make.
        # 
        # _@return_ — The aggregable.
        # 
        # Add a projection to the pipeline.
        # ```ruby
        # aggregable.project(author: 1, name: 0)
        # ```
        sig { params(operation: T.nilable(T::Hash[T.untyped, T.untyped])).returns(Aggregable) }
        def project(operation = nil); end

        # Add an unwind ($unwind) to the aggregation pipeline.
        # 
        # _@param_ `field` — The name of the field to unwind.
        # 
        # _@return_ — The aggregable.
        # 
        # Add an unwind to the pipeline.
        # ```ruby
        # aggregable.unwind(:field)
        # ```
        sig { params(field: T.any(String, Symbol)).returns(Aggregable) }
        def unwind(field); end

        # Add the aggregation operation.
        # 
        # _@param_ `operation` — The operation for the pipeline.
        # 
        # _@return_ — The cloned aggregable.
        # 
        # Aggregate on the operation.
        # ```ruby
        # aggregation(operation) do |pipeline|
        #   pipeline.push("$project" => operation)
        # end
        # ```
        sig { params(operation: T::Hash[T.untyped, T.untyped]).returns(Aggregable) }
        def aggregation(operation); end

                # Adds a method on Symbol for convenience in where queries for the
        # provided operators.
        # 
        # _@param_ `name` — The name of the method.
        # 
        # _@param_ `strategy` — The merge strategy.
        # 
        # _@param_ `operator` — The MongoDB operator.
        # 
        # _@param_ `additional` — The additional MongoDB operator.
        # 
        # Add a symbol key.
        # ```ruby
        # key :all, "$all
        # ```
        sig do
          params(
            name: Symbol,
            strategy: Symbol,
            operator: String,
            additional: T.nilable(String),
            block: T.untyped
          ).returns(T.untyped)
        end
        def self.key(name, strategy, operator, additional = nil, &block); end

                sig { returns(T.untyped) }
        attr_reader :pipeline

                sig { returns(T.untyped) }
        attr_reader :pipeline

                sig { params(aggregating: T.untyped).returns(T.untyped) }
        attr_writer :aggregating

                sig { returns(T.untyped) }
        attr_accessor :aggregating
      end

      # This module encapsulates methods that expand various high level
      # query forms to the MongoDB hash condition selector syntax.
      # 
      # @example Example high level form.
      #   Band.where(:foo.gt => 5)
      # 
      # @api private
      module Expandable
        # Expands the specified condition to MongoDB syntax.
        # 
        # This method is meant to be called when processing the items of
        # a condition hash and the key and the value of each item are
        # already available separately.
        # 
        # The following parameter forms are accepted:
        # 
        # - field is a string or symbol; value is the field query expresision
        # - field is a Key instance; value is the field query expression
        # - field is a string corresponding to a MongoDB operator; value is
        #   the operator value expression.
        # 
        # This method expands the field-value combination to the MongoDB
        # selector syntax and returns an array of
        # [expanded key, expanded value]. The expanded key is converted to
        # a string if it wasn't already a string.
        # 
        # _@param_ `field` — The field to expand.
        # 
        # _@param_ `value` — The field's value.
        # 
        # _@return_ — The expanded field and value.
        sig { params(field: T.any(String, Symbol, Key), value: Object).returns(T::Array[T.any(String, Object)]) }
        def expand_one_condition(field, value); end

        # Expand criterion values to arrays, to be used with operators that
        # take an array as argument such as $in.
        # 
        # _@param_ `criterion` — The criterion.
        # 
        # _@return_ — The $in friendly criterion with array values.
        # 
        # Convert all the values to arrays.
        # ```ruby
        # selectable.with_array_values({ key: 1...4 })
        # ```
        sig { params(criterion: T::Hash[T.untyped, T.untyped]).returns(T::Hash[T.untyped, T.untyped]) }
        def expand_condition_to_array_values(criterion); end
      end

      # An queryable selectable is selectable, in that it has the ability to select
      # document from the database. The selectable module brings all functionality
      # to the selectable that has to do with building MongoDB selectors.
      module Selectable
        extend Mongoid::Criteria::Queryable::Macroable
        LINE_STRING = T.let("LineString", T.untyped)
        POINT = T.let("Point", T.untyped)
        POLYGON = T.let("Polygon", T.untyped)

        # sord infer - argument name in single @param inferred as "*criteria"
        # Add the $all criterion.
        # 
        # _@param_ `criterion` — The key value pairs for $all matching.
        # 
        # _@return_ — The cloned selectable.
        # 
        # Add the criterion.
        # ```ruby
        # selectable.all(field: [ 1, 2 ])
        # ```
        # 
        # Execute an $all in a where query.
        # ```ruby
        # selectable.where(:field.all => [ 1, 2 ])
        # ```
        sig { params(criteria: T::Hash[T.untyped, T.untyped]).returns(Selectable) }
        def all(*criteria); end

        # Add the $and criterion.
        # 
        # _@param_ `criteria` — Multiple key/value pair matches or Criteria objects that all must match to return results.
        # 
        # _@return_ — The new selectable.
        # 
        # Add the criterion.
        # ```ruby
        # selectable.and({ field: value }, { other: value })
        # ```
        sig { params(criteria: T::Array[T.any(T::Hash[T.untyped, T.untyped], Criteria)]).returns(Selectable) }
        def and(*criteria); end

        # Add the range selection.
        # 
        # _@param_ `criterion` — Multiple key/range pairs.
        # 
        # _@return_ — The cloned selectable.
        # 
        # Match on results within a single range.
        # ```ruby
        # selectable.between(field: 1..2)
        # ```
        # 
        # Match on results between multiple ranges.
        # ```ruby
        # selectable.between(field: 1..2, other: 5..7)
        # ```
        sig { params(criterion: T::Hash[T.untyped, T.untyped]).returns(Selectable) }
        def between(criterion); end

        # Select with an $elemMatch.
        # 
        # _@param_ `criterion` — The field/match pairs.
        # 
        # _@return_ — The cloned selectable.
        # 
        # Add criterion for a single match.
        # ```ruby
        # selectable.elem_match(field: { name: "value" })
        # ```
        # 
        # Add criterion for multiple matches.
        # ```ruby
        # selectable.elem_match(
        #   field: { name: "value" },
        #   other: { name: "value"}
        # )
        # ```
        # 
        # Execute an $elemMatch in a where query.
        # ```ruby
        # selectable.where(:field.elem_match => { name: "value" })
        # ```
        sig { params(criterion: T::Hash[T.untyped, T.untyped]).returns(Selectable) }
        def elem_match(criterion); end

        # Add the $exists selection.
        # 
        # _@param_ `criterion` — The field/boolean existence checks.
        # 
        # _@return_ — The cloned selectable.
        # 
        # Add a single selection.
        # ```ruby
        # selectable.exists(field: true)
        # ```
        # 
        # Add multiple selections.
        # ```ruby
        # selectable.exists(field: true, other: false)
        # ```
        # 
        # Execute an $exists in a where query.
        # ```ruby
        # selectable.where(:field.exists => true)
        # ```
        sig { params(criterion: T::Hash[T.untyped, T.untyped]).returns(Selectable) }
        def exists(criterion); end

        # Add a $geoIntersects or $geoWithin selection. Symbol operators must
        # be used as shown in the examples to expand the criteria.
        # 
        # _@param_ `criterion` — The criterion.
        # 
        # _@return_ — The cloned selectable.
        # 
        # Add a geo intersect criterion for a line.
        # ```ruby
        # query.geo_spatial(:location.intersects_line => [[ 1, 10 ], [ 2, 10 ]])
        # ```
        # 
        # Add a geo intersect criterion for a point.
        # ```ruby
        # query.geo_spatial(:location.intersects_point => [[ 1, 10 ]])
        # ```
        # 
        # Add a geo intersect criterion for a polygon.
        # ```ruby
        # query.geo_spatial(:location.intersects_polygon => [[ 1, 10 ], [ 2, 10 ], [ 1, 10 ]])
        # ```
        # 
        # Add a geo within criterion for a polygon.
        # ```ruby
        # query.geo_spatial(:location.within_polygon => [[ 1, 10 ], [ 2, 10 ], [ 1, 10 ]])
        # ```
        # 
        # Add a geo within criterion for a box.
        # ```ruby
        # query.geo_spatial(:location.within_box => [[ 1, 10 ], [ 2, 10 ])
        # ```
        # 
        # _@note_ — The only valid geometry shapes for a $geoIntersects are:
        # :intersects_line, :intersects_point, and :intersects_polygon.
        # 
        # _@note_ — The only valid options for a $geoWithin query are the geometry
        # shape :within_polygon and the operator :within_box.
        # 
        # _@note_ — The :within_box operator for the $geoWithin query expects the
        # lower left (south west) coordinate pair as the first argument and
        # the upper right (north east) as the second argument.
        # Important: When latitude and longitude are passed, longitude is
        # expected as the first element of the coordinate pair.
        # Source: https://docs.mongodb.com/manual/reference/operator/query/box/
        sig { params(criterion: T::Hash[T.untyped, T.untyped]).returns(Selectable) }
        def geo_spatial(criterion); end

                        # Alias for +geo_spatial+.
        # 
        # _@deprecated_ — 
        sig { params(criterion: T.untyped).returns(T.untyped) }
        def geo_spacial(criterion); end

        # Add the $gt criterion to the selector.
        # 
        # _@param_ `criterion` — The field/value pairs to check.
        # 
        # _@return_ — The cloned selectable.
        # 
        # Add the $gt criterion.
        # ```ruby
        # selectable.gt(age: 60)
        # ```
        # 
        # Execute an $gt in a where query.
        # ```ruby
        # selectable.where(:field.gt => 10)
        # ```
        sig { params(criterion: T::Hash[T.untyped, T.untyped]).returns(Selectable) }
        def gt(criterion); end

        # Add the $gte criterion to the selector.
        # 
        # _@param_ `criterion` — The field/value pairs to check.
        # 
        # _@return_ — The cloned selectable.
        # 
        # Add the $gte criterion.
        # ```ruby
        # selectable.gte(age: 60)
        # ```
        # 
        # Execute an $gte in a where query.
        # ```ruby
        # selectable.where(:field.gte => 10)
        # ```
        sig { params(criterion: T::Hash[T.untyped, T.untyped]).returns(Selectable) }
        def gte(criterion); end

        # Adds the $in selection to the selectable.
        # 
        # _@param_ `condition` — The field/value criterion pairs.
        # 
        # _@return_ — The cloned selectable.
        # 
        # Add $in selection on an array.
        # ```ruby
        # selectable.in(age: [ 1, 2, 3 ])
        # ```
        # 
        # Add $in selection on a range.
        # ```ruby
        # selectable.in(age: 18..24)
        # ```
        # 
        # Execute an $in in a where query.
        # ```ruby
        # selectable.where(:field.in => [ 1, 2, 3 ])
        # ```
        sig { params(condition: T::Hash[T.untyped, T.untyped]).returns(Selectable) }
        def in(condition); end

        # Add the $lt criterion to the selector.
        # 
        # _@param_ `criterion` — The field/value pairs to check.
        # 
        # _@return_ — The cloned selectable.
        # 
        # Add the $lt criterion.
        # ```ruby
        # selectable.lt(age: 60)
        # ```
        # 
        # Execute an $lt in a where query.
        # ```ruby
        # selectable.where(:field.lt => 10)
        # ```
        sig { params(criterion: T::Hash[T.untyped, T.untyped]).returns(Selectable) }
        def lt(criterion); end

        # Add the $lte criterion to the selector.
        # 
        # _@param_ `criterion` — The field/value pairs to check.
        # 
        # _@return_ — The cloned selectable.
        # 
        # Add the $lte criterion.
        # ```ruby
        # selectable.lte(age: 60)
        # ```
        # 
        # Execute an $lte in a where query.
        # ```ruby
        # selectable.where(:field.lte => 10)
        # ```
        sig { params(criterion: T::Hash[T.untyped, T.untyped]).returns(Selectable) }
        def lte(criterion); end

        # Add a $maxDistance selection to the selectable.
        # 
        # _@param_ `criterion` — The field/distance pairs.
        # 
        # _@return_ — The cloned selectable.
        # 
        # Add the $maxDistance selection.
        # ```ruby
        # selectable.max_distance(location: 10)
        # ```
        sig { params(criterion: T::Hash[T.untyped, T.untyped]).returns(Selectable) }
        def max_distance(criterion); end

        # Adds $mod selection to the selectable.
        # 
        # _@param_ `criterion` — The field/mod selections.
        # 
        # _@return_ — The cloned selectable.
        # 
        # Add the $mod selection.
        # ```ruby
        # selectable.mod(field: [ 10, 1 ])
        # ```
        # 
        # Execute an $mod in a where query.
        # ```ruby
        # selectable.where(:field.mod => [ 10, 1 ])
        # ```
        sig { params(criterion: T::Hash[T.untyped, T.untyped]).returns(Selectable) }
        def mod(criterion); end

        # Adds $ne selection to the selectable.
        # 
        # _@param_ `criterion` — The field/ne selections.
        # 
        # _@return_ — The cloned selectable.
        # 
        # Query for a value $ne to something.
        # ```ruby
        # selectable.ne(field: 10)
        # ```
        # 
        # Execute an $ne in a where query.
        # ```ruby
        # selectable.where(:field.ne => "value")
        # ```
        sig { params(criterion: T::Hash[T.untyped, T.untyped]).returns(Selectable) }
        def ne(criterion); end

        # Adds a $near criterion to a geo selection.
        # 
        # _@param_ `criterion` — The field/location pair.
        # 
        # _@return_ — The cloned selectable.
        # 
        # Add the $near selection.
        # ```ruby
        # selectable.near(location: [ 23.1, 12.1 ])
        # ```
        # 
        # Execute an $near in a where query.
        # ```ruby
        # selectable.where(:field.near => [ 23.2, 12.1 ])
        # ```
        sig { params(criterion: T::Hash[T.untyped, T.untyped]).returns(Selectable) }
        def near(criterion); end

        # Adds a $nearSphere criterion to a geo selection.
        # 
        # _@param_ `criterion` — The field/location pair.
        # 
        # _@return_ — The cloned selectable.
        # 
        # Add the $nearSphere selection.
        # ```ruby
        # selectable.near_sphere(location: [ 23.1, 12.1 ])
        # ```
        # 
        # Execute an $nearSphere in a where query.
        # ```ruby
        # selectable.where(:field.near_sphere => [ 10.11, 3.22 ])
        # ```
        sig { params(criterion: T::Hash[T.untyped, T.untyped]).returns(Selectable) }
        def near_sphere(criterion); end

        # Adds the $nin selection to the selectable.
        # 
        # _@param_ `condition` — The field/value criterion pairs.
        # 
        # _@return_ — The cloned selectable.
        # 
        # Add $nin selection on an array.
        # ```ruby
        # selectable.nin(age: [ 1, 2, 3 ])
        # ```
        # 
        # Add $nin selection on a range.
        # ```ruby
        # selectable.nin(age: 18..24)
        # ```
        # 
        # Execute an $nin in a where query.
        # ```ruby
        # selectable.where(:field.nin => [ 1, 2, 3 ])
        # ```
        sig { params(condition: T::Hash[T.untyped, T.untyped]).returns(Selectable) }
        def nin(condition); end

        # Adds $nor selection to the selectable.
        # 
        # _@param_ `criteria` — Multiple key/value pair matches or Criteria objects.
        # 
        # _@return_ — The new selectable.
        # 
        # Add the $nor selection.
        # ```ruby
        # selectable.nor(field: 1, field: 2)
        # ```
        sig { params(criteria: T::Array[T.any(T::Hash[T.untyped, T.untyped], Criteria)]).returns(Selectable) }
        def nor(*criteria); end

        # Is the current selectable negating the next selection?
        # 
        # _@return_ — If the selectable is negating.
        # 
        # Is the selectable negating?
        # ```ruby
        # selectable.negating?
        # ```
        sig { returns(T::Boolean) }
        def negating?; end

        # Negate the arguments, or the next selection if no arguments are given.
        # 
        # _@param_ `criteria` — Multiple key/value pair matches or Criteria objects to negate.
        # 
        # _@return_ — The new selectable.
        # 
        # Negate the next selection.
        # ```ruby
        # selectable.not.in(field: [ 1, 2 ])
        # ```
        # 
        # Add the $not criterion.
        # ```ruby
        # selectable.not(name: /Bob/)
        # ```
        # 
        # Execute a $not in a where query.
        # ```ruby
        # selectable.where(:field.not => /Bob/)
        # ```
        sig { params(criteria: T::Array[T.any(T::Hash[T.untyped, T.untyped], Criteria)]).returns(Selectable) }
        def not(*criteria); end

        # Creates a disjunction using $or from the existing criteria in the
        # receiver and the provided arguments.
        # 
        # This behavior (receiver becoming one of the disjunction operands)
        # matches ActiveRecord's +or+ behavior.
        # 
        # Use +any_of+ to add a disjunction of the arguments as an additional
        # constraint to the criteria already existing in the receiver.
        # 
        # Each argument can be a Hash, a Criteria object, an array of
        # Hash or Criteria objects, or a nested array. Nested arrays will be
        # flattened and can be of any depth. Passing arrays is deprecated.
        # 
        # _@param_ `criteria` — Multiple key/value pair matches or Criteria objects, or arrays thereof. Passing arrays is deprecated.
        # 
        # _@return_ — The new selectable.
        # 
        # Add the $or selection where both fields must have the specified values.
        # ```ruby
        # selectable.or(field: 1, field: 2)
        # ```
        # 
        # Add the $or selection where either value match is sufficient.
        # ```ruby
        # selectable.or({field: 1}, {field: 2})
        # ```
        # 
        # Same as previous example but using the deprecated array wrap.
        # ```ruby
        # selectable.or([{field: 1}, {field: 2}])
        # ```
        # 
        # Same as previous example, also deprecated.
        # ```ruby
        # selectable.or([{field: 1}], [{field: 2}])
        # ```
        sig { params(criteria: T.any(T::Hash[T.untyped, T.untyped], Criteria, T::Array[T.any(T::Hash[T.untyped, T.untyped], Criteria)])).returns(Selectable) }
        def or(*criteria); end

        # Adds a disjunction of the arguments as an additional constraint
        # to the criteria already existing in the receiver.
        # 
        # Use +or+ to make the receiver one of the disjunction operands.
        # 
        # Each argument can be a Hash, a Criteria object, an array of
        # Hash or Criteria objects, or a nested array. Nested arrays will be
        # flattened and can be of any depth. Passing arrays is deprecated.
        # 
        # _@param_ `criteria` — Multiple key/value pair matches or Criteria objects, or arrays thereof. Passing arrays is deprecated.
        # 
        # _@return_ — The new selectable.
        # 
        # Add the $or selection where both fields must have the specified values.
        # ```ruby
        # selectable.any_of(field: 1, field: 2)
        # ```
        # 
        # Add the $or selection where either value match is sufficient.
        # ```ruby
        # selectable.any_of({field: 1}, {field: 2})
        # ```
        # 
        # Same as previous example but using the deprecated array wrap.
        # ```ruby
        # selectable.any_of([{field: 1}, {field: 2}])
        # ```
        # 
        # Same as previous example, also deprecated.
        # ```ruby
        # selectable.any_of([{field: 1}], [{field: 2}])
        # ```
        sig { params(criteria: T.any(T::Hash[T.untyped, T.untyped], Criteria, T::Array[T.any(T::Hash[T.untyped, T.untyped], Criteria)])).returns(Selectable) }
        def any_of(*criteria); end

        # Add a $size selection for array fields.
        # 
        # _@param_ `criterion` — The field/size pairs criterion.
        # 
        # _@return_ — The cloned selectable.
        # 
        # Add the $size selection.
        # ```ruby
        # selectable.with_size(field: 5)
        # ```
        # 
        # Execute an $size in a where query.
        # ```ruby
        # selectable.where(:field.with_size => 10)
        # ```
        # 
        # _@note_ — This method is named #with_size not to conflict with any existing
        # #size method on enumerables or symbols.
        sig { params(criterion: T::Hash[T.untyped, T.untyped]).returns(Selectable) }
        def with_size(criterion); end

        # Adds a $type selection to the selectable.
        # 
        # _@param_ `criterion` — The field/type pairs.
        # 
        # _@return_ — The cloned selectable.
        # 
        # Add the $type selection.
        # ```ruby
        # selectable.with_type(field: 15)
        # ```
        # 
        # Execute an $type in a where query.
        # ```ruby
        # selectable.where(:field.with_type => 15)
        # ```
        # 
        # _@note_ — http://vurl.me/PGOU contains a list of all types.
        sig { params(criterion: T::Hash[T.untyped, T.untyped]).returns(Selectable) }
        def with_type(criterion); end

        # Construct a text search selector.
        # 
        # _@param_ `terms` — A string of terms that MongoDB parses and uses to query the text index.
        # 
        # _@param_ `opts` — Text search options. See MongoDB documentation for options.
        # 
        # _@return_ — The cloned selectable.
        # 
        # Construct a text search selector.
        # ```ruby
        # selectable.text_search("testing")
        # ```
        # 
        # Construct a text search selector with options.
        # ```ruby
        # selectable.text_search("testing", :$language => "fr")
        # ```
        # 
        # _@note_ — Per https://docs.mongodb.com/manual/reference/operator/query/text/
        # it is not currently possible to supply multiple text search
        # conditions in a query. Mongoid will build such a query but the
        # server will return an error when trying to execute it.
        sig { params(terms: T.any(String, Symbol), opts: T.nilable(T::Hash[T.untyped, T.untyped])).returns(Selectable) }
        def text_search(terms, opts = nil); end

        # sord infer - argument name in single @param inferred as "*criteria"
        # This is the general entry point for most MongoDB queries. This either
        # creates a standard field: value selection, and expanded selection with
        # the use of hash methods, or a $where selection if a string is provided.
        # 
        # _@param_ `criterion` — The javascript or standard selection.
        # 
        # _@return_ — The cloned selectable.
        # 
        # Add a standard selection.
        # ```ruby
        # selectable.where(name: "syd")
        # ```
        # 
        # Add a javascript selection.
        # ```ruby
        # selectable.where("this.name == 'syd'")
        # ```
        sig { params(criteria: T.any(String, T::Hash[T.untyped, T.untyped])).returns(Selectable) }
        def where(*criteria); end

        # Adds the specified expression to the query.
        # 
        # Criterion must be a hash in one of the following forms:
        # - {field_name: value}
        # - {'field_name' => value}
        # - {key_instance: value}
        # - {'$operator' => operator_value_expression}
        # 
        # Field name and operator may be given as either strings or symbols.
        # 
        # _@param_ `criterion` — The field/value pairs.
        # 
        # _@return_ — The cloned selectable.
        # 
        # Create the selection.
        # ```ruby
        # selectable.expr_query(age: 50)
        # ```
        sig { params(criterion: T::Hash[T.untyped, T.untyped]).returns(Selectable) }
        def expr_query(criterion); end

                        # Force the values of the criterion to be evolved.
        # 
        # _@param_ `criterion` — The criterion.
        # 
        # Force values to booleans.
        # ```ruby
        # selectable.force_typing(criterion) do |val|
        #   Boolean.evolve(val)
        # end
        # ```
        sig { params(criterion: T::Hash[T.untyped, T.untyped], operator: T.untyped).returns(T.untyped) }
        def typed_override(criterion, operator); end

        # Create a javascript selection.
        # 
        # _@param_ `criterion` — The javascript as a string.
        # 
        # _@return_ — The cloned selectable
        # 
        # Create the javascript selection.
        # ```ruby
        # selectable.js_query("this.age == 50")
        # ```
        sig { params(criterion: String).returns(Selectable) }
        def js_query(criterion); end

        # Take the provided criterion and store it as a selection in the query
        # selector.
        # 
        # _@param_ `criterion` — The selection to store.
        # 
        # _@return_ — The cloned selectable.
        # 
        # Store the selection.
        # ```ruby
        # selectable.selection({ field: "value" })
        # ```
        sig { params(criterion: T.nilable(T::Hash[T.untyped, T.untyped])).returns(Selectable) }
        def selection(criterion = nil); end

        # Get the methods on the selectable that can be forwarded to from a model.
        # 
        # _@return_ — The names of the forwardable methods.
        # 
        # Get the forwardable methods.
        # ```ruby
        # Selectable.forwardables
        # ```
        sig { returns(T::Array[Symbol]) }
        def self.forwardables; end

                # Adds a method on Symbol for convenience in where queries for the
        # provided operators.
        # 
        # _@param_ `name` — The name of the method.
        # 
        # _@param_ `strategy` — The merge strategy.
        # 
        # _@param_ `operator` — The MongoDB operator.
        # 
        # _@param_ `additional` — The additional MongoDB operator.
        # 
        # Add a symbol key.
        # ```ruby
        # key :all, "$all
        # ```
        sig do
          params(
            name: Symbol,
            strategy: Symbol,
            operator: String,
            additional: T.nilable(String),
            block: T.untyped
          ).returns(T.untyped)
        end
        def self.key(name, strategy, operator, additional = nil, &block); end

        # Returns the value of attribute negating.
        sig { returns(T.untyped) }
        attr_accessor :negating

                sig { returns(T.untyped) }
        attr_accessor :negating

                sig { returns(T.untyped) }
        attr_accessor :selector

        # Returns the value of attribute selector.
        sig { returns(T.untyped) }
        attr_accessor :selector
      end

      module Extensions
        # This module contains additional object behavior.
        module Set
          module ClassMethods
            # Evolve the set, casting all its elements.
            # 
            # _@param_ `object` — The object to evolve.
            # 
            # _@return_ — The evolved set.
            # 
            # Evolve the set.
            # ```ruby
            # Set.evolve(set)
            # ```
            sig { params(object: T.any(T::Set[T.untyped], Object)).returns(T::Array[T.untyped]) }
            def evolve(object); end
          end
        end

        # This module contains additional date behavior.
        module Date
          # Evolve the date into a mongo friendly time, UTC midnight.
          # 
          # _@return_ — The date as a UTC time at midnight.
          # 
          # Evolve the date.
          # ```ruby
          # date.__evolve_date__
          # ```
          sig { returns(Time) }
          def __evolve_date__; end

          # Evolve the date into a time, which is always in the local timezone.
          # 
          # _@return_ — The date as a local time.
          # 
          # Evolve the date.
          # ```ruby
          # date.__evolve_time__
          # ```
          sig { returns(Time) }
          def __evolve_time__; end

          module ClassMethods
            # Evolve the object to an date.
            # 
            # _@param_ `object` — The object to evolve.
            # 
            # _@return_ — The evolved date.
            # 
            # Evolve dates.
            # ```ruby
            # Date.evolve(Date.new(1990, 1, 1))
            # ```
            # 
            # Evolve string dates.
            # ```ruby
            # Date.evolve("1990-1-1")
            # ```
            # 
            # Evolve date ranges.
            # ```ruby
            # Date.evolve(Date.new(1990, 1, 1)..Date.new(1990, 1, 4))
            # ```
            sig { params(object: Object).returns(Time) }
            def evolve(object); end
          end
        end

        # This module contains additional hash behavior.
        module Hash
          # Add an object to a hash using the merge strategies.
          # 
          # _@param_ `object` — The other hash to add.
          # 
          # _@return_ — The hash with object added.
          # 
          # Add an object to a hash.
          # ```ruby
          # { field: value }.__add__({ field: other_value })
          # ```
          sig { params(object: T::Hash[T.untyped, T.untyped]).returns(T::Hash[T.untyped, T.untyped]) }
          def __add__(object); end

          # Merge this hash into the provided array.
          # 
          # _@param_ `array` — The array to add to.
          # 
          # _@return_ — The merged hash.
          # 
          # Merge the hash into the array.
          # ```ruby
          # { field: value }.__add_from_array__([ 1, 2 ])
          # ```
          sig { params(array: T::Array[T.untyped]).returns(T::Hash[T.untyped, T.untyped]) }
          def __add_from_array__(array); end

          # Add an object to a hash using the merge strategies.
          # 
          # _@param_ `object` — The other hash to intersect.
          # 
          # _@return_ — The hash with object intersected.
          # 
          # Add an object to a hash.
          # ```ruby
          # { field: value }.__intersect__({ field: other_value })
          # ```
          sig { params(object: T::Hash[T.untyped, T.untyped]).returns(T::Hash[T.untyped, T.untyped]) }
          def __intersect__(object); end

          # Merge this hash into the provided array.
          # 
          # _@param_ `array` — The array to intersect to.
          # 
          # _@return_ — The merged hash.
          # 
          # Merge the hash into the array.
          # ```ruby
          # { field: value }.__intersect_from_array__([ 1, 2 ])
          # ```
          sig { params(array: T::Array[T.untyped]).returns(T::Hash[T.untyped, T.untyped]) }
          def __intersect_from_array__(array); end

          # Merge this hash into the provided object.
          # 
          # _@param_ `object` — The object to intersect to.
          # 
          # _@return_ — The merged hash.
          # 
          # Merge the hash into the object.
          # ```ruby
          # { field: value }.__intersect_from_object__([ 1, 2 ])
          # ```
          sig { params(object: Object).returns(T::Hash[T.untyped, T.untyped]) }
          def __intersect_from_object__(object); end

          # Add an object to a hash using the merge strategies.
          # 
          # _@param_ `object` — The other hash to union.
          # 
          # _@return_ — The hash with object unioned.
          # 
          # Add an object to a hash.
          # ```ruby
          # { field: value }.__union__({ field: other_value })
          # ```
          sig { params(object: T::Hash[T.untyped, T.untyped]).returns(T::Hash[T.untyped, T.untyped]) }
          def __union__(object); end

          # Merge this hash into the provided object.
          # 
          # _@param_ `object` — The object to union to.
          # 
          # _@return_ — The merged hash.
          # 
          # Merge the hash into the object.
          # ```ruby
          # { field: value }.__union_from_object__([ 1, 2 ])
          # ```
          sig { params(object: Object).returns(T::Hash[T.untyped, T.untyped]) }
          def __union_from_object__(object); end

          # Make a deep copy of this hash.
          # 
          # _@return_ — The copied hash.
          # 
          # Make a deep copy of the hash.
          # ```ruby
          # { field: value }.__deep_copy__
          # ```
          sig { returns(T::Hash[T.untyped, T.untyped]) }
          def __deep_copy__; end

          # Get the hash as a sort option.
          # 
          # _@return_ — The hash as sort option.
          # 
          # Get the hash as a sort option.
          # ```ruby
          # { field: 1 }.__sort_option__
          # ```
          sig { returns(T::Hash[T.untyped, T.untyped]) }
          def __sort_option__; end

          # Get the object as expanded.
          # 
          # _@return_ — The expanded hash.
          # 
          # Get the object expanded.
          # ```ruby
          # obj.__expand_complex__
          # ```
          sig { returns(T::Hash[T.untyped, T.untyped]) }
          def __expand_complex__; end

          # Update all the values in the hash with the provided block.
          # 
          # _@param_ `block` — The block to execute on each value.
          # 
          # _@return_ — the hash.
          # 
          # Update the values in place.
          # ```ruby
          # { field: "1" }.update_values(&:to_i)
          # ```
          sig { params(block: T.untyped).returns(T::Hash[T.untyped, T.untyped]) }
          def update_values(&block); end

          # Apply the provided strategy for the hash with the given object.
          # 
          # _@param_ `strategy` — The strategy to apply.
          # 
          # _@param_ `object` — The object to merge.
          # 
          # _@return_ — The merged hash.
          # 
          # Apply the strategy.
          # ```ruby
          # { field: value }.apply_strategy(:__add__, 1)
          # ```
          sig { params(strategy: Symbol, object: Object).returns(T::Hash[T.untyped, T.untyped]) }
          def apply_strategy(strategy, object); end
        end

        # This module contains additional time behavior.
        module Time
          # Evolve the time as a date, UTC midnight.
          # 
          # _@return_ — The date at midnight UTC.
          # 
          # Evolve the time to a date query format.
          # ```ruby
          # time.__evolve_date__
          # ```
          sig { returns(Time) }
          def __evolve_date__; end

          # Evolve the time into a utc time.
          # 
          # _@return_ — The time in UTC.
          # 
          # Evolve the time.
          # ```ruby
          # time.__evolve_time__
          # ```
          sig { returns(Time) }
          def __evolve_time__; end

          module ClassMethods
            # Evolve the object to an date.
            # 
            # _@param_ `object` — The object to evolve.
            # 
            # _@return_ — The evolved date time.
            # 
            # Evolve dates.
            # ```ruby
            # ```
            # 
            # Evolve string dates.
            # ```ruby
            # ```
            # 
            # Evolve date ranges.
            # ```ruby
            # ```
            sig { params(object: Object).returns(Time) }
            def evolve(object); end
          end
        end

        # The array module adds custom behavior for Origin onto the Array class.
        module Array
          # Combine the two objects using the add strategy.
          # 
          # _@param_ `object` — The object to add.
          # 
          # _@return_ — The result of the add.
          # 
          # Add the object to the array.
          # ```ruby
          # [ 1, 2, 3 ].__add__(4)
          # ```
          sig { params(object: Object).returns(Object) }
          def __add__(object); end

          # Return the object as an array.
          # 
          # _@return_ — self
          # 
          # Get the array.
          # ```ruby
          # [ 1, 2 ].__array__
          # ```
          sig { returns(T::Array[T.untyped]) }
          def __array__; end

          # Makes a deep copy of the array, deep copying every element inside the
          # array.
          # 
          # _@return_ — The deep copy of the array.
          # 
          # Get a deep copy of the array.
          # ```ruby
          # [ 1, 2, 3 ].__deep_copy__
          # ```
          sig { returns(T::Array[T.untyped]) }
          def __deep_copy__; end

          # Evolve the array into an array of mongo friendly dates. (Times at
          # midnight).
          # 
          # _@return_ — The array as times at midnight UTC.
          # 
          # Evolve the array to dates.
          # ```ruby
          # [ Date.new(2010, 1, 1) ].__evolve_date__
          # ```
          sig { returns(T::Array[Time]) }
          def __evolve_date__; end

          # Get the object as expanded.
          # 
          # _@return_ — The expanded array.
          # 
          # Get the object expanded.
          # ```ruby
          # obj.__expand_complex__
          # ```
          sig { returns(T::Array[T.untyped]) }
          def __expand_complex__; end

          # Evolve the array to an array of times.
          # 
          # _@return_ — The array as times.
          # 
          # Evolve the array to times.
          # ```ruby
          # [ 1231231231 ].__evolve_time__
          # ```
          sig { returns(T::Array[Time]) }
          def __evolve_time__; end

          # Combine the two objects using an intersection strategy.
          # 
          # _@param_ `object` — The object to intersect with.
          # 
          # _@return_ — The result of the intersection.
          # 
          # Interset with the object.
          # ```ruby
          # [ 1, 2 ].__intersect__(3)
          # ```
          sig { params(object: Object).returns(Object) }
          def __intersect__(object); end

          # Gets the array as options in the proper format to pass as MongoDB sort
          # criteria.
          # 
          # _@return_ — The array as sort criterion.
          # 
          # Get the array as sorting options.
          # ```ruby
          # [ :field, 1 ].__sort_option__
          # ```
          sig { returns(T::Hash[T.untyped, T.untyped]) }
          def __sort_option__; end

          # Get the array as a sort pair.
          # 
          # _@return_ — The field/direction pair.
          # 
          # Get the array as field/direction pair.
          # ```ruby
          # [ field, 1 ].__sort_pair__
          # ```
          sig { returns(T::Hash[T.untyped, T.untyped]) }
          def __sort_pair__; end

          # Update all the values in the hash with the provided block.
          # 
          # _@param_ `block` — The block to execute on each value.
          # 
          # _@return_ — the array.
          # 
          # Update the values in place.
          # ```ruby
          # [ 1, 2, 3 ].update_values(&:to_s)
          # ```
          sig { params(block: T.untyped).returns(T::Array[T.untyped]) }
          def update_values(&block); end

          # Converts the array to a multi-dimensional array.
          # 
          # _@return_ — The multi-dimensional array.
          # 
          # Convert to multi-dimensional.
          # ```ruby
          # [ 1, 2, 3 ].multi
          # ```
          sig { returns(T::Array[T.untyped]) }
          def multi; end

          module ClassMethods
            # Evolve the object when the serializer is defined as an array.
            # 
            # _@param_ `object` — The object to evolve.
            # 
            # _@return_ — The evolved object.
            # 
            # Evolve the object.
            # ```ruby
            # Array.evolve(1)
            # ```
            sig { params(object: Object).returns(Object) }
            def evolve(object); end
          end
        end

        # This module contains additional range behavior.
        module Range
          # Get the range as an array.
          # 
          # _@return_ — The range as an array.
          # 
          # Get the range as an array.
          # ```ruby
          # 1...3.__array__
          # ```
          sig { returns(T::Array[T.untyped]) }
          def __array__; end

          # Convert the range to a min/max mongo friendly query for dates.
          # 
          # _@return_ — The min/max range query with times at midnight.
          # 
          # Evolve the range.
          # ```ruby
          # (11231312..213123131).__evolve_date__
          # ```
          sig { returns(T::Hash[T.untyped, T.untyped]) }
          def __evolve_date__; end

          # Convert the range to a min/max mongo friendly query for times.
          # 
          # _@return_ — The min/max range query with times.
          # 
          # Evolve the range.
          # ```ruby
          # (11231312..213123131).__evolve_date__
          # ```
          sig { returns(T::Hash[T.untyped, T.untyped]) }
          def __evolve_time__; end

          module ClassMethods
            # Evolve the range. This will transform it into a $gte/$lte selection.
            # 
            # _@param_ `object` — The range to evolve.
            # 
            # _@return_ — The range as a gte/lte criteria.
            # 
            # Evolve the range.
            # ```ruby
            # Range.evolve(1..3)
            # ```
            sig { params(object: T::Range[T.untyped]).returns(T::Hash[T.untyped, T.untyped]) }
            def evolve(object); end
          end
        end

        # This module contains additional object behavior.
        module Object
          # Combine the two objects using the add strategy.
          # 
          # _@param_ `object` — The object to add.
          # 
          # _@return_ — The result of the add.
          # 
          # Add the object to the array.
          # ```ruby
          # [ 1, 2, 3 ].__add__(4)
          # ```
          sig { params(object: Object).returns(Object) }
          def __add__(object); end

          # Merge this object into the provided array.
          # 
          # _@param_ `array` — The array to add to.
          # 
          # _@return_ — The merged object.
          # 
          # Merge the object into the array.
          # ```ruby
          # 4.__add_from_array__([ 1, 2 ])
          # ```
          sig { params(array: T::Array[T.untyped]).returns(T::Array[T.untyped]) }
          def __add_from_array__(array); end

          # Combine the two objects using the intersect strategy.
          # 
          # _@param_ `object` — The object to intersect.
          # 
          # _@return_ — The result of the intersect.
          # 
          # Add the object to the array.
          # ```ruby
          # [ 1, 2, 3 ].__intersect__(4)
          # ```
          sig { params(object: Object).returns(T::Array[T.untyped]) }
          def __intersect__(object); end

          # Merge this object into the provided array.
          # 
          # _@param_ `array` — The array to intersect to.
          # 
          # _@return_ — The merged object.
          # 
          # Merge the object into the array.
          # ```ruby
          # 4.__intersect_from_array__([ 1, 2 ])
          # ```
          sig { params(array: T::Array[T.untyped]).returns(T::Array[T.untyped]) }
          def __intersect_from_array__(array); end

          # Merge this object into the provided array.
          # 
          # _@param_ `object` — The value to intersect to.
          # 
          # _@return_ — The merged object.
          # 
          # Merge the object into the array.
          # ```ruby
          # 4.__intersect_from_object__([ 1, 2 ])
          # ```
          sig { params(object: Object).returns(T::Array[T.untyped]) }
          def __intersect_from_object__(object); end

          # Combine the two objects using the union strategy.
          # 
          # _@param_ `object` — The object to union.
          # 
          # _@return_ — The result of the union.
          # 
          # Add the object to the array.
          # ```ruby
          # [ 1, 2, 3 ].__union__(4)
          # ```
          sig { params(object: Object).returns(T::Array[T.untyped]) }
          def __union__(object); end

          # Merge this object into the provided array.
          # 
          # _@param_ `object` — The value to union to.
          # 
          # _@return_ — The merged object.
          # 
          # Merge the object into the array.
          # ```ruby
          # 4.__union_from_object__([ 1, 2 ])
          # ```
          sig { params(object: Object).returns(T::Array[T.untyped]) }
          def __union_from_object__(object); end

          # Deep copy the object. This is for API compatibility, but needs to be
          # overridden.
          # 
          # _@return_ — self.
          # 
          # Deep copy the object.
          # ```ruby
          # 1.__deep_copy__
          # ```
          sig { returns(Object) }
          def __deep_copy__; end

          # Get the object as an array.
          # 
          # _@return_ — The wrapped object.
          # 
          # Get the object as an array.
          # ```ruby
          # 4.__array__
          # ```
          sig { returns(T::Array[T.untyped]) }
          def __array__; end

          # Get the object as expanded.
          # 
          # _@return_ — self.
          # 
          # Get the object expanded.
          # ```ruby
          # obj.__expand_complex__
          # ```
          sig { returns(Object) }
          def __expand_complex__; end

          # Is the object a regex.
          # 
          # _@return_ — Always false.
          # 
          # Is the object a regex?
          # ```ruby
          # obj.regexp?
          # ```
          sig { returns(T::Boolean) }
          def regexp?; end

          module ClassMethods
                        # Evolve the object.
            # 
            # _@return_ — The provided object.
            # 
            # Evolve an object.
            # ```ruby
            # Object.evolve("test")
            # ```
            # 
            # _@note_ — This is here for API compatibility.
            sig { params(object: T.untyped).returns(Object) }
            def evolve(object); end

                        # Evolve the object.
            # 
            # _@return_ — The evolved object.
            # 
            # Evolve an object and yield.
            # ```ruby
            # Object.evolve("test") do |obj|
            #   obj.to_s
            # end
            # ```
            sig { params(object: T.untyped).returns(Object) }
            def __evolve__(object); end
          end
        end

        # This module contains additional regex behavior.
        module Regexp
          # Is the object a regexp?
          # 
          # _@return_ — Always true.
          # 
          # Is the object a regex?
          # ```ruby
          # /\A[123]/.regexp?
          # ```
          sig { returns(T::Boolean) }
          def regexp?; end

          module ClassMethods
            # Evolve the object into a regex.
            # 
            # _@param_ `object` — The object to evolve.
            # 
            # _@return_ — The evolved regex.
            # 
            # Evolve the object to a regex.
            # ```ruby
            # Regexp.evolve("\A[123]")
            # ```
            sig { params(object: T.any(Regexp, String)).returns(Regexp) }
            def evolve(object); end
          end

          module Raw_
            # Is the object a regexp?
            # 
            # _@return_ — Always true.
            # 
            # Is the object a regex?
            # ```ruby
            # bson_raw_regexp.regexp?
            # ```
            sig { returns(T::Boolean) }
            def regexp?; end

            module ClassMethods
              # sord warn - BSON::Regexp::Raw wasn't able to be resolved to a constant in this project
              # sord warn - BSON::Regexp::Raw wasn't able to be resolved to a constant in this project
              # Evolve the object into a raw bson regex.
              # 
              # _@param_ `object` — The object to evolve.
              # 
              # _@return_ — The evolved raw regex.
              # 
              # Evolve the object to a regex.
              # ```ruby
              # BSON::Regexp::Raw.evolve("\\A[123]")
              # ```
              sig { params(object: T.any(BSON::Regexp::Raw, String)).returns(BSON::Regexp::Raw) }
              def evolve(object); end
            end
          end
        end

        # This module contains additional object behavior.
        module String
          # Evolve the string into a mongodb friendly date.
          # 
          # _@return_ — The time at UTC midnight.
          # 
          # Evolve the string.
          # ```ruby
          # "2012-1-1".__evolve_date__
          # ```
          sig { returns(Time) }
          def __evolve_date__; end

          # Evolve the string into a mongodb friendly time.
          # 
          # _@return_ — The string as a time.
          # 
          # Evolve the string.
          # ```ruby
          # "2012-1-1".__evolve_time__
          # ```
          sig { returns(Time) }
          def __evolve_time__; end

          # Get the string as a mongo expression, adding $ to the front.
          # 
          # _@return_ — The string with $ at the front.
          # 
          # Get the string as an expression.
          # ```ruby
          # "test".__mongo_expression__
          # ```
          sig { returns(String) }
          def __mongo_expression__; end

          # Get the string as a sort option.
          # 
          # _@return_ — The string as a sort option hash.
          # 
          # Get the string as a sort option.
          # ```ruby
          # "field ASC".__sort_option__
          # ```
          sig { returns(T::Hash[T.untyped, T.untyped]) }
          def __sort_option__; end

          # Get the string as a specification.
          # 
          # _@param_ `value` — The value of the criteria.
          # 
          # _@param_ `negating` — If the selection should be negated.
          # 
          # _@return_ — The selection.
          # 
          # Get the string as a criteria.
          # ```ruby
          # "field".__expr_part__(value)
          # ```
          sig { params(value: Object, negating: T::Boolean).returns(T::Hash[T.untyped, T.untyped]) }
          def __expr_part__(value, negating = false); end

          # Get the string as a sort direction.
          # 
          # _@return_ — The direction.
          # 
          # Get the string as a sort direction.
          # ```ruby
          # "1".to_direction
          # ```
          sig { returns(Integer) }
          def to_direction; end

          module ClassMethods
            # Get the value as a expression.
            # 
            # _@param_ `key` — The field key.
            # 
            # _@param_ `value` — The value of the criteria.
            # 
            # _@param_ `negating` — If the selection should be negated.
            # 
            # _@return_ — The selection.
            # 
            # Get the value as an expression.
            # ```ruby
            # String.__expr_part__("field", value)
            # ```
            sig { params(key: T.any(String, Symbol), value: Object, negating: T::Boolean).returns(T::Hash[T.untyped, T.untyped]) }
            def __expr_part__(key, value, negating = false); end

            # Evolves the string into a MongoDB friendly value - in this case
            # a string.
            # 
            # _@param_ `object` — The object to convert.
            # 
            # _@return_ — The value as a string.
            # 
            # Evolve the string
            # ```ruby
            # String.evolve(1)
            # ```
            sig { params(object: Object).returns(String) }
            def evolve(object); end
          end
        end

        # This module contains additional symbol behavior.
        module Symbol
          # Get the symbol as a specification.
          # 
          # _@param_ `value` — The value of the criteria.
          # 
          # _@param_ `negating` — If the selection should be negated.
          # 
          # _@return_ — The selection.
          # 
          # Get the symbol as a criteria.
          # ```ruby
          # :field.__expr_part__(value)
          # ```
          sig { params(value: Object, negating: T::Boolean).returns(T::Hash[T.untyped, T.untyped]) }
          def __expr_part__(value, negating = false); end

          # Get the symbol as a sort direction.
          # 
          # _@return_ — The direction.
          # 
          # Get the symbol as a sort direction.
          # ```ruby
          # "1".to_direction
          # ```
          sig { returns(Integer) }
          def to_direction; end

          module ClassMethods
                        # Adds a method on symbol as a convenience for the MongoDB operator.
            # 
            # _@param_ `name` — The name of the method.
            # 
            # _@param_ `strategy` — The name of the merge strategy.
            # 
            # _@param_ `operator` — The MongoDB operator.
            # 
            # _@param_ `additional` — The additional MongoDB operator.
            # 
            # Add the $in method.
            # ```ruby
            # Symbol.add_key(:in, "$in")
            # ```
            sig do
              params(
                name: Symbol,
                strategy: Symbol,
                operator: String,
                additional: T.nilable(String),
                block: T.untyped
              ).returns(T.untyped)
            end
            def add_key(name, strategy, operator, additional = nil, &block); end

            # Evolves the symbol into a MongoDB friendly value - in this case
            # a symbol.
            # 
            # _@param_ `object` — The object to convert.
            # 
            # _@return_ — The value as a symbol.
            # 
            # Evolve the symbol
            # ```ruby
            # Symbol.evolve("test")
            # ```
            sig { params(object: Object).returns(Symbol) }
            def evolve(object); end
          end
        end

        # This module contains extensions for boolean selection.
        module Boolean
          module ClassMethods
            # Evolve the value into a boolean value stored in MongoDB. Will return
            # true for any of these values: true, t, yes, y, 1, 1.0.
            # 
            # _@param_ `object` — The object to evolve.
            # 
            # _@return_ — The boolean value.
            # 
            # Evolve the value to a boolean.
            # ```ruby
            # Boolean.evolve(true)
            # ```
            sig { params(object: Object).returns(T::Boolean) }
            def evolve(object); end
          end
        end

        # This module contains additional numeric behavior.
        module Numeric
          # Evolve the numeric value into a mongo friendly date, aka UTC time at
          # midnight.
          # 
          # _@return_ — The time representation at UTC midnight.
          # 
          # Evolve to a date.
          # ```ruby
          # 125214512412.1123.__evolve_date__
          # ```
          sig { returns(Time) }
          def __evolve_date__; end

          # Evolve the numeric value into a mongo friendly time.
          # 
          # _@return_ — The time representation.
          # 
          # Evolve to a time.
          # ```ruby
          # 125214512412.1123.__evolve_time__
          # ```
          sig { returns(Time) }
          def __evolve_time__; end

          # Get the integer as a sort direction.
          # 
          # _@return_ — self.
          # 
          # Get the integer as a sort direction.
          # ```ruby
          # 1.to_direction
          # ```
          sig { returns(Integer) }
          def to_direction; end

          module ClassMethods
            # Get the object as a numeric.
            # 
            # _@param_ `object` — The object to convert.
            # 
            # _@return_ — The converted number.
            # 
            # Get the object as numeric.
            # ```ruby
            # Object.__numeric__("1.442")
            # ```
            sig { params(object: Object).returns(Object) }
            def __numeric__(object); end

            # Evolve the object to an integer.
            # 
            # _@param_ `object` — The object to evolve.
            # 
            # _@return_ — The evolved object.
            # 
            # Evolve to integers.
            # ```ruby
            # Integer.evolve("1")
            # ```
            sig { params(object: Object).returns(Integer) }
            def evolve(object); end
          end
        end

        # This module contains additional datetime behavior.
        module DateTime
          # Evolve the date time into a mongo friendly UTC time.
          # 
          # _@return_ — The converted time in UTC.
          # 
          # Evolve the date time.
          # ```ruby
          # date_time.__evolve_time__
          # ```
          sig { returns(Time) }
          def __evolve_time__; end

          module ClassMethods
            # Evolve the object to an date.
            # 
            # _@param_ `object` — The object to evolve.
            # 
            # _@return_ — The evolved date time.
            # 
            # Evolve dates.
            # ```ruby
            # ```
            # 
            # Evolve string dates.
            # ```ruby
            # ```
            # 
            # Evolve date ranges.
            # ```ruby
            # ```
            sig { params(object: Object).returns(Time) }
            def evolve(object); end
          end
        end

        # This module contains additional nil behavior.
        module NilClass
          # Add this object to nil.
          # 
          # _@param_ `object` — The object to add.
          # 
          # _@return_ — The provided object.
          # 
          # Add the object to a nil value.
          # ```ruby
          # nil.__add__([ 1, 2, 3 ])
          # ```
          sig { params(object: Object).returns(Object) }
          def __add__(object); end

          # Add this object to nil.
          # 
          # _@param_ `object` — The object to expanded.
          # 
          # _@return_ — The provided object.
          # 
          # Add the object to a nil value.
          # ```ruby
          # nil.__expanded__([ 1, 2, 3 ])
          # ```
          sig { params(object: Object).returns(Object) }
          def __expanded__(object); end

          # Evolve the nil into a date or time.
          # 
          # _@return_ — nil.
          # 
          # Evolve the nil.
          # ```ruby
          # nil.__evolve_time__
          # ```
          sig { returns(T.nilable(T.any())) }
          def __evolve_time__; end

          # Add this object to nil.
          # 
          # _@param_ `object` — The object to intersect.
          # 
          # _@return_ — The provided object.
          # 
          # Add the object to a nil value.
          # ```ruby
          # nil.__intersect__([ 1, 2, 3 ])
          # ```
          sig { params(object: Object).returns(Object) }
          def __intersect__(object); end

          # Add this object to nil.
          # 
          # _@param_ `object` — The object to override.
          # 
          # _@return_ — The provided object.
          # 
          # Add the object to a nil value.
          # ```ruby
          # nil.__override__([ 1, 2, 3 ])
          # ```
          sig { params(object: Object).returns(Object) }
          def __override__(object); end

          # Add this object to nil.
          # 
          # _@param_ `object` — The object to union.
          # 
          # _@return_ — The provided object.
          # 
          # Add the object to a nil value.
          # ```ruby
          # nil.__union__([ 1, 2, 3 ])
          # ```
          sig { params(object: Object).returns(Object) }
          def __union__(object); end
        end

        # The big decimal module adds custom behavior for Origin onto the
        # BigDecimal class.
        module BigDecimal
          module ClassMethods
            # Evolves the big decimal into a MongoDB friendly value - in this case
            # a string.
            # 
            # _@param_ `object` — The object to convert.
            # 
            # _@return_ — The big decimal as a string.
            # 
            # Evolve the big decimal
            # ```ruby
            # BigDecimal.evolve(decimal)
            # ```
            sig { params(object: BigDecimal).returns(String) }
            def evolve(object); end
          end
        end

        # This module contains additional time with zone behavior.
        module TimeWithZone
          # Evolve the time as a date, UTC midnight.
          # 
          # _@return_ — The date at midnight UTC.
          # 
          # Evolve the time to a date query format.
          # ```ruby
          # time.__evolve_date__
          # ```
          sig { returns(Time) }
          def __evolve_date__; end

          # Evolve the time into a utc time.
          # 
          # _@return_ — The time in UTC.
          # 
          # Evolve the time.
          # ```ruby
          # time.__evolve_time__
          # ```
          sig { returns(Time) }
          def __evolve_time__; end

          module ClassMethods
            # Evolve the object to an date.
            # 
            # _@param_ `object` — The object to evolve.
            # 
            # _@return_ — The evolved date time.
            # 
            # Evolve dates.
            # ```ruby
            # ```
            # 
            # Evolve string dates.
            # ```ruby
            # ```
            # 
            # Evolve date ranges.
            # ```ruby
            # ```
            sig { params(object: Object).returns(Time) }
            def evolve(object); end
          end
        end
      end
    end

    # Module providing functionality for parsing (nested) inclusion definitions.
    module Includable
      # Eager loads all the provided associations. Will load all the documents
      # into the identity map whose ids match based on the extra query for the
      # ids.
      # 
      # _@param_ `relations` — The names of the associations to eager load.
      # 
      # _@return_ — The cloned criteria.
      # 
      # Eager load the provided associations.
      # ```ruby
      # Person.includes(:posts, :game)
      # ```
      # 
      # _@note_ — This will work for embedded associations that reference another
      # collection via belongs_to as well.
      # 
      # _@note_ — Eager loading brings all the documents into memory, so there is a
      # sweet spot on the performance gains. Internal benchmarks show that
      # eager loading becomes slower around 100k documents, but this will
      # naturally depend on the specific application.
      sig { params(relations: T.any(T::Array[Symbol], T::Array[T::Hash[T.untyped, T.untyped]])).returns(Criteria) }
      def includes(*relations); end

      # Get a list of criteria that are to be executed for eager loading.
      # 
      # _@return_ — The inclusions.
      # 
      # Get the eager loading inclusions.
      # ```ruby
      # Person.includes(:game).inclusions
      # ```
      sig { returns(T::Array[Association]) }
      def inclusions; end

      # Set the inclusions for the criteria.
      # 
      # _@param_ `value` — The inclusions.
      # 
      # _@return_ — The new inclusions.
      # 
      # Set the inclusions.
      # ```ruby
      # criteria.inclusions = [ association ]
      # ```
      sig { params(value: T::Array[Association]).returns(T::Array[Association]) }
      def inclusions=(value); end

            # Add an inclusion definition to the list of inclusions for the criteria.
      # 
      # _@param_ `_klass` — The class or string/symbol of the class name.
      # 
      # _@param_ `association` — The association.
      # 
      # Add an inclusion.
      # ```ruby
      # criteria.add_inclusion(Person, :posts)
      # ```
      sig { params(_klass: T.any(Class, String, Symbol), association: Symbol).returns(T.untyped) }
      def add_inclusion(_klass, association); end

                        sig { params(_parent_class: T.untyped, relations_list: T.untyped).returns(T.untyped) }
      def extract_includes_list(_parent_class, *relations_list); end
    end

    module Modifiable
            # Build a document given the selector and return it.
      # Complex criteria, such as $in and $or operations will get ignored.
      # 
      # _@return_ — A non-persisted document.
      # 
      # build the document.
      # ```ruby
      # Person.where(:title => "Sir").build
      # ```
      # 
      # Build with selectors getting ignored.
      # ```ruby
      # Person.where(:age.gt => 5).build
      # ```
      sig { params(attrs: T.untyped, block: T.untyped).returns(Document) }
      def build(attrs = {}, &block); end

            # Create a document in the database given the selector and return it.
      # Complex criteria, such as $in and $or operations will get ignored.
      # 
      # _@return_ — A newly created document.
      # 
      # Create the document.
      # ```ruby
      # Person.where(:title => "Sir").create
      # ```
      # 
      # Create with selectors getting ignored.
      # ```ruby
      # Person.where(:age.gt => 5).create
      # ```
      sig { params(attrs: T.untyped, block: T.untyped).returns(Document) }
      def create(attrs = {}, &block); end

            # Create a document in the database given the selector and return it.
      # Complex criteria, such as $in and $or operations will get ignored.
      # If validation fails, an error will be raised.
      # 
      # _@return_ — A newly created document.
      # 
      # Create the document.
      # ```ruby
      # Person.where(:title => "Sir").create
      # ```
      # 
      # Create with selectors getting ignored.
      # ```ruby
      # Person.where(:age.gt => 5).create
      # ```
      sig { params(attrs: T.untyped, block: T.untyped).returns(Document) }
      def create!(attrs = {}, &block); end

            # Define attributes with which new documents will be created.
      # 
      # Note that if `find_or_create_by` is called after this in a method chain, the attributes in
      # the query will override those from this method.
      # 
      # _@return_ — A criteria.
      # 
      # Define attributes to be used when a new document is created.
      # ```ruby
      # Person.create_with(job: 'Engineer').find_or_create_by(employer: 'MongoDB')
      # ```
      sig { params(attrs: T.untyped).returns(Mongoid::Criteria) }
      def create_with(attrs = {}); end

      # Find the first +Document+ given the conditions, or creates a new document
      # with the conditions that were supplied.
      # 
      # _@param_ `attrs` — The attributes to check.
      # 
      # _@return_ — A matching or newly created document.
      # 
      # Find or create the document.
      # ```ruby
      # Person.find_or_create_by(:attribute => "value")
      # ```
      sig { params(attrs: T::Hash[T.untyped, T.untyped], block: T.untyped).returns(Document) }
      def find_or_create_by(attrs = {}, &block); end

      # Find the first +Document+ given the conditions, or creates a new document
      # with the conditions that were supplied. If validation fails an
      # exception will be raised.
      # 
      # _@param_ `attrs` — The attributes to check.
      # 
      # _@return_ — A matching or newly created document.
      # 
      # Find or create the document.
      # ```ruby
      # Person.find_or_create_by!(:attribute => "value")
      # ```
      sig { params(attrs: T::Hash[T.untyped, T.untyped], block: T.untyped).returns(Document) }
      def find_or_create_by!(attrs = {}, &block); end

      # Find the first +Document+ given the conditions, or initializes a new document
      # with the conditions that were supplied.
      # 
      # _@param_ `attrs` — The attributes to check.
      # 
      # _@return_ — A matching or newly initialized document.
      # 
      # Find or initialize the document.
      # ```ruby
      # Person.find_or_initialize_by(:attribute => "value")
      # ```
      sig { params(attrs: T::Hash[T.untyped, T.untyped], block: T.untyped).returns(Document) }
      def find_or_initialize_by(attrs = {}, &block); end

      # Find the first +Document+, or creates a new document
      # with the conditions that were supplied plus attributes.
      # 
      # _@param_ `attrs` — The additional attributes to add.
      # 
      # _@return_ — A matching or newly created document.
      # 
      # First or create the document.
      # ```ruby
      # Person.where(name: "Jon").first_or_create(attribute: "value")
      # ```
      sig { params(attrs: T.nilable(T::Hash[T.untyped, T.untyped]), block: T.untyped).returns(Document) }
      def first_or_create(attrs = nil, &block); end

      # Find the first +Document+, or creates a new document
      # with the conditions that were supplied plus attributes and will
      # raise an error if validation fails.
      # 
      # _@param_ `attrs` — The additional attributes to add.
      # 
      # _@return_ — A matching or newly created document.
      # 
      # First or create the document.
      # ```ruby
      # Person.where(name: "Jon").first_or_create!(attribute: "value")
      # ```
      sig { params(attrs: T.nilable(T::Hash[T.untyped, T.untyped]), block: T.untyped).returns(Document) }
      def first_or_create!(attrs = nil, &block); end

      # Find the first +Document+, or initializes a new document
      # with the conditions that were supplied plus attributes.
      # 
      # _@param_ `attrs` — The additional attributes to add.
      # 
      # _@return_ — A matching or newly initialized document.
      # 
      # First or initialize the document.
      # ```ruby
      # Person.where(name: "Jon").first_or_initialize(attribute: "value")
      # ```
      sig { params(attrs: T.nilable(T::Hash[T.untyped, T.untyped]), block: T.untyped).returns(Document) }
      def first_or_initialize(attrs = nil, &block); end

      # Create a document given the provided method and attributes from the
      # existing selector.
      # 
      # _@param_ `method` — Either :new or :create.
      # 
      # _@param_ `attrs` — Additional attributes to use.
      # 
      # _@return_ — The new or saved document.
      # 
      # Create a new document.
      # ```ruby
      # criteria.create_document(:new, {})
      # ```
      sig { params(method: Symbol, attrs: T.nilable(T::Hash[T.untyped, T.untyped]), block: T.untyped).returns(Document) }
      def create_document(method, attrs = nil, &block); end

      # Find the first object or create/initialize it.
      # 
      # _@param_ `method` — The method to invoke.
      # 
      # _@param_ `attrs` — The attributes to query or set.
      # 
      # _@return_ — The first or new document.
      # 
      # Find or perform an action.
      # ```ruby
      # Person.find_or(:create, :name => "Dev")
      # ```
      sig { params(method: Symbol, attrs: T::Hash[T.untyped, T.untyped], block: T.untyped).returns(Document) }
      def find_or(method, attrs = {}, &block); end

      # Find the first document or create/initialize it.
      # 
      # _@param_ `method` — The method to invoke.
      # 
      # _@param_ `attrs` — The attributes to query or set.
      # 
      # _@return_ — The first or new document.
      # 
      # First or perform an action.
      # ```ruby
      # Person.first_or(:create, :name => "Dev")
      # ```
      sig { params(method: Symbol, attrs: T::Hash[T.untyped, T.untyped], block: T.untyped).returns(Document) }
      def first_or(method, attrs = {}, &block); end

                  sig { params(hash: T.untyped, key: T.untyped).returns(T::Boolean) }
      def invalid_key?(hash, key); end

            sig { params(value: T.untyped).returns(T::Boolean) }
      def invalid_embedded_doc?(value); end

            sig { returns(T.untyped) }
      attr_reader :create_attrs

            sig { returns(T.untyped) }
      attr_reader :create_attrs
    end

    module Permission
      # Ensure that the criteria are permitted.
      # 
      # _@param_ `criteria`
      # 
      # _@return_ — if should permit
      # 
      # Ignoring ActionController::Parameters
      # ```ruby
      # should_permit?({_id: ActionController::Parameters.new("$size" => 1)})
      # ```
      sig { params(criteria: Object).returns(T::Boolean) }
      def should_permit?(criteria); end
    end

    module Marshalable
      # Provides the data needed to Marshal.dump a criteria.
      # 
      # _@return_ — The dumped data.
      # 
      # Dump the criteria.
      # ```ruby
      # Marshal.dump(criteria)
      # ```
      sig { returns(T::Array[Object]) }
      def marshal_dump; end

            # Resets the criteria object after a Marshal.load
      # 
      # _@param_ `data` — The raw data.
      # 
      # Load the criteria.
      # ```ruby
      # Marshal.load(criteria)
      # ```
      sig { params(data: T::Array[T.untyped]).returns(T.untyped) }
      def marshal_load(data); end

                  sig { params(name: T.untyped).returns(T.untyped) }
      def dump_hash(name); end

                        sig { params(hash_class: T.untyped, raw: T.untyped).returns(T.untyped) }
      def load_hash(hash_class, raw); end
    end
  end

  # This is the base module for all domain objects that need to be persisted to
  # the database as documents.
  module Document
    include Mongoid::Composable
    include Mongoid::Touchable::InstanceMethods
    extend ActiveSupport::Concern
    ILLEGAL_KEY = T.let(/(\A[$])|(\.)/.freeze, T.untyped)
    MODULES = T.let([
  Atomic,
  Attributes,
  Copyable,
  Changeable,
  Evolvable,
  Fields,
  Indexable,
  Interceptable,
  Matchable,
  Persistable,
  Association,
  Reloadable,
  Scopable,
  Serializable,
  Clients,
  Clients::Options,
  Shardable,
  Stateful,
  Cacheable,
  Threaded::Lifecycle,
  Traversable,
  Validatable,
  Equality,
  Association::Referenced::Syncable,
  Association::Macros,
  ActiveModel::Model,
  ActiveModel::Validations
], T.untyped)
    RESERVED_METHOD_NAMES = T.let([ :fields,
  :aliased_fields,
  :localized_fields,
  :index_specifications,
  :shard_key_fields,
  :nested_attributes,
  :readonly_attributes,
  :storage_options,
  :cascades,
  :cyclic,
  :cache_timestamp_format
], T.untyped)
    CALLBACKS = T.let([
  :after_build,
  :after_create,
  :after_destroy,
  :after_find,
  :after_initialize,
  :after_save,
  :after_touch,
  :after_update,
  :after_upsert,
  :after_validation,
  :around_create,
  :around_destroy,
  :around_save,
  :around_update,
  :around_upsert,
  :before_create,
  :before_destroy,
  :before_save,
  :before_update,
  :before_upsert,
  :before_validation
].freeze, T.untyped)
    MACRO_MAPPING = T.let({
    embeds_one: Association::Embedded::EmbedsOne,
    embeds_many: Association::Embedded::EmbedsMany,
    embedded_in: Association::Embedded::EmbeddedIn,
    has_one: Association::Referenced::HasOne,
    has_many: Association::Referenced::HasMany,
    has_and_belongs_to_many: Association::Referenced::HasAndBelongsToMany,
    belongs_to: Association::Referenced::BelongsTo,
}.freeze, T.untyped)
    STRATEGIES = T.let([
    :delete_all,
    :destroy,
    :nullify,
    :restrict_with_exception,
    :restrict_with_error
], T.untyped)
    LIST_OPERATIONS = T.let([ "$addToSet", "$push", "$pull", "$pullAll" ].freeze, T.untyped)
    StringifiedSymbol = T.let(Mongoid::StringifiedSymbol, T.untyped)
    Boolean = T.let(Mongoid::Boolean, T.untyped)
    TYPE_MAPPINGS = T.let({
  array: Array,
  big_decimal: BigDecimal,
  binary: BSON::Binary,
  boolean: Mongoid::Boolean,
  date: Date,
  date_time: DateTime,
  float: Float,
  hash: Hash,
  integer: Integer,
  object_id: BSON::ObjectId,
  range: Range,
  regexp: Regexp,
  set: Set,
  string: String,
  stringified_symbol: StringifiedSymbol,
  symbol: Symbol,
  time: Time
}.with_indifferent_access, T.untyped)
    IDS = T.let([ :_id, '_id', ].freeze, T.untyped)
    CREATE_LOCK = T.let(Mutex.new, T.untyped)
    UPDATES = T.let([
  :atomic_array_pushes,
  :atomic_array_pulls,
  :atomic_array_add_to_sets,
  :atomic_pulls,
  :delayed_atomic_sets,
  :delayed_atomic_pulls,
  :delayed_atomic_unsets
], T.untyped)

    # Freezes the internal attributes of the document.
    # 
    # _@return_ — The document.
    # 
    # Freeze the document
    # ```ruby
    # document.freeze
    # ```
    sig { returns(Document) }
    def freeze; end

    # Checks if the document is frozen
    # 
    # _@return_ — True if frozen, else false.
    # 
    # Check if frozen
    # ```ruby
    # document.frozen?
    # ```
    sig { returns(T::Boolean) }
    def frozen?; end

    # Delegates to identity in order to allow two records of the same identity
    # to work with something like:
    # 
    #   [ Person.find(1), Person.find(2), Person.find(3) ] &
    #   [ Person.find(1), Person.find(4) ] # => [ Person.find(1) ]
    # 
    # _@return_ — The hash of the document's identity.
    # 
    # Get the hash.
    # ```ruby
    # document.hash
    # ```
    sig { returns(Integer) }
    def hash; end

    # A Document's is identified absolutely by its class and database id:
    # 
    # Person.first.identity #=> [Person, BSON::ObjectId('4f775130a04745933a000003')]
    # 
    # _@return_ — An array containing [document.class, document._id]
    # 
    # Get the identity
    # ```ruby
    # document.identity
    # ```
    sig { returns(T::Array[T.untyped]) }
    def identity; end

    # Instantiate a new +Document+, setting the Document's attributes if
    # given. If no attributes are provided, they will be initialized with
    # an empty +Hash+.
    # 
    # If a primary key is defined, the document's id will be set to that key,
    # otherwise it will be set to a fresh +BSON::ObjectId+ string.
    # 
    # _@param_ `attrs` — The attributes to set up the document with.
    # 
    # _@return_ — A new document.
    # 
    # Create a new document.
    # ```ruby
    # Person.new(:title => "Sir")
    # ```
    sig { params(attrs: T.nilable(T::Hash[T.untyped, T.untyped])).void }
    def initialize(attrs = nil); end

    # Return the model name of the document.
    # 
    # _@return_ — The model name.
    # 
    # Return the model name.
    # ```ruby
    # document.model_name
    # ```
    sig { returns(String) }
    def model_name; end

    # Return the key value for the document.
    # 
    # _@return_ — The id of the document or nil if new.
    # 
    # Return the key.
    # ```ruby
    # document.to_key
    # ```
    sig { returns(String) }
    def to_key; end

    # Return an array with this +Document+ only in it.
    # 
    # _@return_ — An array with the document as its only item.
    # 
    # Return the document in an array.
    # ```ruby
    # document.to_a
    # ```
    sig { returns(T::Array[Document]) }
    def to_a; end

    # Return a hash of the entire document hierarchy from this document and
    # below. Used when the attributes are needed for everything and not just
    # the current document.
    # 
    # _@return_ — A hash of all attributes in the hierarchy.
    # 
    # Get the full hierarchy.
    # ```ruby
    # person.as_document
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def as_document; end

    # Calls #as_json on the document with additional, Mongoid-specific options.
    # 
    # _@param_ `options` — The options.
    # 
    # _@return_ — The document as json.
    # 
    # Get the document as json.
    # ```ruby
    # document.as_json(compact: true)
    # ```
    # 
    # _@note_ — Rails 6 changes return value of as_json for non-primitive types
    # such as BSON::ObjectId. In Rails <= 5, as_json returned these as
    # instances of the class. In Rails 6, these are returned serialized to
    # primitive types (e.g. {"$oid"=>"5bcfc40bde340b37feda98e9"}).
    # See https://github.com/rails/rails/commit/2e5cb980a448e7f4ab00df6e9ad4c1cc456616aa
    # for more information.
    sig { params(options: T.nilable(T::Hash[T.untyped, T.untyped])).returns(T::Hash[T.untyped, T.untyped]) }
    def as_json(options = nil); end

    # Returns an instance of the specified class with the attributes,
    # errors, and embedded documents of the current document.
    # 
    # _@param_ `klass` — The class to become.
    # 
    # _@return_ — An instance of the specified class.
    # 
    # Return a subclass document as a superclass instance.
    # ```ruby
    # manager.becomes(Person)
    # ```
    sig { params(klass: Class).returns(Document) }
    def becomes(klass); end

    # Implement this for calls to flatten on array.
    # 
    # _@return_ — Always nil.
    # 
    # Get the document as an array.
    # ```ruby
    # document.to_ary
    # ```
    sig { returns(T.nilable(T.any())) }
    def to_ary; end

    # Returns the logger
    # 
    # _@return_ — The configured logger or a default Logger instance.
    sig { returns(Logger) }
    def logger; end

    # Get the name of the model used in caching.
    # 
    # _@return_ — The model key.
    # 
    # Get the model key.
    # ```ruby
    # model.model_key
    # ```
    sig { returns(String) }
    def model_key; end

        sig { returns(T.untyped) }
    def as_attributes; end

    # Touch the document, in effect updating its updated_at timestamp and
    # optionally the provided field to the current time. If any belongs_to
    # associations exist with a touch option, they will be updated as well.
    # 
    # _@param_ `field` — The name of an additional field to update.
    # 
    # _@return_ — false if record is new_record otherwise true.
    # 
    # Update the updated_at timestamp.
    # ```ruby
    # document.touch
    # ```
    # 
    # Update the updated_at and provided timestamps.
    # ```ruby
    # document.touch(:audited)
    # ```
    # 
    # _@note_ — This will not autobuild associations if those options are set.
    sig { params(field: T.nilable(Symbol)).returns(T::Boolean) }
    def touch(field = nil); end

    # Default comparison is via the string version of the id.
    # 
    # _@param_ `other` — The document to compare with.
    # 
    # _@return_ — -1, 0, 1.
    # 
    # Compare two documents.
    # ```ruby
    # person <=> other_person
    # ```
    sig { params(other: Document).returns(Integer) }
    def <=>(other); end

    # Performs equality checking on the document ids. For more robust
    # equality checking please override this method.
    # 
    # _@param_ `other` — The other object to compare with.
    # 
    # _@return_ — True if the ids are equal, false if not.
    # 
    # Compare for equality.
    # ```ruby
    # document == other
    # ```
    sig { params(other: T.any(Document, Object)).returns(T::Boolean) }
    def ==(other); end

    # Performs class equality checking.
    # 
    # _@param_ `other` — The other object to compare with.
    # 
    # _@return_ — True if the classes are equal, false if not.
    # 
    # Compare the classes.
    # ```ruby
    # document === other
    # ```
    sig { params(other: T.any(Document, Object)).returns(T::Boolean) }
    def ===(other); end

    # Delegates to ==. Used when needing checks in hashes.
    # 
    # _@param_ `other` — The object to check against.
    # 
    # _@return_ — True if equal, false if not.
    # 
    # Perform equality checking.
    # ```ruby
    # document.eql?(other)
    # ```
    sig { params(other: T.any(Document, Object)).returns(T::Boolean) }
    def eql?(other); end

    # Clone or dup the current +Document+. This will return all attributes with
    # the exception of the document's id, and will reset all the
    # instance variables.
    # 
    # This clone also includes embedded documents.
    # 
    # _@return_ — The new document.
    # 
    # Clone the document.
    # ```ruby
    # document.clone
    # ```
    sig { returns(Document) }
    def clone; end

        # Clone the document attributes
    # 
    # clone document
    # ```ruby
    # model.clone_document
    # ```
    sig { returns(T.untyped) }
    def clone_document; end

            # When cloning, if the document has localized fields we need to ensure they
    # are properly processed in the clone.
    # 
    # _@param_ `attrs` — The attributes.
    # 
    # Process localized attributes.
    # ```ruby
    # model.process_localized_attributes(attributes)
    # ```
    sig { params(klass: T.untyped, attrs: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
    def process_localized_attributes(klass, attrs); end

    # Is the provided type of callback executable by this document?
    # 
    # _@param_ `kind` — The type of callback.
    # 
    # _@return_ — If the callback can be executed.
    # 
    # Is the callback executable?
    # ```ruby
    # document.callback_executable?(:save)
    # ```
    sig { params(kind: Symbol).returns(T::Boolean) }
    def callback_executable?(kind); end

    # Is the document currently in a state that could potentially require
    # callbacks to be executed?
    # 
    # _@param_ `kind` — The callback kind.
    # 
    # _@return_ — If the document is in a callback state.
    # 
    # Is the document in a callback state?
    # ```ruby
    # document.in_callback_state?(:update)
    # ```
    sig { params(kind: Symbol).returns(T::Boolean) }
    def in_callback_state?(kind); end

    # Run only the after callbacks for the specific event.
    # 
    # _@param_ `kinds` — The events that are occurring.
    # 
    # _@return_ — The result of the chain executing.
    # 
    # Run only the after save callbacks.
    # ```ruby
    # model.run_after_callbacks(:save)
    # ```
    # 
    # _@note_ — ActiveSupport does not allow this type of behavior by default, so
    # Mongoid has to get around it and implement itself.
    sig { params(kinds: T::Array[Symbol]).returns(Object) }
    def run_after_callbacks(*kinds); end

    # Run only the before callbacks for the specific event.
    # 
    # _@param_ `kinds` — The events that are occurring.
    # 
    # _@return_ — The result of the chain executing.
    # 
    # Run only the before save callbacks.
    # ```ruby
    # model.run_before_callbacks(:save, :create)
    # ```
    # 
    # _@note_ — ActiveSupport does not allow this type of behavior by default, so
    # Mongoid has to get around it and implement itself.
    sig { params(kinds: T::Array[Symbol]).returns(Object) }
    def run_before_callbacks(*kinds); end

    # Run the callbacks for the document. This overrides active support's
    # functionality to cascade callbacks to embedded documents that have been
    # flagged as such.
    # 
    # _@param_ `kind` — The type of callback to execute.
    # 
    # _@param_ `args` — Any options.
    # 
    # _@return_ — The document
    # 
    # Run the callbacks.
    # ```ruby
    # run_callbacks :save do
    #   save!
    # end
    # ```
    sig { params(kind: Symbol, args: T::Array[T.untyped], block: T.untyped).returns(Document) }
    def run_callbacks(kind, *args, &block); end

    # We need to hook into this for autosave, since we don't want it firing if
    # the before callbacks were halted.
    # 
    # _@return_ — If a before callback was halted.
    # 
    # Was a before callback halted?
    # ```ruby
    # document.before_callback_halted?
    # ```
    sig { returns(T::Boolean) }
    def before_callback_halted?; end

        # Get all the child embedded documents that are flagged as cascadable.
    # 
    # _@param_ `kind` — The type of callback.
    # 
    # _@return_ — The children.
    # 
    # Get all the cascading children.
    # ```ruby
    # document.cascadable_children(:update)
    # ```
    sig { params(kind: Symbol, children: T.untyped).returns(T::Array[Document]) }
    def cascadable_children(kind, children = Set.new); end

        # Determine if the child should fire the callback.
    # 
    # _@param_ `kind` — The type of callback.
    # 
    # _@param_ `child` — The child document.
    # 
    # _@return_ — If the child should fire the callback.
    # 
    # Should the child fire the callback?
    # ```ruby
    # document.cascadable_child?(:update, doc)
    # ```
    sig { params(kind: Symbol, child: Document, association: T.untyped).returns(T::Boolean) }
    def cascadable_child?(kind, child, association); end

    # Get the name of the callback that the child should fire. This changes
    # depending on whether or not the child is new. A persisted parent with a
    # new child would fire :update from the parent, but needs to fire :create
    # on the child.
    # 
    # _@param_ `kind` — The type of callback.
    # 
    # _@param_ `child` — The child document
    # 
    # _@return_ — The name of the callback.
    # 
    # Get the callback type.
    # ```ruby
    # document.child_callback_type(:update, doc)
    # ```
    sig { params(kind: Symbol, child: Document).returns(Symbol) }
    def child_callback_type(kind, child); end

        # We need to hook into this for autosave, since we don't want it firing if
    # the before callbacks were halted.
    # 
    # _@param_ `filter` — The callback that halted.
    # 
    # _@param_ `name` — The name of the callback that was halted (requires Rails 6.1+)
    # 
    # Hook into the halt.
    # ```ruby
    # document.halted_callback_hook(filter)
    # ```
    sig { params(filter: Symbol, name: T.nilable(Symbol)).returns(T.untyped) }
    def halted_callback_hook(filter, name = nil); end

    # Run only the callbacks for the target location (before, after, around)
    # and kind (save, update, create).
    # 
    # _@param_ `place` — The time to run, :before, :after, :around.
    # 
    # _@param_ `kind` — The type of callback, :save, :create, :update.
    # 
    # _@return_ — The result of the chain execution.
    # 
    # Run the targeted callbacks.
    # ```ruby
    # model.run_targeted_callbacks(:before, :save)
    # ```
    sig { params(place: Symbol, kind: Symbol).returns(Object) }
    def run_targeted_callbacks(place, kind); end

        # Begin the associated validation.
    # 
    # Begin validation.
    # ```ruby
    # document.begin_validate
    # ```
    sig { returns(T.untyped) }
    def begin_validate; end

        # Exit the associated validation.
    # 
    # Exit validation.
    # ```ruby
    # document.exit_validate
    # ```
    sig { returns(T.untyped) }
    def exit_validate; end

    # Given the provided options, are we performing validations?
    # 
    # _@param_ `options` — The options to check.
    # 
    # _@return_ — If we are validating.
    # 
    # Are we performing validations?
    # ```ruby
    # document.performing_validations?(validate: true)
    # ```
    sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
    def performing_validations?(options = {}); end

    # Overrides the default ActiveModel behavior since we need to handle
    # validations of associations slightly different than just calling the
    # getter.
    # 
    # _@param_ `attr` — The name of the field or association.
    # 
    # _@return_ — The value of the field or the association.
    # 
    # Read the value.
    # ```ruby
    # person.read_attribute_for_validation(:addresses)
    # ```
    sig { params(attr: Symbol).returns(Object) }
    def read_attribute_for_validation(attr); end

    # Determine if the document is valid.
    # 
    # _@param_ `context` — The optional validation context.
    # 
    # _@return_ — True if valid, false if not.
    # 
    # Is the document valid?
    # ```ruby
    # person.valid?
    # ```
    # 
    # Is the document valid in a context?
    # ```ruby
    # person.valid?(:create)
    # ```
    sig { params(context: T.nilable(Symbol)).returns(T::Boolean) }
    def valid?(context = nil); end

    # Used to prevent infinite loops in associated validations.
    # 
    # _@return_ — Has the document already been validated?
    # 
    # Is the document validated?
    # ```ruby
    # document.validated?
    # ```
    sig { returns(T::Boolean) }
    def validated?; end

    # Are we currently performing a validation that has a query?
    # 
    # _@return_ — If we are validating with a query.
    # 
    # Are we validating with a query?
    # ```ruby
    # document.validating_with_query?
    # ```
    sig { returns(T::Boolean) }
    def validating_with_query?; end

        sig { returns(T.untyped) }
    def _parent; end

            sig { params(p: T.untyped).returns(T.untyped) }
    def _parent=(p); end

    # Get all child +Documents+ to this +Document+, going n levels deep if
    # necessary. This is used when calling update persistence operations from
    # the root document, where changes in the entire tree need to be
    # determined. Note that persistence from the embedded documents will
    # always be preferred, since they are optimized calls... This operation
    # can get expensive in domains with large hierarchies.
    # 
    # _@return_ — All child documents in the hierarchy.
    # 
    # Get all the document's children.
    # ```ruby
    # person._children
    # ```
    sig { returns(T::Array[Document]) }
    def _children; end

    # Collect all the children of this document.
    # 
    # _@return_ — The children.
    # 
    # Collect all the children.
    # ```ruby
    # document.collect_children
    # ```
    sig { returns(T::Array[Document]) }
    def collect_children; end

    # Marks all children as being persisted.
    # 
    # _@return_ — The flagged children.
    # 
    # Flag all the children.
    # ```ruby
    # document.flag_children_persisted
    # ```
    sig { returns(T::Array[Document]) }
    def flag_children_persisted; end

    # Determines if the document is a subclass of another document.
    # 
    # _@return_ — True if hereditary, false if not.
    # 
    # Check if the document is a subclass
    # ```ruby
    # Square.new.hereditary?
    # ```
    sig { returns(T::Boolean) }
    def hereditary?; end

    # Sets up a child/parent association. This is used for newly created
    # objects so they can be properly added to the graph.
    # 
    # _@param_ `document` — The parent document.
    # 
    # _@return_ — The parent document.
    # 
    # Set the parent document.
    # ```ruby
    # document.parentize(parent)
    # ```
    sig { params(document: Document).returns(Document) }
    def parentize(document); end

        # Remove a child document from this parent. If an embeds one then set to
    # nil, otherwise remove from the embeds many.
    # 
    # This is called from the +RemoveEmbedded+ persistence command.
    # 
    # _@param_ `child` — The child (embedded) document to remove.
    # 
    # Remove the child.
    # ```ruby
    # document.remove_child(child)
    # ```
    sig { params(child: Document).returns(T.untyped) }
    def remove_child(child); end

    # After children are persisted we can call this to move all their changes
    # and flag them as persisted in one call.
    # 
    # _@return_ — The children.
    # 
    # Reset the children.
    # ```ruby
    # document.reset_persisted_children
    # ```
    sig { returns(T::Array[Document]) }
    def reset_persisted_children; end

    # Resets the memoized children on the object. Called internally when an
    # embedded array changes size.
    # 
    # _@return_ — nil.
    # 
    # Reset the memoized children.
    # ```ruby
    # document._reset_memoized_children!
    # ```
    sig { returns(T.nilable(T.any())) }
    def _reset_memoized_children!; end

    # Return the root document in the object graph. If the current document
    # is the root object in the graph it will return self.
    # 
    # _@return_ — The root document in the hierarchy.
    # 
    # Get the root document in the hierarchy.
    # ```ruby
    # document._root
    # ```
    sig { returns(Document) }
    def _root; end

    # Is this document the root document of the hierarchy?
    # 
    # _@return_ — If the document is the root.
    # 
    # Is the document the root?
    # ```ruby
    # document._root?
    # ```
    sig { returns(T::Boolean) }
    def _root?; end

    # Begin the assignment of attributes. While in this block embedded
    # documents will not autosave themselves in order to allow the document to
    # be in a valid state.
    # 
    # _@return_ — The yielded value.
    # 
    # Execute the assignment.
    # ```ruby
    # _assigning do
    #   person.attributes = { :addresses => [ address ] }
    # end
    # ```
    sig { returns(Object) }
    def _assigning; end

    # Is the current thread in assigning mode?
    # 
    # _@return_ — If the thread is assigning.
    # 
    # Is the current thread in assigning mode?
    # ```ruby
    # proxy._assigning?
    # ```
    sig { returns(T::Boolean) }
    def _assigning?; end

    # Execute a block in binding mode.
    # 
    # _@return_ — The return value of the block.
    # 
    # Execute in binding mode.
    # ```ruby
    # binding do
    #   relation.push(doc)
    # end
    # ```
    sig { returns(Object) }
    def _binding; end

    # Is the current thread in binding mode?
    # 
    # _@return_ — If the thread is binding.
    # 
    # Is the current thread in binding mode?
    # ```ruby
    # proxy.binding?
    # ```
    sig { returns(T::Boolean) }
    def _binding?; end

    # Execute a block in building mode.
    # 
    # _@return_ — The return value of the block.
    # 
    # Execute in building mode.
    # ```ruby
    # _building do
    #   relation.push(doc)
    # end
    # ```
    sig { returns(Object) }
    def _building; end

    # Is the current thread in building mode?
    # 
    # _@return_ — If the thread is building.
    # 
    # Is the current thread in building mode?
    # ```ruby
    # proxy._building?
    # ```
    sig { returns(T::Boolean) }
    def _building?; end

    # Is the current thread in creating mode?
    # 
    # _@return_ — If the thread is creating.
    # 
    # Is the current thread in creating mode?
    # ```ruby
    # proxy.creating?
    # ```
    sig { returns(T::Boolean) }
    def _creating?; end

    # Execute a block in loading mode.
    # 
    # _@return_ — The return value of the block.
    # 
    # Execute in loading mode.
    # ```ruby
    # _loading do
    #   relation.push(doc)
    # end
    # ```
    sig { returns(Object) }
    def _loading; end

    # Is the current thread in loading mode?
    # 
    # _@return_ — If the thread is loading.
    # 
    # Is the current thread in loading mode?
    # ```ruby
    # proxy._loading?
    # ```
    sig { returns(T::Boolean) }
    def _loading?; end

    # Print out the cache key. This will append different values on the
    # plural model name.
    # 
    # If new_record?     - will append /new
    # If not             - will append /id-updated_at.to_s(cache_timestamp_format)
    # Without updated_at - will append /id
    # 
    # This is usually called insode a cache() block
    # 
    # _@return_ — the string with or without updated_at
    # 
    # Returns the cache key
    # ```ruby
    # document.cache_key
    # ```
    sig { returns(String) }
    def cache_key; end

    # Returns true if the +Document+ has not been persisted to the database,
    # false if it has. This is determined by the variable @new_record
    # and NOT if the object has an id.
    # 
    # _@return_ — True if new, false if not.
    # 
    # Is the document new?
    # ```ruby
    # person.new_record?
    # ```
    sig { returns(T::Boolean) }
    def new_record?; end

    # Checks if the document has been saved to the database. Returns false
    # if the document has been destroyed.
    # 
    # _@return_ — True if persisted, false if not.
    # 
    # Is the document persisted?
    # ```ruby
    # person.persisted?
    # ```
    sig { returns(T::Boolean) }
    def persisted?; end

    # Returns whether or not the document has been flagged for deletion, but
    # not destroyed yet. Used for atomic pulls of child documents.
    # 
    # _@return_ — If the document is flagged.
    # 
    # Is the document flagged?
    # ```ruby
    # document.flagged_for_destroy?
    # ```
    sig { returns(T::Boolean) }
    def flagged_for_destroy?; end

    # Returns true if the +Document+ has been succesfully destroyed, and false
    # if it hasn't. This is determined by the variable @destroyed and NOT
    # by checking the database.
    # 
    # _@return_ — True if destroyed, false if not.
    # 
    # Is the document destroyed?
    # ```ruby
    # person.destroyed?
    # ```
    sig { returns(T::Boolean) }
    def destroyed?; end

    # Determine if the document can be pushed.
    # 
    # _@return_ — Is the document new and embedded?
    # 
    # Is this pushable?
    # ```ruby
    # person.pushable?
    # ```
    sig { returns(T::Boolean) }
    def pushable?; end

    # Is the document readonly?
    # 
    # _@return_ — If the document is readonly.
    # 
    # Is the document readonly?
    # ```ruby
    # document.readonly?
    # ```
    sig { returns(T::Boolean) }
    def readonly?; end

    # Determine if the document can be set.
    # 
    # _@return_ — Is this document a new embeds one?
    # 
    # Is this settable?
    # ```ruby
    # person.settable?
    # ```
    sig { returns(T::Boolean) }
    def settable?; end

    # Is the document updateable?
    # 
    # _@return_ — If the document is changed and persisted.
    # 
    # Is the document updateable?
    # ```ruby
    # person.updateable?
    # ```
    sig { returns(T::Boolean) }
    def updateable?; end

        sig { returns(T.untyped) }
    def reset_readonly; end

    # Get the shard key fields.
    # 
    # _@return_ — The shard key field names.
    # 
    # Get the shard key fields.
    # ```ruby
    # model.shard_key_fields
    # ```
    # 
    # _@note_ — Refactored from using delegate for class load performance.
    sig { returns(T::Array[String]) }
    def shard_key_fields; end

    # Get the document selector with the defined shard keys.
    # 
    # _@return_ — The shard key selector.
    # 
    # Get the selector for the shard keys.
    # ```ruby
    # person.shard_key_selector
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def shard_key_selector; end

    # Gets the document as a serializable hash, used by ActiveModel's JSON
    # serializer.
    # 
    # _@param_ `options` — The options to pass.
    # 
    # _@return_ — The document, ready to be serialized.
    # 
    # Get the serializable hash.
    # ```ruby
    # document.serializable_hash
    # ```
    # 
    # Get the serializable hash with options.
    # ```ruby
    # document.serializable_hash(:include => :addresses)
    # ```
    sig { params(options: T.nilable(T::Hash[T.untyped, T.untyped])).returns(T::Hash[T.untyped, T.untyped]) }
    def serializable_hash(options = nil); end

        # Get the names of all fields that will be serialized.
    # 
    # _@return_ — The names of the fields.
    # 
    # Get all the field names.
    # ```ruby
    # document.send(:field_names)
    # ```
    sig { params(options: T.untyped).returns(T::Array[String]) }
    def field_names(options); end

    # Serialize a single attribute. Handles associations, fields, and dynamic
    # attributes.
    # 
    # _@param_ `attrs` — The attributes.
    # 
    # _@param_ `name` — The attribute name.
    # 
    # _@param_ `names` — The names of all attributes.
    # 
    # _@param_ `options` — The options.
    # 
    # _@return_ — The attribute.
    # 
    # Serialize the attribute.
    # ```ruby
    # document.serialize_attribute({}, "id" , [ "id" ])
    # ```
    sig do
      params(
        attrs: T::Hash[T.untyped, T.untyped],
        name: String,
        names: T::Array[String],
        options: T::Hash[T.untyped, T.untyped]
      ).returns(Object)
    end
    def serialize_attribute(attrs, name, names, options); end

        # For each of the provided include options, get the association needed and
    # provide it in the hash.
    # 
    # _@param_ `attributes` — The attributes to serialize.
    # 
    # _@param_ `options` — The serialization options.
    # 
    # Serialize the included associations.
    # ```ruby
    # document.serialize_relations({}, :include => :addresses)
    # ```
    sig { params(attributes: T::Hash[T.untyped, T.untyped], options: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
    def serialize_relations(attributes = {}, options = {}); end

    # Since the inclusions can be a hash, symbol, or array of symbols, this is
    # provided as a convenience to parse out the names.
    # 
    # _@param_ `inclusions` — The inclusions.
    # 
    # _@return_ — The names of the included associations.
    # 
    # Get the association names.
    # ```ruby
    # document.relation_names(:include => [ :addresses ])
    # ```
    sig { params(inclusions: T.any(T::Hash[T.untyped, T.untyped], Symbol, T::Array[Symbol])).returns(T::Array[Symbol]) }
    def relation_names(inclusions); end

    # Since the inclusions can be a hash, symbol, or array of symbols, this is
    # provided as a convenience to parse out the options.
    # 
    # _@param_ `inclusions` — The inclusions.
    # 
    # _@param_ `options` — The options.
    # 
    # _@param_ `name` — The name of the association.
    # 
    # _@return_ — The options for the association.
    # 
    # Get the association options.
    # ```ruby
    # document.relation_names(:include => [ :addresses ])
    # ```
    sig { params(inclusions: T.any(T::Hash[T.untyped, T.untyped], Symbol, T::Array[Symbol]), options: T::Hash[T.untyped, T.untyped], name: Symbol).returns(T::Hash[T.untyped, T.untyped]) }
    def relation_options(inclusions, options, name); end

    # Get the atomic selector for the document. This is a hash in the simplest
    # case { "_id" => id }, but can become more complex for embedded documents
    # and documents that use a shard key.
    # 
    # _@return_ — The document's selector.
    # 
    # Get the document's atomic selector.
    # ```ruby
    # document.atomic_selector
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def atomic_selector; end

    # Get the atomic selector for an embedded document.
    # 
    # _@return_ — The embedded document selector.
    # 
    # Get the embedded atomic selector.
    # ```ruby
    # document.embedded_atomic_selector
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def embedded_atomic_selector; end

    # Get the atomic selector for a root document.
    # 
    # _@return_ — The root document selector.
    # 
    # Get the root atomic selector.
    # ```ruby
    # document.root_atomic_selector
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def root_atomic_selector; end

    # Apply the default scoping to the attributes of the document, as long as
    # they are not complex queries.
    # 
    # _@return_ — If default scoping was applied.
    # 
    # Apply the default scoping.
    # ```ruby
    # document.apply_default_scoping
    # ```
    sig { returns(T::Boolean) }
    def apply_default_scoping; end

    # Reloads the +Document+ attributes from the database. If the document has
    # not been saved then an error will get raised if the configuration option
    # was set. This can reload root documents or embedded documents.
    # 
    # _@return_ — The document, reloaded.
    # 
    # Reload the document.
    # ```ruby
    # person.reload
    # ```
    sig { returns(Document) }
    def reload; end

    # Reload the document, determining if it's embedded or not and what
    # behavior to use.
    # 
    # _@return_ — The reloaded attributes.
    # 
    # Reload the document.
    # ```ruby
    # document._reload
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def _reload; end

    # Reload the root document.
    # 
    # _@return_ — The reloaded attributes.
    # 
    # Reload the document.
    # ```ruby
    # document.reload_root_document
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def reload_root_document; end

    # Reload the embedded document.
    # 
    # _@return_ — The reloaded attributes.
    # 
    # Reload the document.
    # ```ruby
    # document.reload_embedded_document
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def reload_embedded_document; end

    # Extract only the desired embedded document from the attributes.
    # 
    # _@param_ `attributes` — The document in the db.
    # 
    # _@return_ — The document's extracted attributes.
    # 
    # Extract the embedded document.
    # ```ruby
    # document.extract_embedded_attributes(attributes)
    # ```
    sig { params(attributes: T::Hash[T.untyped, T.untyped]).returns(T::Hash[T.untyped, T.untyped]) }
    def extract_embedded_attributes(attributes); end

    # Determine if the document itself is embedded in another document via the
    # proper channels. (If it has a parent document.)
    # 
    # _@return_ — True if the document has a parent document.
    # 
    # Is the document embedded?
    # ```ruby
    # address.embedded?
    # ```
    sig { returns(T::Boolean) }
    def embedded?; end

    # Determine if the document is part of an embeds_many association.
    # 
    # _@return_ — True if in an embeds many.
    # 
    # Is the document in an embeds many?
    # ```ruby
    # address.embedded_many?
    # ```
    sig { returns(T::Boolean) }
    def embedded_many?; end

    # Determine if the document is part of an embeds_one association.
    # 
    # _@return_ — True if in an embeds one.
    # 
    # Is the document in an embeds one?
    # ```ruby
    # address.embedded_one?
    # ```
    sig { returns(T::Boolean) }
    def embedded_one?; end

    # Get the association name for this document. If no association was defined
    #   an error will be raised.
    # 
    # _@return_ — The association name.
    # 
    # Get the association name.
    # ```ruby
    # document.association_name
    # ```
    sig { returns(Symbol) }
    def association_name; end

    # Determine if the document is part of an references_many association.
    # 
    # _@return_ — True if in a references many.
    # 
    # Is the document in a references many?
    # ```ruby
    # post.referenced_many?
    # ```
    sig { returns(T::Boolean) }
    def referenced_many?; end

    # Determine if the document is part of an references_one association.
    # 
    # _@return_ — True if in a references one.
    # 
    # Is the document in a references one?
    # ```ruby
    # address.referenced_one?
    # ```
    sig { returns(T::Boolean) }
    def referenced_one?; end

    # Convenience method for iterating through the loaded associations and
    # reloading them.
    # 
    # _@return_ — The association metadata.
    # 
    # Reload the associations.
    # ```ruby
    # document.reload_relations
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def reload_relations; end

    # Returns the association metadata for the supplied name.
    # 
    # _@param_ `name` — The name of the association to find.
    # 
    # _@return_ — The matching association metadata.
    # 
    # Find association metadata by name.
    # ```ruby
    # person.reflect_on_association(:addresses)
    # ```
    sig { params(name: T.any(String, Symbol)).returns(Association) }
    def reflect_on_association(name); end

    # Returns all association metadata for the supplied macros.
    # 
    # _@param_ `macros` — The association macros.
    # 
    # _@return_ — The matching association metadata.
    # 
    # Find multiple association metadata by macro.
    # ```ruby
    # person.reflect_on_all_associations(:embeds_many)
    # ```
    sig { params(macros: T::Array[Symbol]).returns(T::Array[Association]) }
    def reflect_on_all_association(*macros); end

    # This is convenience for libraries still on the old API.
    # 
    # _@return_ — The associations.
    # 
    # Get the associations.
    # ```ruby
    # person.associations
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def associations; end

    # Parse out the attributes and the options from the args passed to a
    # build_ or create_ methods.
    # 
    # _@param_ `args` — The arguments.
    # 
    # _@return_ — The attributes and options.
    # 
    # Parse the args.
    # ```ruby
    # doc.parse_args(:name => "Joe")
    # ```
    sig { params(args: T::Array[T.untyped]).returns(T::Array[T::Hash[T.untyped, T.untyped]]) }
    def parse_args(*args); end

        # Perform all cascading deletes, destroys, or nullifies. Will delegate to
    # the appropriate strategy to perform the operation.
    # 
    # Execute cascades.
    # ```ruby
    # document.apply_delete_dependencies!
    # ```
    sig { returns(T.untyped) }
    def apply_delete_dependencies!; end

            sig { params(association: T.untyped).returns(T.untyped) }
    def _dependent_delete_all!(association); end

            sig { params(association: T.untyped).returns(T.untyped) }
    def _dependent_destroy!(association); end

            sig { params(association: T.untyped).returns(T.untyped) }
    def _dependent_nullify!(association); end

            sig { params(association: T.untyped).returns(T.untyped) }
    def _dependent_restrict_with_exception!(association); end

            sig { params(association: T.untyped).returns(T.untyped) }
    def _dependent_restrict_with_error!(association); end

    # Builds the related document and creates the association unless the
    # document is nil, then sets the association on this document.
    # 
    # _@param_ `name` — The name of the association.
    # 
    # _@param_ `object` — The id or attributes to use.
    # 
    # _@param_ `association` — The association metadata.
    # 
    # _@param_ `selected_fields` — Fields which were retrieved via #only. If selected_fields is specified, fields not listed in it will not be accessible in the built document.
    # 
    # _@return_ — The association.
    # 
    # Build the association.
    # ```ruby
    # person.__build__(:addresses, { :_id => 1 }, association)
    # ```
    sig do
      params(
        name: T.any(String, Symbol),
        object: T.any(T::Hash[T.untyped, T.untyped], BSON::ObjectId),
        association: Association,
        selected_fields: T.nilable(T::Hash[T.untyped, T.untyped])
      ).returns(Proxy)
    end
    def __build__(name, object, association, selected_fields = nil); end

    # Create an association from an object and association metadata.
    # 
    # _@param_ `object` — The association target.
    # 
    # _@param_ `association` — The association metadata.
    # 
    # _@param_ `selected_fields` — Fields which were retrieved via #only. If selected_fields is specified, fields not listed in it will not be accessible in the created association document.
    # 
    # _@return_ — The association.
    # 
    # Create the association.
    # ```ruby
    # person.create_relation(document, association)
    # ```
    sig { params(object: T.any(Document, T::Array[Document]), association: Association, selected_fields: T.nilable(T::Hash[T.untyped, T.untyped])).returns(Proxy) }
    def create_relation(object, association, selected_fields = nil); end

        # Resets the criteria inside the association proxy. Used by many-to-many
    # associations to keep the underlying ids array in sync.
    # 
    # _@param_ `name` — The name of the association.
    # 
    # Reset the association criteria.
    # ```ruby
    # person.reset_relation_criteria(:preferences)
    # ```
    sig { params(name: Symbol).returns(T.untyped) }
    def reset_relation_criteria(name); end

    # Set the supplied association to an instance variable on the class with the
    # provided name. Used as a helper just for code cleanliness.
    # 
    # _@param_ `name` — The name of the association.
    # 
    # _@param_ `relation` — The association to set.
    # 
    # _@return_ — The association.
    # 
    # Set the proxy on the document.
    # ```ruby
    # person.set(:addresses, addresses)
    # ```
    sig { params(name: T.any(String, Symbol), relation: Proxy).returns(Proxy) }
    def set_relation(name, relation); end

    # Get the association. Extracted out from the getter method to avoid
    # infinite recursion when overriding the getter.
    # 
    # _@param_ `name` — The name of the association.
    # 
    # _@param_ `association` — The association metadata.
    # 
    # _@param_ `object` — The object used to build the association.
    # 
    # _@param_ `reload` — If the association is to be reloaded.
    # 
    # _@return_ — The association.
    # 
    # Get the association.
    # ```ruby
    # document.get_relation(:name, association)
    # ```
    sig do
      params(
        name: Symbol,
        association: Association,
        object: Object,
        reload: T::Boolean
      ).returns(Proxy)
    end
    def get_relation(name, association, object, reload = false); end

    # Returns a subset of __selected_fields attribute applicable to the
    # (embedded) association with the given key, or nil if no projection
    # is to be performed.
    # 
    # For example, if __selected_fields is {'a' => 1, 'b.c' => 2, 'b.c.f' => 3},
    # and assoc_key is 'b', return value would be {'c' => 2, 'c.f' => 3}.
    # 
    # _@param_ `assoc_key`
    sig { params(assoc_key: String).returns(T.nilable(T::Hash[T.untyped, T.untyped])) }
    def _mongoid_filter_selected_fields(assoc_key); end

            sig { params(object: T.untyped, association: T.untyped).returns(T::Boolean) }
    def needs_no_database_query?(object, association); end

    # Is the current code executing without autobuild functionality?
    # 
    # _@return_ — If autobuild is disabled.
    # 
    # Is autobuild disabled?
    # ```ruby
    # document.without_autobuild?
    # ```
    sig { returns(T::Boolean) }
    def without_autobuild?; end

    # Yield to the block with autobuild functionality turned off.
    # 
    # _@return_ — The result of the yield.
    # 
    # Execute without autobuild.
    # ```ruby
    # document.without_autobuild do
    #   document.name
    # end
    # ```
    sig { returns(Object) }
    def without_autobuild; end

    # Is the document able to be synced on the inverse side? This is only if
    # the key has changed and the association bindings have not been run.
    # 
    # _@param_ `association` — The association metadata.
    # 
    # _@return_ — If we can sync.
    # 
    # Are the foreign keys syncable?
    # ```ruby
    # document._syncable?(association)
    # ```
    sig { params(association: Association).returns(T::Boolean) }
    def _syncable?(association); end

    # Get the synced foreign keys.
    # 
    # _@return_ — The synced foreign keys.
    # 
    # Get the synced foreign keys.
    # ```ruby
    # document._synced
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def _synced; end

    # Has the document been synced for the foreign key?
    # 
    # _@param_ `foreign_key` — The foreign key.
    # 
    # _@return_ — If we can sync.
    # 
    # Has the document been synced?
    # ```ruby
    # document._synced?
    # ```
    sig { params(foreign_key: String).returns(T::Boolean) }
    def _synced?(foreign_key); end

    # Update the inverse keys on destroy.
    # 
    # _@param_ `association` — The association.
    # 
    # _@return_ — The updated values.
    # 
    # Update the inverse keys.
    # ```ruby
    # document.remove_inverse_keys(association)
    # ```
    sig { params(association: Association).returns(Object) }
    def remove_inverse_keys(association); end

    # Update the inverse keys for the association.
    # 
    # _@param_ `association` — The document association.
    # 
    # _@return_ — The updated values.
    # 
    # Update the inverse keys
    # ```ruby
    # document.update_inverse_keys(association)
    # ```
    sig { params(association: Association).returns(Object) }
    def update_inverse_keys(association); end

        # Reset the given counter using the .count() query from the
    # db. This method is usuful in case that a counter got
    # corrupted, or a new counter was added to the collection.
    # 
    # _@param_ `counters` — One or more counter caches to reset
    # 
    # Reset the given counter cache
    # ```ruby
    # post.reset_counters(:comments)
    # ```
    sig { params(counters: T.any(Symbol, T::Array[T.untyped])).returns(T.untyped) }
    def reset_counters(*counters); end

    # Used to prevent infinite loops in associated autosaves.
    # 
    # _@return_ — Has the document already been autosaved?
    # 
    # Is the document autosaved?
    # ```ruby
    # document.autosaved?
    # ```
    sig { returns(T::Boolean) }
    def autosaved?; end

        # Begin the associated autosave.
    # 
    # Begin autosave.
    # ```ruby
    # document.__autosaving__
    # ```
    sig { returns(T.untyped) }
    def __autosaving__; end

        # Check if there is changes for auto-saving
    # 
    #   document.changed_for_autosave?
    # 
    # Return true if there is changes on self or in
    # ```ruby
    # autosaved associations.
    # ```
    sig { params(doc: T.untyped).returns(T::Boolean) }
    def changed_for_autosave?(doc); end

    # Execute operations atomically (in a single database call) for everything
    # that would happen inside the block. This method supports nesting further
    # calls to atomically, which will behave according to the options described
    # below.
    # 
    # An option join_context can be given which, when true, will merge the
    # operations declared by the given block with the atomically block wrapping
    # the current invocation for the same document, if one exists. If this
    # block or any other block sharing the same context raises before
    # persisting, then all the operations of that context will not be
    # persisted, and will also be reset in memory.
    # 
    # When join_context is false, the given block of operations will be
    # persisted independently of other contexts. Failures in other contexts will
    # not affect this one, so long as this block was able to run and persist
    # changes.
    # 
    # The default value of join_context is set by the global configuration
    # option join_contexts, whose own default is false.
    # 
    # _@param_ `join_context` — Join the context (i.e. merge declared atomic operations) of the atomically block wrapping this one for the same document, if one exists.
    # 
    # _@return_ — If the operation succeeded.
    # 
    # Execute the operations atomically.
    # ```ruby
    # document.atomically do
    #   document.set(name: "Tool").inc(likes: 10)
    # end
    # ```
    # 
    # Execute some inner operations atomically, but independently from the outer operations.
    # ```ruby
    # 
    # document.atomically do
    #   document.inc likes: 10
    #   document.atomically join_context: false do
    #     # The following is persisted to the database independently.
    #     document.unset :origin
    #   end
    #   document.atomically join_context: true do
    #     # The following is persisted along with the other outer operations.
    #     document.inc member_count: 3
    #   end
    #   document.set name: "Tool"
    # end
    # ```
    sig { params(join_context: T.nilable(T::Boolean)).returns(T::Boolean) }
    def atomically(join_context: nil); end

        # Raise an error if validation failed.
    # 
    # Raise the validation error.
    # ```ruby
    # Person.fail_due_to_validation!(person)
    # ```
    sig { returns(T.untyped) }
    def fail_due_to_validation!; end

        # Raise an error if a callback failed.
    # 
    # _@param_ `method` — The method being called.
    # 
    # Raise the callback error.
    # ```ruby
    # Person.fail_due_to_callback!(person, :create!)
    # ```
    sig { params(method: Symbol).returns(T.untyped) }
    def fail_due_to_callback!(method); end

    # Are we executing an atomically block on the current document?
    # 
    # _@return_ — If we are current executing atomically.
    # 
    # Are we executing atomically?
    # ```ruby
    # document.executing_atomically?
    # ```
    sig { returns(T::Boolean) }
    def executing_atomically?; end

    # Post process the persistence operation.
    # 
    # _@param_ `result` — The result of the operation.
    # 
    # _@param_ `options` — The options.
    # 
    # _@return_ — true.
    # 
    # Post process the persistence operation.
    # ```ruby
    # document.post_process_persist(true)
    # ```
    sig { params(result: Object, options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
    def post_process_persist(result, options = {}); end

    # Prepare an atomic persistence operation. Yields an empty hash to be sent
    # to the update.
    # 
    # _@return_ — The result of the operation.
    # 
    # Prepare the atomic operation.
    # ```ruby
    # document.prepare_atomic_operation do |coll, selector, opts|
    #   ...
    # end
    # ```
    sig { returns(Object) }
    def prepare_atomic_operation; end

    # Process the atomic operations - this handles the common behavior of
    # iterating through each op, getting the aliased field name, and removing
    # appropriate dirty changes.
    # 
    # _@param_ `operations` — The atomic operations.
    # 
    # _@return_ — The operations.
    # 
    # Process the atomic operations.
    # ```ruby
    # document.process_atomic_operations(pulls) do |field, value|
    #   ...
    # end
    # ```
    sig { params(operations: T::Hash[T.untyped, T.untyped]).returns(T::Hash[T.untyped, T.untyped]) }
    def process_atomic_operations(operations); end

        # Remove the dirty changes for all fields changed in the current atomic
    # context.
    # 
    # Remove the current atomic context's dirty changes.
    # ```ruby
    # document._mongoid_remove_atomic_context_changes
    # ```
    sig { returns(T.untyped) }
    def _mongoid_remove_atomic_context_changes; end

        # Reset the attributes for all fields changed in the current atomic
    # context.
    # 
    # Reset the current atomic context's changed attributes.
    # ```ruby
    # document._mongoid_reset_atomic_context_changes!
    # ```
    sig { returns(T.untyped) }
    def _mongoid_reset_atomic_context_changes!; end

        # Push a new atomic context onto the stack.
    # 
    # Push a new atomic context onto the stack.
    # ```ruby
    # document._mongoid_push_atomic_context
    # ```
    sig { returns(T.untyped) }
    def _mongoid_push_atomic_context; end

        # Pop an atomic context off the stack.
    # 
    # Pop an atomic context off the stack.
    # ```ruby
    # document._mongoid_pop_atomic_context
    # ```
    sig { returns(T.untyped) }
    def _mongoid_pop_atomic_context; end

    # Return the current atomic context's changed fields.
    # 
    # _@return_ — The changed fields.
    # 
    # Return the current atomic context's changed fields.
    # ```ruby
    # document._mongoid_atomic_context_changed_fields
    # ```
    sig { returns(T::Array[T.untyped]) }
    def _mongoid_atomic_context_changed_fields; end

        # If we are in an atomically block, add the operations to the delayed group,
    # otherwise persist immediately.
    # 
    # _@param_ `operation` — The operation.
    # 
    # Persist immediately or delay the operations.
    # ```ruby
    # document.persist_or_delay_atomic_operation(ops)
    # ```
    sig { params(operation: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
    def persist_or_delay_atomic_operation(operation); end

        # Persist the atomic operations.
    # 
    # _@param_ `operations` — The atomic operations.
    # 
    # Persist the atomic operations.
    # ```ruby
    # persist_atomic_operations(ops)
    # ```
    sig { params(operations: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
    def persist_atomic_operations(operations); end

    # Perform an $unset operation on the provided fields and in the
    # values in the document in memory.
    # 
    # _@param_ `fields` — The names of the fields to unset.
    # 
    # _@return_ — The document.
    # 
    # Unset the values.
    # ```ruby
    # document.unset(:first_name, :last_name, :middle)
    # ```
    sig { params(fields: T::Array[T.any(String, Symbol)]).returns(Document) }
    def unset(*fields); end

    # Perform an upsert of the document. If the document does not exist in the
    # database, then Mongo will insert a new one, otherwise the fields will get
    # overwritten with new values on the existing document.
    # 
    # _@param_ `options` — The validation options.
    # 
    # _@return_ — True.
    # 
    # Upsert the document.
    # ```ruby
    # document.upsert
    # ```
    sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
    def upsert(options = {}); end

    # Prepare the upsert for execution.
    # 
    # _@param_ `options` — The options hash.
    # 
    # _@return_ — If the operation succeeded.
    # 
    # Prepare the upsert
    # ```ruby
    # document.prepare_upsert do
    #   collection.find(selector).update(as_document)
    # end
    # ```
    sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
    def prepare_upsert(options = {}); end

    # Update a single attribute and persist the entire document.
    # This skips validation but fires the callbacks.
    # 
    # _@param_ `name` — The name of the attribute.
    # 
    # _@param_ `value` — The new value of the attribute.a
    # 
    # _@return_ — True if save was successfull, false if not.
    # 
    # Update the attribute.
    # ```ruby
    # person.update_attribute(:title, "Sir")
    # ```
    sig { params(name: T.any(Symbol, String), value: Object).returns(T::Boolean) }
    def update_attribute(name, value); end

    # Update the document attributes in the database.
    # 
    # _@param_ `attributes` — The attributes to update.
    # 
    # _@return_ — True if validation passed, false if not.
    # 
    # Update the document's attributes
    # ```ruby
    # document.update(:title => "Sir")
    # ```
    sig { params(attributes: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
    def update(attributes = {}); end

    # Update the document attributes in the database and raise an error if
    # validation failed.
    # 
    # _@param_ `attributes` — The attributes to update.
    # 
    # _@return_ — True if validation passed.
    # 
    # Update the document's attributes.
    # ```ruby
    # document.update!(:title => "Sir")
    # ```
    sig { params(attributes: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
    def update!(attributes = {}); end

    # Initialize the atomic updates.
    # 
    # _@return_ — The updates and conflicts.
    # 
    # Initialize the atomic updates.
    # ```ruby
    # document.init_atomic_updates
    # ```
    sig { returns(T::Array[T::Hash[T.untyped, T.untyped]]) }
    def init_atomic_updates; end

    # Prepare the update for execution. Validates and runs callbacks, etc.
    # 
    # _@param_ `options` — The options.
    # 
    # _@return_ — The result of the update.
    # 
    # Prepare for update.
    # ```ruby
    # document.prepare_update do
    #   collection.update(atomic_selector)
    # end
    # ```
    sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
    def prepare_update(options = {}); end

    # Update the document in the database.
    # 
    # _@param_ `options` — Options to pass to update.
    # 
    # _@return_ — True if succeeded, false if not.
    # 
    # Update an existing document.
    # ```ruby
    # document.update
    # ```
    sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
    def update_document(options = {}); end

    # Perform a $set operation on the provided field/value pairs and set the
    # values in the document in memory.
    # 
    # The key can be a dotted sequence of keys, in which case the
    # top level field is treated as a nested hash and any missing keys
    # are created automatically:
    # 
    # Performing a nested set like this merges values of intermediate keys:
    # 
    # If the top level field was not a hash, its original value is discarded
    # and the field is replaced with a hash.
    # 
    # Note that unlike MongoDB's $set, Mongoid's set writes out the entire
    # field even when setting a subset of the field via the nested hash
    # semantics. This means performing a $set with nested hash semantics
    # can overwrite other hash keys within the top level field in the database.
    # 
    # _@param_ `setters` — The field/value pairs to set.
    # 
    # _@return_ — The document.
    # 
    # Set the values.
    # ```ruby
    # document.set(title: "sir", dob: Date.new(1970, 1, 1))
    # ```
    # 
    # Set the values using nested hash semantics.
    # ```ruby
    # document.set('author.title' => 'Sir')
    # # => document.author == {'title' => 'Sir'}
    # ```
    # 
    # Nested hash value merging.
    # ```ruby
    # document.set('author.title' => 'Sir')
    # document.set('author.name' => 'Linus Torvalds')
    # # => document.author == {'title' => 'Sir', 'name' => 'Linus Torvalds'}
    # ```
    # 
    # Nested hash overwriting a non-hash value.
    # ```ruby
    # document.set('author' => 'John Doe')
    # document.set('author.title' => 'Sir')
    # # => document.author == {'title' => 'Sir'}
    # ```
    sig { params(setters: T::Hash[T.untyped, T.untyped]).returns(Document) }
    def set(setters); end

    # Save the document - will perform an insert if the document is new, and
    # update if not.
    # 
    # _@param_ `options` — Options to pass to the save.
    # 
    # _@return_ — True is success, false if not.
    # 
    # Save the document.
    # ```ruby
    # document.save
    # ```
    sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
    def save(options = {}); end

    # Save the document - will perform an insert if the document is new, and
    # update if not. If a validation error occurs an error will get raised.
    # 
    # _@param_ `options` — Options to pass to the save.
    # 
    # _@return_ — True if validation passed.
    # 
    # Save the document.
    # ```ruby
    # document.save!
    # ```
    sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
    def save!(options = {}); end

    # Rename fields from one value to another via $rename.
    # 
    # _@param_ `renames` — The rename pairs of old name/new name.
    # 
    # _@return_ — The document.
    # 
    # Rename the fields.
    # ```ruby
    # document.rename(title: "salutation", name: "nombre")
    # ```
    # 
    # _@note_ — This does not work for fields in embeds many associations.
    sig { params(renames: T::Hash[T.untyped, T.untyped]).returns(Document) }
    def rename(renames); end

    # Add the single values to the arrays only if the value does not already
    # exist in the array.
    # 
    # _@param_ `adds` — The field/value pairs to add.
    # 
    # _@return_ — The document.
    # 
    # Add the values to the sets.
    # ```ruby
    # document.add_to_set(names: "James", aliases: "Bond")
    # ```
    sig { params(adds: T::Hash[T.untyped, T.untyped]).returns(Document) }
    def add_to_set(adds); end

    # Push a single value or multiple values onto arrays.
    # 
    # _@param_ `pushes` — The $push operations.
    # 
    # _@return_ — The document.
    # 
    # Push a single value onto arrays.
    # ```ruby
    # document.push(names: "James", aliases: "007")
    # ```
    # 
    # Push multiple values onto arrays.
    # ```ruby
    # document.push(names: [ "James", "Bond" ])
    # ```
    sig { params(pushes: T::Hash[T.untyped, T.untyped]).returns(Document) }
    def push(pushes); end

    # Pull single values from the provided arrays.
    # 
    # _@param_ `pulls` — The field/value pull pairs.
    # 
    # _@return_ — The document.
    # 
    # Pull a value from the array.
    # ```ruby
    # document.pull(names: "Jeff", levels: 5)
    # ```
    # 
    # _@note_ — If duplicate values are found they will all be pulled.
    sig { params(pulls: T::Hash[T.untyped, T.untyped]).returns(Document) }
    def pull(pulls); end

    # Pull multiple values from the provided array fields.
    # 
    # _@param_ `pulls` — The pull all operations.
    # 
    # _@return_ — The document.
    # 
    # Pull values from the arrays.
    # ```ruby
    # document.pull_all(names: [ "Jeff", "Bob" ], levels: [ 5, 6 ])
    # ```
    sig { params(pulls: T::Hash[T.untyped, T.untyped]).returns(Document) }
    def pull_all(pulls); end

    # Takes the provided selector and atomic operations and replaces the
    # indexes of the embedded documents with the positional operator when
    # needed.
    # 
    # _@param_ `selector` — The selector.
    # 
    # _@param_ `operations` — The update operations.
    # 
    # _@param_ `processed` — The processed update operations.
    # 
    # _@return_ — The new operations.
    # 
    # Process the operations.
    # ```ruby
    # positionally(
    #   { "_id" => 1, "addresses._id" => 2 },
    #   { "$set" => { "addresses.0.street" => "hobrecht" }}
    # )
    # ```
    # 
    # _@note_ — The only time we can accurately know when to use the positional
    # operator is at the exact time we are going to persist something. So
    # we can tell by the selector that we are sending if it is actually
    # possible to use the positional operator at all. For example, if the
    # selector is: { "_id" => 1 }, then we could not use the positional
    # operator for updating embedded documents since there would never be a
    # match - we base whether we can based on the number of levels deep the
    # selector goes, and if the id values are not nil.
    sig { params(selector: T::Hash[T.untyped, T.untyped], operations: T::Hash[T.untyped, T.untyped], processed: T::Hash[T.untyped, T.untyped]).returns(T::Hash[T.untyped, T.untyped]) }
    def positionally(selector, operations, processed = {}); end

                    sig { params(keys: T.untyped, operations: T.untyped, processed: T.untyped).returns(T.untyped) }
    def process_operations(keys, operations, processed); end

                    sig { params(keys: T.untyped, update: T.untyped, updates: T.untyped).returns(T.untyped) }
    def process_updates(keys, update, updates = {}); end

                sig { params(keys: T.untyped, position: T.untyped).returns(T.untyped) }
    def replace_index(keys, position); end

    # Pop or shift items from arrays using the $pop operator.
    # 
    # _@param_ `pops` — The field/value pop operations.
    # 
    # _@return_ — The document.
    # 
    # Pop items from an array.
    # ```ruby
    # document.pop(aliases: 1)
    # ```
    # 
    # Shift items in the array.
    # ```ruby
    # document.pop(aliases: -1)
    # ```
    # 
    # Multiple pops in one call.
    # ```ruby
    # document.pop(names: 1, aliases: 1)
    # ```
    sig { params(pops: T::Hash[T.untyped, T.untyped]).returns(Document) }
    def pop(pops); end

    # Performs an atomic $bit operation on the field with the provided hash
    # of bitwise ops to execute in order.
    # 
    # _@param_ `operations` — The bitwise operations.
    # 
    # _@return_ — The document.
    # 
    # Execute the bitwise operations.
    # ```ruby
    # person.bit(age: { :and => 12 }, val: { and: 10, or: 12 })
    # ```
    sig { params(operations: T::Hash[T.untyped, T.untyped]).returns(Document) }
    def bit(operations); end

    # Increment the provided fields by the corresponding values. Values can
    # be positive or negative, and if no value exists for the field it will
    # be set with the provided value.
    # 
    # _@param_ `increments` — The field/inc increment pairs.
    # 
    # _@return_ — The document.
    # 
    # Increment the fields.
    # ```ruby
    # document.inc(score: 10, place: 1, lives: -10)
    # ```
    sig { params(increments: T::Hash[T.untyped, T.untyped]).returns(Document) }
    def inc(increments); end

    # Remove the document from the database with callbacks.
    # 
    # _@param_ `options` — Options to pass to destroy.
    # 
    # _@return_ — True if successful, false if not.
    # 
    # Destroy a document.
    # ```ruby
    # document.destroy
    # ```
    sig { params(options: T.nilable(T::Hash[T.untyped, T.untyped])).returns(T::Boolean) }
    def destroy(options = nil); end

            sig { params(options: T.untyped).returns(T.untyped) }
    def destroy!(options = {}); end

    # Remove the document from the database.
    # 
    # _@param_ `options` — Options to pass to remove.
    # 
    # _@return_ — True.
    # 
    # Remove the document.
    # ```ruby
    # document.remove
    # ```
    sig { params(options: T::Hash[T.untyped, T.untyped]).returns(TrueClass) }
    def delete(options = {}); end

    # Get the atomic deletes for the operation.
    # 
    # _@return_ — The atomic deletes.
    # 
    # Get the atomic deletes.
    # ```ruby
    # document.atomic_deletes
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def atomic_deletes; end

    # Delete the embedded document.
    # 
    # _@param_ `options` — The deletion options.
    # 
    # _@return_ — If the operation succeeded.
    # 
    # Delete the embedded document.
    # ```ruby
    # document.delete_as_embedded
    # ```
    sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
    def delete_as_embedded(options = {}); end

    # Delete the root document.
    # 
    # _@return_ — If the document was removed.
    # 
    # Delete the root document.
    # ```ruby
    # document.delete_as_root
    # ```
    sig { returns(T::Boolean) }
    def delete_as_root; end

    # Are we needing to notify the parent document of the deletion.
    # 
    # _@param_ `options` — The delete options.
    # 
    # _@return_ — If the parent should be notified.
    # 
    # Are we notifying the parent.
    # ```ruby
    # document.notifying_parent?(suppress: true)
    # ```
    sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
    def notifying_parent?(options = {}); end

    # Prepare the delete operation.
    # 
    # _@return_ — The result of the block.
    # 
    # Prepare the delete operation.
    # ```ruby
    # document.prepare_delete do
    #   collection.find(atomic_selector).remove
    # end
    # ```
    sig { returns(Object) }
    def prepare_delete; end

    # Insert a new document into the database. Will return the document
    # itself whether or not the save was successful.
    # 
    # _@param_ `options` — Options to pass to insert.
    # 
    # _@return_ — The persisted document.
    # 
    # Insert a document.
    # ```ruby
    # document.insert
    # ```
    sig { params(options: T::Hash[T.untyped, T.untyped]).returns(Document) }
    def insert(options = {}); end

    # Get the atomic insert for embedded documents, either a push or set.
    # 
    # _@return_ — The insert ops.
    # 
    # Get the inserts.
    # ```ruby
    # document.inserts
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def atomic_inserts; end

    # Insert the embedded document.
    # 
    # _@return_ — The document.
    # 
    # Insert the document as embedded.
    # ```ruby
    # document.insert_as_embedded
    # ```
    sig { returns(Document) }
    def insert_as_embedded; end

    # Insert the root document.
    # 
    # _@return_ — The document.
    # 
    # Insert the document as root.
    # ```ruby
    # document.insert_as_root
    # ```
    sig { returns(Document) }
    def insert_as_root; end

    # Post process an insert, which sets the new record attribute to false
    # and flags all the children as persisted.
    # 
    # _@return_ — true.
    # 
    # Post process the insert.
    # ```ruby
    # document.post_process_insert
    # ```
    sig { returns(T::Boolean) }
    def post_process_insert; end

    # Prepare the insert for execution. Validates and runs callbacks, etc.
    # 
    # _@param_ `options` — The options.
    # 
    # _@return_ — The document.
    # 
    # Prepare for insertion.
    # ```ruby
    # document.prepare_insert do
    #   collection.insert(as_document)
    # end
    # ```
    sig { params(options: T::Hash[T.untyped, T.untyped]).returns(Document) }
    def prepare_insert(options = {}); end

    # Determines if this document has the attributes to match the supplied
    # MongoDB selector. Used for matching on embedded associations.
    # 
    # _@param_ `selector` — The MongoDB selector.
    # 
    # _@return_ — True if matches, false if not.
    # 
    # Does the document match?
    # ```ruby
    # document._matches?(:title => { "$in" => [ "test" ] })
    # ```
    sig { params(selector: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
    def _matches?(selector); end

    # Apply all default values to the document which are not procs.
    # 
    # _@return_ — The names of the non-proc defaults.
    # 
    # Apply all the non-proc defaults.
    # ```ruby
    # model.apply_pre_processed_defaults
    # ```
    sig { returns(T::Array[String]) }
    def apply_pre_processed_defaults; end

    # Apply all default values to the document which are procs.
    # 
    # _@return_ — The names of the proc defaults.
    # 
    # Apply all the proc defaults.
    # ```ruby
    # model.apply_post_processed_defaults
    # ```
    sig { returns(T::Array[String]) }
    def apply_post_processed_defaults; end

        # Applies a single default value for the given name.
    # 
    # _@param_ `name` — The name of the field.
    # 
    # Apply a single default.
    # ```ruby
    # model.apply_default("name")
    # ```
    sig { params(name: String).returns(T.untyped) }
    def apply_default(name); end

        # Apply all the defaults at once.
    # 
    # Apply all the defaults.
    # ```ruby
    # model.apply_defaults
    # ```
    sig { returns(T.untyped) }
    def apply_defaults; end

    # Returns an array of names for the attributes available on this object.
    # 
    # Provides the field names in an ORM-agnostic way. Rails v3.1+ uses this
    # method to automatically wrap params in JSON requests.
    # 
    # _@return_ — The field names
    # 
    # Get the field names
    # ```ruby
    # docment.attribute_names
    # ```
    sig { returns(T::Array[String]) }
    def attribute_names; end

    # Get the name of the provided field as it is stored in the database.
    # Used in determining if the field is aliased or not.
    # 
    # _@param_ `name` — The name to get.
    # 
    # _@return_ — The name of the field as it's stored in the db.
    # 
    # Get the database field name.
    # ```ruby
    # model.database_field_name(:authorization)
    # ```
    sig { params(name: T.any(String, Symbol)).returns(String) }
    def database_field_name(name); end

    # Is the provided field a lazy evaluation?
    # 
    # _@param_ `field` — The field.
    # 
    # _@param_ `value` — The current value.
    # 
    # _@return_ — If we set the field lazily.
    # 
    # If the field is lazy settable.
    # ```ruby
    # doc.lazy_settable?(field, nil)
    # ```
    sig { params(field: T.any(Standard, ForeignKey), value: Object).returns(T::Boolean) }
    def lazy_settable?(field, value); end

    # Is the document using object ids?
    # 
    # _@return_ — Using object ids.
    # 
    # Is the document using object ids?
    # ```ruby
    # model.using_object_ids?
    # ```
    # 
    # _@note_ — Refactored from using delegate for class load performance.
    sig { returns(T::Boolean) }
    def using_object_ids?; end

    # Evolve the document into an object id.
    # 
    # _@return_ — The document's id.
    # 
    # Evolve the document.
    # ```ruby
    # document.__evolve_object_id__
    # ```
    sig { returns(Object) }
    def __evolve_object_id__; end

    # Determine if an attribute is present.
    # 
    # _@param_ `name` — The name of the attribute.
    # 
    # _@return_ — True if present, false if not.
    # 
    # Is the attribute present?
    # ```ruby
    # person.attribute_present?("title")
    # ```
    sig { params(name: T.any(String, Symbol)).returns(T::Boolean) }
    def attribute_present?(name); end

    # Get the attributes that have not been cast.
    # 
    # _@return_ — The uncast attributes.
    # 
    # Get the attributes before type cast.
    # ```ruby
    # document.attributes_before_type_cast
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def attributes_before_type_cast; end

    # Does the document have the provided attribute?
    # 
    # _@param_ `name` — The name of the attribute.
    # 
    # _@return_ — If the key is present in the attributes.
    # 
    # Does the document have the attribute?
    # ```ruby
    # model.has_attribute?(:name)
    # ```
    sig { params(name: T.any(String, Symbol)).returns(T::Boolean) }
    def has_attribute?(name); end

    # Does the document have the provided attribute before it was assigned
    # and type cast?
    # 
    # _@param_ `name` — The name of the attribute.
    # 
    # _@return_ — If the key is present in the
    # attributes_before_type_cast.
    # 
    # Does the document have the attribute before it was assigned?
    # ```ruby
    # model.has_attribute_before_type_cast?(:name)
    # ```
    sig { params(name: T.any(String, Symbol)).returns(T::Boolean) }
    def has_attribute_before_type_cast?(name); end

    # Read a value from the document attributes. If the value does not exist
    # it will return nil.
    # 
    # _@param_ `name` — The name of the attribute to get.
    # 
    # _@return_ — The value of the attribute.
    # 
    # Read an attribute.
    # ```ruby
    # person.read_attribute(:title)
    # ```
    # 
    # Read an attribute (alternate syntax.)
    # ```ruby
    # person[:title]
    # ```
    sig { params(name: T.any(String, Symbol)).returns(Object) }
    def read_attribute(name); end

    # Read a value from the attributes before type cast. If the value has not
    # yet been assigned then this will return the attribute's existing value
    # using read_raw_attribute.
    # 
    # _@param_ `name` — The name of the attribute to get.
    # 
    # _@return_ — The value of the attribute before type cast, if
    # available. Otherwise, the value of the attribute.
    # 
    # Read an attribute before type cast.
    # ```ruby
    # person.read_attribute_before_type_cast(:price)
    # ```
    sig { params(name: T.any(String, Symbol)).returns(Object) }
    def read_attribute_before_type_cast(name); end

        # Remove a value from the +Document+ attributes. If the value does not exist
    # it will fail gracefully.
    # 
    # _@param_ `name` — The name of the attribute to remove.
    # 
    # Remove the attribute.
    # ```ruby
    # person.remove_attribute(:title)
    # ```
    sig { params(name: T.any(String, Symbol)).returns(T.untyped) }
    def remove_attribute(name); end

        # Write a single attribute to the document attribute hash. This will
    # also fire the before and after update callbacks, and perform any
    # necessary typecasting.
    # 
    # _@param_ `name` — The name of the attribute to update.
    # 
    # _@param_ `value` — The value to set for the attribute.
    # 
    # Write the attribute.
    # ```ruby
    # person.write_attribute(:title, "Mr.")
    # ```
    # 
    # Write the attribute (alternate syntax.)
    # ```ruby
    # person[:title] = "Mr."
    # ```
    sig { params(name: T.any(String, Symbol), value: Object).returns(T.untyped) }
    def write_attribute(name, value); end

        # Allows you to set all the attributes for a particular mass-assignment security role
    # by passing in a hash of attributes with keys matching the attribute names
    # (which again matches the column names)  and the role name using the :as option.
    # To bypass mass-assignment security you can use the :without_protection => true option.
    # 
    # _@param_ `attrs` — The new attributes to set.
    # 
    # Assign the attributes.
    # ```ruby
    # person.assign_attributes(:title => "Mr.")
    # ```
    # 
    # Assign the attributes (with a role).
    # ```ruby
    # person.assign_attributes({ :title => "Mr." }, :as => :admin)
    # ```
    sig { params(attrs: T.nilable(T::Hash[T.untyped, T.untyped])).returns(T.untyped) }
    def assign_attributes(attrs = nil); end

        # Writes the supplied attributes hash to the document. This will only
    # overwrite existing attributes if they are present in the new +Hash+, all
    # others will be preserved.
    # 
    # _@param_ `attrs` — The new attributes to set.
    # 
    # Write the attributes.
    # ```ruby
    # person.write_attributes(:title => "Mr.")
    # ```
    # 
    # Write the attributes (alternate syntax.)
    # ```ruby
    # person.attributes = { :title => "Mr." }
    # ```
    sig { params(attrs: T.nilable(T::Hash[T.untyped, T.untyped])).returns(T.untyped) }
    def write_attributes(attrs = nil); end

    # Determine if the attribute is missing from the document, due to loading
    # it from the database with missing fields.
    # 
    # _@param_ `name` — The name of the attribute.
    # 
    # _@return_ — If the attribute is missing.
    # 
    # Is the attribute missing?
    # ```ruby
    # document.attribute_missing?("test")
    # ```
    sig { params(name: String).returns(T::Boolean) }
    def attribute_missing?(name); end

    # Return type-casted attributes.
    # 
    # _@return_ — The hash with keys and values of the type-casted attributes.
    # 
    # Type-casted attributes.
    # ```ruby
    # document.typed_attributes
    # ```
    sig { returns(Object) }
    def typed_attributes; end

                sig { params(name: T.untyped, selection: T.untyped, field: T.untyped).returns(T::Boolean) }
    def selection_excluded?(name, selection, field); end

                sig { params(name: T.untyped, selection: T.untyped, field: T.untyped).returns(T::Boolean) }
    def selection_included?(name, selection, field); end

        # Does the string contain dot syntax for accessing hashes?
    # 
    # _@return_ — If the string contains a "."
    # 
    # Is the string in dot syntax.
    # ```ruby
    # model.hash_dot_syntax?
    # ```
    sig { params(string: T.untyped).returns(T::Boolean) }
    def hash_dot_syntax?(string); end

    # Return the typecasted value for a field.
    # 
    # _@param_ `key` — The field name.
    # 
    # _@param_ `value` — The uncast value.
    # 
    # _@return_ — The cast value.
    # 
    # Get the value typecasted.
    # ```ruby
    # person.typed_value_for(:title, :sir)
    # ```
    sig { params(key: T.any(String, Symbol), value: Object).returns(Object) }
    def typed_value_for(key, value); end

            sig { params(name: T.untyped).returns(T.untyped) }
    def read_raw_attribute(name); end

        # Validates an attribute value as being assignable to the specified field.
    # 
    # For now, only Hash and Array fields are validated, and the value is
    # being checked to be of an appropriate type (i.e. either Hash or Array,
    # respectively, or nil).
    # 
    # This method takes the name of the field as stored in the document
    # in the database, not (necessarily) the Ruby method name used to read/write
    # the said field.
    # 
    # _@param_ `field_name` — The name of the field.
    # 
    # _@param_ `value` — The value to be validated.
    sig { params(field_name: T.any(String, Symbol), value: Object).returns(T.untyped) }
    def validate_attribute_value(field_name, value); end

                sig { params(name: T.untyped, value: T.untyped).returns(T.untyped) }
    def lookup_attribute_presence(name, value); end

    # Are we able to write the attribute with the provided name?
    # 
    # _@param_ `name` — The name of the field.
    # 
    # _@return_ — If the document is new, or if the field is not
    # readonly.
    # 
    # Can we write the attribute?
    # ```ruby
    # model.attribute_writable?(:title)
    # ```
    sig { params(name: T.any(String, Symbol)).returns(T::Boolean) }
    def attribute_writable?(name); end

                sig { params(name: T.untyped, value: T.untyped).returns(T.untyped) }
    def as_writable_attribute!(name, value = :nil); end

        sig { params(name: T.untyped).returns(T::Boolean) }
    def _loaded?(name); end

        sig { params(name: T.untyped).returns(T::Boolean) }
    def projected_field?(name); end

        # Process the provided attributes casting them to their proper values if a
    # field exists for them on the document. This will be limited to only the
    # attributes provided in the suppied +Hash+ so that no extra nil values get
    # put into the document's attributes.
    # 
    # _@param_ `attrs` — The attributes to set.
    # 
    # Process the attributes.
    # ```ruby
    # person.process_attributes(:title => "sir", :age => 40)
    # ```
    sig { params(attrs: T.nilable(T::Hash[T.untyped, T.untyped])).returns(T.untyped) }
    def process_attributes(attrs = nil); end

    # If the key provided is the name of an association or a nested attribute, we
    # need to wait until all other attributes are set before processing
    # these.
    # 
    # _@param_ `key` — The name of the attribute.
    # 
    # _@param_ `value` — The value of the attribute.
    # 
    # _@return_ — True if pending, false if not.
    # 
    # Is the attribute pending?
    # ```ruby
    # document.pending_attribute?(:name, "Durran")
    # ```
    sig { params(key: Symbol, value: Object).returns(T::Boolean) }
    def pending_attribute?(key, value); end

    # Get all the pending associations that need to be set.
    # 
    # _@return_ — The pending associations in key/value pairs.
    # 
    # Get the pending associations.
    # ```ruby
    # document.pending_relations
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def pending_relations; end

    # Get all the pending nested attributes that need to be set.
    # 
    # _@return_ — The pending nested attributes in key/value pairs.
    # 
    # Get the pending nested attributes.
    # ```ruby
    # document.pending_nested
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def pending_nested; end

        # If the attribute is dynamic, add a field for it with a type of object
    # and then either way set the value.
    # 
    # _@param_ `name` — The name of the field.
    # 
    # _@param_ `value` — The value of the field.
    # 
    # Process the attribute.
    # ```ruby
    # document.process_attribute(name, value)
    # ```
    sig { params(name: Symbol, value: Object).returns(T.untyped) }
    def process_attribute(name, value); end

        # Process all the pending nested attributes that needed to wait until
    # ids were set to fire off.
    # 
    # Process the nested attributes.
    # ```ruby
    # document.process_nested
    # ```
    sig { returns(T.untyped) }
    def process_nested; end

        # Process all the pending items, then clear them out.
    # 
    # Process the pending items.
    # ```ruby
    # document.process_pending
    # ```
    sig { returns(T.untyped) }
    def process_pending; end

        # Process all the pending associations that needed to wait until ids were set
    # to fire off.
    # 
    # Process the associations.
    # ```ruby
    # document.process_relations
    # ```
    sig { returns(T.untyped) }
    def process_relations; end

    # Execute a block within the context of a session.
    # 
    # _@param_ `options` — The session options. Please see the driver documentation for the available session options.
    # 
    # _@return_ — The result of calling the block.
    # 
    # Execute some operations in the context of a session.
    # ```ruby
    # band.with_session(causal_consistency: true) do
    #   band.records << Record.create
    #   band.name = 'FKA Twigs'
    #   band.save
    #   band.reload
    # end
    # ```
    # 
    # _@note_ — You cannot do any operations in the block using models or objects
    # that use a different client; the block will execute all operations
    # in the context of the implicit session and operations on any models using
    # another client will fail. For example, if you set a client using store_in on a
    # particular model and execute an operation on it in the session context block,
    # that operation can't use the block's session and an error will be raised.
    # An error will also be raised if sessions are nested.
    sig { params(options: T::Hash[T.untyped, T.untyped]).returns(Object) }
    def with_session(options = {}); end

        sig { returns(T.untyped) }
    def _session; end

        # Change the persistence context for this object during the block.
    # 
    # _@param_ `options_or_context` — The storage options or a persistence context.
    # 
    # Save the current document to a different collection.
    # ```ruby
    # model.with(collection: "bands") do |m|
    #   m.save
    # end
    # ```
    sig { params(options_or_context: T.any(T::Hash[T.untyped, T.untyped], Mongoid::PersistenceContext), block: T.untyped).returns(T.untyped) }
    def with(options_or_context, &block); end

            sig { params(parent: T.untyped).returns(T.untyped) }
    def collection(parent = nil); end

        sig { returns(T.untyped) }
    def collection_name; end

        sig { returns(T.untyped) }
    def mongo_client; end

        sig { returns(T.untyped) }
    def persistence_context; end

            sig { params(options_or_context: T.untyped).returns(T.untyped) }
    def set_persistence_context(options_or_context); end

                sig { params(original_cluster: T.untyped, context: T.untyped).returns(T.untyped) }
    def clear_persistence_context(original_cluster = nil, context = nil); end

    # Get the changed attributes for the document.
    # 
    # _@return_ — The changed attributes.
    # 
    # Get the changed attributes.
    # ```ruby
    # model.changed
    # ```
    sig { returns(T::Array[String]) }
    def changed; end

    # Has the document changed?
    # 
    # _@return_ — If the document is changed.
    # 
    # Has the document changed?
    # ```ruby
    # model.changed?
    # ```
    sig { returns(T::Boolean) }
    def changed?; end

    # Have any children (embedded documents) of this document changed?
    # 
    # _@return_ — If any children have changed.
    # 
    # Have any children changed?
    # ```ruby
    # model.children_changed?
    # ```
    sig { returns(T::Boolean) }
    def children_changed?; end

    # Get the attribute changes.
    # 
    # _@return_ — The attribute changes.
    # 
    # Get the attribute changes.
    # ```ruby
    # model.changed_attributes
    # ```
    sig { returns(T::Hash[String, Object]) }
    def changed_attributes; end

    # Get all the changes for the document.
    # 
    # _@return_ — The changes.
    # 
    # Get all the changes.
    # ```ruby
    # model.changes
    # ```
    sig { returns(T::Hash[String, T::Array[T.any(Object, Object)]]) }
    def changes; end

        # Call this method after save, so the changes can be properly switched.
    # 
    # This will unset the memoized children array, set new record to
    # false, set the document as validated, and move the dirty changes.
    # 
    # Move the changes to previous.
    # ```ruby
    # person.move_changes
    # ```
    sig { returns(T.untyped) }
    def move_changes; end

        # Things that need to execute after a document has been persisted.
    # 
    # Handle post persistence.
    # ```ruby
    # document.post_persist
    # ```
    sig { returns(T.untyped) }
    def post_persist; end

    # Get the previous changes on the document.
    # 
    # _@return_ — The previous changes.
    # 
    # Get the previous changes.
    # ```ruby
    # model.previous_changes
    # ```
    sig { returns(T::Hash[String, T::Array[T.any(Object, Object)]]) }
    def previous_changes; end

        # Remove a change from the dirty attributes hash. Used by the single field
    # atomic updators.
    # 
    # _@param_ `name` — The name of the field.
    # 
    # Remove a flagged change.
    # ```ruby
    # model.remove_change(:field)
    # ```
    sig { params(name: T.any(Symbol, String)).returns(T.untyped) }
    def remove_change(name); end

    # Gets all the new values for each of the changed fields, to be passed to
    # a MongoDB $set modifier.
    # 
    # _@return_ — A +Hash+ of atomic setters.
    # 
    # Get the setters for the atomic updates.
    # ```ruby
    # person = Person.new(:title => "Sir")
    # person.title = "Madam"
    # person.setters # returns { "title" => "Madam" }
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def setters; end

    # Get the old and new value for the provided attribute.
    # 
    # _@param_ `attr` — The name of the attribute.
    # 
    # _@return_ — The old and new values.
    # 
    # Get the attribute change.
    # ```ruby
    # model.attribute_change("name")
    # ```
    sig { params(attr: String).returns(T::Array[Object]) }
    def attribute_change(attr); end

    # Determine if a specific attribute has changed.
    # 
    # _@param_ `attr` — The name of the attribute.
    # 
    # _@return_ — Whether the attribute has changed.
    # 
    # Has the attribute changed?
    # ```ruby
    # model.attribute_changed?("name")
    # ```
    sig { params(attr: String).returns(T::Boolean) }
    def attribute_changed?(attr); end

    # Get whether or not the field has a different value from the default.
    # 
    # _@param_ `attr` — The name of the attribute.
    # 
    # _@return_ — If the attribute differs.
    # 
    # Is the field different from the default?
    # ```ruby
    # model.attribute_changed_from_default?
    # ```
    sig { params(attr: String).returns(T::Boolean) }
    def attribute_changed_from_default?(attr); end

        # Get the previous value for the attribute.
    # 
    # _@param_ `attr` — The attribute name.
    # 
    # Get the previous value.
    # ```ruby
    # model.attribute_was("name")
    # ```
    sig { params(attr: String).returns(T.untyped) }
    def attribute_was(attr); end

    # Flag an attribute as going to change.
    # 
    # _@param_ `attr` — The name of the attribute.
    # 
    # _@return_ — The old value.
    # 
    # Flag the attribute.
    # ```ruby
    # model.attribute_will_change!("name")
    # ```
    sig { params(attr: String).returns(Object) }
    def attribute_will_change!(attr); end

    # Set the attribute back to its old value.
    # 
    # _@param_ `attr` — The name of the attribute.
    # 
    # _@return_ — The old value.
    # 
    # Reset the attribute.
    # ```ruby
    # model.reset_attribute!("name")
    # ```
    sig { params(attr: String).returns(Object) }
    def reset_attribute!(attr); end

            sig { params(attr: T.untyped).returns(T.untyped) }
    def reset_attribute_to_default!(attr); end

        # Add the document as an atomic pull.
    # 
    # _@param_ `document` — The embedded document to pull.
    # 
    # Add the atomic pull.
    # ```ruby
    # person.add_atomic_pull(address)
    # ```
    sig { params(document: Document).returns(T.untyped) }
    def add_atomic_pull(document); end

    # Add an atomic unset for the document.
    # 
    # _@param_ `document` — The child document.
    # 
    # _@return_ — The children.
    # 
    # Add an atomic unset.
    # ```ruby
    # document.add_atomic_unset(doc)
    # ```
    sig { params(document: Document).returns(T::Array[Document]) }
    def add_atomic_unset(document); end

        # Returns path of the attribute for modification
    # 
    # _@return_ — The path to the document attribute in the database
    # 
    # Get path of the attribute
    # ```ruby
    # address.atomic_attribute_name(:city)
    # ```
    sig { params(name: T.untyped).returns(String) }
    def atomic_attribute_name(name); end

    # For array fields these are the pushes that need to happen.
    # 
    # _@return_ — The array pushes.
    # 
    # Get the array pushes.
    # ```ruby
    # person.atomic_array_pushes
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def atomic_array_pushes; end

    # For array fields these are the pulls that need to happen.
    # 
    # _@return_ — The array pulls.
    # 
    # Get the array pulls.
    # ```ruby
    # person.atomic_array_pulls
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def atomic_array_pulls; end

    # For array fields these are the unique adds that need to happen.
    # 
    # _@return_ — The array add_to_sets.
    # 
    # Get the array unique adds.
    # ```ruby
    # person.atomic_array_add_to_sets
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def atomic_array_add_to_sets; end

        # Get all the atomic updates that need to happen for the current
    # +Document+. This includes all changes that need to happen in the
    # entire hierarchy that exists below where the save call was made.
    # 
    # _@return_ — The updates and their modifiers.
    # 
    # Get the updates that need to occur.
    # ```ruby
    # person.atomic_updates(children)
    # ```
    # 
    # _@note_ — MongoDB does not allow "conflicting modifications" to be
    # performed in a single operation. Conflicting modifications are
    # detected by the 'haveConflictingMod' function in MongoDB.
    # Examination of the code suggests that two modifications (a $set
    # and a $push with $each, for example) conflict if:
    #   (1) the key paths being modified are equal.
    #   (2) one key path is a prefix of the other.
    # So a $set of 'addresses.0.street' will conflict with a $push and $each
    # to 'addresses', and we will need to split our update into two
    # pieces. We do not, however, attempt to match MongoDB's logic
    # exactly. Instead, we assume that two updates conflict if the
    # first component of the two key paths matches.
    sig { params(_use_indexes: T.untyped).returns(T::Hash[T.untyped, T.untyped]) }
    def atomic_updates(_use_indexes = false); end

    # Get the removal modifier for the document. Will be nil on root
    # documents, $unset on embeds_one, $set on embeds_many.
    # 
    # _@return_ — The pull or unset operation.
    # 
    # Get the removal operator.
    # ```ruby
    # name.atomic_delete_modifier
    # ```
    sig { returns(String) }
    def atomic_delete_modifier; end

    # Get the insertion modifier for the document. Will be nil on root
    # documents, $set on embeds_one, $push on embeds_many.
    # 
    # _@return_ — The pull or set operator.
    # 
    # Get the insert operation.
    # ```ruby
    # name.atomic_insert_modifier
    # ```
    sig { returns(String) }
    def atomic_insert_modifier; end

    # Return the path to this +Document+ in JSON notation, used for atomic
    # updates via $set in MongoDB.
    # 
    # _@return_ — The path to the document in the database.
    # 
    # Get the path to this document.
    # ```ruby
    # address.atomic_path
    # ```
    sig { returns(String) }
    def atomic_path; end

    # Returns the positional operator of this document for modification.
    # 
    # _@return_ — The positional operator with indexes.
    # 
    # Get the positional operator.
    # ```ruby
    # address.atomic_position
    # ```
    sig { returns(String) }
    def atomic_position; end

    # Get the atomic paths utility for this document.
    # 
    # _@return_ — The associated path.
    # 
    # Get the atomic paths.
    # ```ruby
    # document.atomic_paths
    # ```
    sig { returns(Object) }
    def atomic_paths; end

    # Get all the attributes that need to be pulled.
    # 
    # _@return_ — The $pullAll operations.
    # 
    # Get the pulls.
    # ```ruby
    # person.atomic_pulls
    # ```
    sig { returns(T::Array[T::Hash[T.untyped, T.untyped]]) }
    def atomic_pulls; end

    # Get all the push attributes that need to occur.
    # 
    # _@return_ — The $push and $each operations.
    # 
    # Get the pushes.
    # ```ruby
    # person.atomic_pushes
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def atomic_pushes; end

    # Get all the attributes that need to be set.
    # 
    # _@return_ — The $set operations.
    # 
    # Get the sets.
    # ```ruby
    # person.atomic_sets
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def atomic_sets; end

    # Get all the attributes that need to be unset.
    # 
    # _@return_ — The $unset operations.
    # 
    # Get the unsets.
    # ```ruby
    # person.atomic_unsets
    # ```
    sig { returns(T::Array[T::Hash[T.untyped, T.untyped]]) }
    def atomic_unsets; end

    # Get all the atomic sets that have had their saves delayed.
    # 
    # _@return_ — The delayed $sets.
    # 
    # Get the delayed atomic sets.
    # ```ruby
    # person.delayed_atomic_sets
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def delayed_atomic_sets; end

    # Get a hash of atomic pulls that are pending.
    # 
    # _@return_ — name/document pairs.
    # 
    # Get the atomic pulls.
    # ```ruby
    # document.delayed_atomic_pulls
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def delayed_atomic_pulls; end

    # Get the delayed atomic unsets.
    # 
    # _@return_ — The atomic unsets
    # 
    # Get the delayed atomic unsets.
    # ```ruby
    # document.delayed_atomic_unsets
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def delayed_atomic_unsets; end

    # Flag the document as destroyed and return the atomic path.
    # 
    # _@return_ — The atomic path.
    # 
    # Flag destroyed and return path.
    # ```ruby
    # document.flag_as_destroyed
    # ```
    sig { returns(String) }
    def flag_as_destroyed; end

    # Get the flagged destroys.
    # 
    # _@return_ — The flagged destroys.
    # 
    # Get the flagged destroy.
    # ```ruby
    # document.flagged_destroys
    # ```
    sig { returns(T::Array[Proc]) }
    def flagged_destroys; end

    # Process all the pending flagged destroys from nested attributes.
    # 
    # _@return_ — The cleared array.
    # 
    # Process all the pending flagged destroys.
    # ```ruby
    # document.process_flagged_destroys
    # ```
    sig { returns(T::Array[T.untyped]) }
    def process_flagged_destroys; end

        # Generates the atomic updates in the correct order.
    # 
    # _@param_ `mods` — The atomic modifications.
    # 
    # _@param_ `doc` — The document to update for.
    # 
    # Generate the updates.
    # ```ruby
    # model.generate_atomic_updates(mods, doc)
    # ```
    sig { params(mods: Modifiers, doc: Document).returns(T.untyped) }
    def generate_atomic_updates(mods, doc); end

    # Get the atomic updates for a touch operation. Should only include the
    # updated_at field and the optional extra field.
    # 
    # _@param_ `field` — The optional field.
    # 
    # _@return_ — The atomic updates.
    # 
    # Get the touch atomic updates.
    # ```ruby
    # document.touch_atomic_updates
    # ```
    sig { params(field: T.nilable(Symbol)).returns(T::Hash[T.untyped, T.untyped]) }
    def touch_atomic_updates(field = nil); end

    # Returns the value of attribute __selected_fields.
    sig { returns(T.untyped) }
    attr_accessor :__selected_fields

        # Returns the value of attribute new_record.
    sig { returns(T.untyped) }
    attr_reader :new_record

    module ClassMethods
      # Performs class equality checking.
      # 
      # _@param_ `other` — The other object to compare with.
      # 
      # _@return_ — True if the classes are equal, false if not.
      # 
      # Compare the classes.
      # ```ruby
      # document === other
      # ```
      sig { params(other: T.any(Document, Object)).returns(T::Boolean) }
      def ===(other); end

      # Instantiate a new object, only when loaded from the database or when
      # the attributes have already been typecast.
      # 
      # _@param_ `attrs` — The hash of attributes to instantiate with.
      # 
      # _@param_ `selected_fields` — The selected fields from the criteria.
      # 
      # _@return_ — A new document.
      # 
      # Create the document.
      # ```ruby
      # Person.instantiate(:title => "Sir", :age => 30)
      # ```
      sig { params(attrs: T.nilable(T::Hash[T.untyped, T.untyped]), selected_fields: T.nilable(Integer)).returns(Document) }
      def instantiate(attrs = nil, selected_fields = nil); end

      # Returns all types to query for when using this class as the base.
      # 
      # _@return_ — All subclasses of the current document.
      # 
      # Get the types.
      # ```ruby
      # document._types
      # ```
      sig { returns(T::Array[Class]) }
      def _types; end

            # Clear the @_type cache. This is generally called when changing the discriminator
      # key/value on a class.
      # 
      # Get the types.
      # ```ruby
      # document._mongoid_clear_types
      # ```
      sig { returns(T.untyped) }
      def _mongoid_clear_types; end

      # Set the i18n scope to overwrite ActiveModel.
      # 
      # _@return_ — :mongoid
      sig { returns(Symbol) }
      def i18n_scope; end

      # Returns the logger
      # 
      # _@return_ — The configured logger or a default Logger instance.
      # 
      # Get the logger.
      # ```ruby
      # Person.logger
      # ```
      sig { returns(Logger) }
      def logger; end
    end
  end

  # This module contains the behavior of Mongoid's clone/dup of documents.
  module Equality
    # Default comparison is via the string version of the id.
    # 
    # _@param_ `other` — The document to compare with.
    # 
    # _@return_ — -1, 0, 1.
    # 
    # Compare two documents.
    # ```ruby
    # person <=> other_person
    # ```
    sig { params(other: Document).returns(Integer) }
    def <=>(other); end

    # Performs equality checking on the document ids. For more robust
    # equality checking please override this method.
    # 
    # _@param_ `other` — The other object to compare with.
    # 
    # _@return_ — True if the ids are equal, false if not.
    # 
    # Compare for equality.
    # ```ruby
    # document == other
    # ```
    sig { params(other: T.any(Document, Object)).returns(T::Boolean) }
    def ==(other); end

    # Performs class equality checking.
    # 
    # _@param_ `other` — The other object to compare with.
    # 
    # _@return_ — True if the classes are equal, false if not.
    # 
    # Compare the classes.
    # ```ruby
    # document === other
    # ```
    sig { params(other: T.any(Document, Object)).returns(T::Boolean) }
    def ===(other); end

    # Delegates to ==. Used when needing checks in hashes.
    # 
    # _@param_ `other` — The object to check against.
    # 
    # _@return_ — True if equal, false if not.
    # 
    # Perform equality checking.
    # ```ruby
    # document.eql?(other)
    # ```
    sig { params(other: T.any(Document, Object)).returns(T::Boolean) }
    def eql?(other); end
  end

  # This module defines the finder methods that hang off the document at the
  # class level.
  # 
  # @since 4.0.0
  module Findable
    extend Forwardable

    # Returns a count of records in the database.
    # If you want to specify conditions use where.
    # 
    # _@return_ — The number of matching documents.
    # 
    # Get the count of matching documents.
    # ```ruby
    # Person.count
    # Person.where(title: "Sir").count
    # ```
    sig { returns(Integer) }
    def count; end

    # Returns an estimated count of records in the database.
    # 
    # _@return_ — The number of matching documents.
    # 
    # Get the count of matching documents.
    # ```ruby
    # Person.estimated_count
    # ```
    sig { returns(Integer) }
    def estimated_count; end

    # Returns true if count is zero
    # 
    # _@return_ — If the collection is empty.
    # 
    # Are there no saved documents for this model?
    # ```ruby
    # Person.empty?
    # ```
    sig { returns(T::Boolean) }
    def empty?; end

    # Returns true if there are on document in database based on the
    # provided arguments.
    # 
    # _@return_ — If any documents exist for the conditions.
    # 
    # Do any documents exist for the conditions?
    # ```ruby
    # Person.exists?
    # ```
    sig { returns(T::Boolean) }
    def exists?; end

    # Finds a +Document+ or multiple documents by their _id values.
    # 
    # If a single non-Array argument is given, this argument is interpreted
    # as the _id value of a document to find. If there is a matching document
    # in the database, this document is returned; otherwise, if the
    # +raise_not_found_error+ Mongoid configuration option is truthy
    # (which is the default), +Errors::DocumentNotFound+ is raised, and if
    # +raise_not_found_error+ is falsy, +find+ returns +nil+.
    # 
    # If multiple arguments are given, or an Array argument is given, the
    # array is flattened and each array element is interpreted as the _id
    # value of the document to find. Mongoid then attempts to retrieve all
    # documents with the provided _id values. The return value is an array
    # of found documents. Each document appears one time in the returned array,
    # even if its _id is given multiple times in the argument to +find+.
    # If the +raise_not_found_error+ Mongoid configuration option is truthy,
    # +Errors::DocumentNotFound+ exception is raised if any of the specified
    # _ids were not found in the database. If the ++raise_not_found_error+
    # Mongoid configuration option is falsy, only those documents which are
    # found are returned; if no documents are found, the return value is an
    # empty array.
    # 
    # Note that MongoDB does not allow the _id field to be an array.
    # 
    # The argument undergoes customary Mongoid type conversions based on
    # the type declared for the _id field. By default the _id field is a
    # +BSON::ObjectId+; this allows strings to be passed to +find+ and the
    # strings will be transparently converted to +BSON::ObjectId+ instances
    # during query construction.
    # 
    # The +find+ method takes into account the default scope defined on the
    # model class, if any.
    # 
    # _@param_ `args` — The _id values to find or an array thereof.
    # 
    # _@return_ — A document or matching documents.
    sig { params(args: T.any(Object, T::Array[Object])).returns(T.nilable(T.any(Document, T::Array[Document]))) }
    def find(*args); end

    # Find the first +Document+ given the conditions.
    # If a matching Document is not found and
    # Mongoid.raise_not_found_error is true it raises
    # Mongoid::Errors::DocumentNotFound, return null nil elsewise.
    # 
    # and Mongoid.raise_not_found_error is true.
    # 
    # _@param_ `attrs` — The attributes to check.
    # 
    # _@return_ — A matching document.
    # 
    # Find the document by attribute other than id
    # ```ruby
    # Person.find_by(:username => "superuser")
    # ```
    sig { params(attrs: T::Hash[T.untyped, T.untyped]).returns(T.nilable(Document)) }
    def find_by(attrs = {}); end

    # Find the first +Document+ given the conditions, or raises
    # Mongoid::Errors::DocumentNotFound
    # 
    # _@param_ `attrs` — The attributes to check.
    # 
    # _@return_ — A matching document.
    # 
    # Find the document by attribute other than id
    # ```ruby
    # Person.find_by(:username => "superuser")
    # ```
    sig { params(attrs: T::Hash[T.untyped, T.untyped]).returns(Document) }
    def find_by!(attrs = {}); end

    # Find the first +Document+ given the conditions.
    # 
    # _@return_ — The first matching document.
    # 
    # Find the first document.
    # ```ruby
    # Person.first
    # ```
    sig { returns(Document) }
    def first; end

    # Find the last +Document+ given the conditions.
    # 
    # _@return_ — The last matching document.
    # 
    # Find the last document.
    # ```ruby
    # Person.last
    # ```
    sig { returns(Document) }
    def last; end
  end

  # Contains logging behavior.
  module Loggable
    # Get the logger.
    # 
    # _@return_ — The logger.
    # 
    # Get the logger.
    # ```ruby
    # Loggable.logger
    # ```
    # 
    # _@note_ — Will try to grab Rails' logger first before creating a new logger
    # with stderr.
    sig { returns(Logger) }
    def logger; end

    # Set the logger.
    # 
    # _@param_ `logger` — The logger to set.
    # 
    # _@return_ — The new logger.
    # 
    # Set the logger.
    # ```ruby
    # Loggable.logger = Logger.new(STDERR)
    # ```
    sig { params(logger: Logger).returns(Logger) }
    def logger=(logger); end

    # Gets the default Mongoid logger - stderr.
    # 
    # _@return_ — The default logger.
    # 
    # Get the default logger.
    # ```ruby
    # Loggable.default_logger
    # ```
    sig { returns(Logger) }
    def default_logger; end

    # Get the Rails logger if loaded in a Rails application, otherwise nil.
    # 
    # _@return_ — The Rails logger.
    # 
    # Get Rails' logger.
    # ```ruby
    # Loggable.rails_logger
    # ```
    sig { returns(Logger) }
    def rails_logger; end
  end

  # This module contains behavior for all Mongoid scoping - named scopes,
  # default scopes, and criteria accessors via scoped and unscoped.
  # 
  # @since 4.0.0
  module Scopable
    extend ActiveSupport::Concern

    # Apply the default scoping to the attributes of the document, as long as
    # they are not complex queries.
    # 
    # _@return_ — If default scoping was applied.
    # 
    # Apply the default scoping.
    # ```ruby
    # document.apply_default_scoping
    # ```
    sig { returns(T::Boolean) }
    def apply_default_scoping; end

    module ClassMethods
      # Returns a hash of all the scopes defined for this class, including
      # scopes defined on ancestor classes.
      # 
      # _@return_ — The scopes defined for this class
      # 
      # Get the defined scopes for a class
      # ```ruby
      # class Band
      #   include Mongoid::Document
      #   field :active, type: Boolean
      # 
      #   scope :active, -> { where(active: true) }
      # end
      # Band.scopes
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def scopes; end

      # Add a default scope to the model. This scope will be applied to all
      # criteria unless #unscoped is specified.
      # 
      # _@param_ `value` — The default scope.
      # 
      # _@return_ — The default scope.
      # 
      # Define a default scope with a criteria.
      # ```ruby
      # class Band
      #   include Mongoid::Document
      #   field :active, type: Boolean
      #   default_scope where(active: true)
      # end
      # ```
      # 
      # Define a default scope with a proc.
      # ```ruby
      # class Band
      #   include Mongoid::Document
      #   field :active, type: Boolean
      #   default_scope ->{ where(active: true) }
      # end
      # ```
      sig { params(value: T.nilable(T.any(Proc, Criteria))).returns(Proc) }
      def default_scope(value = nil); end

      # Is the class able to have the default scope applied?
      # 
      # _@return_ — If the default scope can be applied.
      # 
      # Can the default scope be applied?
      # ```ruby
      # Band.default_scopable?
      # ```
      sig { returns(T::Boolean) }
      def default_scopable?; end

      # Get a queryable, either the last one on the scope stack or a fresh one.
      # 
      # _@return_ — The queryable.
      # 
      # Get a queryable.
      # ```ruby
      # Model.queryable
      # ```
      sig { returns(Criteria) }
      def queryable; end

            # Create a scope that can be accessed from the class level or chained to
      # criteria by the provided name.
      # 
      # _@param_ `name` — The name of the scope.
      # 
      # _@param_ `value` — The conditions of the scope.
      # 
      # Create named scopes.
      # ```ruby
      # 
      # class Person
      #   include Mongoid::Document
      #   field :active, type: Boolean
      #   field :count, type: Integer
      # 
      #   scope :active, -> { where(active: true) }
      #   scope :at_least, ->(count){ where(:count.gt => count) }
      # end
      # ```
      sig { params(name: Symbol, value: Proc, block: T.untyped).returns(T.untyped) }
      def scope(name, value, &block); end

      # Get a criteria for the document with normal scoping.
      # 
      # _@param_ `options` — Query options for the criteria.
      # 
      # _@return_ — A scoped criteria.
      # 
      # Get the criteria.
      # ```ruby
      # Band.scoped(skip: 10)
      # ```
      # 
      # _@note_ — This will force the default scope to be applied.
      sig { params(options: T.nilable(T::Hash[T.untyped, T.untyped])).returns(Criteria) }
      def scoped(options = nil); end

      # Get the criteria without the default scoping applied.
      # 
      # _@return_ — The unscoped criteria or result of the
      # block.
      # 
      # Get the unscoped criteria.
      # ```ruby
      # Band.unscoped
      # ```
      # 
      # Yield to block with no default scoping.
      # ```ruby
      # Band.unscoped do
      #   Band.where(name: "Depeche Mode")
      # end
      # ```
      # 
      # _@note_ — This will force the default scope to be removed.
      sig { returns(T.any(Criteria, Object)) }
      def unscoped; end

      # Get a criteria with the default scope applied, if possible.
      # 
      # _@return_ — The criteria.
      # 
      # Get a criteria with the default scope.
      # ```ruby
      # Model.with_default_scope
      # ```
      sig { returns(Criteria) }
      def with_default_scope; end

      # Pushes the provided criteria onto the scope stack, and removes it after the
      # provided block is yielded.
      # 
      # _@param_ `criteria` — The criteria to apply.
      # 
      # _@return_ — The yielded criteria.
      # 
      # Yield to the criteria.
      # ```ruby
      # Person.with_scope(criteria)
      # ```
      sig { params(criteria: Criteria).returns(Criteria) }
      def with_scope(criteria); end

      # Execute the block without applying the default scope.
      # 
      # _@return_ — The result of the block.
      # 
      # Execute without the default scope.
      # ```ruby
      # Band.without_default_scope do
      #   Band.where(name: "Depeche Mode")
      # end
      # ```
      sig { returns(Object) }
      def without_default_scope; end

            # Warns or raises exception if overriding another scope or method.
      # 
      # _@param_ `name` — The name of the scope.
      # 
      # Warn or raise error if name exists.
      # ```ruby
      # Model.valid_scope_name?("test")
      # ```
      sig { params(name: T.any(String, Symbol)).returns(T.untyped) }
      def check_scope_name(name); end

            # Checks if the intended scope is a valid object, either a criteria or
      # proc with a criteria.
      # 
      # _@param_ `value` — The intended scope.
      # 
      # Check if the scope is valid.
      # ```ruby
      # Model.check_scope_validity({})
      # ```
      sig { params(value: Object).returns(T.untyped) }
      def check_scope_validity(value); end

      # Defines the actual class method that will execute the scope when
      # called.
      # 
      # _@param_ `name` — The method/scope name.
      # 
      # _@return_ — The defined method.
      # 
      # Define the scope class method.
      # ```ruby
      # Model.define_scope_method(:active)
      # ```
      sig { params(name: Symbol).returns(Method) }
      def define_scope_method(name); end

            # Process the default scope value. If one already exists, we merge the
      # new one into the old one.
      # 
      # _@param_ `value` — The default scope value.
      # 
      # Process the default scope.
      # ```ruby
      # Model.process_default_scope(value)
      # ```
      sig { params(value: T.any(Criteria, Proc)).returns(T.untyped) }
      def process_default_scope(value); end
    end
  end

  # This module contains the behavior for getting the various states a
  # document can transition through.
  module Stateful
    # Returns true if the +Document+ has not been persisted to the database,
    # false if it has. This is determined by the variable @new_record
    # and NOT if the object has an id.
    # 
    # _@return_ — True if new, false if not.
    # 
    # Is the document new?
    # ```ruby
    # person.new_record?
    # ```
    sig { returns(T::Boolean) }
    def new_record?; end

    # Checks if the document has been saved to the database. Returns false
    # if the document has been destroyed.
    # 
    # _@return_ — True if persisted, false if not.
    # 
    # Is the document persisted?
    # ```ruby
    # person.persisted?
    # ```
    sig { returns(T::Boolean) }
    def persisted?; end

    # Returns whether or not the document has been flagged for deletion, but
    # not destroyed yet. Used for atomic pulls of child documents.
    # 
    # _@return_ — If the document is flagged.
    # 
    # Is the document flagged?
    # ```ruby
    # document.flagged_for_destroy?
    # ```
    sig { returns(T::Boolean) }
    def flagged_for_destroy?; end

    # Returns true if the +Document+ has been succesfully destroyed, and false
    # if it hasn't. This is determined by the variable @destroyed and NOT
    # by checking the database.
    # 
    # _@return_ — True if destroyed, false if not.
    # 
    # Is the document destroyed?
    # ```ruby
    # person.destroyed?
    # ```
    sig { returns(T::Boolean) }
    def destroyed?; end

    # Determine if the document can be pushed.
    # 
    # _@return_ — Is the document new and embedded?
    # 
    # Is this pushable?
    # ```ruby
    # person.pushable?
    # ```
    sig { returns(T::Boolean) }
    def pushable?; end

    # Is the document readonly?
    # 
    # _@return_ — If the document is readonly.
    # 
    # Is the document readonly?
    # ```ruby
    # document.readonly?
    # ```
    sig { returns(T::Boolean) }
    def readonly?; end

    # Determine if the document can be set.
    # 
    # _@return_ — Is this document a new embeds one?
    # 
    # Is this settable?
    # ```ruby
    # person.settable?
    # ```
    sig { returns(T::Boolean) }
    def settable?; end

    # Is the document updateable?
    # 
    # _@return_ — If the document is changed and persisted.
    # 
    # Is the document updateable?
    # ```ruby
    # person.updateable?
    # ```
    sig { returns(T::Boolean) }
    def updateable?; end

        sig { returns(T.untyped) }
    def reset_readonly; end

    # Sets the attribute destroyed
    # 
    # _@param_ `value` — the value to set the attribute destroyed to.
    sig { params(destroyed: T.untyped).returns(T.untyped) }
    attr_writer :destroyed

    # Sets the attribute flagged_for_destroy
    # 
    # _@param_ `value` — the value to set the attribute flagged_for_destroy to.
    sig { params(flagged_for_destroy: T.untyped).returns(T.untyped) }
    attr_writer :flagged_for_destroy

    # Sets the attribute new_record
    # 
    # _@param_ `value` — the value to set the attribute new_record to.
    sig { params(new_record: T.untyped).returns(T.untyped) }
    attr_writer :new_record
  end

  # This module contains logic for easy access to objects that have a lifecycle
  # on the current thread.
  module Threaded
    extend Mongoid::Threaded
    DATABASE_OVERRIDE_KEY = T.let("[mongoid]:db-override", T.untyped)
    CLIENTS_KEY = T.let("[mongoid]:clients", T.untyped)
    CLIENT_OVERRIDE_KEY = T.let("[mongoid]:client-override", T.untyped)
    CURRENT_SCOPE_KEY = T.let("[mongoid]:current-scope", T.untyped)
    AUTOSAVES_KEY = T.let("[mongoid]:autosaves", T.untyped)
    VALIDATIONS_KEY = T.let("[mongoid]:validations", T.untyped)
    STACK_KEYS = T.let(Hash.new do |hash, key|
  hash[key] = "[mongoid]:#{key}-stack"
end, T.untyped)
    BIND = T.let('bind'.freeze, T.untyped)
    ASSIGN = T.let('assign'.freeze, T.untyped)
    BUILD = T.let('build'.freeze, T.untyped)
    LOAD = T.let('load'.freeze, T.untyped)
    CREATE = T.let('create'.freeze, T.untyped)

    # Begin entry into a named thread local stack.
    # 
    # _@param_ `name` — The name of the stack
    # 
    # _@return_ — True.
    # 
    # Begin entry into the stack.
    # ```ruby
    # Threaded.begin_execution(:create)
    # ```
    sig { params(name: String).returns(T::Boolean) }
    def begin_execution(name); end

    # Get the global database override.
    # 
    # _@return_ — The override.
    # 
    # Get the global database override.
    # ```ruby
    # Threaded.database_override
    # ```
    sig { returns(T.any(String, Symbol)) }
    def database_override; end

    # Set the global database override.
    # 
    # _@param_ `name` — The global override name.
    # 
    # _@return_ — The override.
    # 
    # Set the global database override.
    # ```ruby
    # Threaded.database_override = :testing
    # ```
    sig { params(name: T.any(String, Symbol)).returns(T.any(String, Symbol)) }
    def database_override=(name); end

    # Are in the middle of executing the named stack
    # 
    # _@param_ `name` — The name of the stack
    # 
    # _@return_ — If the stack is being executed.
    # 
    # Are we in the stack execution?
    # ```ruby
    # Threaded.executing?(:create)
    # ```
    sig { params(name: Symbol).returns(T::Boolean) }
    def executing?(name); end

    # Exit from a named thread local stack.
    # 
    # _@param_ `name` — The name of the stack
    # 
    # _@return_ — True.
    # 
    # Exit from the stack.
    # ```ruby
    # Threaded.exit_execution(:create)
    # ```
    sig { params(name: Symbol).returns(T::Boolean) }
    def exit_execution(name); end

    # Get the named stack.
    # 
    # _@param_ `name` — The name of the stack
    # 
    # _@return_ — The stack.
    # 
    # Get a stack by name
    # ```ruby
    # Threaded.stack(:create)
    # ```
    sig { params(name: Symbol).returns(T::Array[T.untyped]) }
    def stack(name); end

        # Begin autosaving a document on the current thread.
    # 
    # _@param_ `document` — The document to autosave.
    # 
    # Begin autosave.
    # ```ruby
    # Threaded.begin_autosave(doc)
    # ```
    sig { params(document: Document).returns(T.untyped) }
    def begin_autosave(document); end

        # Begin validating a document on the current thread.
    # 
    # _@param_ `document` — The document to validate.
    # 
    # Begin validation.
    # ```ruby
    # Threaded.begin_validate(doc)
    # ```
    sig { params(document: Document).returns(T.untyped) }
    def begin_validate(document); end

        # Exit autosaving a document on the current thread.
    # 
    # _@param_ `document` — The document to autosave.
    # 
    # Exit autosave.
    # ```ruby
    # Threaded.exit_autosave(doc)
    # ```
    sig { params(document: Document).returns(T.untyped) }
    def exit_autosave(document); end

        # Exit validating a document on the current thread.
    # 
    # _@param_ `document` — The document to validate.
    # 
    # Exit validation.
    # ```ruby
    # Threaded.exit_validate(doc)
    # ```
    sig { params(document: Document).returns(T.untyped) }
    def exit_validate(document); end

        # Begin suppressing default scopes for given model on the current thread.
    # 
    # _@param_ `klass` — The model to suppress default scoping on.
    # 
    # Begin without default scope stack.
    # ```ruby
    # Threaded.begin_without_default_scope(klass)
    # ```
    sig { params(klass: Class).returns(T.untyped) }
    def begin_without_default_scope(klass); end

        # Exit suppressing default scopes for given model on the current thread.
    # 
    # _@param_ `klass` — The model to unsuppress default scoping on.
    # 
    # Exit without default scope stack.
    # ```ruby
    # Threaded.exit_without_default_scope(klass)
    # ```
    sig { params(klass: Class).returns(T.untyped) }
    def exit_without_default_scope(klass); end

    # Get the global client override.
    # 
    # _@return_ — The override.
    # 
    # Get the global client override.
    # ```ruby
    # Threaded.client_override
    # ```
    sig { returns(T.any(String, Symbol)) }
    def client_override; end

    # Set the global client override.
    # 
    # _@param_ `name` — The global override name.
    # 
    # _@return_ — The override.
    # 
    # Set the global client override.
    # ```ruby
    # Threaded.client_override = :testing
    # ```
    sig { params(name: T.any(String, Symbol)).returns(T.any(String, Symbol)) }
    def client_override=(name); end

    # Get the current Mongoid scope.
    # 
    # _@param_ `klass` — The class type of the scope.
    # 
    # _@return_ — The scope.
    # 
    # Get the scope.
    # ```ruby
    # Threaded.current_scope(klass)
    # Threaded.current_scope
    # ```
    sig { params(klass: T.nilable(Class)).returns(Criteria) }
    def current_scope(klass = nil); end

    # Set the current Mongoid scope.
    # 
    # _@param_ `scope` — The current scope.
    # 
    # _@return_ — The scope.
    # 
    # Set the scope.
    # ```ruby
    # Threaded.current_scope = scope
    # ```
    sig { params(scope: Criteria).returns(Criteria) }
    def current_scope=(scope); end

    # Set the current Mongoid scope. Safe for multi-model scope chaining.
    # 
    # _@param_ `scope` — The current scope.
    # 
    # _@param_ `klass` — The current model class.
    # 
    # _@return_ — The scope.
    # 
    # Set the scope.
    # ```ruby
    # Threaded.current_scope(scope, klass)
    # ```
    sig { params(scope: Criteria, klass: Class).returns(Criteria) }
    def set_current_scope(scope, klass); end

    # Is the given klass' default scope suppressed on the current thread?
    # 
    # _@param_ `klass` — The model to check for default scope suppression.
    # 
    # Is the given klass' default scope suppressed?
    # ```ruby
    # Threaded.without_default_scope?(klass)
    # ```
    sig { params(klass: Class).returns(T::Boolean) }
    def without_default_scope?(klass); end

    # Is the document autosaved on the current thread?
    # 
    # _@param_ `document` — The document to check.
    # 
    # _@return_ — If the document is autosaved.
    # 
    # Is the document autosaved?
    # ```ruby
    # Threaded.autosaved?(doc)
    # ```
    sig { params(document: Document).returns(T::Boolean) }
    def autosaved?(document); end

    # Is the document validated on the current thread?
    # 
    # _@param_ `document` — The document to check.
    # 
    # _@return_ — If the document is validated.
    # 
    # Is the document validated?
    # ```ruby
    # Threaded.validated?(doc)
    # ```
    sig { params(document: Document).returns(T::Boolean) }
    def validated?(document); end

    # Get all autosaves on the current thread.
    # 
    # _@return_ — The current autosaves.
    # 
    # Get all autosaves.
    # ```ruby
    # Threaded.autosaves
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def autosaves; end

    # Get all validations on the current thread.
    # 
    # _@return_ — The current validations.
    # 
    # Get all validations.
    # ```ruby
    # Threaded.validations
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def validations; end

    # Get all autosaves on the current thread for the class.
    # 
    # _@param_ `klass` — The class to check.
    # 
    # _@return_ — The current autosaves.
    # 
    # Get all autosaves.
    # ```ruby
    # Threaded.autosaves_for(Person)
    # ```
    sig { params(klass: Class).returns(T::Array[T.untyped]) }
    def autosaves_for(klass); end

    # Get all validations on the current thread for the class.
    # 
    # _@param_ `klass` — The class to check.
    # 
    # _@return_ — The current validations.
    # 
    # Get all validations.
    # ```ruby
    # Threaded.validations_for(Person)
    # ```
    sig { params(klass: Class).returns(T::Array[T.untyped]) }
    def validations_for(klass); end

    # sord warn - Mongo::Session wasn't able to be resolved to a constant in this project
        # Cache a session for this thread.
    # 
    # _@param_ `session` — The session to save.
    # 
    # Save a session for this thread.
    # ```ruby
    # Threaded.set_session(session)
    # ```
    sig { params(session: Mongo::Session).returns(T.untyped) }
    def set_session(session); end

    # sord warn - Mongo::Session wasn't able to be resolved to a constant in this project
    # Get the cached session for this thread.
    # 
    # _@return_ — The session cached on this thread or nil.
    # 
    # Get the session for this thread.
    # ```ruby
    # Threaded.get_session
    # ```
    sig { returns(T.nilable(Mongo::Session)) }
    def get_session; end

    # Clear the cached session for this thread.
    # 
    # Clear this thread's session.
    # ```ruby
    # Threaded.clear_session
    # ```
    sig { returns(T.nilable(T.any())) }
    def clear_session; end

    # Begin entry into a named thread local stack.
    # 
    # _@param_ `name` — The name of the stack
    # 
    # _@return_ — True.
    # 
    # Begin entry into the stack.
    # ```ruby
    # Threaded.begin_execution(:create)
    # ```
    sig { params(name: String).returns(T::Boolean) }
    def self.begin_execution(name); end

    # Get the global database override.
    # 
    # _@return_ — The override.
    # 
    # Get the global database override.
    # ```ruby
    # Threaded.database_override
    # ```
    sig { returns(T.any(String, Symbol)) }
    def self.database_override; end

    # Set the global database override.
    # 
    # _@param_ `name` — The global override name.
    # 
    # _@return_ — The override.
    # 
    # Set the global database override.
    # ```ruby
    # Threaded.database_override = :testing
    # ```
    sig { params(name: T.any(String, Symbol)).returns(T.any(String, Symbol)) }
    def self.database_override=(name); end

    # Are in the middle of executing the named stack
    # 
    # _@param_ `name` — The name of the stack
    # 
    # _@return_ — If the stack is being executed.
    # 
    # Are we in the stack execution?
    # ```ruby
    # Threaded.executing?(:create)
    # ```
    sig { params(name: Symbol).returns(T::Boolean) }
    def self.executing?(name); end

    # Exit from a named thread local stack.
    # 
    # _@param_ `name` — The name of the stack
    # 
    # _@return_ — True.
    # 
    # Exit from the stack.
    # ```ruby
    # Threaded.exit_execution(:create)
    # ```
    sig { params(name: Symbol).returns(T::Boolean) }
    def self.exit_execution(name); end

    # Get the named stack.
    # 
    # _@param_ `name` — The name of the stack
    # 
    # _@return_ — The stack.
    # 
    # Get a stack by name
    # ```ruby
    # Threaded.stack(:create)
    # ```
    sig { params(name: Symbol).returns(T::Array[T.untyped]) }
    def self.stack(name); end

        # Begin autosaving a document on the current thread.
    # 
    # _@param_ `document` — The document to autosave.
    # 
    # Begin autosave.
    # ```ruby
    # Threaded.begin_autosave(doc)
    # ```
    sig { params(document: Document).returns(T.untyped) }
    def self.begin_autosave(document); end

        # Begin validating a document on the current thread.
    # 
    # _@param_ `document` — The document to validate.
    # 
    # Begin validation.
    # ```ruby
    # Threaded.begin_validate(doc)
    # ```
    sig { params(document: Document).returns(T.untyped) }
    def self.begin_validate(document); end

        # Exit autosaving a document on the current thread.
    # 
    # _@param_ `document` — The document to autosave.
    # 
    # Exit autosave.
    # ```ruby
    # Threaded.exit_autosave(doc)
    # ```
    sig { params(document: Document).returns(T.untyped) }
    def self.exit_autosave(document); end

        # Exit validating a document on the current thread.
    # 
    # _@param_ `document` — The document to validate.
    # 
    # Exit validation.
    # ```ruby
    # Threaded.exit_validate(doc)
    # ```
    sig { params(document: Document).returns(T.untyped) }
    def self.exit_validate(document); end

        # Begin suppressing default scopes for given model on the current thread.
    # 
    # _@param_ `klass` — The model to suppress default scoping on.
    # 
    # Begin without default scope stack.
    # ```ruby
    # Threaded.begin_without_default_scope(klass)
    # ```
    sig { params(klass: Class).returns(T.untyped) }
    def self.begin_without_default_scope(klass); end

        # Exit suppressing default scopes for given model on the current thread.
    # 
    # _@param_ `klass` — The model to unsuppress default scoping on.
    # 
    # Exit without default scope stack.
    # ```ruby
    # Threaded.exit_without_default_scope(klass)
    # ```
    sig { params(klass: Class).returns(T.untyped) }
    def self.exit_without_default_scope(klass); end

    # Get the global client override.
    # 
    # _@return_ — The override.
    # 
    # Get the global client override.
    # ```ruby
    # Threaded.client_override
    # ```
    sig { returns(T.any(String, Symbol)) }
    def self.client_override; end

    # Set the global client override.
    # 
    # _@param_ `name` — The global override name.
    # 
    # _@return_ — The override.
    # 
    # Set the global client override.
    # ```ruby
    # Threaded.client_override = :testing
    # ```
    sig { params(name: T.any(String, Symbol)).returns(T.any(String, Symbol)) }
    def self.client_override=(name); end

    # Get the current Mongoid scope.
    # 
    # _@param_ `klass` — The class type of the scope.
    # 
    # _@return_ — The scope.
    # 
    # Get the scope.
    # ```ruby
    # Threaded.current_scope(klass)
    # Threaded.current_scope
    # ```
    sig { params(klass: T.nilable(Class)).returns(Criteria) }
    def self.current_scope(klass = nil); end

    # Set the current Mongoid scope.
    # 
    # _@param_ `scope` — The current scope.
    # 
    # _@return_ — The scope.
    # 
    # Set the scope.
    # ```ruby
    # Threaded.current_scope = scope
    # ```
    sig { params(scope: Criteria).returns(Criteria) }
    def self.current_scope=(scope); end

    # Set the current Mongoid scope. Safe for multi-model scope chaining.
    # 
    # _@param_ `scope` — The current scope.
    # 
    # _@param_ `klass` — The current model class.
    # 
    # _@return_ — The scope.
    # 
    # Set the scope.
    # ```ruby
    # Threaded.current_scope(scope, klass)
    # ```
    sig { params(scope: Criteria, klass: Class).returns(Criteria) }
    def self.set_current_scope(scope, klass); end

    # Is the given klass' default scope suppressed on the current thread?
    # 
    # _@param_ `klass` — The model to check for default scope suppression.
    # 
    # Is the given klass' default scope suppressed?
    # ```ruby
    # Threaded.without_default_scope?(klass)
    # ```
    sig { params(klass: Class).returns(T::Boolean) }
    def self.without_default_scope?(klass); end

    # Is the document autosaved on the current thread?
    # 
    # _@param_ `document` — The document to check.
    # 
    # _@return_ — If the document is autosaved.
    # 
    # Is the document autosaved?
    # ```ruby
    # Threaded.autosaved?(doc)
    # ```
    sig { params(document: Document).returns(T::Boolean) }
    def self.autosaved?(document); end

    # Is the document validated on the current thread?
    # 
    # _@param_ `document` — The document to check.
    # 
    # _@return_ — If the document is validated.
    # 
    # Is the document validated?
    # ```ruby
    # Threaded.validated?(doc)
    # ```
    sig { params(document: Document).returns(T::Boolean) }
    def self.validated?(document); end

    # Get all autosaves on the current thread.
    # 
    # _@return_ — The current autosaves.
    # 
    # Get all autosaves.
    # ```ruby
    # Threaded.autosaves
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def self.autosaves; end

    # Get all validations on the current thread.
    # 
    # _@return_ — The current validations.
    # 
    # Get all validations.
    # ```ruby
    # Threaded.validations
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def self.validations; end

    # Get all autosaves on the current thread for the class.
    # 
    # _@param_ `klass` — The class to check.
    # 
    # _@return_ — The current autosaves.
    # 
    # Get all autosaves.
    # ```ruby
    # Threaded.autosaves_for(Person)
    # ```
    sig { params(klass: Class).returns(T::Array[T.untyped]) }
    def self.autosaves_for(klass); end

    # Get all validations on the current thread for the class.
    # 
    # _@param_ `klass` — The class to check.
    # 
    # _@return_ — The current validations.
    # 
    # Get all validations.
    # ```ruby
    # Threaded.validations_for(Person)
    # ```
    sig { params(klass: Class).returns(T::Array[T.untyped]) }
    def self.validations_for(klass); end

    # sord warn - Mongo::Session wasn't able to be resolved to a constant in this project
        # Cache a session for this thread.
    # 
    # _@param_ `session` — The session to save.
    # 
    # Save a session for this thread.
    # ```ruby
    # Threaded.set_session(session)
    # ```
    sig { params(session: Mongo::Session).returns(T.untyped) }
    def self.set_session(session); end

    # sord warn - Mongo::Session wasn't able to be resolved to a constant in this project
    # Get the cached session for this thread.
    # 
    # _@return_ — The session cached on this thread or nil.
    # 
    # Get the session for this thread.
    # ```ruby
    # Threaded.get_session
    # ```
    sig { returns(T.nilable(Mongo::Session)) }
    def self.get_session; end

    # Clear the cached session for this thread.
    # 
    # Clear this thread's session.
    # ```ruby
    # Threaded.clear_session
    # ```
    sig { returns(T.nilable(T.any())) }
    def self.clear_session; end

    # This module contains convenience methods for document lifecycle that
    # resides on thread locals.
    module Lifecycle
      extend ActiveSupport::Concern

      # Begin the assignment of attributes. While in this block embedded
      # documents will not autosave themselves in order to allow the document to
      # be in a valid state.
      # 
      # _@return_ — The yielded value.
      # 
      # Execute the assignment.
      # ```ruby
      # _assigning do
      #   person.attributes = { :addresses => [ address ] }
      # end
      # ```
      sig { returns(Object) }
      def _assigning; end

      # Is the current thread in assigning mode?
      # 
      # _@return_ — If the thread is assigning.
      # 
      # Is the current thread in assigning mode?
      # ```ruby
      # proxy._assigning?
      # ```
      sig { returns(T::Boolean) }
      def _assigning?; end

      # Execute a block in binding mode.
      # 
      # _@return_ — The return value of the block.
      # 
      # Execute in binding mode.
      # ```ruby
      # binding do
      #   relation.push(doc)
      # end
      # ```
      sig { returns(Object) }
      def _binding; end

      # Is the current thread in binding mode?
      # 
      # _@return_ — If the thread is binding.
      # 
      # Is the current thread in binding mode?
      # ```ruby
      # proxy.binding?
      # ```
      sig { returns(T::Boolean) }
      def _binding?; end

      # Execute a block in building mode.
      # 
      # _@return_ — The return value of the block.
      # 
      # Execute in building mode.
      # ```ruby
      # _building do
      #   relation.push(doc)
      # end
      # ```
      sig { returns(Object) }
      def _building; end

      # Is the current thread in building mode?
      # 
      # _@return_ — If the thread is building.
      # 
      # Is the current thread in building mode?
      # ```ruby
      # proxy._building?
      # ```
      sig { returns(T::Boolean) }
      def _building?; end

      # Is the current thread in creating mode?
      # 
      # _@return_ — If the thread is creating.
      # 
      # Is the current thread in creating mode?
      # ```ruby
      # proxy.creating?
      # ```
      sig { returns(T::Boolean) }
      def _creating?; end

      # Execute a block in loading mode.
      # 
      # _@return_ — The return value of the block.
      # 
      # Execute in loading mode.
      # ```ruby
      # _loading do
      #   relation.push(doc)
      # end
      # ```
      sig { returns(Object) }
      def _loading; end

      # Is the current thread in loading mode?
      # 
      # _@return_ — If the thread is loading.
      # 
      # Is the current thread in loading mode?
      # ```ruby
      # proxy._loading?
      # ```
      sig { returns(T::Boolean) }
      def _loading?; end

      module ClassMethods
        # Execute a block in creating mode.
        # 
        # _@return_ — The return value of the block.
        # 
        # Execute in creating mode.
        # ```ruby
        # creating do
        #   relation.push(doc)
        # end
        # ```
        sig { returns(Object) }
        def _creating; end
      end
    end
  end

  # Encapsulates behavior around caching.
  # 
  # @since 6.0.0
  module Cacheable
    extend ActiveSupport::Concern

    # Print out the cache key. This will append different values on the
    # plural model name.
    # 
    # If new_record?     - will append /new
    # If not             - will append /id-updated_at.to_s(cache_timestamp_format)
    # Without updated_at - will append /id
    # 
    # This is usually called insode a cache() block
    # 
    # _@return_ — the string with or without updated_at
    # 
    # Returns the cache key
    # ```ruby
    # document.cache_key
    # ```
    sig { returns(String) }
    def cache_key; end
  end

  # Contains behavior specific to evolving for queryable queries.
  module Evolvable
    # Evolve the document into an object id.
    # 
    # _@return_ — The document's id.
    # 
    # Evolve the document.
    # ```ruby
    # document.__evolve_object_id__
    # ```
    sig { returns(Object) }
    def __evolve_object_id__; end
  end

  # Encapsulates behavior around defining indexes.
  # 
  # @since 4.0.0
  module Indexable
    extend ActiveSupport::Concern

    module ClassMethods
      # Send the actual index creation comments to the MongoDB driver
      # 
      # _@return_ — If the operation succeeded.
      # 
      # Create the indexes for the class.
      # ```ruby
      # Person.create_indexes
      # ```
      sig { returns(T::Boolean) }
      def create_indexes; end

      # Send the actual index removal comments to the MongoDB driver,
      # but lets _id untouched.
      # 
      # _@return_ — If the operation succeeded.
      # 
      # Remove the indexes for the class.
      # ```ruby
      # Person.remove_indexes
      # ```
      sig { returns(T::Boolean) }
      def remove_indexes; end

      # Add the default indexes to the root document if they do not already
      # exist. Currently this is only _type.
      # 
      # _@return_ — If the operation succeeded.
      # 
      # Add Mongoid internal indexes.
      # ```ruby
      # Person.add_indexes
      # ```
      sig { returns(T::Boolean) }
      def add_indexes; end

      # Adds an index definition for the provided single or compound keys.
      # 
      # _@param_ `spec` — The index spec.
      # 
      # _@param_ `options` — The index options.
      # 
      # _@return_ — The index options.
      # 
      # Create a basic index.
      # ```ruby
      # class Person
      #   include Mongoid::Document
      #   field :name, type: String
      #   index({ name: 1 }, { background: true })
      # end
      # ```
      sig { params(spec: Symbol, options: T.nilable(T::Hash[T.untyped, T.untyped])).returns(T::Hash[T.untyped, T.untyped]) }
      def index(spec, options = nil); end

      # sord warn - Mongoid::Indexable::Specification wasn't able to be resolved to a constant in this project
      # Get an index specification for the provided key.
      # 
      # _@param_ `index_hash` — The index key/direction pair.
      # 
      # _@param_ `index_name` — The index name.
      # 
      # _@return_ — The found specification.
      # 
      # Get the index specification.
      # ```ruby
      # Model.index_specification(name: 1)
      # ```
      sig { params(index_hash: T::Hash[T.untyped, T.untyped], index_name: T.nilable(String)).returns(T.untyped) }
      def index_specification(index_hash, index_name = nil); end

      # Get the names of all databases for this model that have index
      # definitions.
      # 
      # _@return_ — The names.
      # 
      # Get the indexed database names.
      # ```ruby
      # Model.indexed_database_names
      # ```
      sig { returns(T::Array[String]) }
      def indexed_database_names; end

      # Gets a list of index specification keys.
      # 
      # _@return_ — The specification keys.
      # 
      # Get the specification key list.
      # ```ruby
      # Model.index_keys
      # ```
      sig { returns(T::Array[T::Hash[T.untyped, T.untyped]]) }
      def index_keys; end
    end

    module Validators
      # Validates the options passed to the index macro.
      module Options
        extend Mongoid::Indexable::Validators::Options
        VALID_OPTIONS = T.let([
  :background,
  :database,
  :default_language,
  :language_override,
  :drop_dups,
  :name,
  :sparse,
  :unique,
  :max,
  :min,
  :bits,
  :bucket_size,
  :expire_after_seconds,
  :weights,
  :storage_engine,
  :key,
  :sphere_version,
  :text_version,
  :version,
  :partial_filter_expression,
  :collation
], T.untyped)
        VALID_TYPES = T.let([
  1,
  -1,
  "2d",
  "2dsphere",
  "geoHaystack",
  "text",
  "hashed"
], T.untyped)

                # Validate the index specification.
        # 
        # _@param_ `klass` — The model class.
        # 
        # _@param_ `spec` — The index specification.
        # 
        # _@param_ `options` — The index options.
        # 
        # Validate the index spec.
        # ```ruby
        # Options.validate(Band, name: 1)
        # ```
        sig { params(klass: Class, spec: T::Hash[T.untyped, T.untyped], options: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
        def validate(klass, spec, options); end

                # Validates the options of the index spec.
        # 
        # _@param_ `klass` — The model class.
        # 
        # _@param_ `spec` — The index specification.
        # 
        # _@param_ `options` — The index options.
        # 
        # Validate the options.
        # ```ruby
        # Options.validate_options(Band, name: 1)
        # ```
        sig { params(klass: Class, spec: T::Hash[T.untyped, T.untyped], options: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
        def validate_options(klass, spec, options); end

                # Validates the index spec.
        # 
        # _@param_ `klass` — The model class.
        # 
        # _@param_ `spec` — The index specification.
        # 
        # _@param_ `options` — The index options.
        # 
        # Validate the spec.
        # ```ruby
        # Options.validate_spec(Band, name: 1)
        # ```
        sig { params(klass: Class, spec: T::Hash[T.untyped, T.untyped], options: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
        def validate_spec(klass, spec, options); end

                # Validate the index specification.
        # 
        # _@param_ `klass` — The model class.
        # 
        # _@param_ `spec` — The index specification.
        # 
        # _@param_ `options` — The index options.
        # 
        # Validate the index spec.
        # ```ruby
        # Options.validate(Band, name: 1)
        # ```
        sig { params(klass: Class, spec: T::Hash[T.untyped, T.untyped], options: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
        def self.validate(klass, spec, options); end

                # Validates the options of the index spec.
        # 
        # _@param_ `klass` — The model class.
        # 
        # _@param_ `spec` — The index specification.
        # 
        # _@param_ `options` — The index options.
        # 
        # Validate the options.
        # ```ruby
        # Options.validate_options(Band, name: 1)
        # ```
        sig { params(klass: Class, spec: T::Hash[T.untyped, T.untyped], options: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
        def self.validate_options(klass, spec, options); end

                # Validates the index spec.
        # 
        # _@param_ `klass` — The model class.
        # 
        # _@param_ `spec` — The index specification.
        # 
        # _@param_ `options` — The index options.
        # 
        # Validate the spec.
        # ```ruby
        # Options.validate_spec(Band, name: 1)
        # ```
        sig { params(klass: Class, spec: T::Hash[T.untyped, T.untyped], options: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
        def self.validate_spec(klass, spec, options); end
      end
    end
  end

  # This module contains all the behavior for Ruby implementations of MongoDB
  # selectors.
  # 
  # @since 4.0.0
  module Matchable
    extend ActiveSupport::Concern

    # Determines if this document has the attributes to match the supplied
    # MongoDB selector. Used for matching on embedded associations.
    # 
    # _@param_ `selector` — The MongoDB selector.
    # 
    # _@return_ — True if matches, false if not.
    # 
    # Does the document match?
    # ```ruby
    # document._matches?(:title => { "$in" => [ "test" ] })
    # ```
    sig { params(selector: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
    def _matches?(selector); end
  end

  # This module contains behavior for adding shard key fields to updates.
  # 
  # @since 4.0.0
  module Shardable
    extend ActiveSupport::Concern

    # Get the shard key fields.
    # 
    # _@return_ — The shard key field names.
    # 
    # Get the shard key fields.
    # ```ruby
    # model.shard_key_fields
    # ```
    # 
    # _@note_ — Refactored from using delegate for class load performance.
    sig { returns(T::Array[String]) }
    def shard_key_fields; end

    # Get the document selector with the defined shard keys.
    # 
    # _@return_ — The shard key selector.
    # 
    # Get the selector for the shard keys.
    # ```ruby
    # person.shard_key_selector
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def shard_key_selector; end

    module ClassMethods
                  # Specifies a shard key with the field(s) specified.
      # 
      # Specify the shard key.
      # ```ruby
      # 
      # class Person
      #   include Mongoid::Document
      #   field :first_name, :type => String
      #   field :last_name, :type => String
      # 
      #   shard_key first_name: 1, last_name: 1
      # end
      # ```
      sig { params(args: T.untyped).returns(T.untyped) }
      def shard_key(*args); end
    end
  end

  module Touchable
    extend Mongoid::Touchable

    # Add the association to the touchable associations if the touch option was
    # provided.
    # 
    # _@param_ `association` — The association metadata.
    # 
    # _@return_ — The model class.
    # 
    # Add the touchable.
    # ```ruby
    # Model.define_touchable!(assoc)
    # ```
    sig { params(association: Association).returns(Class) }
    def define_touchable!(association); end

    # Define the method that will get called for touching belongs_to
    # associations.
    # 
    # _@param_ `name` — The name of the association.
    # 
    # _@param_ `association` — The association metadata.
    # 
    # _@return_ — The method name.
    # 
    # Define the touch association.
    # ```ruby
    # Model.define_relation_touch_method(:band)
    # Model.define_relation_touch_method(:band, :band_updated_at)
    # ```
    sig { params(name: Symbol, association: Association).returns(Symbol) }
    def define_relation_touch_method(name, association); end

    # Add the association to the touchable associations if the touch option was
    # provided.
    # 
    # _@param_ `association` — The association metadata.
    # 
    # _@return_ — The model class.
    # 
    # Add the touchable.
    # ```ruby
    # Model.define_touchable!(assoc)
    # ```
    sig { params(association: Association).returns(Class) }
    def self.define_touchable!(association); end

    # Define the method that will get called for touching belongs_to
    # associations.
    # 
    # _@param_ `name` — The name of the association.
    # 
    # _@param_ `association` — The association metadata.
    # 
    # _@return_ — The method name.
    # 
    # Define the touch association.
    # ```ruby
    # Model.define_relation_touch_method(:band)
    # Model.define_relation_touch_method(:band, :band_updated_at)
    # ```
    sig { params(name: Symbol, association: Association).returns(Symbol) }
    def self.define_relation_touch_method(name, association); end

    module InstanceMethods
      # Touch the document, in effect updating its updated_at timestamp and
      # optionally the provided field to the current time. If any belongs_to
      # associations exist with a touch option, they will be updated as well.
      # 
      # _@param_ `field` — The name of an additional field to update.
      # 
      # _@return_ — false if record is new_record otherwise true.
      # 
      # Update the updated_at timestamp.
      # ```ruby
      # document.touch
      # ```
      # 
      # Update the updated_at and provided timestamps.
      # ```ruby
      # document.touch(:audited)
      # ```
      # 
      # _@note_ — This will not autobuild associations if those options are set.
      sig { params(field: T.nilable(Symbol)).returns(T::Boolean) }
      def touch(field = nil); end
    end
  end

  # This module contains the logic for handling the internal attributes hash,
  # and how to get and set values.
  module Attributes
    include Mongoid::Attributes::Nested
    include Mongoid::Attributes::Processing
    include Mongoid::Attributes::Readonly
    extend ActiveSupport::Concern

    # Determine if an attribute is present.
    # 
    # _@param_ `name` — The name of the attribute.
    # 
    # _@return_ — True if present, false if not.
    # 
    # Is the attribute present?
    # ```ruby
    # person.attribute_present?("title")
    # ```
    sig { params(name: T.any(String, Symbol)).returns(T::Boolean) }
    def attribute_present?(name); end

    # Get the attributes that have not been cast.
    # 
    # _@return_ — The uncast attributes.
    # 
    # Get the attributes before type cast.
    # ```ruby
    # document.attributes_before_type_cast
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def attributes_before_type_cast; end

    # Does the document have the provided attribute?
    # 
    # _@param_ `name` — The name of the attribute.
    # 
    # _@return_ — If the key is present in the attributes.
    # 
    # Does the document have the attribute?
    # ```ruby
    # model.has_attribute?(:name)
    # ```
    sig { params(name: T.any(String, Symbol)).returns(T::Boolean) }
    def has_attribute?(name); end

    # Does the document have the provided attribute before it was assigned
    # and type cast?
    # 
    # _@param_ `name` — The name of the attribute.
    # 
    # _@return_ — If the key is present in the
    # attributes_before_type_cast.
    # 
    # Does the document have the attribute before it was assigned?
    # ```ruby
    # model.has_attribute_before_type_cast?(:name)
    # ```
    sig { params(name: T.any(String, Symbol)).returns(T::Boolean) }
    def has_attribute_before_type_cast?(name); end

    # Read a value from the document attributes. If the value does not exist
    # it will return nil.
    # 
    # _@param_ `name` — The name of the attribute to get.
    # 
    # _@return_ — The value of the attribute.
    # 
    # Read an attribute.
    # ```ruby
    # person.read_attribute(:title)
    # ```
    # 
    # Read an attribute (alternate syntax.)
    # ```ruby
    # person[:title]
    # ```
    sig { params(name: T.any(String, Symbol)).returns(Object) }
    def read_attribute(name); end

    # Read a value from the attributes before type cast. If the value has not
    # yet been assigned then this will return the attribute's existing value
    # using read_raw_attribute.
    # 
    # _@param_ `name` — The name of the attribute to get.
    # 
    # _@return_ — The value of the attribute before type cast, if
    # available. Otherwise, the value of the attribute.
    # 
    # Read an attribute before type cast.
    # ```ruby
    # person.read_attribute_before_type_cast(:price)
    # ```
    sig { params(name: T.any(String, Symbol)).returns(Object) }
    def read_attribute_before_type_cast(name); end

        # Remove a value from the +Document+ attributes. If the value does not exist
    # it will fail gracefully.
    # 
    # _@param_ `name` — The name of the attribute to remove.
    # 
    # Remove the attribute.
    # ```ruby
    # person.remove_attribute(:title)
    # ```
    sig { params(name: T.any(String, Symbol)).returns(T.untyped) }
    def remove_attribute(name); end

        # Write a single attribute to the document attribute hash. This will
    # also fire the before and after update callbacks, and perform any
    # necessary typecasting.
    # 
    # _@param_ `name` — The name of the attribute to update.
    # 
    # _@param_ `value` — The value to set for the attribute.
    # 
    # Write the attribute.
    # ```ruby
    # person.write_attribute(:title, "Mr.")
    # ```
    # 
    # Write the attribute (alternate syntax.)
    # ```ruby
    # person[:title] = "Mr."
    # ```
    sig { params(name: T.any(String, Symbol), value: Object).returns(T.untyped) }
    def write_attribute(name, value); end

        # Allows you to set all the attributes for a particular mass-assignment security role
    # by passing in a hash of attributes with keys matching the attribute names
    # (which again matches the column names)  and the role name using the :as option.
    # To bypass mass-assignment security you can use the :without_protection => true option.
    # 
    # _@param_ `attrs` — The new attributes to set.
    # 
    # Assign the attributes.
    # ```ruby
    # person.assign_attributes(:title => "Mr.")
    # ```
    # 
    # Assign the attributes (with a role).
    # ```ruby
    # person.assign_attributes({ :title => "Mr." }, :as => :admin)
    # ```
    sig { params(attrs: T.nilable(T::Hash[T.untyped, T.untyped])).returns(T.untyped) }
    def assign_attributes(attrs = nil); end

        # Writes the supplied attributes hash to the document. This will only
    # overwrite existing attributes if they are present in the new +Hash+, all
    # others will be preserved.
    # 
    # _@param_ `attrs` — The new attributes to set.
    # 
    # Write the attributes.
    # ```ruby
    # person.write_attributes(:title => "Mr.")
    # ```
    # 
    # Write the attributes (alternate syntax.)
    # ```ruby
    # person.attributes = { :title => "Mr." }
    # ```
    sig { params(attrs: T.nilable(T::Hash[T.untyped, T.untyped])).returns(T.untyped) }
    def write_attributes(attrs = nil); end

    # Determine if the attribute is missing from the document, due to loading
    # it from the database with missing fields.
    # 
    # _@param_ `name` — The name of the attribute.
    # 
    # _@return_ — If the attribute is missing.
    # 
    # Is the attribute missing?
    # ```ruby
    # document.attribute_missing?("test")
    # ```
    sig { params(name: String).returns(T::Boolean) }
    def attribute_missing?(name); end

    # Return type-casted attributes.
    # 
    # _@return_ — The hash with keys and values of the type-casted attributes.
    # 
    # Type-casted attributes.
    # ```ruby
    # document.typed_attributes
    # ```
    sig { returns(Object) }
    def typed_attributes; end

                sig { params(name: T.untyped, selection: T.untyped, field: T.untyped).returns(T::Boolean) }
    def selection_excluded?(name, selection, field); end

                sig { params(name: T.untyped, selection: T.untyped, field: T.untyped).returns(T::Boolean) }
    def selection_included?(name, selection, field); end

        # Does the string contain dot syntax for accessing hashes?
    # 
    # _@return_ — If the string contains a "."
    # 
    # Is the string in dot syntax.
    # ```ruby
    # model.hash_dot_syntax?
    # ```
    sig { params(string: T.untyped).returns(T::Boolean) }
    def hash_dot_syntax?(string); end

    # Return the typecasted value for a field.
    # 
    # _@param_ `key` — The field name.
    # 
    # _@param_ `value` — The uncast value.
    # 
    # _@return_ — The cast value.
    # 
    # Get the value typecasted.
    # ```ruby
    # person.typed_value_for(:title, :sir)
    # ```
    sig { params(key: T.any(String, Symbol), value: Object).returns(Object) }
    def typed_value_for(key, value); end

            sig { params(name: T.untyped).returns(T.untyped) }
    def read_raw_attribute(name); end

        # Validates an attribute value as being assignable to the specified field.
    # 
    # For now, only Hash and Array fields are validated, and the value is
    # being checked to be of an appropriate type (i.e. either Hash or Array,
    # respectively, or nil).
    # 
    # This method takes the name of the field as stored in the document
    # in the database, not (necessarily) the Ruby method name used to read/write
    # the said field.
    # 
    # _@param_ `field_name` — The name of the field.
    # 
    # _@param_ `value` — The value to be validated.
    sig { params(field_name: T.any(String, Symbol), value: Object).returns(T.untyped) }
    def validate_attribute_value(field_name, value); end

                sig { params(name: T.untyped, value: T.untyped).returns(T.untyped) }
    def lookup_attribute_presence(name, value); end

    # Are we able to write the attribute with the provided name?
    # 
    # _@param_ `name` — The name of the field.
    # 
    # _@return_ — If the document is new, or if the field is not
    # readonly.
    # 
    # Can we write the attribute?
    # ```ruby
    # model.attribute_writable?(:title)
    # ```
    sig { params(name: T.any(String, Symbol)).returns(T::Boolean) }
    def attribute_writable?(name); end

                sig { params(name: T.untyped, value: T.untyped).returns(T.untyped) }
    def as_writable_attribute!(name, value = :nil); end

        sig { params(name: T.untyped).returns(T::Boolean) }
    def _loaded?(name); end

        sig { params(name: T.untyped).returns(T::Boolean) }
    def projected_field?(name); end

        # Process the provided attributes casting them to their proper values if a
    # field exists for them on the document. This will be limited to only the
    # attributes provided in the suppied +Hash+ so that no extra nil values get
    # put into the document's attributes.
    # 
    # _@param_ `attrs` — The attributes to set.
    # 
    # Process the attributes.
    # ```ruby
    # person.process_attributes(:title => "sir", :age => 40)
    # ```
    sig { params(attrs: T.nilable(T::Hash[T.untyped, T.untyped])).returns(T.untyped) }
    def process_attributes(attrs = nil); end

    # If the key provided is the name of an association or a nested attribute, we
    # need to wait until all other attributes are set before processing
    # these.
    # 
    # _@param_ `key` — The name of the attribute.
    # 
    # _@param_ `value` — The value of the attribute.
    # 
    # _@return_ — True if pending, false if not.
    # 
    # Is the attribute pending?
    # ```ruby
    # document.pending_attribute?(:name, "Durran")
    # ```
    sig { params(key: Symbol, value: Object).returns(T::Boolean) }
    def pending_attribute?(key, value); end

    # Get all the pending associations that need to be set.
    # 
    # _@return_ — The pending associations in key/value pairs.
    # 
    # Get the pending associations.
    # ```ruby
    # document.pending_relations
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def pending_relations; end

    # Get all the pending nested attributes that need to be set.
    # 
    # _@return_ — The pending nested attributes in key/value pairs.
    # 
    # Get the pending nested attributes.
    # ```ruby
    # document.pending_nested
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def pending_nested; end

        # If the attribute is dynamic, add a field for it with a type of object
    # and then either way set the value.
    # 
    # _@param_ `name` — The name of the field.
    # 
    # _@param_ `value` — The value of the field.
    # 
    # Process the attribute.
    # ```ruby
    # document.process_attribute(name, value)
    # ```
    sig { params(name: Symbol, value: Object).returns(T.untyped) }
    def process_attribute(name, value); end

        # Process all the pending nested attributes that needed to wait until
    # ids were set to fire off.
    # 
    # Process the nested attributes.
    # ```ruby
    # document.process_nested
    # ```
    sig { returns(T.untyped) }
    def process_nested; end

        # Process all the pending items, then clear them out.
    # 
    # Process the pending items.
    # ```ruby
    # document.process_pending
    # ```
    sig { returns(T.untyped) }
    def process_pending; end

        # Process all the pending associations that needed to wait until ids were set
    # to fire off.
    # 
    # Process the associations.
    # ```ruby
    # document.process_relations
    # ```
    sig { returns(T.untyped) }
    def process_relations; end

        # Returns the value of attribute attributes.
    sig { returns(T.untyped) }
    attr_reader :attributes

    module ClassMethods
            # Alias the provided name to the original field. This will provide an
      # aliased getter, setter, existence check, and all dirty attribute
      # methods.
      # 
      # _@param_ `name` — The new name.
      # 
      # _@param_ `original` — The original name.
      # 
      # Alias the attribute.
      # ```ruby
      # class Product
      #   include Mongoid::Document
      #   field :price, :type => Float
      #   alias_attribute :cost, :price
      # end
      # ```
      sig { params(name: Symbol, original: Symbol).returns(T.untyped) }
      def alias_attribute(name, original); end

            # Removes a field alias.
      # 
      # _@param_ `name` — The aliased field name to remove.
      sig { params(name: Symbol).returns(T.untyped) }
      def unalias_attribute(name); end
    end

    # Defines behavior around that lovel Rails feature nested attributes.
    # 
    # @since 1.0.0
    module Nested
      extend ActiveSupport::Concern

      module ClassMethods
        REJECT_ALL_BLANK_PROC = T.let(->(attributes){
  attributes.all? { |key, value| key == '_destroy' || value.blank? }
}, T.untyped)

                # Used when needing to update related models from a parent association. Can
        # be used on embedded or referenced associations.
        # 
        # _@param_ `args` — A list of association names, followed by a hash of options.
        # 
        # Defining nested attributes.
        # ```ruby
        # 
        # class Person
        #   include Mongoid::Document
        # 
        #   embeds_many :addresses
        #   embeds_one :game
        #   references_many :posts
        # 
        #   accepts_nested_attributes_for :addresses, :game, :posts
        # end
        # ```
        sig { params(args: T.any(T::Array[Symbol], T::Hash[T.untyped, T.untyped])).returns(T.untyped) }
        def accepts_nested_attributes_for(*args); end

                # Add the autosave information for the nested association.
        # 
        # _@param_ `association` — The existing association metadata.
        # 
        # Add the autosave if appropriate.
        # ```ruby
        # Person.autosave_nested_attributes(metadata)
        # ```
        sig { params(association: Association).returns(T.untyped) }
        def autosave_nested_attributes(association); end
      end
    end

    # This module contains the behavior for dynamic attributes.
    # 
    # @since 4.0.0
    module Dynamic
      extend ActiveSupport::Concern

      # Override respond_to? so it responds properly for dynamic attributes.
      # 
      # _@param_ `name` — The name of the method.
      # 
      # _@param_ `include_private`
      # 
      # _@return_ — True if it does, false if not.
      # 
      # Does this object respond to the method?
      # ```ruby
      # person.respond_to?(:title)
      # ```
      sig { params(name: T::Array[T.untyped], include_private: T::Boolean).returns(T::Boolean) }
      def respond_to?(name, include_private = false); end

            # Define a reader method for a dynamic attribute.
      # 
      # _@param_ `name` — The name of the field.
      # 
      # Define a reader method.
      # ```ruby
      # model.define_dynamic_reader(:field)
      # ```
      sig { params(name: String).returns(T.untyped) }
      def define_dynamic_reader(name); end

            # Define a reader method for a dynamic attribute before type cast.
      # 
      # _@param_ `name` — The name of the field.
      # 
      # Define a reader method for an attribute.
      # ```ruby
      # model.define_dynamic_before_type_cast_reader(:field)
      # ```
      sig { params(name: String).returns(T.untyped) }
      def define_dynamic_before_type_cast_reader(name); end

            # Define a writer method for a dynamic attribute.
      # 
      # _@param_ `name` — The name of the field.
      # 
      # Define a writer method.
      # ```ruby
      # model.define_dynamic_writer(:field)
      # ```
      sig { params(name: String).returns(T.untyped) }
      def define_dynamic_writer(name); end

            # If the attribute is dynamic, add a field for it with a type of object
      # and set the value.
      # 
      # _@param_ `name` — The name of the field.
      # 
      # _@param_ `value` — The value of the field.
      # 
      # Process the attribute.
      # ```ruby
      # document.process_attribute(name, value)
      # ```
      sig { params(name: Symbol, value: Object).returns(T.untyped) }
      def process_attribute(name, value); end

      # Get an array of inspected dynamic fields for the document.
      # 
      # _@return_ — An array of pretty printed dynamic field values.
      # 
      # Inspect the dynamic fields.
      # ```ruby
      # document.inspect_dynamic_fields
      # ```
      sig { returns(String) }
      def inspect_dynamic_fields; end

      # Used for allowing accessor methods for dynamic attributes.
      # 
      # _@param_ `name` — The name of the method.
      # 
      # _@param_ `args` — The arguments to the method.
      # 
      # _@return_ — The result of the method call.
      # 
      # Call through method_missing.
      # ```ruby
      # document.method_missing(:test)
      # ```
      sig { params(name: T.any(String, Symbol), args: T::Array[T.untyped]).returns(Object) }
      def method_missing(name, *args); end
    end

    # This module defines behavior for readonly attributes.
    module Readonly
      extend ActiveSupport::Concern

      # Are we able to write the attribute with the provided name?
      # 
      # _@param_ `name` — The name of the field.
      # 
      # _@return_ — If the document is new, or if the field is not
      # readonly.
      # 
      # Can we write the attribute?
      # ```ruby
      # model.attribute_writable?(:title)
      # ```
      sig { params(name: T.any(String, Symbol)).returns(T::Boolean) }
      def attribute_writable?(name); end

                        sig { params(name: T.untyped, value: T.untyped).returns(T.untyped) }
      def as_writable_attribute!(name, value = :nil); end

            sig { params(name: T.untyped).returns(T::Boolean) }
      def _loaded?(name); end

            sig { params(name: T.untyped).returns(T::Boolean) }
      def projected_field?(name); end

      module ClassMethods
                # Defines an attribute as readonly. This will ensure that the value for
        # the attribute is only set when the document is new or we are
        # creating. In other cases, the field write will be ignored with the
        # exception of #remove_attribute and #update_attribute, where an error
        # will get raised.
        # 
        # _@param_ `names` — The names of the fields.
        # 
        # Flag fields as readonly.
        # ```ruby
        # class Band
        #   include Mongoid::Document
        #   field :name, type: String
        #   field :genre, type: String
        #   attr_readonly :name, :genre
        # end
        # ```
        sig { params(names: T::Array[Symbol]).returns(T.untyped) }
        def attr_readonly(*names); end
      end
    end

    # This module contains the behavior for processing attributes.
    module Processing
            # Process the provided attributes casting them to their proper values if a
      # field exists for them on the document. This will be limited to only the
      # attributes provided in the suppied +Hash+ so that no extra nil values get
      # put into the document's attributes.
      # 
      # _@param_ `attrs` — The attributes to set.
      # 
      # Process the attributes.
      # ```ruby
      # person.process_attributes(:title => "sir", :age => 40)
      # ```
      sig { params(attrs: T.nilable(T::Hash[T.untyped, T.untyped])).returns(T.untyped) }
      def process_attributes(attrs = nil); end

      # If the key provided is the name of an association or a nested attribute, we
      # need to wait until all other attributes are set before processing
      # these.
      # 
      # _@param_ `key` — The name of the attribute.
      # 
      # _@param_ `value` — The value of the attribute.
      # 
      # _@return_ — True if pending, false if not.
      # 
      # Is the attribute pending?
      # ```ruby
      # document.pending_attribute?(:name, "Durran")
      # ```
      sig { params(key: Symbol, value: Object).returns(T::Boolean) }
      def pending_attribute?(key, value); end

      # Get all the pending associations that need to be set.
      # 
      # _@return_ — The pending associations in key/value pairs.
      # 
      # Get the pending associations.
      # ```ruby
      # document.pending_relations
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def pending_relations; end

      # Get all the pending nested attributes that need to be set.
      # 
      # _@return_ — The pending nested attributes in key/value pairs.
      # 
      # Get the pending nested attributes.
      # ```ruby
      # document.pending_nested
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def pending_nested; end

            # If the attribute is dynamic, add a field for it with a type of object
      # and then either way set the value.
      # 
      # _@param_ `name` — The name of the field.
      # 
      # _@param_ `value` — The value of the field.
      # 
      # Process the attribute.
      # ```ruby
      # document.process_attribute(name, value)
      # ```
      sig { params(name: Symbol, value: Object).returns(T.untyped) }
      def process_attribute(name, value); end

            # Process all the pending nested attributes that needed to wait until
      # ids were set to fire off.
      # 
      # Process the nested attributes.
      # ```ruby
      # document.process_nested
      # ```
      sig { returns(T.untyped) }
      def process_nested; end

            # Process all the pending items, then clear them out.
      # 
      # Process the pending items.
      # ```ruby
      # document.process_pending
      # ```
      sig { returns(T.untyped) }
      def process_pending; end

            # Process all the pending associations that needed to wait until ids were set
      # to fire off.
      # 
      # Process the associations.
      # ```ruby
      # document.process_relations
      # ```
      sig { returns(T.untyped) }
      def process_relations; end
    end
  end

  # Defines behavior for dirty tracking.
  # 
  # @since 4.0.0
  module Changeable
    extend ActiveSupport::Concern

    # Get the changed attributes for the document.
    # 
    # _@return_ — The changed attributes.
    # 
    # Get the changed attributes.
    # ```ruby
    # model.changed
    # ```
    sig { returns(T::Array[String]) }
    def changed; end

    # Has the document changed?
    # 
    # _@return_ — If the document is changed.
    # 
    # Has the document changed?
    # ```ruby
    # model.changed?
    # ```
    sig { returns(T::Boolean) }
    def changed?; end

    # Have any children (embedded documents) of this document changed?
    # 
    # _@return_ — If any children have changed.
    # 
    # Have any children changed?
    # ```ruby
    # model.children_changed?
    # ```
    sig { returns(T::Boolean) }
    def children_changed?; end

    # Get the attribute changes.
    # 
    # _@return_ — The attribute changes.
    # 
    # Get the attribute changes.
    # ```ruby
    # model.changed_attributes
    # ```
    sig { returns(T::Hash[String, Object]) }
    def changed_attributes; end

    # Get all the changes for the document.
    # 
    # _@return_ — The changes.
    # 
    # Get all the changes.
    # ```ruby
    # model.changes
    # ```
    sig { returns(T::Hash[String, T::Array[T.any(Object, Object)]]) }
    def changes; end

        # Call this method after save, so the changes can be properly switched.
    # 
    # This will unset the memoized children array, set new record to
    # false, set the document as validated, and move the dirty changes.
    # 
    # Move the changes to previous.
    # ```ruby
    # person.move_changes
    # ```
    sig { returns(T.untyped) }
    def move_changes; end

        # Things that need to execute after a document has been persisted.
    # 
    # Handle post persistence.
    # ```ruby
    # document.post_persist
    # ```
    sig { returns(T.untyped) }
    def post_persist; end

    # Get the previous changes on the document.
    # 
    # _@return_ — The previous changes.
    # 
    # Get the previous changes.
    # ```ruby
    # model.previous_changes
    # ```
    sig { returns(T::Hash[String, T::Array[T.any(Object, Object)]]) }
    def previous_changes; end

        # Remove a change from the dirty attributes hash. Used by the single field
    # atomic updators.
    # 
    # _@param_ `name` — The name of the field.
    # 
    # Remove a flagged change.
    # ```ruby
    # model.remove_change(:field)
    # ```
    sig { params(name: T.any(Symbol, String)).returns(T.untyped) }
    def remove_change(name); end

    # Gets all the new values for each of the changed fields, to be passed to
    # a MongoDB $set modifier.
    # 
    # _@return_ — A +Hash+ of atomic setters.
    # 
    # Get the setters for the atomic updates.
    # ```ruby
    # person = Person.new(:title => "Sir")
    # person.title = "Madam"
    # person.setters # returns { "title" => "Madam" }
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def setters; end

    # Get the old and new value for the provided attribute.
    # 
    # _@param_ `attr` — The name of the attribute.
    # 
    # _@return_ — The old and new values.
    # 
    # Get the attribute change.
    # ```ruby
    # model.attribute_change("name")
    # ```
    sig { params(attr: String).returns(T::Array[Object]) }
    def attribute_change(attr); end

    # Determine if a specific attribute has changed.
    # 
    # _@param_ `attr` — The name of the attribute.
    # 
    # _@return_ — Whether the attribute has changed.
    # 
    # Has the attribute changed?
    # ```ruby
    # model.attribute_changed?("name")
    # ```
    sig { params(attr: String).returns(T::Boolean) }
    def attribute_changed?(attr); end

    # Get whether or not the field has a different value from the default.
    # 
    # _@param_ `attr` — The name of the attribute.
    # 
    # _@return_ — If the attribute differs.
    # 
    # Is the field different from the default?
    # ```ruby
    # model.attribute_changed_from_default?
    # ```
    sig { params(attr: String).returns(T::Boolean) }
    def attribute_changed_from_default?(attr); end

        # Get the previous value for the attribute.
    # 
    # _@param_ `attr` — The attribute name.
    # 
    # Get the previous value.
    # ```ruby
    # model.attribute_was("name")
    # ```
    sig { params(attr: String).returns(T.untyped) }
    def attribute_was(attr); end

    # Flag an attribute as going to change.
    # 
    # _@param_ `attr` — The name of the attribute.
    # 
    # _@return_ — The old value.
    # 
    # Flag the attribute.
    # ```ruby
    # model.attribute_will_change!("name")
    # ```
    sig { params(attr: String).returns(Object) }
    def attribute_will_change!(attr); end

    # Set the attribute back to its old value.
    # 
    # _@param_ `attr` — The name of the attribute.
    # 
    # _@return_ — The old value.
    # 
    # Reset the attribute.
    # ```ruby
    # model.reset_attribute!("name")
    # ```
    sig { params(attr: String).returns(Object) }
    def reset_attribute!(attr); end

            sig { params(attr: T.untyped).returns(T.untyped) }
    def reset_attribute_to_default!(attr); end

    module ClassMethods
      # Generate all the dirty methods needed for the attribute.
      # 
      # _@param_ `name` — The name of the field.
      # 
      # _@param_ `meth` — The name of the accessor.
      # 
      # _@return_ — The fields module.
      # 
      # Generate the dirty methods.
      # ```ruby
      # Model.create_dirty_methods("name", "name")
      # ```
      sig { params(name: String, meth: String).returns(Module) }
      def create_dirty_methods(name, meth); end

            # Creates the dirty change accessor.
      # 
      # _@param_ `name` — The attribute name.
      # 
      # _@param_ `meth` — The name of the accessor.
      # 
      # Create the accessor.
      # ```ruby
      # Model.create_dirty_change_accessor("name", "alias")
      # ```
      sig { params(name: String, meth: String).returns(T.untyped) }
      def create_dirty_change_accessor(name, meth); end

            # Creates the dirty change check.
      # 
      # _@param_ `name` — The attribute name.
      # 
      # _@param_ `meth` — The name of the accessor.
      # 
      # Create the check.
      # ```ruby
      # Model.create_dirty_change_check("name", "alias")
      # ```
      sig { params(name: String, meth: String).returns(T.untyped) }
      def create_dirty_change_check(name, meth); end

            # Creates the dirty default change check.
      # 
      # _@param_ `name` — The attribute name.
      # 
      # _@param_ `meth` — The name of the accessor.
      # 
      # Create the check.
      # ```ruby
      # Model.create_dirty_default_change_check("name", "alias")
      # ```
      sig { params(name: String, meth: String).returns(T.untyped) }
      def create_dirty_default_change_check(name, meth); end

            # Creates the dirty change previous value accessor.
      # 
      # _@param_ `name` — The attribute name.
      # 
      # _@param_ `meth` — The name of the accessor.
      # 
      # Create the accessor.
      # ```ruby
      # Model.create_dirty_previous_value_accessor("name", "alias")
      # ```
      sig { params(name: String, meth: String).returns(T.untyped) }
      def create_dirty_previous_value_accessor(name, meth); end

            # Creates the dirty change flag.
      # 
      # _@param_ `name` — The attribute name.
      # 
      # _@param_ `meth` — The name of the accessor.
      # 
      # Create the flag.
      # ```ruby
      # Model.create_dirty_change_flag("name", "alias")
      # ```
      sig { params(name: String, meth: String).returns(T.untyped) }
      def create_dirty_change_flag(name, meth); end

            # Creates the dirty change reset.
      # 
      # _@param_ `name` — The attribute name.
      # 
      # _@param_ `meth` — The name of the accessor.
      # 
      # Create the reset.
      # ```ruby
      # Model.create_dirty_reset("name", "alias")
      # ```
      sig { params(name: String, meth: String).returns(T.untyped) }
      def create_dirty_reset(name, meth); end

            # Creates the dirty change reset to default.
      # 
      # _@param_ `name` — The attribute name.
      # 
      # _@param_ `meth` — The name of the accessor.
      # 
      # Create the reset.
      # ```ruby
      # Model.create_dirty_reset_to_default("name", "alias")
      # ```
      sig { params(name: String, meth: String).returns(T.untyped) }
      def create_dirty_reset_to_default(name, meth); end

      # Creates the dirty change check.
      # 
      # _@param_ `name` — The attribute name.
      # 
      # _@param_ `meth` — The name of the accessor.
      # 
      # Create the dirty change check.
      # ```ruby
      # Model.create_dirty_previously_changed?("name", "alias")
      # ```
      sig { params(name: String, meth: String).returns(T::Boolean) }
      def create_dirty_previously_changed?(name, meth); end

            # Creates the dirty change accessor.
      # 
      # _@param_ `name` — The attribute name.
      # 
      # _@param_ `meth` — The name of the accessor.
      # 
      # Create the dirty change accessor.
      # ```ruby
      # Model.create_dirty_previous_change("name", "alias")
      # ```
      sig { params(name: String, meth: String).returns(T.untyped) }
      def create_dirty_previous_change(name, meth); end
    end
  end

  # This module provides inclusions of all behavior in a Mongoid document.
  # 
  # @since 4.0.0
  module Composable
    include ActiveModel::Model
    include ActiveModel::ForbiddenAttributesProtection
    include ActiveModel::Serializers::JSON
    include Mongoid::Atomic
    include Mongoid::Changeable
    include Mongoid::Clients
    include Mongoid::Attributes
    include Mongoid::Evolvable
    include Mongoid::Fields
    include Mongoid::Indexable
    include Mongoid::Matchable
    include Mongoid::Persistable
    include Mongoid::Association
    include Mongoid::Reloadable
    include Mongoid::Scopable
    include Mongoid::Selectable
    include Mongoid::Serializable
    include Mongoid::Shardable
    include Mongoid::Stateful
    include Mongoid::Cacheable
    include Mongoid::Threaded::Lifecycle
    include Mongoid::Traversable
    include Mongoid::Validatable
    include Mongoid::Interceptable
    include Mongoid::Copyable
    include Mongoid::Equality
    extend ActiveSupport::Concern
    MODULES = T.let([
  Atomic,
  Attributes,
  Copyable,
  Changeable,
  Evolvable,
  Fields,
  Indexable,
  Interceptable,
  Matchable,
  Persistable,
  Association,
  Reloadable,
  Scopable,
  Serializable,
  Clients,
  Clients::Options,
  Shardable,
  Stateful,
  Cacheable,
  Threaded::Lifecycle,
  Traversable,
  Validatable,
  Equality,
  Association::Referenced::Syncable,
  Association::Macros,
  ActiveModel::Model,
  ActiveModel::Validations
], T.untyped)
    RESERVED_METHOD_NAMES = T.let([ :fields,
  :aliased_fields,
  :localized_fields,
  :index_specifications,
  :shard_key_fields,
  :nested_attributes,
  :readonly_attributes,
  :storage_options,
  :cascades,
  :cyclic,
  :cache_timestamp_format
], T.untyped)
    CALLBACKS = T.let([
  :after_build,
  :after_create,
  :after_destroy,
  :after_find,
  :after_initialize,
  :after_save,
  :after_touch,
  :after_update,
  :after_upsert,
  :after_validation,
  :around_create,
  :around_destroy,
  :around_save,
  :around_update,
  :around_upsert,
  :before_create,
  :before_destroy,
  :before_save,
  :before_update,
  :before_upsert,
  :before_validation
].freeze, T.untyped)
    MACRO_MAPPING = T.let({
    embeds_one: Association::Embedded::EmbedsOne,
    embeds_many: Association::Embedded::EmbedsMany,
    embedded_in: Association::Embedded::EmbeddedIn,
    has_one: Association::Referenced::HasOne,
    has_many: Association::Referenced::HasMany,
    has_and_belongs_to_many: Association::Referenced::HasAndBelongsToMany,
    belongs_to: Association::Referenced::BelongsTo,
}.freeze, T.untyped)
    STRATEGIES = T.let([
    :delete_all,
    :destroy,
    :nullify,
    :restrict_with_exception,
    :restrict_with_error
], T.untyped)
    LIST_OPERATIONS = T.let([ "$addToSet", "$push", "$pull", "$pullAll" ].freeze, T.untyped)
    StringifiedSymbol = T.let(Mongoid::StringifiedSymbol, T.untyped)
    Boolean = T.let(Mongoid::Boolean, T.untyped)
    TYPE_MAPPINGS = T.let({
  array: Array,
  big_decimal: BigDecimal,
  binary: BSON::Binary,
  boolean: Mongoid::Boolean,
  date: Date,
  date_time: DateTime,
  float: Float,
  hash: Hash,
  integer: Integer,
  object_id: BSON::ObjectId,
  range: Range,
  regexp: Regexp,
  set: Set,
  string: String,
  stringified_symbol: StringifiedSymbol,
  symbol: Symbol,
  time: Time
}.with_indifferent_access, T.untyped)
    IDS = T.let([ :_id, '_id', ].freeze, T.untyped)
    CREATE_LOCK = T.let(Mutex.new, T.untyped)
    UPDATES = T.let([
  :atomic_array_pushes,
  :atomic_array_pulls,
  :atomic_array_add_to_sets,
  :atomic_pulls,
  :delayed_atomic_sets,
  :delayed_atomic_pulls,
  :delayed_atomic_unsets
], T.untyped)

    # Get a list of methods that would be a bad idea to define as field names
    # or override when including Mongoid::Document.
    # 
    # Bad thing!
    # ```ruby
    # Mongoid::Components.prohibited_methods
    # ```
    sig { returns(T::Array[Symbol]) }
    def self.prohibited_methods; end

    # Default comparison is via the string version of the id.
    # 
    # _@param_ `other` — The document to compare with.
    # 
    # _@return_ — -1, 0, 1.
    # 
    # Compare two documents.
    # ```ruby
    # person <=> other_person
    # ```
    sig { params(other: Document).returns(Integer) }
    def <=>(other); end

    # Performs equality checking on the document ids. For more robust
    # equality checking please override this method.
    # 
    # _@param_ `other` — The other object to compare with.
    # 
    # _@return_ — True if the ids are equal, false if not.
    # 
    # Compare for equality.
    # ```ruby
    # document == other
    # ```
    sig { params(other: T.any(Document, Object)).returns(T::Boolean) }
    def ==(other); end

    # Performs class equality checking.
    # 
    # _@param_ `other` — The other object to compare with.
    # 
    # _@return_ — True if the classes are equal, false if not.
    # 
    # Compare the classes.
    # ```ruby
    # document === other
    # ```
    sig { params(other: T.any(Document, Object)).returns(T::Boolean) }
    def ===(other); end

    # Delegates to ==. Used when needing checks in hashes.
    # 
    # _@param_ `other` — The object to check against.
    # 
    # _@return_ — True if equal, false if not.
    # 
    # Perform equality checking.
    # ```ruby
    # document.eql?(other)
    # ```
    sig { params(other: T.any(Document, Object)).returns(T::Boolean) }
    def eql?(other); end

    # Clone or dup the current +Document+. This will return all attributes with
    # the exception of the document's id, and will reset all the
    # instance variables.
    # 
    # This clone also includes embedded documents.
    # 
    # _@return_ — The new document.
    # 
    # Clone the document.
    # ```ruby
    # document.clone
    # ```
    sig { returns(Document) }
    def clone; end

        # Clone the document attributes
    # 
    # clone document
    # ```ruby
    # model.clone_document
    # ```
    sig { returns(T.untyped) }
    def clone_document; end

            # When cloning, if the document has localized fields we need to ensure they
    # are properly processed in the clone.
    # 
    # _@param_ `attrs` — The attributes.
    # 
    # Process localized attributes.
    # ```ruby
    # model.process_localized_attributes(attributes)
    # ```
    sig { params(klass: T.untyped, attrs: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
    def process_localized_attributes(klass, attrs); end

    # Is the provided type of callback executable by this document?
    # 
    # _@param_ `kind` — The type of callback.
    # 
    # _@return_ — If the callback can be executed.
    # 
    # Is the callback executable?
    # ```ruby
    # document.callback_executable?(:save)
    # ```
    sig { params(kind: Symbol).returns(T::Boolean) }
    def callback_executable?(kind); end

    # Is the document currently in a state that could potentially require
    # callbacks to be executed?
    # 
    # _@param_ `kind` — The callback kind.
    # 
    # _@return_ — If the document is in a callback state.
    # 
    # Is the document in a callback state?
    # ```ruby
    # document.in_callback_state?(:update)
    # ```
    sig { params(kind: Symbol).returns(T::Boolean) }
    def in_callback_state?(kind); end

    # Run only the after callbacks for the specific event.
    # 
    # _@param_ `kinds` — The events that are occurring.
    # 
    # _@return_ — The result of the chain executing.
    # 
    # Run only the after save callbacks.
    # ```ruby
    # model.run_after_callbacks(:save)
    # ```
    # 
    # _@note_ — ActiveSupport does not allow this type of behavior by default, so
    # Mongoid has to get around it and implement itself.
    sig { params(kinds: T::Array[Symbol]).returns(Object) }
    def run_after_callbacks(*kinds); end

    # Run only the before callbacks for the specific event.
    # 
    # _@param_ `kinds` — The events that are occurring.
    # 
    # _@return_ — The result of the chain executing.
    # 
    # Run only the before save callbacks.
    # ```ruby
    # model.run_before_callbacks(:save, :create)
    # ```
    # 
    # _@note_ — ActiveSupport does not allow this type of behavior by default, so
    # Mongoid has to get around it and implement itself.
    sig { params(kinds: T::Array[Symbol]).returns(Object) }
    def run_before_callbacks(*kinds); end

    # Run the callbacks for the document. This overrides active support's
    # functionality to cascade callbacks to embedded documents that have been
    # flagged as such.
    # 
    # _@param_ `kind` — The type of callback to execute.
    # 
    # _@param_ `args` — Any options.
    # 
    # _@return_ — The document
    # 
    # Run the callbacks.
    # ```ruby
    # run_callbacks :save do
    #   save!
    # end
    # ```
    sig { params(kind: Symbol, args: T::Array[T.untyped], block: T.untyped).returns(Document) }
    def run_callbacks(kind, *args, &block); end

    # We need to hook into this for autosave, since we don't want it firing if
    # the before callbacks were halted.
    # 
    # _@return_ — If a before callback was halted.
    # 
    # Was a before callback halted?
    # ```ruby
    # document.before_callback_halted?
    # ```
    sig { returns(T::Boolean) }
    def before_callback_halted?; end

        # Get all the child embedded documents that are flagged as cascadable.
    # 
    # _@param_ `kind` — The type of callback.
    # 
    # _@return_ — The children.
    # 
    # Get all the cascading children.
    # ```ruby
    # document.cascadable_children(:update)
    # ```
    sig { params(kind: Symbol, children: T.untyped).returns(T::Array[Document]) }
    def cascadable_children(kind, children = Set.new); end

        # Determine if the child should fire the callback.
    # 
    # _@param_ `kind` — The type of callback.
    # 
    # _@param_ `child` — The child document.
    # 
    # _@return_ — If the child should fire the callback.
    # 
    # Should the child fire the callback?
    # ```ruby
    # document.cascadable_child?(:update, doc)
    # ```
    sig { params(kind: Symbol, child: Document, association: T.untyped).returns(T::Boolean) }
    def cascadable_child?(kind, child, association); end

    # Get the name of the callback that the child should fire. This changes
    # depending on whether or not the child is new. A persisted parent with a
    # new child would fire :update from the parent, but needs to fire :create
    # on the child.
    # 
    # _@param_ `kind` — The type of callback.
    # 
    # _@param_ `child` — The child document
    # 
    # _@return_ — The name of the callback.
    # 
    # Get the callback type.
    # ```ruby
    # document.child_callback_type(:update, doc)
    # ```
    sig { params(kind: Symbol, child: Document).returns(Symbol) }
    def child_callback_type(kind, child); end

        # We need to hook into this for autosave, since we don't want it firing if
    # the before callbacks were halted.
    # 
    # _@param_ `filter` — The callback that halted.
    # 
    # _@param_ `name` — The name of the callback that was halted (requires Rails 6.1+)
    # 
    # Hook into the halt.
    # ```ruby
    # document.halted_callback_hook(filter)
    # ```
    sig { params(filter: Symbol, name: T.nilable(Symbol)).returns(T.untyped) }
    def halted_callback_hook(filter, name = nil); end

    # Run only the callbacks for the target location (before, after, around)
    # and kind (save, update, create).
    # 
    # _@param_ `place` — The time to run, :before, :after, :around.
    # 
    # _@param_ `kind` — The type of callback, :save, :create, :update.
    # 
    # _@return_ — The result of the chain execution.
    # 
    # Run the targeted callbacks.
    # ```ruby
    # model.run_targeted_callbacks(:before, :save)
    # ```
    sig { params(place: Symbol, kind: Symbol).returns(Object) }
    def run_targeted_callbacks(place, kind); end

        # Begin the associated validation.
    # 
    # Begin validation.
    # ```ruby
    # document.begin_validate
    # ```
    sig { returns(T.untyped) }
    def begin_validate; end

        # Exit the associated validation.
    # 
    # Exit validation.
    # ```ruby
    # document.exit_validate
    # ```
    sig { returns(T.untyped) }
    def exit_validate; end

    # Given the provided options, are we performing validations?
    # 
    # _@param_ `options` — The options to check.
    # 
    # _@return_ — If we are validating.
    # 
    # Are we performing validations?
    # ```ruby
    # document.performing_validations?(validate: true)
    # ```
    sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
    def performing_validations?(options = {}); end

    # Overrides the default ActiveModel behavior since we need to handle
    # validations of associations slightly different than just calling the
    # getter.
    # 
    # _@param_ `attr` — The name of the field or association.
    # 
    # _@return_ — The value of the field or the association.
    # 
    # Read the value.
    # ```ruby
    # person.read_attribute_for_validation(:addresses)
    # ```
    sig { params(attr: Symbol).returns(Object) }
    def read_attribute_for_validation(attr); end

    # Determine if the document is valid.
    # 
    # _@param_ `context` — The optional validation context.
    # 
    # _@return_ — True if valid, false if not.
    # 
    # Is the document valid?
    # ```ruby
    # person.valid?
    # ```
    # 
    # Is the document valid in a context?
    # ```ruby
    # person.valid?(:create)
    # ```
    sig { params(context: T.nilable(Symbol)).returns(T::Boolean) }
    def valid?(context = nil); end

    # Used to prevent infinite loops in associated validations.
    # 
    # _@return_ — Has the document already been validated?
    # 
    # Is the document validated?
    # ```ruby
    # document.validated?
    # ```
    sig { returns(T::Boolean) }
    def validated?; end

    # Are we currently performing a validation that has a query?
    # 
    # _@return_ — If we are validating with a query.
    # 
    # Are we validating with a query?
    # ```ruby
    # document.validating_with_query?
    # ```
    sig { returns(T::Boolean) }
    def validating_with_query?; end

        sig { returns(T.untyped) }
    def _parent; end

            sig { params(p: T.untyped).returns(T.untyped) }
    def _parent=(p); end

    # Get all child +Documents+ to this +Document+, going n levels deep if
    # necessary. This is used when calling update persistence operations from
    # the root document, where changes in the entire tree need to be
    # determined. Note that persistence from the embedded documents will
    # always be preferred, since they are optimized calls... This operation
    # can get expensive in domains with large hierarchies.
    # 
    # _@return_ — All child documents in the hierarchy.
    # 
    # Get all the document's children.
    # ```ruby
    # person._children
    # ```
    sig { returns(T::Array[Document]) }
    def _children; end

    # Collect all the children of this document.
    # 
    # _@return_ — The children.
    # 
    # Collect all the children.
    # ```ruby
    # document.collect_children
    # ```
    sig { returns(T::Array[Document]) }
    def collect_children; end

    # Marks all children as being persisted.
    # 
    # _@return_ — The flagged children.
    # 
    # Flag all the children.
    # ```ruby
    # document.flag_children_persisted
    # ```
    sig { returns(T::Array[Document]) }
    def flag_children_persisted; end

    # Determines if the document is a subclass of another document.
    # 
    # _@return_ — True if hereditary, false if not.
    # 
    # Check if the document is a subclass
    # ```ruby
    # Square.new.hereditary?
    # ```
    sig { returns(T::Boolean) }
    def hereditary?; end

    # Sets up a child/parent association. This is used for newly created
    # objects so they can be properly added to the graph.
    # 
    # _@param_ `document` — The parent document.
    # 
    # _@return_ — The parent document.
    # 
    # Set the parent document.
    # ```ruby
    # document.parentize(parent)
    # ```
    sig { params(document: Document).returns(Document) }
    def parentize(document); end

        # Remove a child document from this parent. If an embeds one then set to
    # nil, otherwise remove from the embeds many.
    # 
    # This is called from the +RemoveEmbedded+ persistence command.
    # 
    # _@param_ `child` — The child (embedded) document to remove.
    # 
    # Remove the child.
    # ```ruby
    # document.remove_child(child)
    # ```
    sig { params(child: Document).returns(T.untyped) }
    def remove_child(child); end

    # After children are persisted we can call this to move all their changes
    # and flag them as persisted in one call.
    # 
    # _@return_ — The children.
    # 
    # Reset the children.
    # ```ruby
    # document.reset_persisted_children
    # ```
    sig { returns(T::Array[Document]) }
    def reset_persisted_children; end

    # Resets the memoized children on the object. Called internally when an
    # embedded array changes size.
    # 
    # _@return_ — nil.
    # 
    # Reset the memoized children.
    # ```ruby
    # document._reset_memoized_children!
    # ```
    sig { returns(T.nilable(T.any())) }
    def _reset_memoized_children!; end

    # Return the root document in the object graph. If the current document
    # is the root object in the graph it will return self.
    # 
    # _@return_ — The root document in the hierarchy.
    # 
    # Get the root document in the hierarchy.
    # ```ruby
    # document._root
    # ```
    sig { returns(Document) }
    def _root; end

    # Is this document the root document of the hierarchy?
    # 
    # _@return_ — If the document is the root.
    # 
    # Is the document the root?
    # ```ruby
    # document._root?
    # ```
    sig { returns(T::Boolean) }
    def _root?; end

    # Begin the assignment of attributes. While in this block embedded
    # documents will not autosave themselves in order to allow the document to
    # be in a valid state.
    # 
    # _@return_ — The yielded value.
    # 
    # Execute the assignment.
    # ```ruby
    # _assigning do
    #   person.attributes = { :addresses => [ address ] }
    # end
    # ```
    sig { returns(Object) }
    def _assigning; end

    # Is the current thread in assigning mode?
    # 
    # _@return_ — If the thread is assigning.
    # 
    # Is the current thread in assigning mode?
    # ```ruby
    # proxy._assigning?
    # ```
    sig { returns(T::Boolean) }
    def _assigning?; end

    # Execute a block in binding mode.
    # 
    # _@return_ — The return value of the block.
    # 
    # Execute in binding mode.
    # ```ruby
    # binding do
    #   relation.push(doc)
    # end
    # ```
    sig { returns(Object) }
    def _binding; end

    # Is the current thread in binding mode?
    # 
    # _@return_ — If the thread is binding.
    # 
    # Is the current thread in binding mode?
    # ```ruby
    # proxy.binding?
    # ```
    sig { returns(T::Boolean) }
    def _binding?; end

    # Execute a block in building mode.
    # 
    # _@return_ — The return value of the block.
    # 
    # Execute in building mode.
    # ```ruby
    # _building do
    #   relation.push(doc)
    # end
    # ```
    sig { returns(Object) }
    def _building; end

    # Is the current thread in building mode?
    # 
    # _@return_ — If the thread is building.
    # 
    # Is the current thread in building mode?
    # ```ruby
    # proxy._building?
    # ```
    sig { returns(T::Boolean) }
    def _building?; end

    # Is the current thread in creating mode?
    # 
    # _@return_ — If the thread is creating.
    # 
    # Is the current thread in creating mode?
    # ```ruby
    # proxy.creating?
    # ```
    sig { returns(T::Boolean) }
    def _creating?; end

    # Execute a block in loading mode.
    # 
    # _@return_ — The return value of the block.
    # 
    # Execute in loading mode.
    # ```ruby
    # _loading do
    #   relation.push(doc)
    # end
    # ```
    sig { returns(Object) }
    def _loading; end

    # Is the current thread in loading mode?
    # 
    # _@return_ — If the thread is loading.
    # 
    # Is the current thread in loading mode?
    # ```ruby
    # proxy._loading?
    # ```
    sig { returns(T::Boolean) }
    def _loading?; end

    # Print out the cache key. This will append different values on the
    # plural model name.
    # 
    # If new_record?     - will append /new
    # If not             - will append /id-updated_at.to_s(cache_timestamp_format)
    # Without updated_at - will append /id
    # 
    # This is usually called insode a cache() block
    # 
    # _@return_ — the string with or without updated_at
    # 
    # Returns the cache key
    # ```ruby
    # document.cache_key
    # ```
    sig { returns(String) }
    def cache_key; end

    # Returns true if the +Document+ has not been persisted to the database,
    # false if it has. This is determined by the variable @new_record
    # and NOT if the object has an id.
    # 
    # _@return_ — True if new, false if not.
    # 
    # Is the document new?
    # ```ruby
    # person.new_record?
    # ```
    sig { returns(T::Boolean) }
    def new_record?; end

    # Checks if the document has been saved to the database. Returns false
    # if the document has been destroyed.
    # 
    # _@return_ — True if persisted, false if not.
    # 
    # Is the document persisted?
    # ```ruby
    # person.persisted?
    # ```
    sig { returns(T::Boolean) }
    def persisted?; end

    # Returns whether or not the document has been flagged for deletion, but
    # not destroyed yet. Used for atomic pulls of child documents.
    # 
    # _@return_ — If the document is flagged.
    # 
    # Is the document flagged?
    # ```ruby
    # document.flagged_for_destroy?
    # ```
    sig { returns(T::Boolean) }
    def flagged_for_destroy?; end

    # Returns true if the +Document+ has been succesfully destroyed, and false
    # if it hasn't. This is determined by the variable @destroyed and NOT
    # by checking the database.
    # 
    # _@return_ — True if destroyed, false if not.
    # 
    # Is the document destroyed?
    # ```ruby
    # person.destroyed?
    # ```
    sig { returns(T::Boolean) }
    def destroyed?; end

    # Determine if the document can be pushed.
    # 
    # _@return_ — Is the document new and embedded?
    # 
    # Is this pushable?
    # ```ruby
    # person.pushable?
    # ```
    sig { returns(T::Boolean) }
    def pushable?; end

    # Is the document readonly?
    # 
    # _@return_ — If the document is readonly.
    # 
    # Is the document readonly?
    # ```ruby
    # document.readonly?
    # ```
    sig { returns(T::Boolean) }
    def readonly?; end

    # Determine if the document can be set.
    # 
    # _@return_ — Is this document a new embeds one?
    # 
    # Is this settable?
    # ```ruby
    # person.settable?
    # ```
    sig { returns(T::Boolean) }
    def settable?; end

    # Is the document updateable?
    # 
    # _@return_ — If the document is changed and persisted.
    # 
    # Is the document updateable?
    # ```ruby
    # person.updateable?
    # ```
    sig { returns(T::Boolean) }
    def updateable?; end

        sig { returns(T.untyped) }
    def reset_readonly; end

    # Get the shard key fields.
    # 
    # _@return_ — The shard key field names.
    # 
    # Get the shard key fields.
    # ```ruby
    # model.shard_key_fields
    # ```
    # 
    # _@note_ — Refactored from using delegate for class load performance.
    sig { returns(T::Array[String]) }
    def shard_key_fields; end

    # Get the document selector with the defined shard keys.
    # 
    # _@return_ — The shard key selector.
    # 
    # Get the selector for the shard keys.
    # ```ruby
    # person.shard_key_selector
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def shard_key_selector; end

    # Gets the document as a serializable hash, used by ActiveModel's JSON
    # serializer.
    # 
    # _@param_ `options` — The options to pass.
    # 
    # _@return_ — The document, ready to be serialized.
    # 
    # Get the serializable hash.
    # ```ruby
    # document.serializable_hash
    # ```
    # 
    # Get the serializable hash with options.
    # ```ruby
    # document.serializable_hash(:include => :addresses)
    # ```
    sig { params(options: T.nilable(T::Hash[T.untyped, T.untyped])).returns(T::Hash[T.untyped, T.untyped]) }
    def serializable_hash(options = nil); end

        # Get the names of all fields that will be serialized.
    # 
    # _@return_ — The names of the fields.
    # 
    # Get all the field names.
    # ```ruby
    # document.send(:field_names)
    # ```
    sig { params(options: T.untyped).returns(T::Array[String]) }
    def field_names(options); end

    # Serialize a single attribute. Handles associations, fields, and dynamic
    # attributes.
    # 
    # _@param_ `attrs` — The attributes.
    # 
    # _@param_ `name` — The attribute name.
    # 
    # _@param_ `names` — The names of all attributes.
    # 
    # _@param_ `options` — The options.
    # 
    # _@return_ — The attribute.
    # 
    # Serialize the attribute.
    # ```ruby
    # document.serialize_attribute({}, "id" , [ "id" ])
    # ```
    sig do
      params(
        attrs: T::Hash[T.untyped, T.untyped],
        name: String,
        names: T::Array[String],
        options: T::Hash[T.untyped, T.untyped]
      ).returns(Object)
    end
    def serialize_attribute(attrs, name, names, options); end

        # For each of the provided include options, get the association needed and
    # provide it in the hash.
    # 
    # _@param_ `attributes` — The attributes to serialize.
    # 
    # _@param_ `options` — The serialization options.
    # 
    # Serialize the included associations.
    # ```ruby
    # document.serialize_relations({}, :include => :addresses)
    # ```
    sig { params(attributes: T::Hash[T.untyped, T.untyped], options: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
    def serialize_relations(attributes = {}, options = {}); end

    # Since the inclusions can be a hash, symbol, or array of symbols, this is
    # provided as a convenience to parse out the names.
    # 
    # _@param_ `inclusions` — The inclusions.
    # 
    # _@return_ — The names of the included associations.
    # 
    # Get the association names.
    # ```ruby
    # document.relation_names(:include => [ :addresses ])
    # ```
    sig { params(inclusions: T.any(T::Hash[T.untyped, T.untyped], Symbol, T::Array[Symbol])).returns(T::Array[Symbol]) }
    def relation_names(inclusions); end

    # Since the inclusions can be a hash, symbol, or array of symbols, this is
    # provided as a convenience to parse out the options.
    # 
    # _@param_ `inclusions` — The inclusions.
    # 
    # _@param_ `options` — The options.
    # 
    # _@param_ `name` — The name of the association.
    # 
    # _@return_ — The options for the association.
    # 
    # Get the association options.
    # ```ruby
    # document.relation_names(:include => [ :addresses ])
    # ```
    sig { params(inclusions: T.any(T::Hash[T.untyped, T.untyped], Symbol, T::Array[Symbol]), options: T::Hash[T.untyped, T.untyped], name: Symbol).returns(T::Hash[T.untyped, T.untyped]) }
    def relation_options(inclusions, options, name); end

    # Get the atomic selector for the document. This is a hash in the simplest
    # case { "_id" => id }, but can become more complex for embedded documents
    # and documents that use a shard key.
    # 
    # _@return_ — The document's selector.
    # 
    # Get the document's atomic selector.
    # ```ruby
    # document.atomic_selector
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def atomic_selector; end

    # Get the atomic selector for an embedded document.
    # 
    # _@return_ — The embedded document selector.
    # 
    # Get the embedded atomic selector.
    # ```ruby
    # document.embedded_atomic_selector
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def embedded_atomic_selector; end

    # Get the atomic selector for a root document.
    # 
    # _@return_ — The root document selector.
    # 
    # Get the root atomic selector.
    # ```ruby
    # document.root_atomic_selector
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def root_atomic_selector; end

    # Apply the default scoping to the attributes of the document, as long as
    # they are not complex queries.
    # 
    # _@return_ — If default scoping was applied.
    # 
    # Apply the default scoping.
    # ```ruby
    # document.apply_default_scoping
    # ```
    sig { returns(T::Boolean) }
    def apply_default_scoping; end

    # Reloads the +Document+ attributes from the database. If the document has
    # not been saved then an error will get raised if the configuration option
    # was set. This can reload root documents or embedded documents.
    # 
    # _@return_ — The document, reloaded.
    # 
    # Reload the document.
    # ```ruby
    # person.reload
    # ```
    sig { returns(Document) }
    def reload; end

    # Reload the document, determining if it's embedded or not and what
    # behavior to use.
    # 
    # _@return_ — The reloaded attributes.
    # 
    # Reload the document.
    # ```ruby
    # document._reload
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def _reload; end

    # Reload the root document.
    # 
    # _@return_ — The reloaded attributes.
    # 
    # Reload the document.
    # ```ruby
    # document.reload_root_document
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def reload_root_document; end

    # Reload the embedded document.
    # 
    # _@return_ — The reloaded attributes.
    # 
    # Reload the document.
    # ```ruby
    # document.reload_embedded_document
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def reload_embedded_document; end

    # Extract only the desired embedded document from the attributes.
    # 
    # _@param_ `attributes` — The document in the db.
    # 
    # _@return_ — The document's extracted attributes.
    # 
    # Extract the embedded document.
    # ```ruby
    # document.extract_embedded_attributes(attributes)
    # ```
    sig { params(attributes: T::Hash[T.untyped, T.untyped]).returns(T::Hash[T.untyped, T.untyped]) }
    def extract_embedded_attributes(attributes); end

    # Determine if the document itself is embedded in another document via the
    # proper channels. (If it has a parent document.)
    # 
    # _@return_ — True if the document has a parent document.
    # 
    # Is the document embedded?
    # ```ruby
    # address.embedded?
    # ```
    sig { returns(T::Boolean) }
    def embedded?; end

    # Determine if the document is part of an embeds_many association.
    # 
    # _@return_ — True if in an embeds many.
    # 
    # Is the document in an embeds many?
    # ```ruby
    # address.embedded_many?
    # ```
    sig { returns(T::Boolean) }
    def embedded_many?; end

    # Determine if the document is part of an embeds_one association.
    # 
    # _@return_ — True if in an embeds one.
    # 
    # Is the document in an embeds one?
    # ```ruby
    # address.embedded_one?
    # ```
    sig { returns(T::Boolean) }
    def embedded_one?; end

    # Get the association name for this document. If no association was defined
    #   an error will be raised.
    # 
    # _@return_ — The association name.
    # 
    # Get the association name.
    # ```ruby
    # document.association_name
    # ```
    sig { returns(Symbol) }
    def association_name; end

    # Determine if the document is part of an references_many association.
    # 
    # _@return_ — True if in a references many.
    # 
    # Is the document in a references many?
    # ```ruby
    # post.referenced_many?
    # ```
    sig { returns(T::Boolean) }
    def referenced_many?; end

    # Determine if the document is part of an references_one association.
    # 
    # _@return_ — True if in a references one.
    # 
    # Is the document in a references one?
    # ```ruby
    # address.referenced_one?
    # ```
    sig { returns(T::Boolean) }
    def referenced_one?; end

    # Convenience method for iterating through the loaded associations and
    # reloading them.
    # 
    # _@return_ — The association metadata.
    # 
    # Reload the associations.
    # ```ruby
    # document.reload_relations
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def reload_relations; end

    # Returns the association metadata for the supplied name.
    # 
    # _@param_ `name` — The name of the association to find.
    # 
    # _@return_ — The matching association metadata.
    # 
    # Find association metadata by name.
    # ```ruby
    # person.reflect_on_association(:addresses)
    # ```
    sig { params(name: T.any(String, Symbol)).returns(Association) }
    def reflect_on_association(name); end

    # Returns all association metadata for the supplied macros.
    # 
    # _@param_ `macros` — The association macros.
    # 
    # _@return_ — The matching association metadata.
    # 
    # Find multiple association metadata by macro.
    # ```ruby
    # person.reflect_on_all_associations(:embeds_many)
    # ```
    sig { params(macros: T::Array[Symbol]).returns(T::Array[Association]) }
    def reflect_on_all_association(*macros); end

    # This is convenience for libraries still on the old API.
    # 
    # _@return_ — The associations.
    # 
    # Get the associations.
    # ```ruby
    # person.associations
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def associations; end

    # Parse out the attributes and the options from the args passed to a
    # build_ or create_ methods.
    # 
    # _@param_ `args` — The arguments.
    # 
    # _@return_ — The attributes and options.
    # 
    # Parse the args.
    # ```ruby
    # doc.parse_args(:name => "Joe")
    # ```
    sig { params(args: T::Array[T.untyped]).returns(T::Array[T::Hash[T.untyped, T.untyped]]) }
    def parse_args(*args); end

        # Perform all cascading deletes, destroys, or nullifies. Will delegate to
    # the appropriate strategy to perform the operation.
    # 
    # Execute cascades.
    # ```ruby
    # document.apply_delete_dependencies!
    # ```
    sig { returns(T.untyped) }
    def apply_delete_dependencies!; end

            sig { params(association: T.untyped).returns(T.untyped) }
    def _dependent_delete_all!(association); end

            sig { params(association: T.untyped).returns(T.untyped) }
    def _dependent_destroy!(association); end

            sig { params(association: T.untyped).returns(T.untyped) }
    def _dependent_nullify!(association); end

            sig { params(association: T.untyped).returns(T.untyped) }
    def _dependent_restrict_with_exception!(association); end

            sig { params(association: T.untyped).returns(T.untyped) }
    def _dependent_restrict_with_error!(association); end

    # Builds the related document and creates the association unless the
    # document is nil, then sets the association on this document.
    # 
    # _@param_ `name` — The name of the association.
    # 
    # _@param_ `object` — The id or attributes to use.
    # 
    # _@param_ `association` — The association metadata.
    # 
    # _@param_ `selected_fields` — Fields which were retrieved via #only. If selected_fields is specified, fields not listed in it will not be accessible in the built document.
    # 
    # _@return_ — The association.
    # 
    # Build the association.
    # ```ruby
    # person.__build__(:addresses, { :_id => 1 }, association)
    # ```
    sig do
      params(
        name: T.any(String, Symbol),
        object: T.any(T::Hash[T.untyped, T.untyped], BSON::ObjectId),
        association: Association,
        selected_fields: T.nilable(T::Hash[T.untyped, T.untyped])
      ).returns(Proxy)
    end
    def __build__(name, object, association, selected_fields = nil); end

    # Create an association from an object and association metadata.
    # 
    # _@param_ `object` — The association target.
    # 
    # _@param_ `association` — The association metadata.
    # 
    # _@param_ `selected_fields` — Fields which were retrieved via #only. If selected_fields is specified, fields not listed in it will not be accessible in the created association document.
    # 
    # _@return_ — The association.
    # 
    # Create the association.
    # ```ruby
    # person.create_relation(document, association)
    # ```
    sig { params(object: T.any(Document, T::Array[Document]), association: Association, selected_fields: T.nilable(T::Hash[T.untyped, T.untyped])).returns(Proxy) }
    def create_relation(object, association, selected_fields = nil); end

        # Resets the criteria inside the association proxy. Used by many-to-many
    # associations to keep the underlying ids array in sync.
    # 
    # _@param_ `name` — The name of the association.
    # 
    # Reset the association criteria.
    # ```ruby
    # person.reset_relation_criteria(:preferences)
    # ```
    sig { params(name: Symbol).returns(T.untyped) }
    def reset_relation_criteria(name); end

    # Set the supplied association to an instance variable on the class with the
    # provided name. Used as a helper just for code cleanliness.
    # 
    # _@param_ `name` — The name of the association.
    # 
    # _@param_ `relation` — The association to set.
    # 
    # _@return_ — The association.
    # 
    # Set the proxy on the document.
    # ```ruby
    # person.set(:addresses, addresses)
    # ```
    sig { params(name: T.any(String, Symbol), relation: Proxy).returns(Proxy) }
    def set_relation(name, relation); end

    # Get the association. Extracted out from the getter method to avoid
    # infinite recursion when overriding the getter.
    # 
    # _@param_ `name` — The name of the association.
    # 
    # _@param_ `association` — The association metadata.
    # 
    # _@param_ `object` — The object used to build the association.
    # 
    # _@param_ `reload` — If the association is to be reloaded.
    # 
    # _@return_ — The association.
    # 
    # Get the association.
    # ```ruby
    # document.get_relation(:name, association)
    # ```
    sig do
      params(
        name: Symbol,
        association: Association,
        object: Object,
        reload: T::Boolean
      ).returns(Proxy)
    end
    def get_relation(name, association, object, reload = false); end

    # Returns a subset of __selected_fields attribute applicable to the
    # (embedded) association with the given key, or nil if no projection
    # is to be performed.
    # 
    # For example, if __selected_fields is {'a' => 1, 'b.c' => 2, 'b.c.f' => 3},
    # and assoc_key is 'b', return value would be {'c' => 2, 'c.f' => 3}.
    # 
    # _@param_ `assoc_key`
    sig { params(assoc_key: String).returns(T.nilable(T::Hash[T.untyped, T.untyped])) }
    def _mongoid_filter_selected_fields(assoc_key); end

            sig { params(object: T.untyped, association: T.untyped).returns(T::Boolean) }
    def needs_no_database_query?(object, association); end

    # Is the current code executing without autobuild functionality?
    # 
    # _@return_ — If autobuild is disabled.
    # 
    # Is autobuild disabled?
    # ```ruby
    # document.without_autobuild?
    # ```
    sig { returns(T::Boolean) }
    def without_autobuild?; end

    # Yield to the block with autobuild functionality turned off.
    # 
    # _@return_ — The result of the yield.
    # 
    # Execute without autobuild.
    # ```ruby
    # document.without_autobuild do
    #   document.name
    # end
    # ```
    sig { returns(Object) }
    def without_autobuild; end

    # Is the document able to be synced on the inverse side? This is only if
    # the key has changed and the association bindings have not been run.
    # 
    # _@param_ `association` — The association metadata.
    # 
    # _@return_ — If we can sync.
    # 
    # Are the foreign keys syncable?
    # ```ruby
    # document._syncable?(association)
    # ```
    sig { params(association: Association).returns(T::Boolean) }
    def _syncable?(association); end

    # Get the synced foreign keys.
    # 
    # _@return_ — The synced foreign keys.
    # 
    # Get the synced foreign keys.
    # ```ruby
    # document._synced
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def _synced; end

    # Has the document been synced for the foreign key?
    # 
    # _@param_ `foreign_key` — The foreign key.
    # 
    # _@return_ — If we can sync.
    # 
    # Has the document been synced?
    # ```ruby
    # document._synced?
    # ```
    sig { params(foreign_key: String).returns(T::Boolean) }
    def _synced?(foreign_key); end

    # Update the inverse keys on destroy.
    # 
    # _@param_ `association` — The association.
    # 
    # _@return_ — The updated values.
    # 
    # Update the inverse keys.
    # ```ruby
    # document.remove_inverse_keys(association)
    # ```
    sig { params(association: Association).returns(Object) }
    def remove_inverse_keys(association); end

    # Update the inverse keys for the association.
    # 
    # _@param_ `association` — The document association.
    # 
    # _@return_ — The updated values.
    # 
    # Update the inverse keys
    # ```ruby
    # document.update_inverse_keys(association)
    # ```
    sig { params(association: Association).returns(Object) }
    def update_inverse_keys(association); end

        # Reset the given counter using the .count() query from the
    # db. This method is usuful in case that a counter got
    # corrupted, or a new counter was added to the collection.
    # 
    # _@param_ `counters` — One or more counter caches to reset
    # 
    # Reset the given counter cache
    # ```ruby
    # post.reset_counters(:comments)
    # ```
    sig { params(counters: T.any(Symbol, T::Array[T.untyped])).returns(T.untyped) }
    def reset_counters(*counters); end

    # Used to prevent infinite loops in associated autosaves.
    # 
    # _@return_ — Has the document already been autosaved?
    # 
    # Is the document autosaved?
    # ```ruby
    # document.autosaved?
    # ```
    sig { returns(T::Boolean) }
    def autosaved?; end

        # Begin the associated autosave.
    # 
    # Begin autosave.
    # ```ruby
    # document.__autosaving__
    # ```
    sig { returns(T.untyped) }
    def __autosaving__; end

        # Check if there is changes for auto-saving
    # 
    #   document.changed_for_autosave?
    # 
    # Return true if there is changes on self or in
    # ```ruby
    # autosaved associations.
    # ```
    sig { params(doc: T.untyped).returns(T::Boolean) }
    def changed_for_autosave?(doc); end

    # Execute operations atomically (in a single database call) for everything
    # that would happen inside the block. This method supports nesting further
    # calls to atomically, which will behave according to the options described
    # below.
    # 
    # An option join_context can be given which, when true, will merge the
    # operations declared by the given block with the atomically block wrapping
    # the current invocation for the same document, if one exists. If this
    # block or any other block sharing the same context raises before
    # persisting, then all the operations of that context will not be
    # persisted, and will also be reset in memory.
    # 
    # When join_context is false, the given block of operations will be
    # persisted independently of other contexts. Failures in other contexts will
    # not affect this one, so long as this block was able to run and persist
    # changes.
    # 
    # The default value of join_context is set by the global configuration
    # option join_contexts, whose own default is false.
    # 
    # _@param_ `join_context` — Join the context (i.e. merge declared atomic operations) of the atomically block wrapping this one for the same document, if one exists.
    # 
    # _@return_ — If the operation succeeded.
    # 
    # Execute the operations atomically.
    # ```ruby
    # document.atomically do
    #   document.set(name: "Tool").inc(likes: 10)
    # end
    # ```
    # 
    # Execute some inner operations atomically, but independently from the outer operations.
    # ```ruby
    # 
    # document.atomically do
    #   document.inc likes: 10
    #   document.atomically join_context: false do
    #     # The following is persisted to the database independently.
    #     document.unset :origin
    #   end
    #   document.atomically join_context: true do
    #     # The following is persisted along with the other outer operations.
    #     document.inc member_count: 3
    #   end
    #   document.set name: "Tool"
    # end
    # ```
    sig { params(join_context: T.nilable(T::Boolean)).returns(T::Boolean) }
    def atomically(join_context: nil); end

        # Raise an error if validation failed.
    # 
    # Raise the validation error.
    # ```ruby
    # Person.fail_due_to_validation!(person)
    # ```
    sig { returns(T.untyped) }
    def fail_due_to_validation!; end

        # Raise an error if a callback failed.
    # 
    # _@param_ `method` — The method being called.
    # 
    # Raise the callback error.
    # ```ruby
    # Person.fail_due_to_callback!(person, :create!)
    # ```
    sig { params(method: Symbol).returns(T.untyped) }
    def fail_due_to_callback!(method); end

    # Are we executing an atomically block on the current document?
    # 
    # _@return_ — If we are current executing atomically.
    # 
    # Are we executing atomically?
    # ```ruby
    # document.executing_atomically?
    # ```
    sig { returns(T::Boolean) }
    def executing_atomically?; end

    # Post process the persistence operation.
    # 
    # _@param_ `result` — The result of the operation.
    # 
    # _@param_ `options` — The options.
    # 
    # _@return_ — true.
    # 
    # Post process the persistence operation.
    # ```ruby
    # document.post_process_persist(true)
    # ```
    sig { params(result: Object, options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
    def post_process_persist(result, options = {}); end

    # Prepare an atomic persistence operation. Yields an empty hash to be sent
    # to the update.
    # 
    # _@return_ — The result of the operation.
    # 
    # Prepare the atomic operation.
    # ```ruby
    # document.prepare_atomic_operation do |coll, selector, opts|
    #   ...
    # end
    # ```
    sig { returns(Object) }
    def prepare_atomic_operation; end

    # Process the atomic operations - this handles the common behavior of
    # iterating through each op, getting the aliased field name, and removing
    # appropriate dirty changes.
    # 
    # _@param_ `operations` — The atomic operations.
    # 
    # _@return_ — The operations.
    # 
    # Process the atomic operations.
    # ```ruby
    # document.process_atomic_operations(pulls) do |field, value|
    #   ...
    # end
    # ```
    sig { params(operations: T::Hash[T.untyped, T.untyped]).returns(T::Hash[T.untyped, T.untyped]) }
    def process_atomic_operations(operations); end

        # Remove the dirty changes for all fields changed in the current atomic
    # context.
    # 
    # Remove the current atomic context's dirty changes.
    # ```ruby
    # document._mongoid_remove_atomic_context_changes
    # ```
    sig { returns(T.untyped) }
    def _mongoid_remove_atomic_context_changes; end

        # Reset the attributes for all fields changed in the current atomic
    # context.
    # 
    # Reset the current atomic context's changed attributes.
    # ```ruby
    # document._mongoid_reset_atomic_context_changes!
    # ```
    sig { returns(T.untyped) }
    def _mongoid_reset_atomic_context_changes!; end

        # Push a new atomic context onto the stack.
    # 
    # Push a new atomic context onto the stack.
    # ```ruby
    # document._mongoid_push_atomic_context
    # ```
    sig { returns(T.untyped) }
    def _mongoid_push_atomic_context; end

        # Pop an atomic context off the stack.
    # 
    # Pop an atomic context off the stack.
    # ```ruby
    # document._mongoid_pop_atomic_context
    # ```
    sig { returns(T.untyped) }
    def _mongoid_pop_atomic_context; end

    # Return the current atomic context's changed fields.
    # 
    # _@return_ — The changed fields.
    # 
    # Return the current atomic context's changed fields.
    # ```ruby
    # document._mongoid_atomic_context_changed_fields
    # ```
    sig { returns(T::Array[T.untyped]) }
    def _mongoid_atomic_context_changed_fields; end

        # If we are in an atomically block, add the operations to the delayed group,
    # otherwise persist immediately.
    # 
    # _@param_ `operation` — The operation.
    # 
    # Persist immediately or delay the operations.
    # ```ruby
    # document.persist_or_delay_atomic_operation(ops)
    # ```
    sig { params(operation: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
    def persist_or_delay_atomic_operation(operation); end

        # Persist the atomic operations.
    # 
    # _@param_ `operations` — The atomic operations.
    # 
    # Persist the atomic operations.
    # ```ruby
    # persist_atomic_operations(ops)
    # ```
    sig { params(operations: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
    def persist_atomic_operations(operations); end

    # Perform an $unset operation on the provided fields and in the
    # values in the document in memory.
    # 
    # _@param_ `fields` — The names of the fields to unset.
    # 
    # _@return_ — The document.
    # 
    # Unset the values.
    # ```ruby
    # document.unset(:first_name, :last_name, :middle)
    # ```
    sig { params(fields: T::Array[T.any(String, Symbol)]).returns(Document) }
    def unset(*fields); end

    # Perform an upsert of the document. If the document does not exist in the
    # database, then Mongo will insert a new one, otherwise the fields will get
    # overwritten with new values on the existing document.
    # 
    # _@param_ `options` — The validation options.
    # 
    # _@return_ — True.
    # 
    # Upsert the document.
    # ```ruby
    # document.upsert
    # ```
    sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
    def upsert(options = {}); end

    # Prepare the upsert for execution.
    # 
    # _@param_ `options` — The options hash.
    # 
    # _@return_ — If the operation succeeded.
    # 
    # Prepare the upsert
    # ```ruby
    # document.prepare_upsert do
    #   collection.find(selector).update(as_document)
    # end
    # ```
    sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
    def prepare_upsert(options = {}); end

    # Update a single attribute and persist the entire document.
    # This skips validation but fires the callbacks.
    # 
    # _@param_ `name` — The name of the attribute.
    # 
    # _@param_ `value` — The new value of the attribute.a
    # 
    # _@return_ — True if save was successfull, false if not.
    # 
    # Update the attribute.
    # ```ruby
    # person.update_attribute(:title, "Sir")
    # ```
    sig { params(name: T.any(Symbol, String), value: Object).returns(T::Boolean) }
    def update_attribute(name, value); end

    # Update the document attributes in the database.
    # 
    # _@param_ `attributes` — The attributes to update.
    # 
    # _@return_ — True if validation passed, false if not.
    # 
    # Update the document's attributes
    # ```ruby
    # document.update(:title => "Sir")
    # ```
    sig { params(attributes: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
    def update(attributes = {}); end

    # Update the document attributes in the database and raise an error if
    # validation failed.
    # 
    # _@param_ `attributes` — The attributes to update.
    # 
    # _@return_ — True if validation passed.
    # 
    # Update the document's attributes.
    # ```ruby
    # document.update!(:title => "Sir")
    # ```
    sig { params(attributes: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
    def update!(attributes = {}); end

    # Initialize the atomic updates.
    # 
    # _@return_ — The updates and conflicts.
    # 
    # Initialize the atomic updates.
    # ```ruby
    # document.init_atomic_updates
    # ```
    sig { returns(T::Array[T::Hash[T.untyped, T.untyped]]) }
    def init_atomic_updates; end

    # Prepare the update for execution. Validates and runs callbacks, etc.
    # 
    # _@param_ `options` — The options.
    # 
    # _@return_ — The result of the update.
    # 
    # Prepare for update.
    # ```ruby
    # document.prepare_update do
    #   collection.update(atomic_selector)
    # end
    # ```
    sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
    def prepare_update(options = {}); end

    # Update the document in the database.
    # 
    # _@param_ `options` — Options to pass to update.
    # 
    # _@return_ — True if succeeded, false if not.
    # 
    # Update an existing document.
    # ```ruby
    # document.update
    # ```
    sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
    def update_document(options = {}); end

    # Perform a $set operation on the provided field/value pairs and set the
    # values in the document in memory.
    # 
    # The key can be a dotted sequence of keys, in which case the
    # top level field is treated as a nested hash and any missing keys
    # are created automatically:
    # 
    # Performing a nested set like this merges values of intermediate keys:
    # 
    # If the top level field was not a hash, its original value is discarded
    # and the field is replaced with a hash.
    # 
    # Note that unlike MongoDB's $set, Mongoid's set writes out the entire
    # field even when setting a subset of the field via the nested hash
    # semantics. This means performing a $set with nested hash semantics
    # can overwrite other hash keys within the top level field in the database.
    # 
    # _@param_ `setters` — The field/value pairs to set.
    # 
    # _@return_ — The document.
    # 
    # Set the values.
    # ```ruby
    # document.set(title: "sir", dob: Date.new(1970, 1, 1))
    # ```
    # 
    # Set the values using nested hash semantics.
    # ```ruby
    # document.set('author.title' => 'Sir')
    # # => document.author == {'title' => 'Sir'}
    # ```
    # 
    # Nested hash value merging.
    # ```ruby
    # document.set('author.title' => 'Sir')
    # document.set('author.name' => 'Linus Torvalds')
    # # => document.author == {'title' => 'Sir', 'name' => 'Linus Torvalds'}
    # ```
    # 
    # Nested hash overwriting a non-hash value.
    # ```ruby
    # document.set('author' => 'John Doe')
    # document.set('author.title' => 'Sir')
    # # => document.author == {'title' => 'Sir'}
    # ```
    sig { params(setters: T::Hash[T.untyped, T.untyped]).returns(Document) }
    def set(setters); end

    # Save the document - will perform an insert if the document is new, and
    # update if not.
    # 
    # _@param_ `options` — Options to pass to the save.
    # 
    # _@return_ — True is success, false if not.
    # 
    # Save the document.
    # ```ruby
    # document.save
    # ```
    sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
    def save(options = {}); end

    # Save the document - will perform an insert if the document is new, and
    # update if not. If a validation error occurs an error will get raised.
    # 
    # _@param_ `options` — Options to pass to the save.
    # 
    # _@return_ — True if validation passed.
    # 
    # Save the document.
    # ```ruby
    # document.save!
    # ```
    sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
    def save!(options = {}); end

    # Rename fields from one value to another via $rename.
    # 
    # _@param_ `renames` — The rename pairs of old name/new name.
    # 
    # _@return_ — The document.
    # 
    # Rename the fields.
    # ```ruby
    # document.rename(title: "salutation", name: "nombre")
    # ```
    # 
    # _@note_ — This does not work for fields in embeds many associations.
    sig { params(renames: T::Hash[T.untyped, T.untyped]).returns(Document) }
    def rename(renames); end

    # Add the single values to the arrays only if the value does not already
    # exist in the array.
    # 
    # _@param_ `adds` — The field/value pairs to add.
    # 
    # _@return_ — The document.
    # 
    # Add the values to the sets.
    # ```ruby
    # document.add_to_set(names: "James", aliases: "Bond")
    # ```
    sig { params(adds: T::Hash[T.untyped, T.untyped]).returns(Document) }
    def add_to_set(adds); end

    # Push a single value or multiple values onto arrays.
    # 
    # _@param_ `pushes` — The $push operations.
    # 
    # _@return_ — The document.
    # 
    # Push a single value onto arrays.
    # ```ruby
    # document.push(names: "James", aliases: "007")
    # ```
    # 
    # Push multiple values onto arrays.
    # ```ruby
    # document.push(names: [ "James", "Bond" ])
    # ```
    sig { params(pushes: T::Hash[T.untyped, T.untyped]).returns(Document) }
    def push(pushes); end

    # Pull single values from the provided arrays.
    # 
    # _@param_ `pulls` — The field/value pull pairs.
    # 
    # _@return_ — The document.
    # 
    # Pull a value from the array.
    # ```ruby
    # document.pull(names: "Jeff", levels: 5)
    # ```
    # 
    # _@note_ — If duplicate values are found they will all be pulled.
    sig { params(pulls: T::Hash[T.untyped, T.untyped]).returns(Document) }
    def pull(pulls); end

    # Pull multiple values from the provided array fields.
    # 
    # _@param_ `pulls` — The pull all operations.
    # 
    # _@return_ — The document.
    # 
    # Pull values from the arrays.
    # ```ruby
    # document.pull_all(names: [ "Jeff", "Bob" ], levels: [ 5, 6 ])
    # ```
    sig { params(pulls: T::Hash[T.untyped, T.untyped]).returns(Document) }
    def pull_all(pulls); end

    # Takes the provided selector and atomic operations and replaces the
    # indexes of the embedded documents with the positional operator when
    # needed.
    # 
    # _@param_ `selector` — The selector.
    # 
    # _@param_ `operations` — The update operations.
    # 
    # _@param_ `processed` — The processed update operations.
    # 
    # _@return_ — The new operations.
    # 
    # Process the operations.
    # ```ruby
    # positionally(
    #   { "_id" => 1, "addresses._id" => 2 },
    #   { "$set" => { "addresses.0.street" => "hobrecht" }}
    # )
    # ```
    # 
    # _@note_ — The only time we can accurately know when to use the positional
    # operator is at the exact time we are going to persist something. So
    # we can tell by the selector that we are sending if it is actually
    # possible to use the positional operator at all. For example, if the
    # selector is: { "_id" => 1 }, then we could not use the positional
    # operator for updating embedded documents since there would never be a
    # match - we base whether we can based on the number of levels deep the
    # selector goes, and if the id values are not nil.
    sig { params(selector: T::Hash[T.untyped, T.untyped], operations: T::Hash[T.untyped, T.untyped], processed: T::Hash[T.untyped, T.untyped]).returns(T::Hash[T.untyped, T.untyped]) }
    def positionally(selector, operations, processed = {}); end

                    sig { params(keys: T.untyped, operations: T.untyped, processed: T.untyped).returns(T.untyped) }
    def process_operations(keys, operations, processed); end

                    sig { params(keys: T.untyped, update: T.untyped, updates: T.untyped).returns(T.untyped) }
    def process_updates(keys, update, updates = {}); end

                sig { params(keys: T.untyped, position: T.untyped).returns(T.untyped) }
    def replace_index(keys, position); end

    # Pop or shift items from arrays using the $pop operator.
    # 
    # _@param_ `pops` — The field/value pop operations.
    # 
    # _@return_ — The document.
    # 
    # Pop items from an array.
    # ```ruby
    # document.pop(aliases: 1)
    # ```
    # 
    # Shift items in the array.
    # ```ruby
    # document.pop(aliases: -1)
    # ```
    # 
    # Multiple pops in one call.
    # ```ruby
    # document.pop(names: 1, aliases: 1)
    # ```
    sig { params(pops: T::Hash[T.untyped, T.untyped]).returns(Document) }
    def pop(pops); end

    # Performs an atomic $bit operation on the field with the provided hash
    # of bitwise ops to execute in order.
    # 
    # _@param_ `operations` — The bitwise operations.
    # 
    # _@return_ — The document.
    # 
    # Execute the bitwise operations.
    # ```ruby
    # person.bit(age: { :and => 12 }, val: { and: 10, or: 12 })
    # ```
    sig { params(operations: T::Hash[T.untyped, T.untyped]).returns(Document) }
    def bit(operations); end

    # Increment the provided fields by the corresponding values. Values can
    # be positive or negative, and if no value exists for the field it will
    # be set with the provided value.
    # 
    # _@param_ `increments` — The field/inc increment pairs.
    # 
    # _@return_ — The document.
    # 
    # Increment the fields.
    # ```ruby
    # document.inc(score: 10, place: 1, lives: -10)
    # ```
    sig { params(increments: T::Hash[T.untyped, T.untyped]).returns(Document) }
    def inc(increments); end

    # Remove the document from the database with callbacks.
    # 
    # _@param_ `options` — Options to pass to destroy.
    # 
    # _@return_ — True if successful, false if not.
    # 
    # Destroy a document.
    # ```ruby
    # document.destroy
    # ```
    sig { params(options: T.nilable(T::Hash[T.untyped, T.untyped])).returns(T::Boolean) }
    def destroy(options = nil); end

            sig { params(options: T.untyped).returns(T.untyped) }
    def destroy!(options = {}); end

    # Remove the document from the database.
    # 
    # _@param_ `options` — Options to pass to remove.
    # 
    # _@return_ — True.
    # 
    # Remove the document.
    # ```ruby
    # document.remove
    # ```
    sig { params(options: T::Hash[T.untyped, T.untyped]).returns(TrueClass) }
    def delete(options = {}); end

    # Get the atomic deletes for the operation.
    # 
    # _@return_ — The atomic deletes.
    # 
    # Get the atomic deletes.
    # ```ruby
    # document.atomic_deletes
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def atomic_deletes; end

    # Delete the embedded document.
    # 
    # _@param_ `options` — The deletion options.
    # 
    # _@return_ — If the operation succeeded.
    # 
    # Delete the embedded document.
    # ```ruby
    # document.delete_as_embedded
    # ```
    sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
    def delete_as_embedded(options = {}); end

    # Delete the root document.
    # 
    # _@return_ — If the document was removed.
    # 
    # Delete the root document.
    # ```ruby
    # document.delete_as_root
    # ```
    sig { returns(T::Boolean) }
    def delete_as_root; end

    # Are we needing to notify the parent document of the deletion.
    # 
    # _@param_ `options` — The delete options.
    # 
    # _@return_ — If the parent should be notified.
    # 
    # Are we notifying the parent.
    # ```ruby
    # document.notifying_parent?(suppress: true)
    # ```
    sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
    def notifying_parent?(options = {}); end

    # Prepare the delete operation.
    # 
    # _@return_ — The result of the block.
    # 
    # Prepare the delete operation.
    # ```ruby
    # document.prepare_delete do
    #   collection.find(atomic_selector).remove
    # end
    # ```
    sig { returns(Object) }
    def prepare_delete; end

    # Insert a new document into the database. Will return the document
    # itself whether or not the save was successful.
    # 
    # _@param_ `options` — Options to pass to insert.
    # 
    # _@return_ — The persisted document.
    # 
    # Insert a document.
    # ```ruby
    # document.insert
    # ```
    sig { params(options: T::Hash[T.untyped, T.untyped]).returns(Document) }
    def insert(options = {}); end

    # Get the atomic insert for embedded documents, either a push or set.
    # 
    # _@return_ — The insert ops.
    # 
    # Get the inserts.
    # ```ruby
    # document.inserts
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def atomic_inserts; end

    # Insert the embedded document.
    # 
    # _@return_ — The document.
    # 
    # Insert the document as embedded.
    # ```ruby
    # document.insert_as_embedded
    # ```
    sig { returns(Document) }
    def insert_as_embedded; end

    # Insert the root document.
    # 
    # _@return_ — The document.
    # 
    # Insert the document as root.
    # ```ruby
    # document.insert_as_root
    # ```
    sig { returns(Document) }
    def insert_as_root; end

    # Post process an insert, which sets the new record attribute to false
    # and flags all the children as persisted.
    # 
    # _@return_ — true.
    # 
    # Post process the insert.
    # ```ruby
    # document.post_process_insert
    # ```
    sig { returns(T::Boolean) }
    def post_process_insert; end

    # Prepare the insert for execution. Validates and runs callbacks, etc.
    # 
    # _@param_ `options` — The options.
    # 
    # _@return_ — The document.
    # 
    # Prepare for insertion.
    # ```ruby
    # document.prepare_insert do
    #   collection.insert(as_document)
    # end
    # ```
    sig { params(options: T::Hash[T.untyped, T.untyped]).returns(Document) }
    def prepare_insert(options = {}); end

    # Determines if this document has the attributes to match the supplied
    # MongoDB selector. Used for matching on embedded associations.
    # 
    # _@param_ `selector` — The MongoDB selector.
    # 
    # _@return_ — True if matches, false if not.
    # 
    # Does the document match?
    # ```ruby
    # document._matches?(:title => { "$in" => [ "test" ] })
    # ```
    sig { params(selector: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
    def _matches?(selector); end

    # Apply all default values to the document which are not procs.
    # 
    # _@return_ — The names of the non-proc defaults.
    # 
    # Apply all the non-proc defaults.
    # ```ruby
    # model.apply_pre_processed_defaults
    # ```
    sig { returns(T::Array[String]) }
    def apply_pre_processed_defaults; end

    # Apply all default values to the document which are procs.
    # 
    # _@return_ — The names of the proc defaults.
    # 
    # Apply all the proc defaults.
    # ```ruby
    # model.apply_post_processed_defaults
    # ```
    sig { returns(T::Array[String]) }
    def apply_post_processed_defaults; end

        # Applies a single default value for the given name.
    # 
    # _@param_ `name` — The name of the field.
    # 
    # Apply a single default.
    # ```ruby
    # model.apply_default("name")
    # ```
    sig { params(name: String).returns(T.untyped) }
    def apply_default(name); end

        # Apply all the defaults at once.
    # 
    # Apply all the defaults.
    # ```ruby
    # model.apply_defaults
    # ```
    sig { returns(T.untyped) }
    def apply_defaults; end

    # Returns an array of names for the attributes available on this object.
    # 
    # Provides the field names in an ORM-agnostic way. Rails v3.1+ uses this
    # method to automatically wrap params in JSON requests.
    # 
    # _@return_ — The field names
    # 
    # Get the field names
    # ```ruby
    # docment.attribute_names
    # ```
    sig { returns(T::Array[String]) }
    def attribute_names; end

    # Get the name of the provided field as it is stored in the database.
    # Used in determining if the field is aliased or not.
    # 
    # _@param_ `name` — The name to get.
    # 
    # _@return_ — The name of the field as it's stored in the db.
    # 
    # Get the database field name.
    # ```ruby
    # model.database_field_name(:authorization)
    # ```
    sig { params(name: T.any(String, Symbol)).returns(String) }
    def database_field_name(name); end

    # Is the provided field a lazy evaluation?
    # 
    # _@param_ `field` — The field.
    # 
    # _@param_ `value` — The current value.
    # 
    # _@return_ — If we set the field lazily.
    # 
    # If the field is lazy settable.
    # ```ruby
    # doc.lazy_settable?(field, nil)
    # ```
    sig { params(field: T.any(Standard, ForeignKey), value: Object).returns(T::Boolean) }
    def lazy_settable?(field, value); end

    # Is the document using object ids?
    # 
    # _@return_ — Using object ids.
    # 
    # Is the document using object ids?
    # ```ruby
    # model.using_object_ids?
    # ```
    # 
    # _@note_ — Refactored from using delegate for class load performance.
    sig { returns(T::Boolean) }
    def using_object_ids?; end

    # Evolve the document into an object id.
    # 
    # _@return_ — The document's id.
    # 
    # Evolve the document.
    # ```ruby
    # document.__evolve_object_id__
    # ```
    sig { returns(Object) }
    def __evolve_object_id__; end

    # Determine if an attribute is present.
    # 
    # _@param_ `name` — The name of the attribute.
    # 
    # _@return_ — True if present, false if not.
    # 
    # Is the attribute present?
    # ```ruby
    # person.attribute_present?("title")
    # ```
    sig { params(name: T.any(String, Symbol)).returns(T::Boolean) }
    def attribute_present?(name); end

    # Get the attributes that have not been cast.
    # 
    # _@return_ — The uncast attributes.
    # 
    # Get the attributes before type cast.
    # ```ruby
    # document.attributes_before_type_cast
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def attributes_before_type_cast; end

    # Does the document have the provided attribute?
    # 
    # _@param_ `name` — The name of the attribute.
    # 
    # _@return_ — If the key is present in the attributes.
    # 
    # Does the document have the attribute?
    # ```ruby
    # model.has_attribute?(:name)
    # ```
    sig { params(name: T.any(String, Symbol)).returns(T::Boolean) }
    def has_attribute?(name); end

    # Does the document have the provided attribute before it was assigned
    # and type cast?
    # 
    # _@param_ `name` — The name of the attribute.
    # 
    # _@return_ — If the key is present in the
    # attributes_before_type_cast.
    # 
    # Does the document have the attribute before it was assigned?
    # ```ruby
    # model.has_attribute_before_type_cast?(:name)
    # ```
    sig { params(name: T.any(String, Symbol)).returns(T::Boolean) }
    def has_attribute_before_type_cast?(name); end

    # Read a value from the document attributes. If the value does not exist
    # it will return nil.
    # 
    # _@param_ `name` — The name of the attribute to get.
    # 
    # _@return_ — The value of the attribute.
    # 
    # Read an attribute.
    # ```ruby
    # person.read_attribute(:title)
    # ```
    # 
    # Read an attribute (alternate syntax.)
    # ```ruby
    # person[:title]
    # ```
    sig { params(name: T.any(String, Symbol)).returns(Object) }
    def read_attribute(name); end

    # Read a value from the attributes before type cast. If the value has not
    # yet been assigned then this will return the attribute's existing value
    # using read_raw_attribute.
    # 
    # _@param_ `name` — The name of the attribute to get.
    # 
    # _@return_ — The value of the attribute before type cast, if
    # available. Otherwise, the value of the attribute.
    # 
    # Read an attribute before type cast.
    # ```ruby
    # person.read_attribute_before_type_cast(:price)
    # ```
    sig { params(name: T.any(String, Symbol)).returns(Object) }
    def read_attribute_before_type_cast(name); end

        # Remove a value from the +Document+ attributes. If the value does not exist
    # it will fail gracefully.
    # 
    # _@param_ `name` — The name of the attribute to remove.
    # 
    # Remove the attribute.
    # ```ruby
    # person.remove_attribute(:title)
    # ```
    sig { params(name: T.any(String, Symbol)).returns(T.untyped) }
    def remove_attribute(name); end

        # Write a single attribute to the document attribute hash. This will
    # also fire the before and after update callbacks, and perform any
    # necessary typecasting.
    # 
    # _@param_ `name` — The name of the attribute to update.
    # 
    # _@param_ `value` — The value to set for the attribute.
    # 
    # Write the attribute.
    # ```ruby
    # person.write_attribute(:title, "Mr.")
    # ```
    # 
    # Write the attribute (alternate syntax.)
    # ```ruby
    # person[:title] = "Mr."
    # ```
    sig { params(name: T.any(String, Symbol), value: Object).returns(T.untyped) }
    def write_attribute(name, value); end

        # Allows you to set all the attributes for a particular mass-assignment security role
    # by passing in a hash of attributes with keys matching the attribute names
    # (which again matches the column names)  and the role name using the :as option.
    # To bypass mass-assignment security you can use the :without_protection => true option.
    # 
    # _@param_ `attrs` — The new attributes to set.
    # 
    # Assign the attributes.
    # ```ruby
    # person.assign_attributes(:title => "Mr.")
    # ```
    # 
    # Assign the attributes (with a role).
    # ```ruby
    # person.assign_attributes({ :title => "Mr." }, :as => :admin)
    # ```
    sig { params(attrs: T.nilable(T::Hash[T.untyped, T.untyped])).returns(T.untyped) }
    def assign_attributes(attrs = nil); end

        # Writes the supplied attributes hash to the document. This will only
    # overwrite existing attributes if they are present in the new +Hash+, all
    # others will be preserved.
    # 
    # _@param_ `attrs` — The new attributes to set.
    # 
    # Write the attributes.
    # ```ruby
    # person.write_attributes(:title => "Mr.")
    # ```
    # 
    # Write the attributes (alternate syntax.)
    # ```ruby
    # person.attributes = { :title => "Mr." }
    # ```
    sig { params(attrs: T.nilable(T::Hash[T.untyped, T.untyped])).returns(T.untyped) }
    def write_attributes(attrs = nil); end

    # Determine if the attribute is missing from the document, due to loading
    # it from the database with missing fields.
    # 
    # _@param_ `name` — The name of the attribute.
    # 
    # _@return_ — If the attribute is missing.
    # 
    # Is the attribute missing?
    # ```ruby
    # document.attribute_missing?("test")
    # ```
    sig { params(name: String).returns(T::Boolean) }
    def attribute_missing?(name); end

    # Return type-casted attributes.
    # 
    # _@return_ — The hash with keys and values of the type-casted attributes.
    # 
    # Type-casted attributes.
    # ```ruby
    # document.typed_attributes
    # ```
    sig { returns(Object) }
    def typed_attributes; end

                sig { params(name: T.untyped, selection: T.untyped, field: T.untyped).returns(T::Boolean) }
    def selection_excluded?(name, selection, field); end

                sig { params(name: T.untyped, selection: T.untyped, field: T.untyped).returns(T::Boolean) }
    def selection_included?(name, selection, field); end

        # Does the string contain dot syntax for accessing hashes?
    # 
    # _@return_ — If the string contains a "."
    # 
    # Is the string in dot syntax.
    # ```ruby
    # model.hash_dot_syntax?
    # ```
    sig { params(string: T.untyped).returns(T::Boolean) }
    def hash_dot_syntax?(string); end

    # Return the typecasted value for a field.
    # 
    # _@param_ `key` — The field name.
    # 
    # _@param_ `value` — The uncast value.
    # 
    # _@return_ — The cast value.
    # 
    # Get the value typecasted.
    # ```ruby
    # person.typed_value_for(:title, :sir)
    # ```
    sig { params(key: T.any(String, Symbol), value: Object).returns(Object) }
    def typed_value_for(key, value); end

            sig { params(name: T.untyped).returns(T.untyped) }
    def read_raw_attribute(name); end

        # Validates an attribute value as being assignable to the specified field.
    # 
    # For now, only Hash and Array fields are validated, and the value is
    # being checked to be of an appropriate type (i.e. either Hash or Array,
    # respectively, or nil).
    # 
    # This method takes the name of the field as stored in the document
    # in the database, not (necessarily) the Ruby method name used to read/write
    # the said field.
    # 
    # _@param_ `field_name` — The name of the field.
    # 
    # _@param_ `value` — The value to be validated.
    sig { params(field_name: T.any(String, Symbol), value: Object).returns(T.untyped) }
    def validate_attribute_value(field_name, value); end

                sig { params(name: T.untyped, value: T.untyped).returns(T.untyped) }
    def lookup_attribute_presence(name, value); end

    # Are we able to write the attribute with the provided name?
    # 
    # _@param_ `name` — The name of the field.
    # 
    # _@return_ — If the document is new, or if the field is not
    # readonly.
    # 
    # Can we write the attribute?
    # ```ruby
    # model.attribute_writable?(:title)
    # ```
    sig { params(name: T.any(String, Symbol)).returns(T::Boolean) }
    def attribute_writable?(name); end

                sig { params(name: T.untyped, value: T.untyped).returns(T.untyped) }
    def as_writable_attribute!(name, value = :nil); end

        sig { params(name: T.untyped).returns(T::Boolean) }
    def _loaded?(name); end

        sig { params(name: T.untyped).returns(T::Boolean) }
    def projected_field?(name); end

        # Process the provided attributes casting them to their proper values if a
    # field exists for them on the document. This will be limited to only the
    # attributes provided in the suppied +Hash+ so that no extra nil values get
    # put into the document's attributes.
    # 
    # _@param_ `attrs` — The attributes to set.
    # 
    # Process the attributes.
    # ```ruby
    # person.process_attributes(:title => "sir", :age => 40)
    # ```
    sig { params(attrs: T.nilable(T::Hash[T.untyped, T.untyped])).returns(T.untyped) }
    def process_attributes(attrs = nil); end

    # If the key provided is the name of an association or a nested attribute, we
    # need to wait until all other attributes are set before processing
    # these.
    # 
    # _@param_ `key` — The name of the attribute.
    # 
    # _@param_ `value` — The value of the attribute.
    # 
    # _@return_ — True if pending, false if not.
    # 
    # Is the attribute pending?
    # ```ruby
    # document.pending_attribute?(:name, "Durran")
    # ```
    sig { params(key: Symbol, value: Object).returns(T::Boolean) }
    def pending_attribute?(key, value); end

    # Get all the pending associations that need to be set.
    # 
    # _@return_ — The pending associations in key/value pairs.
    # 
    # Get the pending associations.
    # ```ruby
    # document.pending_relations
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def pending_relations; end

    # Get all the pending nested attributes that need to be set.
    # 
    # _@return_ — The pending nested attributes in key/value pairs.
    # 
    # Get the pending nested attributes.
    # ```ruby
    # document.pending_nested
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def pending_nested; end

        # If the attribute is dynamic, add a field for it with a type of object
    # and then either way set the value.
    # 
    # _@param_ `name` — The name of the field.
    # 
    # _@param_ `value` — The value of the field.
    # 
    # Process the attribute.
    # ```ruby
    # document.process_attribute(name, value)
    # ```
    sig { params(name: Symbol, value: Object).returns(T.untyped) }
    def process_attribute(name, value); end

        # Process all the pending nested attributes that needed to wait until
    # ids were set to fire off.
    # 
    # Process the nested attributes.
    # ```ruby
    # document.process_nested
    # ```
    sig { returns(T.untyped) }
    def process_nested; end

        # Process all the pending items, then clear them out.
    # 
    # Process the pending items.
    # ```ruby
    # document.process_pending
    # ```
    sig { returns(T.untyped) }
    def process_pending; end

        # Process all the pending associations that needed to wait until ids were set
    # to fire off.
    # 
    # Process the associations.
    # ```ruby
    # document.process_relations
    # ```
    sig { returns(T.untyped) }
    def process_relations; end

    # Execute a block within the context of a session.
    # 
    # _@param_ `options` — The session options. Please see the driver documentation for the available session options.
    # 
    # _@return_ — The result of calling the block.
    # 
    # Execute some operations in the context of a session.
    # ```ruby
    # band.with_session(causal_consistency: true) do
    #   band.records << Record.create
    #   band.name = 'FKA Twigs'
    #   band.save
    #   band.reload
    # end
    # ```
    # 
    # _@note_ — You cannot do any operations in the block using models or objects
    # that use a different client; the block will execute all operations
    # in the context of the implicit session and operations on any models using
    # another client will fail. For example, if you set a client using store_in on a
    # particular model and execute an operation on it in the session context block,
    # that operation can't use the block's session and an error will be raised.
    # An error will also be raised if sessions are nested.
    sig { params(options: T::Hash[T.untyped, T.untyped]).returns(Object) }
    def with_session(options = {}); end

        sig { returns(T.untyped) }
    def _session; end

        # Change the persistence context for this object during the block.
    # 
    # _@param_ `options_or_context` — The storage options or a persistence context.
    # 
    # Save the current document to a different collection.
    # ```ruby
    # model.with(collection: "bands") do |m|
    #   m.save
    # end
    # ```
    sig { params(options_or_context: T.any(T::Hash[T.untyped, T.untyped], Mongoid::PersistenceContext), block: T.untyped).returns(T.untyped) }
    def with(options_or_context, &block); end

            sig { params(parent: T.untyped).returns(T.untyped) }
    def collection(parent = nil); end

        sig { returns(T.untyped) }
    def collection_name; end

        sig { returns(T.untyped) }
    def mongo_client; end

        sig { returns(T.untyped) }
    def persistence_context; end

            sig { params(options_or_context: T.untyped).returns(T.untyped) }
    def set_persistence_context(options_or_context); end

                sig { params(original_cluster: T.untyped, context: T.untyped).returns(T.untyped) }
    def clear_persistence_context(original_cluster = nil, context = nil); end

    # Get the changed attributes for the document.
    # 
    # _@return_ — The changed attributes.
    # 
    # Get the changed attributes.
    # ```ruby
    # model.changed
    # ```
    sig { returns(T::Array[String]) }
    def changed; end

    # Has the document changed?
    # 
    # _@return_ — If the document is changed.
    # 
    # Has the document changed?
    # ```ruby
    # model.changed?
    # ```
    sig { returns(T::Boolean) }
    def changed?; end

    # Have any children (embedded documents) of this document changed?
    # 
    # _@return_ — If any children have changed.
    # 
    # Have any children changed?
    # ```ruby
    # model.children_changed?
    # ```
    sig { returns(T::Boolean) }
    def children_changed?; end

    # Get the attribute changes.
    # 
    # _@return_ — The attribute changes.
    # 
    # Get the attribute changes.
    # ```ruby
    # model.changed_attributes
    # ```
    sig { returns(T::Hash[String, Object]) }
    def changed_attributes; end

    # Get all the changes for the document.
    # 
    # _@return_ — The changes.
    # 
    # Get all the changes.
    # ```ruby
    # model.changes
    # ```
    sig { returns(T::Hash[String, T::Array[T.any(Object, Object)]]) }
    def changes; end

        # Call this method after save, so the changes can be properly switched.
    # 
    # This will unset the memoized children array, set new record to
    # false, set the document as validated, and move the dirty changes.
    # 
    # Move the changes to previous.
    # ```ruby
    # person.move_changes
    # ```
    sig { returns(T.untyped) }
    def move_changes; end

        # Things that need to execute after a document has been persisted.
    # 
    # Handle post persistence.
    # ```ruby
    # document.post_persist
    # ```
    sig { returns(T.untyped) }
    def post_persist; end

    # Get the previous changes on the document.
    # 
    # _@return_ — The previous changes.
    # 
    # Get the previous changes.
    # ```ruby
    # model.previous_changes
    # ```
    sig { returns(T::Hash[String, T::Array[T.any(Object, Object)]]) }
    def previous_changes; end

        # Remove a change from the dirty attributes hash. Used by the single field
    # atomic updators.
    # 
    # _@param_ `name` — The name of the field.
    # 
    # Remove a flagged change.
    # ```ruby
    # model.remove_change(:field)
    # ```
    sig { params(name: T.any(Symbol, String)).returns(T.untyped) }
    def remove_change(name); end

    # Gets all the new values for each of the changed fields, to be passed to
    # a MongoDB $set modifier.
    # 
    # _@return_ — A +Hash+ of atomic setters.
    # 
    # Get the setters for the atomic updates.
    # ```ruby
    # person = Person.new(:title => "Sir")
    # person.title = "Madam"
    # person.setters # returns { "title" => "Madam" }
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def setters; end

    # Get the old and new value for the provided attribute.
    # 
    # _@param_ `attr` — The name of the attribute.
    # 
    # _@return_ — The old and new values.
    # 
    # Get the attribute change.
    # ```ruby
    # model.attribute_change("name")
    # ```
    sig { params(attr: String).returns(T::Array[Object]) }
    def attribute_change(attr); end

    # Determine if a specific attribute has changed.
    # 
    # _@param_ `attr` — The name of the attribute.
    # 
    # _@return_ — Whether the attribute has changed.
    # 
    # Has the attribute changed?
    # ```ruby
    # model.attribute_changed?("name")
    # ```
    sig { params(attr: String).returns(T::Boolean) }
    def attribute_changed?(attr); end

    # Get whether or not the field has a different value from the default.
    # 
    # _@param_ `attr` — The name of the attribute.
    # 
    # _@return_ — If the attribute differs.
    # 
    # Is the field different from the default?
    # ```ruby
    # model.attribute_changed_from_default?
    # ```
    sig { params(attr: String).returns(T::Boolean) }
    def attribute_changed_from_default?(attr); end

        # Get the previous value for the attribute.
    # 
    # _@param_ `attr` — The attribute name.
    # 
    # Get the previous value.
    # ```ruby
    # model.attribute_was("name")
    # ```
    sig { params(attr: String).returns(T.untyped) }
    def attribute_was(attr); end

    # Flag an attribute as going to change.
    # 
    # _@param_ `attr` — The name of the attribute.
    # 
    # _@return_ — The old value.
    # 
    # Flag the attribute.
    # ```ruby
    # model.attribute_will_change!("name")
    # ```
    sig { params(attr: String).returns(Object) }
    def attribute_will_change!(attr); end

    # Set the attribute back to its old value.
    # 
    # _@param_ `attr` — The name of the attribute.
    # 
    # _@return_ — The old value.
    # 
    # Reset the attribute.
    # ```ruby
    # model.reset_attribute!("name")
    # ```
    sig { params(attr: String).returns(Object) }
    def reset_attribute!(attr); end

            sig { params(attr: T.untyped).returns(T.untyped) }
    def reset_attribute_to_default!(attr); end

        # Add the document as an atomic pull.
    # 
    # _@param_ `document` — The embedded document to pull.
    # 
    # Add the atomic pull.
    # ```ruby
    # person.add_atomic_pull(address)
    # ```
    sig { params(document: Document).returns(T.untyped) }
    def add_atomic_pull(document); end

    # Add an atomic unset for the document.
    # 
    # _@param_ `document` — The child document.
    # 
    # _@return_ — The children.
    # 
    # Add an atomic unset.
    # ```ruby
    # document.add_atomic_unset(doc)
    # ```
    sig { params(document: Document).returns(T::Array[Document]) }
    def add_atomic_unset(document); end

        # Returns path of the attribute for modification
    # 
    # _@return_ — The path to the document attribute in the database
    # 
    # Get path of the attribute
    # ```ruby
    # address.atomic_attribute_name(:city)
    # ```
    sig { params(name: T.untyped).returns(String) }
    def atomic_attribute_name(name); end

    # For array fields these are the pushes that need to happen.
    # 
    # _@return_ — The array pushes.
    # 
    # Get the array pushes.
    # ```ruby
    # person.atomic_array_pushes
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def atomic_array_pushes; end

    # For array fields these are the pulls that need to happen.
    # 
    # _@return_ — The array pulls.
    # 
    # Get the array pulls.
    # ```ruby
    # person.atomic_array_pulls
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def atomic_array_pulls; end

    # For array fields these are the unique adds that need to happen.
    # 
    # _@return_ — The array add_to_sets.
    # 
    # Get the array unique adds.
    # ```ruby
    # person.atomic_array_add_to_sets
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def atomic_array_add_to_sets; end

        # Get all the atomic updates that need to happen for the current
    # +Document+. This includes all changes that need to happen in the
    # entire hierarchy that exists below where the save call was made.
    # 
    # _@return_ — The updates and their modifiers.
    # 
    # Get the updates that need to occur.
    # ```ruby
    # person.atomic_updates(children)
    # ```
    # 
    # _@note_ — MongoDB does not allow "conflicting modifications" to be
    # performed in a single operation. Conflicting modifications are
    # detected by the 'haveConflictingMod' function in MongoDB.
    # Examination of the code suggests that two modifications (a $set
    # and a $push with $each, for example) conflict if:
    #   (1) the key paths being modified are equal.
    #   (2) one key path is a prefix of the other.
    # So a $set of 'addresses.0.street' will conflict with a $push and $each
    # to 'addresses', and we will need to split our update into two
    # pieces. We do not, however, attempt to match MongoDB's logic
    # exactly. Instead, we assume that two updates conflict if the
    # first component of the two key paths matches.
    sig { params(_use_indexes: T.untyped).returns(T::Hash[T.untyped, T.untyped]) }
    def atomic_updates(_use_indexes = false); end

    # Get the removal modifier for the document. Will be nil on root
    # documents, $unset on embeds_one, $set on embeds_many.
    # 
    # _@return_ — The pull or unset operation.
    # 
    # Get the removal operator.
    # ```ruby
    # name.atomic_delete_modifier
    # ```
    sig { returns(String) }
    def atomic_delete_modifier; end

    # Get the insertion modifier for the document. Will be nil on root
    # documents, $set on embeds_one, $push on embeds_many.
    # 
    # _@return_ — The pull or set operator.
    # 
    # Get the insert operation.
    # ```ruby
    # name.atomic_insert_modifier
    # ```
    sig { returns(String) }
    def atomic_insert_modifier; end

    # Return the path to this +Document+ in JSON notation, used for atomic
    # updates via $set in MongoDB.
    # 
    # _@return_ — The path to the document in the database.
    # 
    # Get the path to this document.
    # ```ruby
    # address.atomic_path
    # ```
    sig { returns(String) }
    def atomic_path; end

    # Returns the positional operator of this document for modification.
    # 
    # _@return_ — The positional operator with indexes.
    # 
    # Get the positional operator.
    # ```ruby
    # address.atomic_position
    # ```
    sig { returns(String) }
    def atomic_position; end

    # Get the atomic paths utility for this document.
    # 
    # _@return_ — The associated path.
    # 
    # Get the atomic paths.
    # ```ruby
    # document.atomic_paths
    # ```
    sig { returns(Object) }
    def atomic_paths; end

    # Get all the attributes that need to be pulled.
    # 
    # _@return_ — The $pullAll operations.
    # 
    # Get the pulls.
    # ```ruby
    # person.atomic_pulls
    # ```
    sig { returns(T::Array[T::Hash[T.untyped, T.untyped]]) }
    def atomic_pulls; end

    # Get all the push attributes that need to occur.
    # 
    # _@return_ — The $push and $each operations.
    # 
    # Get the pushes.
    # ```ruby
    # person.atomic_pushes
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def atomic_pushes; end

    # Get all the attributes that need to be set.
    # 
    # _@return_ — The $set operations.
    # 
    # Get the sets.
    # ```ruby
    # person.atomic_sets
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def atomic_sets; end

    # Get all the attributes that need to be unset.
    # 
    # _@return_ — The $unset operations.
    # 
    # Get the unsets.
    # ```ruby
    # person.atomic_unsets
    # ```
    sig { returns(T::Array[T::Hash[T.untyped, T.untyped]]) }
    def atomic_unsets; end

    # Get all the atomic sets that have had their saves delayed.
    # 
    # _@return_ — The delayed $sets.
    # 
    # Get the delayed atomic sets.
    # ```ruby
    # person.delayed_atomic_sets
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def delayed_atomic_sets; end

    # Get a hash of atomic pulls that are pending.
    # 
    # _@return_ — name/document pairs.
    # 
    # Get the atomic pulls.
    # ```ruby
    # document.delayed_atomic_pulls
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def delayed_atomic_pulls; end

    # Get the delayed atomic unsets.
    # 
    # _@return_ — The atomic unsets
    # 
    # Get the delayed atomic unsets.
    # ```ruby
    # document.delayed_atomic_unsets
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def delayed_atomic_unsets; end

    # Flag the document as destroyed and return the atomic path.
    # 
    # _@return_ — The atomic path.
    # 
    # Flag destroyed and return path.
    # ```ruby
    # document.flag_as_destroyed
    # ```
    sig { returns(String) }
    def flag_as_destroyed; end

    # Get the flagged destroys.
    # 
    # _@return_ — The flagged destroys.
    # 
    # Get the flagged destroy.
    # ```ruby
    # document.flagged_destroys
    # ```
    sig { returns(T::Array[Proc]) }
    def flagged_destroys; end

    # Process all the pending flagged destroys from nested attributes.
    # 
    # _@return_ — The cleared array.
    # 
    # Process all the pending flagged destroys.
    # ```ruby
    # document.process_flagged_destroys
    # ```
    sig { returns(T::Array[T.untyped]) }
    def process_flagged_destroys; end

        # Generates the atomic updates in the correct order.
    # 
    # _@param_ `mods` — The atomic modifications.
    # 
    # _@param_ `doc` — The document to update for.
    # 
    # Generate the updates.
    # ```ruby
    # model.generate_atomic_updates(mods, doc)
    # ```
    sig { params(mods: Modifiers, doc: Document).returns(T.untyped) }
    def generate_atomic_updates(mods, doc); end

    # Get the atomic updates for a touch operation. Should only include the
    # updated_at field and the optional extra field.
    # 
    # _@param_ `field` — The optional field.
    # 
    # _@return_ — The atomic updates.
    # 
    # Get the touch atomic updates.
    # ```ruby
    # document.touch_atomic_updates
    # ```
    sig { params(field: T.nilable(Symbol)).returns(T::Hash[T.untyped, T.untyped]) }
    def touch_atomic_updates(field = nil); end
  end

  module Contextual
    extend Forwardable

    # Get the context in which criteria queries should execute. This is either
    # in memory (for embedded documents) or mongo (for root level documents.)
    # 
    # _@return_ — The context.
    # 
    # Get the context.
    # ```ruby
    # criteria.context
    # ```
    sig { returns(T.any(Memory, Mongo)) }
    def context; end

    # Create the context for the queries to execute. Will be memory for
    # embedded documents and mongo for root documents.
    # 
    # _@return_ — The context.
    # 
    # Create the context.
    # ```ruby
    # contextual.create_context
    # ```
    sig { returns(T.any(Mongo, Memory)) }
    def create_context; end

    class None
      include Enumerable
      include Mongoid::Contextual::Queryable

      # Check if the context is equal to the other object.
      # 
      # _@param_ `other` — The other array.
      # 
      # _@return_ — If the objects are equal.
      # 
      # Check equality.
      # ```ruby
      # context == []
      # ```
      sig { params(other: T::Array[T.untyped]).returns(T::Boolean) }
      def ==(other); end

      # Allow distinct for null context.
      # 
      # _@param_ `field` — the name of the field.
      # 
      # _@return_ — Empty Array
      # 
      # Get the distinct values.
      # ```ruby
      # context.distinct(:name)
      # ```
      sig { params(field: T.any(String, Symbol)).returns(T::Array[T.untyped]) }
      def distinct(field); end

      # Iterate over the null context. There are no documents to iterate over
      # in this case.
      # 
      # _@return_ — The enumerator.
      # 
      # Iterate over the context.
      # ```ruby
      # context.each do |doc|
      #   puts doc.name
      # end
      # ```
      sig { returns(T::Enumerator[T.untyped]) }
      def each; end

      # Do any documents exist for the context.
      # 
      # _@return_ — If the count is more than zero.
      # 
      # Do any documents exist for the context.
      # ```ruby
      # context.exists?
      # ```
      sig { returns(T::Boolean) }
      def exists?; end

      # Allow pluck for null context.
      # 
      # _@param_ `args` — Field or fields to pluck.
      # 
      # _@return_ — Emtpy Array
      # 
      # Allow pluck for null context.
      # ```ruby
      # context.pluck(:name)
      # ```
      sig { params(args: T.any(String, Symbol, T::Array[T.untyped])).returns(T::Array[T.untyped]) }
      def pluck(*args); end

      # Create the new null context.
      # 
      # _@param_ `criteria` — The criteria.
      # 
      # Create the new context.
      # ```ruby
      # Null.new(criteria)
      # ```
      sig { params(criteria: Criteria).void }
      def initialize(criteria); end

      # Always returns nil.
      # 
      # _@return_ — Always nil.
      # 
      # Get the last document.
      # ```ruby
      # context.last
      # ```
      sig { returns(T.nilable(T.any())) }
      def last; end

      # Always returns zero.
      # 
      # _@return_ — Always zero.
      # 
      # Get the length of matching documents.
      # ```ruby
      # context.length
      # ```
      sig { returns(Integer) }
      def length; end

      # Is the enumerable of matching documents empty?
      # 
      # _@return_ — If the context is empty.
      # 
      # Is the context empty?
      # ```ruby
      # context.blank?
      # ```
      sig { returns(T::Boolean) }
      def blank?; end

            # Returns the value of attribute criteria.
      sig { returns(T.untyped) }
      attr_reader :criteria

            # Returns the value of attribute klass.
      sig { returns(T.untyped) }
      attr_reader :klass
    end

    class Mongo
      include Enumerable
      include Mongoid::Contextual::Aggregable::Mongo
      include Mongoid::Atomic
      include Mongoid::Association::EagerLoadable
      include Mongoid::Contextual::Queryable
      extend Forwardable
      OPTIONS = T.let([ :hint,
  :limit,
  :skip,
  :sort,
  :batch_size,
  :max_scan,
  :max_time_ms,
  :snapshot,
  :comment,
  :read,
  :cursor_type,
  :collation
].freeze, T.untyped)
      UPDATES = T.let([
  :atomic_array_pushes,
  :atomic_array_pulls,
  :atomic_array_add_to_sets,
  :atomic_pulls,
  :delayed_atomic_sets,
  :delayed_atomic_pulls,
  :delayed_atomic_unsets
], T.untyped)

      # Is the context cached?
      # 
      # _@return_ — If the context is cached.
      # 
      # Is the context cached?
      # ```ruby
      # context.cached?
      # ```
      sig { returns(T::Boolean) }
      def cached?; end

      # Get the number of documents matching the query.
      # 
      # _@param_ `options` — The options, such as skip and limit to be factored into the count.
      # 
      # _@return_ — The number of matches.
      # 
      # Get the number of matching documents.
      # ```ruby
      # context.count
      # ```
      # 
      # Get the count of documents with the provided options.
      # ```ruby
      # context.count(limit: 1)
      # ```
      # 
      # Get the count for where the provided block is true.
      # ```ruby
      # context.count do |doc|
      #   doc.likes > 1
      # end
      # ```
      sig { params(options: T::Hash[T.untyped, T.untyped], block: T.untyped).returns(Integer) }
      def count(options = {}, &block); end

      # Get the estimated number of documents matching the query.
      # 
      # Unlike count, estimated_count does not take a block because it is not
      # traditionally defined (with a block) on Enumarable like count is.
      # 
      # _@param_ `options` — The options, such as maxTimeMS to be factored into the count.
      # 
      # _@return_ — The number of matches.
      # 
      # Get the estimated number of matching documents.
      # ```ruby
      # context.estimated_count
      # ```
      sig { params(options: T::Hash[T.untyped, T.untyped]).returns(Integer) }
      def estimated_count(options = {}); end

      # Delete all documents in the database that match the selector.
      # 
      # _@return_ — Nil.
      # 
      # Delete all the documents.
      # ```ruby
      # context.delete
      # ```
      sig { returns(T.nilable(T.any())) }
      def delete; end

      # Destroy all documents in the database that match the selector.
      # 
      # _@return_ — Nil.
      # 
      # Destroy all the documents.
      # ```ruby
      # context.destroy
      # ```
      sig { returns(T.nilable(T.any())) }
      def destroy; end

      # Get the distinct values in the db for the provided field.
      # 
      # _@param_ `field` — The name of the field.
      # 
      # _@return_ — The distinct values for the field.
      # 
      # Get the distinct values.
      # ```ruby
      # context.distinct(:name)
      # ```
      sig { params(field: T.any(String, Symbol)).returns(T::Array[Object]) }
      def distinct(field); end

      # Iterate over the context. If provided a block, yield to a Mongoid
      # document for each, otherwise return an enum.
      # 
      # _@return_ — The enumerator.
      # 
      # Iterate over the context.
      # ```ruby
      # context.each do |doc|
      #   puts doc.name
      # end
      # ```
      sig { params(block: T.untyped).returns(T::Enumerator[T.untyped]) }
      def each(&block); end

      # Do any documents exist for the context.
      # 
      # _@return_ — If the count is more than zero.
      # 
      # Do any documents exist for the context.
      # ```ruby
      # context.exists?
      # ```
      # 
      # _@note_ — We don't use count here since Mongo does not use counted
      # b-tree indexes, unless a count is already cached then that is
      # used to determine the value.
      sig { returns(T::Boolean) }
      def exists?; end

      # Run an explain on the criteria.
      # 
      # _@return_ — The explain result.
      # 
      # Explain the criteria.
      # ```ruby
      # Band.where(name: "Depeche Mode").explain
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def explain; end

      # Execute the find and modify command, used for MongoDB's
      # $findAndModify.
      # 
      # _@param_ `update` — The updates.
      # 
      # _@param_ `options` — The command options.
      # 
      # _@return_ — The result of the command.
      # 
      # Execute the command.
      # ```ruby
      # context.find_one_and_update({ "$inc" => { likes: 1 }})
      # ```
      sig { params(update: T::Hash[T.untyped, T.untyped], options: T::Hash[T.untyped, T.untyped]).returns(Document) }
      def find_one_and_update(update, options = {}); end

      # Execute the find and modify command, used for MongoDB's
      # $findAndModify.
      # 
      # _@param_ `replacement` — The replacement.
      # 
      # _@param_ `options` — The command options.
      # 
      # _@return_ — The result of the command.
      # 
      # Execute the command.
      # ```ruby
      # context.find_one_and_update({ likes: 1 })
      # ```
      sig { params(replacement: T::Hash[T.untyped, T.untyped], options: T::Hash[T.untyped, T.untyped]).returns(Document) }
      def find_one_and_replace(replacement, options = {}); end

      # Execute the find and modify command, used for MongoDB's
      # $findAndModify. This deletes the found document.
      # 
      # _@return_ — The result of the command.
      # 
      # Execute the command.
      # ```ruby
      # context.find_one_and_delete
      # ```
      sig { returns(Document) }
      def find_one_and_delete; end

      # Get the first document in the database for the criteria's selector.
      # 
      # _@param_ `opts` — The options for the query returning the first document.
      # 
      # _@return_ — The first document.
      # 
      # Get the first document.
      # ```ruby
      # context.first
      # ```
      # 
      # _@note_ — Automatically adding a sort on _id when no other sort is
      # defined on the criteria has the potential to cause bad performance issues.
      # If you experience unexpected poor performance when using #first or #last
      # and have no sort defined on the criteria, use the option { id_sort: :none }.
      # Be aware that #first/#last won't guarantee order in this case.
      sig { params(opts: T::Hash[T.untyped, T.untyped]).returns(Document) }
      def first(opts = {}); end

            # Return the first result without applying sort
      sig { returns(T.untyped) }
      def find_first; end

      # Execute a $geoNear command against the database.
      # 
      # _@param_ `coordinates` — The coordinates.
      # 
      # _@return_ — The GeoNear command.
      # 
      # Find documents close to 10, 10.
      # ```ruby
      # context.geo_near([ 10, 10 ])
      # ```
      # 
      # Find with spherical distance.
      # ```ruby
      # context.geo_near([ 10, 10 ]).spherical
      # ```
      # 
      # Find with a max distance.
      # ```ruby
      # context.geo_near([ 10, 10 ]).max_distance(0.5)
      # ```
      # 
      # Provide a distance multiplier.
      # ```ruby
      # context.geo_near([ 10, 10 ]).distance_multiplier(1133)
      # ```
      # 
      # _@deprecated_ — 
      sig { params(coordinates: T::Array[Float]).returns(GeoNear) }
      def geo_near(coordinates); end

      # Invoke the block for each element of Contextual. Create a new array
      # containing the values returned by the block.
      # 
      # If the symbol field name is passed instead of the block, additional
      # optimizations would be used.
      # 
      # _@param_ `field` — The field name.
      # 
      # _@return_ — The result of mapping.
      # 
      # Map by some field.
      # ```ruby
      # context.map(:field1)
      # ```
      # 
      # Map with block.
      # ```ruby
      # context.map(&:field1)
      # ```
      sig { params(field: T.nilable(Symbol), block: T.untyped).returns(T::Array[T.untyped]) }
      def map(field = nil, &block); end

      # Create the new Mongo context. This delegates operations to the
      # underlying driver.
      # 
      # _@param_ `criteria` — The criteria.
      # 
      # Create the new context.
      # ```ruby
      # Mongo.new(criteria)
      # ```
      sig { params(criteria: Criteria).void }
      def initialize(criteria); end

            # Get the last document in the database for the criteria's selector.
      # 
      # _@param_ `opts` — The options for the query returning the first document.
      # 
      # Get the last document.
      # ```ruby
      # context.last
      # ```
      # 
      # _@note_ — Automatically adding a sort on _id when no other sort is
      # defined on the criteria has the potential to cause bad performance issues.
      # If you experience unexpected poor performance when using #first or #last
      # and have no sort defined on the criteria, use the option { id_sort: :none }.
      # Be aware that #first/#last won't guarantee order in this case.
      sig { params(opts: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
      def last(opts = {}); end

      # Get's the number of documents matching the query selector.
      # 
      # _@return_ — The number of documents.
      # 
      # Get the length.
      # ```ruby
      # context.length
      # ```
      sig { returns(Integer) }
      def length; end

      # Limits the number of documents that are returned from the database.
      # 
      # _@param_ `value` — The number of documents to return.
      # 
      # _@return_ — The context.
      # 
      # Limit the documents.
      # ```ruby
      # context.limit(20)
      # ```
      sig { params(value: Integer).returns(Mongo) }
      def limit(value); end

      # Initiate a map/reduce operation from the context.
      # 
      # _@param_ `map` — The map js function.
      # 
      # _@param_ `reduce` — The reduce js function.
      # 
      # _@return_ — The map/reduce lazy wrapper.
      # 
      # Initiate a map/reduce.
      # ```ruby
      # context.map_reduce(map, reduce)
      # ```
      sig { params(map: String, reduce: String).returns(MapReduce) }
      def map_reduce(map, reduce); end

      # Pluck the single field values from the database. Will return duplicates
      # if they exist and only works for top level fields.
      # 
      # _@param_ `fields` — Fields to pluck.
      # 
      # _@return_ — The plucked values.
      # 
      # Pluck a field.
      # ```ruby
      # context.pluck(:_id)
      # ```
      # 
      # _@note_ — This method will return the raw db values - it performs no custom
      # serialization.
      sig { params(fields: T.any(String, Symbol, T::Array[T.untyped])).returns(T::Array[T.any(Object, T::Array[T.untyped])]) }
      def pluck(*fields); end

      # Skips the provided number of documents.
      # 
      # _@param_ `value` — The number of documents to skip.
      # 
      # _@return_ — The context.
      # 
      # Skip the documents.
      # ```ruby
      # context.skip(20)
      # ```
      sig { params(value: Integer).returns(Mongo) }
      def skip(value); end

      # Sorts the documents by the provided spec.
      # 
      # _@param_ `values` — The sorting values as field/direction(1/-1) pairs.
      # 
      # _@return_ — The context.
      # 
      # Sort the documents.
      # ```ruby
      # context.sort(name: -1, title: 1)
      # ```
      sig { params(values: T.nilable(T::Hash[T.untyped, T.untyped]), block: T.untyped).returns(Mongo) }
      def sort(values = nil, &block); end

      # Update the first matching document atomically.
      # 
      # _@param_ `attributes` — The new attributes for the document.
      # 
      # _@param_ `opts` — The update operation options.
      # 
      # _@return_ — False if no attributes were provided.
      # 
      # Update the first matching document.
      # ```ruby
      # context.update({ "$set" => { name: "Smiths" }})
      # ```
      sig { params(attributes: T.nilable(T::Hash[T.untyped, T.untyped]), opts: T::Hash[T.untyped, T.untyped]).returns(T.nilable(T::Boolean)) }
      def update(attributes = nil, opts = {}); end

      # Update all the matching documents atomically.
      # 
      # _@param_ `attributes` — The new attributes for each document.
      # 
      # _@param_ `opts` — The update operation options.
      # 
      # _@return_ — False if no attributes were provided.
      # 
      # Update all the matching documents.
      # ```ruby
      # context.update_all({ "$set" => { name: "Smiths" }})
      # ```
      sig { params(attributes: T.nilable(T::Hash[T.untyped, T.untyped]), opts: T::Hash[T.untyped, T.untyped]).returns(T.nilable(T::Boolean)) }
      def update_all(attributes = nil, opts = {}); end

      # yield the block given or return the cached value
      # 
      # _@param_ `key` — The instance variable name
      # 
      # _@return_ — the result of the block
      sig { params(key: T.any(String, Symbol), block: T.untyped).returns(T.untyped) }
      def try_cache(key, &block); end

            # Update the documents for the provided method.
      # 
      # _@param_ `attributes` — The updates.
      # 
      # _@param_ `method` — The method to use.
      # 
      # _@return_ — If the update succeeded.
      # 
      # Update the documents.
      # ```ruby
      # context.update_documents(attrs)
      # ```
      sig { params(attributes: T::Hash[T.untyped, T.untyped], method: Symbol, opts: T.untyped).returns(T::Boolean) }
      def update_documents(attributes, method = :update_one, opts = {}); end

            # Apply the field limitations.
      # 
      # Apply the field limitations.
      # ```ruby
      # context.apply_fields
      # ```
      sig { returns(T.untyped) }
      def apply_fields; end

            # Apply the options.
      # 
      # Apply all options.
      # ```ruby
      # context.apply_options
      # ```
      sig { returns(T.untyped) }
      def apply_options; end

                  # Apply an option.
      # 
      # Apply the skip option.
      # ```ruby
      # context.apply_option(:skip)
      # ```
      sig { params(name: T.untyped).returns(T.untyped) }
      def apply_option(name); end

                  # Map the inverse sort symbols to the correct MongoDB values.
      # 
      # Apply the inverse sorting params to the given block
      # ```ruby
      # context.with_inverse_sorting
      # ```
      sig { params(opts: T.untyped).returns(T.untyped) }
      def with_inverse_sorting(opts = {}); end

      # Is the cache able to be added to?
      # 
      # _@return_ — If caching, and the cache isn't loaded.
      # 
      # Is the context cacheable?
      # ```ruby
      # context.cacheable?
      # ```
      sig { returns(T::Boolean) }
      def cacheable?; end

      # Is the cache fully loaded? Will be true if caching after one full
      # iteration.
      # 
      # _@return_ — If the cache is loaded.
      # 
      # Is the cache loaded?
      # ```ruby
      # context.cache_loaded?
      # ```
      sig { returns(T::Boolean) }
      def cache_loaded?; end

      # Get the documents for cached queries.
      # 
      # _@return_ — The documents.
      # 
      # Get the cached documents.
      # ```ruby
      # context.documents
      # ```
      sig { returns(T::Array[Document]) }
      def documents; end

      # sord warn - Mongo::Collection::View wasn't able to be resolved to a constant in this project
      # Get the documents the context should iterate. This follows 3 rules:
      # 
      # 1. If the query is cached, and we already have documents loaded, use
      #   them.
      # 2. If we are eager loading, then eager load the documents and use
      #   those.
      # 3. Use the query.
      # 
      # _@return_ — The docs to iterate.
      # 
      # Get the documents for iteration.
      # ```ruby
      # context.documents_for_iteration
      # ```
      sig { returns(T.any(T::Array[Document], ::Mongo::Collection::View)) }
      def documents_for_iteration; end

            # Yield to the document.
      # 
      # _@param_ `document` — The document to yield to.
      # 
      # Yield the document.
      # ```ruby
      # context.yield_document(doc) do |doc|
      #   ...
      # end
      # ```
      sig { params(document: Document, block: T.untyped).returns(T.untyped) }
      def yield_document(document, &block); end

            sig { returns(T.untyped) }
      def _session; end

      sig { returns(T::Boolean) }
      def acknowledged_write?; end

      # Is the enumerable of matching documents empty?
      # 
      # _@return_ — If the context is empty.
      # 
      # Is the context empty?
      # ```ruby
      # context.blank?
      # ```
      sig { returns(T::Boolean) }
      def blank?; end

      sig { returns(T::Boolean) }
      def eager_loadable?; end

                  sig { params(docs: T.untyped).returns(T.untyped) }
      def eager_load(docs); end

                        sig { params(relations: T.untyped, docs: T.untyped).returns(T.untyped) }
      def preload(relations, docs); end

            # Add the document as an atomic pull.
      # 
      # _@param_ `document` — The embedded document to pull.
      # 
      # Add the atomic pull.
      # ```ruby
      # person.add_atomic_pull(address)
      # ```
      sig { params(document: Document).returns(T.untyped) }
      def add_atomic_pull(document); end

      # Add an atomic unset for the document.
      # 
      # _@param_ `document` — The child document.
      # 
      # _@return_ — The children.
      # 
      # Add an atomic unset.
      # ```ruby
      # document.add_atomic_unset(doc)
      # ```
      sig { params(document: Document).returns(T::Array[Document]) }
      def add_atomic_unset(document); end

            # Returns path of the attribute for modification
      # 
      # _@return_ — The path to the document attribute in the database
      # 
      # Get path of the attribute
      # ```ruby
      # address.atomic_attribute_name(:city)
      # ```
      sig { params(name: T.untyped).returns(String) }
      def atomic_attribute_name(name); end

      # For array fields these are the pushes that need to happen.
      # 
      # _@return_ — The array pushes.
      # 
      # Get the array pushes.
      # ```ruby
      # person.atomic_array_pushes
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def atomic_array_pushes; end

      # For array fields these are the pulls that need to happen.
      # 
      # _@return_ — The array pulls.
      # 
      # Get the array pulls.
      # ```ruby
      # person.atomic_array_pulls
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def atomic_array_pulls; end

      # For array fields these are the unique adds that need to happen.
      # 
      # _@return_ — The array add_to_sets.
      # 
      # Get the array unique adds.
      # ```ruby
      # person.atomic_array_add_to_sets
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def atomic_array_add_to_sets; end

            # Get all the atomic updates that need to happen for the current
      # +Document+. This includes all changes that need to happen in the
      # entire hierarchy that exists below where the save call was made.
      # 
      # _@return_ — The updates and their modifiers.
      # 
      # Get the updates that need to occur.
      # ```ruby
      # person.atomic_updates(children)
      # ```
      # 
      # _@note_ — MongoDB does not allow "conflicting modifications" to be
      # performed in a single operation. Conflicting modifications are
      # detected by the 'haveConflictingMod' function in MongoDB.
      # Examination of the code suggests that two modifications (a $set
      # and a $push with $each, for example) conflict if:
      #   (1) the key paths being modified are equal.
      #   (2) one key path is a prefix of the other.
      # So a $set of 'addresses.0.street' will conflict with a $push and $each
      # to 'addresses', and we will need to split our update into two
      # pieces. We do not, however, attempt to match MongoDB's logic
      # exactly. Instead, we assume that two updates conflict if the
      # first component of the two key paths matches.
      sig { params(_use_indexes: T.untyped).returns(T::Hash[T.untyped, T.untyped]) }
      def atomic_updates(_use_indexes = false); end

      # Get the removal modifier for the document. Will be nil on root
      # documents, $unset on embeds_one, $set on embeds_many.
      # 
      # _@return_ — The pull or unset operation.
      # 
      # Get the removal operator.
      # ```ruby
      # name.atomic_delete_modifier
      # ```
      sig { returns(String) }
      def atomic_delete_modifier; end

      # Get the insertion modifier for the document. Will be nil on root
      # documents, $set on embeds_one, $push on embeds_many.
      # 
      # _@return_ — The pull or set operator.
      # 
      # Get the insert operation.
      # ```ruby
      # name.atomic_insert_modifier
      # ```
      sig { returns(String) }
      def atomic_insert_modifier; end

      # Return the path to this +Document+ in JSON notation, used for atomic
      # updates via $set in MongoDB.
      # 
      # _@return_ — The path to the document in the database.
      # 
      # Get the path to this document.
      # ```ruby
      # address.atomic_path
      # ```
      sig { returns(String) }
      def atomic_path; end

      # Returns the positional operator of this document for modification.
      # 
      # _@return_ — The positional operator with indexes.
      # 
      # Get the positional operator.
      # ```ruby
      # address.atomic_position
      # ```
      sig { returns(String) }
      def atomic_position; end

      # Get the atomic paths utility for this document.
      # 
      # _@return_ — The associated path.
      # 
      # Get the atomic paths.
      # ```ruby
      # document.atomic_paths
      # ```
      sig { returns(Object) }
      def atomic_paths; end

      # Get all the attributes that need to be pulled.
      # 
      # _@return_ — The $pullAll operations.
      # 
      # Get the pulls.
      # ```ruby
      # person.atomic_pulls
      # ```
      sig { returns(T::Array[T::Hash[T.untyped, T.untyped]]) }
      def atomic_pulls; end

      # Get all the push attributes that need to occur.
      # 
      # _@return_ — The $push and $each operations.
      # 
      # Get the pushes.
      # ```ruby
      # person.atomic_pushes
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def atomic_pushes; end

      # Get all the attributes that need to be set.
      # 
      # _@return_ — The $set operations.
      # 
      # Get the sets.
      # ```ruby
      # person.atomic_sets
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def atomic_sets; end

      # Get all the attributes that need to be unset.
      # 
      # _@return_ — The $unset operations.
      # 
      # Get the unsets.
      # ```ruby
      # person.atomic_unsets
      # ```
      sig { returns(T::Array[T::Hash[T.untyped, T.untyped]]) }
      def atomic_unsets; end

      # Get all the atomic sets that have had their saves delayed.
      # 
      # _@return_ — The delayed $sets.
      # 
      # Get the delayed atomic sets.
      # ```ruby
      # person.delayed_atomic_sets
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def delayed_atomic_sets; end

      # Get a hash of atomic pulls that are pending.
      # 
      # _@return_ — name/document pairs.
      # 
      # Get the atomic pulls.
      # ```ruby
      # document.delayed_atomic_pulls
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def delayed_atomic_pulls; end

      # Get the delayed atomic unsets.
      # 
      # _@return_ — The atomic unsets
      # 
      # Get the delayed atomic unsets.
      # ```ruby
      # document.delayed_atomic_unsets
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def delayed_atomic_unsets; end

      # Flag the document as destroyed and return the atomic path.
      # 
      # _@return_ — The atomic path.
      # 
      # Flag destroyed and return path.
      # ```ruby
      # document.flag_as_destroyed
      # ```
      sig { returns(String) }
      def flag_as_destroyed; end

      # Get the flagged destroys.
      # 
      # _@return_ — The flagged destroys.
      # 
      # Get the flagged destroy.
      # ```ruby
      # document.flagged_destroys
      # ```
      sig { returns(T::Array[Proc]) }
      def flagged_destroys; end

      # Process all the pending flagged destroys from nested attributes.
      # 
      # _@return_ — The cleared array.
      # 
      # Process all the pending flagged destroys.
      # ```ruby
      # document.process_flagged_destroys
      # ```
      sig { returns(T::Array[T.untyped]) }
      def process_flagged_destroys; end

            # Generates the atomic updates in the correct order.
      # 
      # _@param_ `mods` — The atomic modifications.
      # 
      # _@param_ `doc` — The document to update for.
      # 
      # Generate the updates.
      # ```ruby
      # model.generate_atomic_updates(mods, doc)
      # ```
      sig { params(mods: Modifiers, doc: Document).returns(T.untyped) }
      def generate_atomic_updates(mods, doc); end

      # Get the atomic updates for a touch operation. Should only include the
      # updated_at field and the optional extra field.
      # 
      # _@param_ `field` — The optional field.
      # 
      # _@return_ — The atomic updates.
      # 
      # Get the touch atomic updates.
      # ```ruby
      # document.touch_atomic_updates
      # ```
      sig { params(field: T.nilable(Symbol)).returns(T::Hash[T.untyped, T.untyped]) }
      def touch_atomic_updates(field = nil); end

      # Get all the aggregate values for the provided field.
      # 
      # _@param_ `field` — The field name.
      # 
      # _@return_ — count is a number of documents with the provided
      # field. If there're none, then count is 0 and max, min, sum, avg
      # are nil.
      # 
      # Get all the aggregate values.
      # ```ruby
      # aggregable.aggregates(:likes)
      # # => {
      # #   "count" => 2.0,
      # #   "max" => 1000.0,
      # #   "min" => 500.0,
      # #   "sum" => 1500.0,
      # #   "avg" => 750.0
      # # }
      # ```
      sig { params(field: T.any(String, Symbol)).returns(T::Hash[T.untyped, T.untyped]) }
      def aggregates(field); end

      # Get the average value of the provided field.
      # 
      # _@param_ `field` — The field to average.
      # 
      # _@return_ — The average.
      # 
      # Get the average of a single field.
      # ```ruby
      # aggregable.avg(:likes)
      # ```
      sig { params(field: Symbol).returns(Float) }
      def avg(field); end

      # Get the max value of the provided field. If provided a block, will
      # return the Document with the greatest value for the field, in
      # accordance with Ruby's enumerable API.
      # 
      # _@param_ `field` — The field to max.
      # 
      # _@return_ — The max value or document with the max
      # value.
      # 
      # Get the max of a single field.
      # ```ruby
      # aggregable.max(:likes)
      # ```
      # 
      # Get the document with the max value.
      # ```ruby
      # aggregable.max do |a, b|
      #   a.likes <=> b.likes
      # end
      # ```
      sig { params(field: T.nilable(Symbol)).returns(T.any(Float, Document)) }
      def max(field = nil); end

      # Get the min value of the provided field. If provided a block, will
      # return the Document with the smallest value for the field, in
      # accordance with Ruby's enumerable API.
      # 
      # _@param_ `field` — The field to min.
      # 
      # _@return_ — The min value or document with the min
      # value.
      # 
      # Get the min of a single field.
      # ```ruby
      # aggregable.min(:likes)
      # ```
      # 
      # Get the document with the min value.
      # ```ruby
      # aggregable.min do |a, b|
      #   a.likes <=> b.likes
      # end
      # ```
      sig { params(field: T.nilable(Symbol)).returns(T.any(Float, Document)) }
      def min(field = nil); end

      # Get the sum value of the provided field. If provided a block, will
      # return the sum in accordance with Ruby's enumerable API.
      # 
      # _@param_ `field` — The field to sum.
      # 
      # _@return_ — The sum value.
      # 
      # Get the sum of a single field.
      # ```ruby
      # aggregable.sum(:likes)
      # ```
      # 
      # Get the sum for the provided block.
      # ```ruby
      # aggregable.sum(&:likes)
      # ```
      sig { params(field: T.nilable(Symbol)).returns(Float) }
      def sum(field = nil); end

      # Get the aggregation pipeline for provided field.
      # 
      # _@param_ `field` — The name of the field.
      # 
      # _@return_ — The array of pipeline operators.
      # 
      # Get the pipeline.
      # ```ruby
      # aggregable.pipeline(:likes)
      # ```
      sig { params(field: T.any(String, Symbol)).returns(T::Array[T.untyped]) }
      def pipeline(field); end

            # Returns the value of attribute view.
      sig { returns(T.untyped) }
      attr_reader :view

            sig { returns(T.untyped) }
      attr_reader :view
    end

    module Atomic
      # Execute an atomic $addToSet on the matching documents.
      # 
      # _@param_ `adds` — The operations.
      # 
      # _@return_ — Nil.
      # 
      # Add the value to the set.
      # ```ruby
      # context.add_to_set(members: "Dave", genres: "Electro")
      # ```
      sig { params(adds: T::Hash[T.untyped, T.untyped]).returns(T.nilable(T.any())) }
      def add_to_set(adds); end

      # Perform an atomic $addToSet/$each on the matching documents.
      # 
      # _@param_ `adds` — The operations.
      # 
      # _@return_ — Nil.
      # 
      # Add the value to the set.
      # ```ruby
      # context.add_each_to_set(members: ["Dave", "Bill"], genres: ["Electro", "Disco"])
      # ```
      sig { params(adds: T::Hash[T.untyped, T.untyped]).returns(T.nilable(T.any())) }
      def add_each_to_set(adds); end

      # Perform an atomic $bit operation on the matching documents.
      # 
      # _@param_ `bits` — The operations.
      # 
      # _@return_ — Nil.
      # 
      # Perform the bitwise op.
      # ```ruby
      # context.bit(likes: { and: 14, or: 4 })
      # ```
      sig { params(bits: T::Hash[T.untyped, T.untyped]).returns(T.nilable(T.any())) }
      def bit(bits); end

      # Perform an atomic $inc operation on the matching documents.
      # 
      # _@param_ `incs` — The operations.
      # 
      # _@return_ — Nil.
      # 
      # Perform the atomic increment.
      # ```ruby
      # context.inc(likes: 10)
      # ```
      sig { params(incs: T::Hash[T.untyped, T.untyped]).returns(T.nilable(T.any())) }
      def inc(incs); end

      # Perform an atomic $pop operation on the matching documents.
      # 
      # _@param_ `pops` — The operations.
      # 
      # _@return_ — Nil.
      # 
      # Pop the first value on the matches.
      # ```ruby
      # context.pop(members: -1)
      # ```
      # 
      # Pop the last value on the matches.
      # ```ruby
      # context.pop(members: 1)
      # ```
      sig { params(pops: T::Hash[T.untyped, T.untyped]).returns(T.nilable(T.any())) }
      def pop(pops); end

      # Perform an atomic $pull operation on the matching documents.
      # 
      # _@param_ `pulls` — The operations.
      # 
      # _@return_ — Nil.
      # 
      # Pull the value from the matches.
      # ```ruby
      # context.pull(members: "Dave")
      # ```
      # 
      # _@note_ — Expression pulling is not yet supported.
      sig { params(pulls: T::Hash[T.untyped, T.untyped]).returns(T.nilable(T.any())) }
      def pull(pulls); end

      # Perform an atomic $pullAll operation on the matching documents.
      # 
      # _@param_ `pulls` — The operations.
      # 
      # _@return_ — Nil.
      # 
      # Pull all the matching values from the matches.
      # ```ruby
      # context.pull_all(:members, [ "Alan", "Vince" ])
      # ```
      sig { params(pulls: T::Hash[T.untyped, T.untyped]).returns(T.nilable(T.any())) }
      def pull_all(pulls); end

      # Perform an atomic $push operation on the matching documents.
      # 
      # _@param_ `pushes` — The operations.
      # 
      # _@return_ — Nil.
      # 
      # Push the value to the matching docs.
      # ```ruby
      # context.push(members: "Alan")
      # ```
      sig { params(pushes: T::Hash[T.untyped, T.untyped]).returns(T.nilable(T.any())) }
      def push(pushes); end

      # Perform an atomic $push/$each operation on the matching documents.
      # 
      # _@param_ `pushes` — The operations.
      # 
      # _@return_ — Nil.
      # 
      # Push the values to the matching docs.
      # ```ruby
      # context.push_all(members: [ "Alan", "Fletch" ])
      # ```
      sig { params(pushes: T::Hash[T.untyped, T.untyped]).returns(T.nilable(T.any())) }
      def push_all(pushes); end

      # Perform an atomic $rename of fields on the matching documents.
      # 
      # _@param_ `renames` — The operations.
      # 
      # _@return_ — Nil.
      # 
      # Rename the fields on the matching documents.
      # ```ruby
      # context.rename(members: :artists)
      # ```
      sig { params(renames: T::Hash[T.untyped, T.untyped]).returns(T.nilable(T.any())) }
      def rename(renames); end

      # Perform an atomic $set of fields on the matching documents.
      # 
      # _@param_ `sets` — The operations.
      # 
      # _@return_ — Nil.
      # 
      # Set the field value on the matches.
      # ```ruby
      # context.set(name: "Depeche Mode")
      # ```
      sig { params(sets: T::Hash[T.untyped, T.untyped]).returns(T.nilable(T.any())) }
      def set(sets); end

      # Perform an atomic $unset of a field on the matching documents.
      # 
      # _@param_ `args` — The name of the fields.
      # 
      # _@return_ — Nil.
      # 
      # Unset the field on the matches.
      # ```ruby
      # context.unset(:name)
      # ```
      sig { params(args: T.any(String, Symbol, T::Array[T.untyped])).returns(T.nilable(T.any())) }
      def unset(*args); end

                  sig { params(ops: T.untyped).returns(T.untyped) }
      def collect_operations(ops); end

                  sig { params(ops: T.untyped).returns(T.untyped) }
      def collect_each_operations(ops); end
    end

    class Memory
      include Enumerable
      include Mongoid::Contextual::Aggregable::Memory
      include Mongoid::Association::EagerLoadable
      include Mongoid::Contextual::Queryable
      include Mongoid::Positional

      # Check if the context is equal to the other object.
      # 
      # _@param_ `other` — The other array.
      # 
      # _@return_ — If the objects are equal.
      # 
      # Check equality.
      # ```ruby
      # context == []
      # ```
      sig { params(other: T::Array[T.untyped]).returns(T::Boolean) }
      def ==(other); end

      # Delete all documents in the database that match the selector.
      # 
      # _@return_ — Nil.
      # 
      # Delete all the documents.
      # ```ruby
      # context.delete
      # ```
      sig { returns(T.nilable(T.any())) }
      def delete; end

      # Destroy all documents in the database that match the selector.
      # 
      # _@return_ — Nil.
      # 
      # Destroy all the documents.
      # ```ruby
      # context.destroy
      # ```
      sig { returns(T.nilable(T.any())) }
      def destroy; end

      # Get the distinct values in the db for the provided field.
      # 
      # _@param_ `field` — The name of the field.
      # 
      # _@return_ — The distinct values for the field.
      # 
      # Get the distinct values.
      # ```ruby
      # context.distinct(:name)
      # ```
      sig { params(field: T.any(String, Symbol)).returns(T::Array[Object]) }
      def distinct(field); end

      # Iterate over the context. If provided a block, yield to a Mongoid
      # document for each, otherwise return an enum.
      # 
      # _@return_ — The enumerator.
      # 
      # Iterate over the context.
      # ```ruby
      # context.each do |doc|
      #   puts doc.name
      # end
      # ```
      sig { returns(T::Enumerator[T.untyped]) }
      def each; end

      # Do any documents exist for the context.
      # 
      # _@return_ — If the count is more than zero.
      # 
      # Do any documents exist for the context.
      # ```ruby
      # context.exists?
      # ```
      sig { returns(T::Boolean) }
      def exists?; end

            # Get the first document in the database for the criteria's selector.
      # 
      # _@return_ — The first document.
      # 
      # Get the first document.
      # ```ruby
      # context.first
      # ```
      sig { params(args: T.untyped).returns(Document) }
      def first(*args); end

      # Create the new in memory context.
      # 
      # _@param_ `criteria` — The criteria.
      # 
      # Create the new context.
      # ```ruby
      # Memory.new(criteria)
      # ```
      sig { params(criteria: Criteria).void }
      def initialize(criteria); end

      # Increment a value on all documents.
      # 
      # _@param_ `incs` — The operations.
      # 
      # _@return_ — The enumerator.
      # 
      # Perform the increment.
      # ```ruby
      # context.inc(likes: 10)
      # ```
      sig { params(incs: T::Hash[T.untyped, T.untyped]).returns(T::Enumerator[T.untyped]) }
      def inc(incs); end

      # Get the last document in the database for the criteria's selector.
      # 
      # _@return_ — The last document.
      # 
      # Get the last document.
      # ```ruby
      # context.last
      # ```
      sig { returns(Document) }
      def last; end

      # Get the length of matching documents in the context.
      # 
      # _@return_ — The matching length.
      # 
      # Get the length of matching documents.
      # ```ruby
      # context.length
      # ```
      sig { returns(Integer) }
      def length; end

      # Limits the number of documents that are returned.
      # 
      # _@param_ `value` — The number of documents to return.
      # 
      # _@return_ — The context.
      # 
      # Limit the documents.
      # ```ruby
      # context.limit(20)
      # ```
      sig { params(value: Integer).returns(Mongo) }
      def limit(value); end

                  sig { params(fields: T.untyped).returns(T.untyped) }
      def pluck(*fields); end

      # Skips the provided number of documents.
      # 
      # _@param_ `value` — The number of documents to skip.
      # 
      # _@return_ — The context.
      # 
      # Skip the documents.
      # ```ruby
      # context.skip(20)
      # ```
      sig { params(value: Integer).returns(Mongo) }
      def skip(value); end

      # Sorts the documents by the provided spec.
      # 
      # _@param_ `values` — The sorting values as field/direction(1/-1) pairs.
      # 
      # _@return_ — The context.
      # 
      # Sort the documents.
      # ```ruby
      # context.sort(name: -1, title: 1)
      # ```
      sig { params(values: T::Hash[T.untyped, T.untyped]).returns(Mongo) }
      def sort(values); end

      # Update the first matching document atomically.
      # 
      # _@param_ `attributes` — The new attributes for the document.
      # 
      # _@return_ — False if no attributes were provided.
      # 
      # Update the matching document.
      # ```ruby
      # context.update(name: "Smiths")
      # ```
      sig { params(attributes: T.nilable(T::Hash[T.untyped, T.untyped])).returns(T.nilable(T::Boolean)) }
      def update(attributes = nil); end

      # Update all the matching documents atomically.
      # 
      # _@param_ `attributes` — The new attributes for each document.
      # 
      # _@return_ — False if no attributes were provided.
      # 
      # Update all the matching documents.
      # ```ruby
      # context.update_all(name: "Smiths")
      # ```
      sig { params(attributes: T.nilable(T::Hash[T.untyped, T.untyped])).returns(T.nilable(T::Boolean)) }
      def update_all(attributes = nil); end

      # Get the documents the context should iterate. This follows 3 rules:
      # 
      # _@return_ — The docs to iterate.
      # 
      # Get the documents for iteration.
      # ```ruby
      # context.documents_for_iteration
      # ```
      sig { returns(T::Array[Document]) }
      def documents_for_iteration; end

            # Update the provided documents with the attributes.
      # 
      # _@param_ `attributes` — The attributes.
      # 
      # _@param_ `docs` — The docs to update.
      # 
      # Update the documents.
      # ```ruby
      # context.update_documents({}, doc)
      # ```
      sig { params(attributes: T::Hash[T.untyped, T.untyped], docs: T::Array[Document]).returns(T.untyped) }
      def update_documents(attributes, docs); end

      # Get the limiting value.
      # 
      # _@return_ — The limit.
      # 
      # Get the limiting value.
      # ```ruby
      # ```
      sig { returns(Integer) }
      def limiting; end

      # Set the limiting value.
      # 
      # _@param_ `value` — The limit.
      # 
      # _@return_ — The limit.
      # 
      # Set the limiting value.
      # ```ruby
      # ```
      sig { params(value: Integer).returns(Integer) }
      def limiting=(value); end

      # Get the skiping value.
      # 
      # _@return_ — The skip.
      # 
      # Get the skiping value.
      # ```ruby
      # ```
      sig { returns(Integer) }
      def skipping; end

      # Set the skiping value.
      # 
      # _@param_ `value` — The skip.
      # 
      # _@return_ — The skip.
      # 
      # Set the skiping value.
      # ```ruby
      # ```
      sig { params(value: Integer).returns(Integer) }
      def skipping=(value); end

      # Apply criteria options.
      # 
      # _@return_ — self.
      # 
      # Apply criteria options.
      # ```ruby
      # context.apply_options
      # ```
      sig { returns(Memory) }
      def apply_options; end

            # Map the sort symbols to the correct MongoDB values.
      # 
      # Apply the sorting params.
      # ```ruby
      # context.apply_sorting
      # ```
      sig { returns(T.untyped) }
      def apply_sorting; end

      # Compare two values, checking for nil.
      # 
      # _@param_ `a` — The first object.
      # 
      # _@param_ `b` — The first object.
      # 
      # _@return_ — The comparison value.
      # 
      # Compare the two objects.
      # ```ruby
      # context.compare(a, b)
      # ```
      sig { params(a: Object, b: Object).returns(Integer) }
      def compare(a, b); end

            # Sort the documents in place.
      # 
      # _@param_ `values` — The field/direction sorting pairs.
      # 
      # Sort the documents.
      # ```ruby
      # context.in_place_sort(name: 1)
      # ```
      sig { params(values: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
      def in_place_sort(values); end

            # Prepare the document for batch removal.
      # 
      # _@param_ `doc` — The document.
      # 
      # Prepare for removal.
      # ```ruby
      # context.prepare_remove(doc)
      # ```
      sig { params(doc: Document).returns(T.untyped) }
      def prepare_remove(doc); end

            sig { returns(T.untyped) }
      def _session; end

      # Takes the provided selector and atomic operations and replaces the
      # indexes of the embedded documents with the positional operator when
      # needed.
      # 
      # _@param_ `selector` — The selector.
      # 
      # _@param_ `operations` — The update operations.
      # 
      # _@param_ `processed` — The processed update operations.
      # 
      # _@return_ — The new operations.
      # 
      # Process the operations.
      # ```ruby
      # positionally(
      #   { "_id" => 1, "addresses._id" => 2 },
      #   { "$set" => { "addresses.0.street" => "hobrecht" }}
      # )
      # ```
      # 
      # _@note_ — The only time we can accurately know when to use the positional
      # operator is at the exact time we are going to persist something. So
      # we can tell by the selector that we are sending if it is actually
      # possible to use the positional operator at all. For example, if the
      # selector is: { "_id" => 1 }, then we could not use the positional
      # operator for updating embedded documents since there would never be a
      # match - we base whether we can based on the number of levels deep the
      # selector goes, and if the id values are not nil.
      sig { params(selector: T::Hash[T.untyped, T.untyped], operations: T::Hash[T.untyped, T.untyped], processed: T::Hash[T.untyped, T.untyped]).returns(T::Hash[T.untyped, T.untyped]) }
      def positionally(selector, operations, processed = {}); end

                              sig { params(keys: T.untyped, operations: T.untyped, processed: T.untyped).returns(T.untyped) }
      def process_operations(keys, operations, processed); end

                              sig { params(keys: T.untyped, update: T.untyped, updates: T.untyped).returns(T.untyped) }
      def process_updates(keys, update, updates = {}); end

                        sig { params(keys: T.untyped, position: T.untyped).returns(T.untyped) }
      def replace_index(keys, position); end

      # Is the enumerable of matching documents empty?
      # 
      # _@return_ — If the context is empty.
      # 
      # Is the context empty?
      # ```ruby
      # context.blank?
      # ```
      sig { returns(T::Boolean) }
      def blank?; end

      sig { returns(T::Boolean) }
      def eager_loadable?; end

                  sig { params(docs: T.untyped).returns(T.untyped) }
      def eager_load(docs); end

                        sig { params(relations: T.untyped, docs: T.untyped).returns(T.untyped) }
      def preload(relations, docs); end

      # Get the average value of the provided field.
      # 
      # _@param_ `field` — The field to average.
      # 
      # _@return_ — The average.
      # 
      # Get the average of a single field.
      # ```ruby
      # aggregable.avg(:likes)
      # ```
      sig { params(field: Symbol).returns(Float) }
      def avg(field); end

      # Get the max value of the provided field. If provided a block, will
      # return the Document with the greatest value for the field, in
      # accordance with Ruby's enumerable API.
      # 
      # _@param_ `field` — The field to max.
      # 
      # _@return_ — The max value or document with the max
      # value.
      # 
      # Get the max of a single field.
      # ```ruby
      # aggregable.max(:likes)
      # ```
      # 
      # Get the document with the max value.
      # ```ruby
      # aggregable.max do |a, b|
      #   a.likes <=> b.likes
      # end
      # ```
      sig { params(field: T.nilable(Symbol)).returns(T.any(Float, Document)) }
      def max(field = nil); end

      # Get the min value of the provided field. If provided a block, will
      # return the Document with the smallest value for the field, in
      # accordance with Ruby's enumerable API.
      # 
      # _@param_ `field` — The field to min.
      # 
      # _@return_ — The min value or document with the min
      # value.
      # 
      # Get the min of a single field.
      # ```ruby
      # aggregable.min(:likes)
      # ```
      # 
      # Get the document with the min value.
      # ```ruby
      # aggregable.min do |a, b|
      #   a.likes <=> b.likes
      # end
      # ```
      sig { params(field: T.nilable(Symbol)).returns(T.any(Float, Document)) }
      def min(field = nil); end

      # Get the sum value of the provided field. If provided a block, will
      # return the sum in accordance with Ruby's enumerable API.
      # 
      # _@param_ `field` — The field to sum.
      # 
      # _@return_ — The sum value.
      # 
      # Get the sum of a single field.
      # ```ruby
      # aggregable.sum(:likes)
      # ```
      # 
      # Get the sum for the provided block.
      # ```ruby
      # aggregable.sum(&:likes)
      # ```
      sig { params(field: T.nilable(Symbol)).returns(Float) }
      def sum(field = nil); end

      # Aggregate by the provided field and method.
      # 
      # _@param_ `field` — The field to aggregate on.
      # 
      # _@param_ `method` — The method (min_by or max_by).
      # 
      # _@return_ — The aggregate.
      # 
      # Aggregate by the field and method.
      # ```ruby
      # aggregable.aggregate_by(:name, :min_by)
      # ```
      sig { params(field: Symbol, method: Symbol).returns(Integer) }
      def aggregate_by(field, method); end

            # Returns the value of attribute documents.
      sig { returns(T.untyped) }
      attr_reader :documents

            sig { returns(T.untyped) }
      attr_reader :root

            sig { returns(T.untyped) }
      attr_reader :path

            sig { returns(T.untyped) }
      attr_reader :selector

            sig { returns(T.untyped) }
      attr_reader :matching

            # Returns the value of attribute path.
      sig { returns(T.untyped) }
      attr_reader :path

            # Returns the value of attribute root.
      sig { returns(T.untyped) }
      attr_reader :root

            # Returns the value of attribute selector.
      sig { returns(T.untyped) }
      attr_reader :selector
    end

    module Command
      # The database command that is being built to send to the db.
      # 
      # _@return_ — The db command.
      # 
      # Get the command.
      # ```ruby
      # command.command
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def command; end

      # sord warn - Mongo::Client wasn't able to be resolved to a constant in this project
      # Get the database client.
      # 
      # _@return_ — The Mongo client.
      # 
      # Get the client.
      # ```ruby
      # command.client
      # ```
      sig { returns(::Mongo::Client) }
      def client; end

            # Returns the value of attribute collection.
      sig { returns(T.untyped) }
      attr_reader :collection

            sig { returns(T.untyped) }
      attr_reader :collection

            sig { returns(T.untyped) }
      attr_reader :criteria

            # Returns the value of attribute criteria.
      sig { returns(T.untyped) }
      attr_reader :criteria
    end

    class GeoNear
      include Enumerable
      include Mongoid::Contextual::Command
      extend Forwardable

      # Get the average distance for all documents from the point in the
      # command.
      # 
      # _@return_ — The average distance.
      # 
      # Get the average distance.
      # ```ruby
      # geo_near.average_distance
      # ```
      sig { returns(T.nilable(Float)) }
      def average_distance; end

      # Iterates over each of the documents in the $geoNear, excluding the
      # extra information that was passed back from the database.
      # 
      # _@return_ — The enumerator.
      # 
      # Iterate over the results.
      # ```ruby
      # geo_near.each do |doc|
      #   p doc
      # end
      # ```
      sig { returns(T::Enumerator[T.untyped]) }
      def each; end

      # Provide a distance multiplier to be used for each returned distance.
      # 
      # _@param_ `value` — The distance multiplier.
      # 
      # _@return_ — The GeoNear wrapper.
      # 
      # Provide the distance multiplier.
      # ```ruby
      # geo_near.distance_multiplier(13113.1)
      # ```
      sig { params(value: T.any(Integer, Float)).returns(GeoNear) }
      def distance_multiplier(value); end

      # sord warn - Mongo::Collection wasn't able to be resolved to a constant in this project
      # Initialize the new map/reduce directive.
      # 
      # _@param_ `collection` — The collection to run the operation on.
      # 
      # _@param_ `criteria` — The Mongoid criteria.
      # 
      # _@param_ `near`
      # 
      # Initialize the new map/reduce.
      # ```ruby
      # MapReduce.new(criteria, map, reduce)
      # ```
      sig { params(collection: ::Mongo::Collection, criteria: Criteria, near: String).void }
      def initialize(collection, criteria, near); end

      # Get a pretty string representation of the command.
      # 
      # _@return_ — The inspection string.
      # 
      # Inspect the geoNear.
      # ```ruby
      # geo_near.inspect
      # ```
      sig { returns(String) }
      def inspect; end

      # Specify the maximum distance to find documents for, or get the value of
      # the document with the furthest distance.
      # 
      # _@param_ `value` — The maximum distance.
      # 
      # _@return_ — The GeoNear command or the value.
      # 
      # Set the max distance.
      # ```ruby
      # geo_near.max_distance(0.5)
      # ```
      # 
      # Get the max distance.
      # ```ruby
      # geo_near.max_distance
      # ```
      sig { params(value: T.nilable(T.any(Integer, Float))).returns(T.any(GeoNear, Float)) }
      def max_distance(value = nil); end

      # Specify the minimum distance to find documents for.
      # 
      # _@param_ `value` — The minimum distance.
      # 
      # _@return_ — The GeoNear command.
      # 
      # Set the min distance.
      # ```ruby
      # geo_near.min_distance(0.5)
      # ```
      sig { params(value: T.any(Integer, Float)).returns(GeoNear) }
      def min_distance(value); end

      # Tell the command to calculate based on spherical distances.
      # 
      # _@return_ — The command.
      # 
      # Add the spherical flag.
      # ```ruby
      # geo_near.spherical
      # ```
      sig { returns(GeoNear) }
      def spherical; end

      # Tell the command whether or not the retured results should be unique.
      # 
      # _@param_ `value` — Whether to return unique documents.
      # 
      # _@return_ — The command.
      # 
      # Set the unique flag.
      # ```ruby
      # geo_near.unique(false)
      # ```
      sig { params(value: T::Boolean).returns(GeoNear) }
      def unique(value = true); end

      # Execute the $geoNear, returning the raw output.
      # 
      # _@return_ — The raw output
      # 
      # Run the $geoNear
      # ```ruby
      # geo_near.execute
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def execute; end

      # Get the stats for the command run.
      # 
      # _@return_ — The stats from the command run.
      # 
      # Get the stats.
      # ```ruby
      # geo_near.stats
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def stats; end

      # Get the execution time of the command.
      # 
      # _@return_ — The execution time.
      # 
      # Get the execution time.
      # ```ruby
      # geo_near.time
      # ```
      sig { returns(Float) }
      def time; end

      # Is this context's criteria considered empty?
      # 
      # _@return_ — Always true.
      # 
      # Is this context's criteria considered empty?
      # ```ruby
      # geo_near.empty_and_chainable?
      # ```
      sig { returns(T::Boolean) }
      def empty_and_chainable?; end

      # Apply criteria specific options - query, limit.
      # 
      # _@return_ — Nothing.
      # 
      # Apply the criteria options
      # ```ruby
      # geo_near.apply_criteria_options
      # ```
      sig { returns(T.nilable(T.any())) }
      def apply_criteria_options; end

      # sord warn - Cursor wasn't able to be resolved to a constant in this project
      # Get the result documents from the $geoNear.
      # 
      # _@return_ — The documents.
      # 
      # Get the documents.
      # ```ruby
      # geo_near.documents
      # ```
      sig { returns(T.any(T::Array[T.untyped], ::Mongo::Cursor)) }
      def documents; end

      # Execute the $geoNear command and get the results.
      # 
      # _@return_ — The results of the command.
      # 
      # Get the results.
      # ```ruby
      # geo_near.results
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def results; end

      # The database command that is being built to send to the db.
      # 
      # _@return_ — The db command.
      # 
      # Get the command.
      # ```ruby
      # command.command
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def command; end

      # sord warn - Mongo::Client wasn't able to be resolved to a constant in this project
      # Get the database client.
      # 
      # _@return_ — The Mongo client.
      # 
      # Get the client.
      # ```ruby
      # command.client
      # ```
      sig { returns(::Mongo::Client) }
      def client; end
    end

    module Queryable
      # Is the enumerable of matching documents empty?
      # 
      # _@return_ — If the context is empty.
      # 
      # Is the context empty?
      # ```ruby
      # context.blank?
      # ```
      sig { returns(T::Boolean) }
      def blank?; end

            # Returns the value of attribute collection.
      sig { returns(T.untyped) }
      attr_reader :collection

            sig { returns(T.untyped) }
      attr_reader :collection

            sig { returns(T.untyped) }
      attr_reader :criteria

            sig { returns(T.untyped) }
      attr_reader :klass

            # Returns the value of attribute criteria.
      sig { returns(T.untyped) }
      attr_reader :criteria

            # Returns the value of attribute klass.
      sig { returns(T.untyped) }
      attr_reader :klass
    end

    class MapReduce
      include Enumerable
      include Mongoid::Contextual::Command
      extend Forwardable

      # Get all the counts returned by the map/reduce.
      # 
      # _@return_ — The counts.
      # 
      # Get the counts.
      # ```ruby
      # map_reduce.counts
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def counts; end

      # Iterates over each of the documents in the map/reduce, excluding the
      # extra information that was passed back from the database.
      # 
      # _@return_ — The enumerator.
      # 
      # Iterate over the results.
      # ```ruby
      # map_reduce.each do |doc|
      #   p doc
      # end
      # ```
      sig { returns(T::Enumerator[T.untyped]) }
      def each; end

      # Get the number of documents emitted by the map/reduce.
      # 
      # _@return_ — The number of emitted documents.
      # 
      # Get the emitted document count.
      # ```ruby
      # map_reduce.emitted
      # ```
      sig { returns(Integer) }
      def emitted; end

      # Provide a finalize js function for the map/reduce.
      # 
      # _@param_ `function` — The finalize function.
      # 
      # _@return_ — The map reduce.
      # 
      # Provide a finalize function.
      # ```ruby
      # map_reduce.finalize(func)
      # ```
      sig { params(function: String).returns(MapReduce) }
      def finalize(function); end

            # Initialize the new map/reduce directive.
      # 
      # _@param_ `criteria` — The Mongoid criteria.
      # 
      # _@param_ `map` — The map js function.
      # 
      # _@param_ `reduce` — The reduce js function.
      # 
      # Initialize the new map/reduce.
      # ```ruby
      # MapReduce.new(criteria, map, reduce)
      # ```
      sig do
        params(
          collection: T.untyped,
          criteria: Criteria,
          map: String,
          reduce: String
        ).void
      end
      def initialize(collection, criteria, map, reduce); end

      # Get the number of documents that were input into the map/reduce.
      # 
      # _@return_ — The number of input documents.
      # 
      # Get the count of input documents.
      # ```ruby
      # map_reduce.input
      # ```
      sig { returns(Integer) }
      def input; end

      # Sets the map/reduce to use jsMode.
      # 
      # _@return_ — The map/reduce.
      # 
      # Set the map/reduce to jsMode.
      # ```ruby
      # map_reduce.js_mode
      # ```
      sig { returns(MapReduce) }
      def js_mode; end

      # Specifies where the map/reduce output is to be stored.
      # Please see MongoDB documentation for supported map reduce options.
      # 
      # _@param_ `location` — The place to store the results.
      # 
      # _@return_ — The map/reduce object.
      # 
      # Store output in memory.
      # ```ruby
      # map_reduce.out(inline: 1)
      # ```
      # 
      # Store output in a collection, replacing existing documents.
      # ```ruby
      # map_reduce.out(replace: "collection_name")
      # ```
      # 
      # Store output in a collection, merging existing documents.
      # ```ruby
      # map_reduce.out(merge: "collection_name")
      # ```
      # 
      # Store output in a collection, reducing existing documents.
      # ```ruby
      # map_reduce.out(reduce: "collection_name")
      # ```
      # 
      # Return results from map reduce.
      # ```ruby
      # map_reduce.out(inline: 1)
      # ```
      sig { params(location: T::Hash[T.untyped, T.untyped]).returns(MapReduce) }
      def out(location); end

      # Get the number of documents output by the map/reduce.
      # 
      # _@return_ — The number of output documents.
      # 
      # Get the output document count.
      # ```ruby
      # map_reduce.output
      # ```
      sig { returns(Integer) }
      def output; end

      # Get the raw output from the map/reduce operation.
      # 
      # _@return_ — The raw output.
      # 
      # Get the raw output.
      # ```ruby
      # map_reduce.raw
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def raw; end

      # Get the number of documents reduced by the map/reduce.
      # 
      # _@return_ — The number of reduced documents.
      # 
      # Get the reduced document count.
      # ```ruby
      # map_reduce.reduced
      # ```
      sig { returns(Integer) }
      def reduced; end

      # Adds a javascript object to the global scope of the map/reduce.
      # 
      # _@param_ `object` — A hash of key/values for the global scope.
      # 
      # Add an object to the global scope.
      # ```ruby
      # map_reduce.scope(name: value)
      # ```
      sig { params(object: T::Hash[T.untyped, T.untyped]).returns(MapReduce) }
      def scope(object); end

      # Get the execution time of the map/reduce.
      # 
      # _@return_ — The time in milliseconds.
      # 
      # Get the execution time.
      # ```ruby
      # map_reduce.time
      # ```
      sig { returns(Float) }
      def time; end

      # Get a pretty string representation of the map/reduce, including the
      # criteria, map, reduce, finalize, and out option.
      # 
      # _@return_ — The inspection string.
      # 
      # Inspect the map_reduce.
      # ```ruby
      # map_reduce.inspect
      # ```
      sig { returns(String) }
      def inspect; end

            sig { returns(T.untyped) }
      def command; end

            sig { returns(T.untyped) }
      def validate_out!; end

            sig { returns(T.untyped) }
      def _session; end

      # sord warn - Mongo::Client wasn't able to be resolved to a constant in this project
      # Get the database client.
      # 
      # _@return_ — The Mongo client.
      # 
      # Get the client.
      # ```ruby
      # command.client
      # ```
      sig { returns(::Mongo::Client) }
      def client; end
    end

    module Aggregable
      # Contains behavior for aggregating values in Mongo.
      module Mongo
        # Get all the aggregate values for the provided field.
        # 
        # _@param_ `field` — The field name.
        # 
        # _@return_ — count is a number of documents with the provided
        # field. If there're none, then count is 0 and max, min, sum, avg
        # are nil.
        # 
        # Get all the aggregate values.
        # ```ruby
        # aggregable.aggregates(:likes)
        # # => {
        # #   "count" => 2.0,
        # #   "max" => 1000.0,
        # #   "min" => 500.0,
        # #   "sum" => 1500.0,
        # #   "avg" => 750.0
        # # }
        # ```
        sig { params(field: T.any(String, Symbol)).returns(T::Hash[T.untyped, T.untyped]) }
        def aggregates(field); end

        # Get the average value of the provided field.
        # 
        # _@param_ `field` — The field to average.
        # 
        # _@return_ — The average.
        # 
        # Get the average of a single field.
        # ```ruby
        # aggregable.avg(:likes)
        # ```
        sig { params(field: Symbol).returns(Float) }
        def avg(field); end

        # Get the max value of the provided field. If provided a block, will
        # return the Document with the greatest value for the field, in
        # accordance with Ruby's enumerable API.
        # 
        # _@param_ `field` — The field to max.
        # 
        # _@return_ — The max value or document with the max
        # value.
        # 
        # Get the max of a single field.
        # ```ruby
        # aggregable.max(:likes)
        # ```
        # 
        # Get the document with the max value.
        # ```ruby
        # aggregable.max do |a, b|
        #   a.likes <=> b.likes
        # end
        # ```
        sig { params(field: T.nilable(Symbol)).returns(T.any(Float, Document)) }
        def max(field = nil); end

        # Get the min value of the provided field. If provided a block, will
        # return the Document with the smallest value for the field, in
        # accordance with Ruby's enumerable API.
        # 
        # _@param_ `field` — The field to min.
        # 
        # _@return_ — The min value or document with the min
        # value.
        # 
        # Get the min of a single field.
        # ```ruby
        # aggregable.min(:likes)
        # ```
        # 
        # Get the document with the min value.
        # ```ruby
        # aggregable.min do |a, b|
        #   a.likes <=> b.likes
        # end
        # ```
        sig { params(field: T.nilable(Symbol)).returns(T.any(Float, Document)) }
        def min(field = nil); end

        # Get the sum value of the provided field. If provided a block, will
        # return the sum in accordance with Ruby's enumerable API.
        # 
        # _@param_ `field` — The field to sum.
        # 
        # _@return_ — The sum value.
        # 
        # Get the sum of a single field.
        # ```ruby
        # aggregable.sum(:likes)
        # ```
        # 
        # Get the sum for the provided block.
        # ```ruby
        # aggregable.sum(&:likes)
        # ```
        sig { params(field: T.nilable(Symbol)).returns(Float) }
        def sum(field = nil); end

        # Get the aggregation pipeline for provided field.
        # 
        # _@param_ `field` — The name of the field.
        # 
        # _@return_ — The array of pipeline operators.
        # 
        # Get the pipeline.
        # ```ruby
        # aggregable.pipeline(:likes)
        # ```
        sig { params(field: T.any(String, Symbol)).returns(T::Array[T.untyped]) }
        def pipeline(field); end
      end

      # Contains behavior for aggregating values in memory.
      module Memory
        # Get the average value of the provided field.
        # 
        # _@param_ `field` — The field to average.
        # 
        # _@return_ — The average.
        # 
        # Get the average of a single field.
        # ```ruby
        # aggregable.avg(:likes)
        # ```
        sig { params(field: Symbol).returns(Float) }
        def avg(field); end

        # Get the max value of the provided field. If provided a block, will
        # return the Document with the greatest value for the field, in
        # accordance with Ruby's enumerable API.
        # 
        # _@param_ `field` — The field to max.
        # 
        # _@return_ — The max value or document with the max
        # value.
        # 
        # Get the max of a single field.
        # ```ruby
        # aggregable.max(:likes)
        # ```
        # 
        # Get the document with the max value.
        # ```ruby
        # aggregable.max do |a, b|
        #   a.likes <=> b.likes
        # end
        # ```
        sig { params(field: T.nilable(Symbol)).returns(T.any(Float, Document)) }
        def max(field = nil); end

        # Get the min value of the provided field. If provided a block, will
        # return the Document with the smallest value for the field, in
        # accordance with Ruby's enumerable API.
        # 
        # _@param_ `field` — The field to min.
        # 
        # _@return_ — The min value or document with the min
        # value.
        # 
        # Get the min of a single field.
        # ```ruby
        # aggregable.min(:likes)
        # ```
        # 
        # Get the document with the min value.
        # ```ruby
        # aggregable.min do |a, b|
        #   a.likes <=> b.likes
        # end
        # ```
        sig { params(field: T.nilable(Symbol)).returns(T.any(Float, Document)) }
        def min(field = nil); end

        # Get the sum value of the provided field. If provided a block, will
        # return the sum in accordance with Ruby's enumerable API.
        # 
        # _@param_ `field` — The field to sum.
        # 
        # _@return_ — The sum value.
        # 
        # Get the sum of a single field.
        # ```ruby
        # aggregable.sum(:likes)
        # ```
        # 
        # Get the sum for the provided block.
        # ```ruby
        # aggregable.sum(&:likes)
        # ```
        sig { params(field: T.nilable(Symbol)).returns(Float) }
        def sum(field = nil); end

        # Aggregate by the provided field and method.
        # 
        # _@param_ `field` — The field to aggregate on.
        # 
        # _@param_ `method` — The method (min_by or max_by).
        # 
        # _@return_ — The aggregate.
        # 
        # Aggregate by the field and method.
        # ```ruby
        # aggregable.aggregate_by(:name, :min_by)
        # ```
        sig { params(field: Symbol, method: Symbol).returns(Integer) }
        def aggregate_by(field, method); end
      end
    end
  end

  # This module is responsible for taking update selectors and switching out
  # the indexes for the $ positional operator where appropriate.
  # 
  # @since 4.0.0
  module Positional
    # Takes the provided selector and atomic operations and replaces the
    # indexes of the embedded documents with the positional operator when
    # needed.
    # 
    # _@param_ `selector` — The selector.
    # 
    # _@param_ `operations` — The update operations.
    # 
    # _@param_ `processed` — The processed update operations.
    # 
    # _@return_ — The new operations.
    # 
    # Process the operations.
    # ```ruby
    # positionally(
    #   { "_id" => 1, "addresses._id" => 2 },
    #   { "$set" => { "addresses.0.street" => "hobrecht" }}
    # )
    # ```
    # 
    # _@note_ — The only time we can accurately know when to use the positional
    # operator is at the exact time we are going to persist something. So
    # we can tell by the selector that we are sending if it is actually
    # possible to use the positional operator at all. For example, if the
    # selector is: { "_id" => 1 }, then we could not use the positional
    # operator for updating embedded documents since there would never be a
    # match - we base whether we can based on the number of levels deep the
    # selector goes, and if the id values are not nil.
    sig { params(selector: T::Hash[T.untyped, T.untyped], operations: T::Hash[T.untyped, T.untyped], processed: T::Hash[T.untyped, T.untyped]).returns(T::Hash[T.untyped, T.untyped]) }
    def positionally(selector, operations, processed = {}); end

                    sig { params(keys: T.untyped, operations: T.untyped, processed: T.untyped).returns(T.untyped) }
    def process_operations(keys, operations, processed); end

                    sig { params(keys: T.untyped, update: T.untyped, updates: T.untyped).returns(T.untyped) }
    def process_updates(keys, update, updates = {}); end

                sig { params(keys: T.untyped, position: T.untyped).returns(T.untyped) }
    def replace_index(keys, position); end
  end

  # This module handles reloading behavior of documents.
  # 
  # @since 4.0.0
  module Reloadable
    # Reloads the +Document+ attributes from the database. If the document has
    # not been saved then an error will get raised if the configuration option
    # was set. This can reload root documents or embedded documents.
    # 
    # _@return_ — The document, reloaded.
    # 
    # Reload the document.
    # ```ruby
    # person.reload
    # ```
    sig { returns(Document) }
    def reload; end

    # Reload the document, determining if it's embedded or not and what
    # behavior to use.
    # 
    # _@return_ — The reloaded attributes.
    # 
    # Reload the document.
    # ```ruby
    # document._reload
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def _reload; end

    # Reload the root document.
    # 
    # _@return_ — The reloaded attributes.
    # 
    # Reload the document.
    # ```ruby
    # document.reload_root_document
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def reload_root_document; end

    # Reload the embedded document.
    # 
    # _@return_ — The reloaded attributes.
    # 
    # Reload the document.
    # ```ruby
    # document.reload_embedded_document
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def reload_embedded_document; end

    # Extract only the desired embedded document from the attributes.
    # 
    # _@param_ `attributes` — The document in the db.
    # 
    # _@return_ — The document's extracted attributes.
    # 
    # Extract the embedded document.
    # ```ruby
    # document.extract_embedded_attributes(attributes)
    # ```
    sig { params(attributes: T::Hash[T.untyped, T.untyped]).returns(T::Hash[T.untyped, T.untyped]) }
    def extract_embedded_attributes(attributes); end
  end

  # Provides behavior for generating the selector for a specific document.
  # 
  # @since 4.0.0
  module Selectable
    extend ActiveSupport::Concern

    # Get the atomic selector for the document. This is a hash in the simplest
    # case { "_id" => id }, but can become more complex for embedded documents
    # and documents that use a shard key.
    # 
    # _@return_ — The document's selector.
    # 
    # Get the document's atomic selector.
    # ```ruby
    # document.atomic_selector
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def atomic_selector; end

    # Get the atomic selector for an embedded document.
    # 
    # _@return_ — The embedded document selector.
    # 
    # Get the embedded atomic selector.
    # ```ruby
    # document.embedded_atomic_selector
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def embedded_atomic_selector; end

    # Get the atomic selector for a root document.
    # 
    # _@return_ — The root document selector.
    # 
    # Get the root atomic selector.
    # ```ruby
    # document.root_atomic_selector
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def root_atomic_selector; end
  end

  # This module handles the behavior for setting up document created at and
  # updated at timestamps.
  module Timestamps
    include Mongoid::Timestamps::Created
    include Mongoid::Timestamps::Updated
    extend ActiveSupport::Concern

        # Update the updated_at field on the Document to the current time.
    # This is only called on create and on save.
    # 
    # Set the updated at time.
    # ```ruby
    # person.set_updated_at
    # ```
    sig { returns(T.untyped) }
    def set_updated_at; end

    # Is the updated timestamp able to be set?
    # 
    # _@return_ — If the timestamp can be set.
    # 
    # Can the timestamp be set?
    # ```ruby
    # document.able_to_set_updated_at?
    # ```
    sig { returns(T::Boolean) }
    def able_to_set_updated_at?; end

        # Update the created_at field on the Document to the current time. This is
    # only called on create.
    # 
    # Set the created at time.
    # ```ruby
    # person.set_created_at
    # ```
    sig { returns(T.untyped) }
    def set_created_at; end

    module Short
      include Mongoid::Timestamps::Created::Short
      include Mongoid::Timestamps::Updated::Short
      extend ActiveSupport::Concern
    end

    # This module handles the behavior for setting up document created at
    # timestamp.
    module Created
      extend ActiveSupport::Concern

            # Update the created_at field on the Document to the current time. This is
      # only called on create.
      # 
      # Set the created at time.
      # ```ruby
      # person.set_created_at
      # ```
      sig { returns(T.untyped) }
      def set_created_at; end

      # Adds a created_at timestamp to the document, but it is stored as c_at
      # with a created_at alias.
      module Short
        extend ActiveSupport::Concern
      end
    end

    # This module handles the behavior for setting up document updated at
    # timestamp.
    module Updated
      extend ActiveSupport::Concern

            # Update the updated_at field on the Document to the current time.
      # This is only called on create and on save.
      # 
      # Set the updated at time.
      # ```ruby
      # person.set_updated_at
      # ```
      sig { returns(T.untyped) }
      def set_updated_at; end

      # Is the updated timestamp able to be set?
      # 
      # _@return_ — If the timestamp can be set.
      # 
      # Can the timestamp be set?
      # ```ruby
      # document.able_to_set_updated_at?
      # ```
      sig { returns(T::Boolean) }
      def able_to_set_updated_at?; end

      # Adds an updated_at timestamp to the document, but it is stored as u_at
      # with an updated_at alias.
      module Short
        extend ActiveSupport::Concern
      end
    end

    # This module adds behavior for turning off timestamping in single or
    # multiple calls.
    module Timeless
      extend ActiveSupport::Concern
      extend Forwardable

      # Clears out the timeless option.
      # 
      # _@return_ — True.
      # 
      # Clear the timeless option.
      # ```ruby
      # document.clear_timeless_option
      # ```
      sig { returns(T::Boolean) }
      def clear_timeless_option; end

      # Begin an execution that should skip timestamping.
      # 
      # _@return_ — The document this was called on.
      # 
      # Save a document but don't timestamp.
      # ```ruby
      # person.timeless.save
      # ```
      sig { returns(Document) }
      def timeless; end

      sig { returns(T::Boolean) }
      def timeless?; end

            sig { returns(T.untyped) }
      def self.timeless_table; end

      module ClassMethods
        # Begin an execution that should skip timestamping.
        # 
        # _@return_ — The class this was called on.
        # 
        # Create a document but don't timestamp.
        # ```ruby
        # Person.timeless.create(:title => "Sir")
        # ```
        sig { returns(Class) }
        def timeless; end

                sig { returns(T.untyped) }
        def clear_timeless_option; end

                sig { returns(T.untyped) }
        def clear_timeless_option_on_update; end

                        sig { params(counter: T.untyped).returns(T.untyped) }
        def set_timeless_counter(counter); end

        sig { returns(T::Boolean) }
        def timeless?; end
      end
    end
  end

  module Association
    include Mongoid::Association::Embedded::Cyclic
    include Mongoid::Association::Referenced::AutoSave
    include Mongoid::Association::Referenced::CounterCache
    include Mongoid::Association::Referenced::Syncable
    include Mongoid::Association::Accessors
    include Mongoid::Association::Depending
    include Mongoid::Association::Builders
    include Mongoid::Association::Macros
    include Mongoid::Association::Reflections
    extend ActiveSupport::Concern
    MACRO_MAPPING = T.let({
    embeds_one: Association::Embedded::EmbedsOne,
    embeds_many: Association::Embedded::EmbedsMany,
    embedded_in: Association::Embedded::EmbeddedIn,
    has_one: Association::Referenced::HasOne,
    has_many: Association::Referenced::HasMany,
    has_and_belongs_to_many: Association::Referenced::HasAndBelongsToMany,
    belongs_to: Association::Referenced::BelongsTo,
}.freeze, T.untyped)
    STRATEGIES = T.let([
    :delete_all,
    :destroy,
    :nullify,
    :restrict_with_exception,
    :restrict_with_error
], T.untyped)

    # Determine if the document itself is embedded in another document via the
    # proper channels. (If it has a parent document.)
    # 
    # _@return_ — True if the document has a parent document.
    # 
    # Is the document embedded?
    # ```ruby
    # address.embedded?
    # ```
    sig { returns(T::Boolean) }
    def embedded?; end

    # Determine if the document is part of an embeds_many association.
    # 
    # _@return_ — True if in an embeds many.
    # 
    # Is the document in an embeds many?
    # ```ruby
    # address.embedded_many?
    # ```
    sig { returns(T::Boolean) }
    def embedded_many?; end

    # Determine if the document is part of an embeds_one association.
    # 
    # _@return_ — True if in an embeds one.
    # 
    # Is the document in an embeds one?
    # ```ruby
    # address.embedded_one?
    # ```
    sig { returns(T::Boolean) }
    def embedded_one?; end

    # Get the association name for this document. If no association was defined
    #   an error will be raised.
    # 
    # _@return_ — The association name.
    # 
    # Get the association name.
    # ```ruby
    # document.association_name
    # ```
    sig { returns(Symbol) }
    def association_name; end

    # Determine if the document is part of an references_many association.
    # 
    # _@return_ — True if in a references many.
    # 
    # Is the document in a references many?
    # ```ruby
    # post.referenced_many?
    # ```
    sig { returns(T::Boolean) }
    def referenced_many?; end

    # Determine if the document is part of an references_one association.
    # 
    # _@return_ — True if in a references one.
    # 
    # Is the document in a references one?
    # ```ruby
    # address.referenced_one?
    # ```
    sig { returns(T::Boolean) }
    def referenced_one?; end

    # Convenience method for iterating through the loaded associations and
    # reloading them.
    # 
    # _@return_ — The association metadata.
    # 
    # Reload the associations.
    # ```ruby
    # document.reload_relations
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def reload_relations; end

    # Returns the association metadata for the supplied name.
    # 
    # _@param_ `name` — The name of the association to find.
    # 
    # _@return_ — The matching association metadata.
    # 
    # Find association metadata by name.
    # ```ruby
    # person.reflect_on_association(:addresses)
    # ```
    sig { params(name: T.any(String, Symbol)).returns(Association) }
    def reflect_on_association(name); end

    # Returns all association metadata for the supplied macros.
    # 
    # _@param_ `macros` — The association macros.
    # 
    # _@return_ — The matching association metadata.
    # 
    # Find multiple association metadata by macro.
    # ```ruby
    # person.reflect_on_all_associations(:embeds_many)
    # ```
    sig { params(macros: T::Array[Symbol]).returns(T::Array[Association]) }
    def reflect_on_all_association(*macros); end

    # This is convenience for libraries still on the old API.
    # 
    # _@return_ — The associations.
    # 
    # Get the associations.
    # ```ruby
    # person.associations
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def associations; end

    # Parse out the attributes and the options from the args passed to a
    # build_ or create_ methods.
    # 
    # _@param_ `args` — The arguments.
    # 
    # _@return_ — The attributes and options.
    # 
    # Parse the args.
    # ```ruby
    # doc.parse_args(:name => "Joe")
    # ```
    sig { params(args: T::Array[T.untyped]).returns(T::Array[T::Hash[T.untyped, T.untyped]]) }
    def parse_args(*args); end

        # Perform all cascading deletes, destroys, or nullifies. Will delegate to
    # the appropriate strategy to perform the operation.
    # 
    # Execute cascades.
    # ```ruby
    # document.apply_delete_dependencies!
    # ```
    sig { returns(T.untyped) }
    def apply_delete_dependencies!; end

            sig { params(association: T.untyped).returns(T.untyped) }
    def _dependent_delete_all!(association); end

            sig { params(association: T.untyped).returns(T.untyped) }
    def _dependent_destroy!(association); end

            sig { params(association: T.untyped).returns(T.untyped) }
    def _dependent_nullify!(association); end

            sig { params(association: T.untyped).returns(T.untyped) }
    def _dependent_restrict_with_exception!(association); end

            sig { params(association: T.untyped).returns(T.untyped) }
    def _dependent_restrict_with_error!(association); end

    # Builds the related document and creates the association unless the
    # document is nil, then sets the association on this document.
    # 
    # _@param_ `name` — The name of the association.
    # 
    # _@param_ `object` — The id or attributes to use.
    # 
    # _@param_ `association` — The association metadata.
    # 
    # _@param_ `selected_fields` — Fields which were retrieved via #only. If selected_fields is specified, fields not listed in it will not be accessible in the built document.
    # 
    # _@return_ — The association.
    # 
    # Build the association.
    # ```ruby
    # person.__build__(:addresses, { :_id => 1 }, association)
    # ```
    sig do
      params(
        name: T.any(String, Symbol),
        object: T.any(T::Hash[T.untyped, T.untyped], BSON::ObjectId),
        association: Association,
        selected_fields: T.nilable(T::Hash[T.untyped, T.untyped])
      ).returns(Proxy)
    end
    def __build__(name, object, association, selected_fields = nil); end

    # Create an association from an object and association metadata.
    # 
    # _@param_ `object` — The association target.
    # 
    # _@param_ `association` — The association metadata.
    # 
    # _@param_ `selected_fields` — Fields which were retrieved via #only. If selected_fields is specified, fields not listed in it will not be accessible in the created association document.
    # 
    # _@return_ — The association.
    # 
    # Create the association.
    # ```ruby
    # person.create_relation(document, association)
    # ```
    sig { params(object: T.any(Document, T::Array[Document]), association: Association, selected_fields: T.nilable(T::Hash[T.untyped, T.untyped])).returns(Proxy) }
    def create_relation(object, association, selected_fields = nil); end

        # Resets the criteria inside the association proxy. Used by many-to-many
    # associations to keep the underlying ids array in sync.
    # 
    # _@param_ `name` — The name of the association.
    # 
    # Reset the association criteria.
    # ```ruby
    # person.reset_relation_criteria(:preferences)
    # ```
    sig { params(name: Symbol).returns(T.untyped) }
    def reset_relation_criteria(name); end

    # Set the supplied association to an instance variable on the class with the
    # provided name. Used as a helper just for code cleanliness.
    # 
    # _@param_ `name` — The name of the association.
    # 
    # _@param_ `relation` — The association to set.
    # 
    # _@return_ — The association.
    # 
    # Set the proxy on the document.
    # ```ruby
    # person.set(:addresses, addresses)
    # ```
    sig { params(name: T.any(String, Symbol), relation: Proxy).returns(Proxy) }
    def set_relation(name, relation); end

    # Get the association. Extracted out from the getter method to avoid
    # infinite recursion when overriding the getter.
    # 
    # _@param_ `name` — The name of the association.
    # 
    # _@param_ `association` — The association metadata.
    # 
    # _@param_ `object` — The object used to build the association.
    # 
    # _@param_ `reload` — If the association is to be reloaded.
    # 
    # _@return_ — The association.
    # 
    # Get the association.
    # ```ruby
    # document.get_relation(:name, association)
    # ```
    sig do
      params(
        name: Symbol,
        association: Association,
        object: Object,
        reload: T::Boolean
      ).returns(Proxy)
    end
    def get_relation(name, association, object, reload = false); end

    # Returns a subset of __selected_fields attribute applicable to the
    # (embedded) association with the given key, or nil if no projection
    # is to be performed.
    # 
    # For example, if __selected_fields is {'a' => 1, 'b.c' => 2, 'b.c.f' => 3},
    # and assoc_key is 'b', return value would be {'c' => 2, 'c.f' => 3}.
    # 
    # _@param_ `assoc_key`
    sig { params(assoc_key: String).returns(T.nilable(T::Hash[T.untyped, T.untyped])) }
    def _mongoid_filter_selected_fields(assoc_key); end

            sig { params(object: T.untyped, association: T.untyped).returns(T::Boolean) }
    def needs_no_database_query?(object, association); end

    # Is the current code executing without autobuild functionality?
    # 
    # _@return_ — If autobuild is disabled.
    # 
    # Is autobuild disabled?
    # ```ruby
    # document.without_autobuild?
    # ```
    sig { returns(T::Boolean) }
    def without_autobuild?; end

    # Yield to the block with autobuild functionality turned off.
    # 
    # _@return_ — The result of the yield.
    # 
    # Execute without autobuild.
    # ```ruby
    # document.without_autobuild do
    #   document.name
    # end
    # ```
    sig { returns(Object) }
    def without_autobuild; end

    # Is the document able to be synced on the inverse side? This is only if
    # the key has changed and the association bindings have not been run.
    # 
    # _@param_ `association` — The association metadata.
    # 
    # _@return_ — If we can sync.
    # 
    # Are the foreign keys syncable?
    # ```ruby
    # document._syncable?(association)
    # ```
    sig { params(association: Association).returns(T::Boolean) }
    def _syncable?(association); end

    # Get the synced foreign keys.
    # 
    # _@return_ — The synced foreign keys.
    # 
    # Get the synced foreign keys.
    # ```ruby
    # document._synced
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def _synced; end

    # Has the document been synced for the foreign key?
    # 
    # _@param_ `foreign_key` — The foreign key.
    # 
    # _@return_ — If we can sync.
    # 
    # Has the document been synced?
    # ```ruby
    # document._synced?
    # ```
    sig { params(foreign_key: String).returns(T::Boolean) }
    def _synced?(foreign_key); end

    # Update the inverse keys on destroy.
    # 
    # _@param_ `association` — The association.
    # 
    # _@return_ — The updated values.
    # 
    # Update the inverse keys.
    # ```ruby
    # document.remove_inverse_keys(association)
    # ```
    sig { params(association: Association).returns(Object) }
    def remove_inverse_keys(association); end

    # Update the inverse keys for the association.
    # 
    # _@param_ `association` — The document association.
    # 
    # _@return_ — The updated values.
    # 
    # Update the inverse keys
    # ```ruby
    # document.update_inverse_keys(association)
    # ```
    sig { params(association: Association).returns(Object) }
    def update_inverse_keys(association); end

        # Reset the given counter using the .count() query from the
    # db. This method is usuful in case that a counter got
    # corrupted, or a new counter was added to the collection.
    # 
    # _@param_ `counters` — One or more counter caches to reset
    # 
    # Reset the given counter cache
    # ```ruby
    # post.reset_counters(:comments)
    # ```
    sig { params(counters: T.any(Symbol, T::Array[T.untyped])).returns(T.untyped) }
    def reset_counters(*counters); end

    # Used to prevent infinite loops in associated autosaves.
    # 
    # _@return_ — Has the document already been autosaved?
    # 
    # Is the document autosaved?
    # ```ruby
    # document.autosaved?
    # ```
    sig { returns(T::Boolean) }
    def autosaved?; end

        # Begin the associated autosave.
    # 
    # Begin autosave.
    # ```ruby
    # document.__autosaving__
    # ```
    sig { returns(T.untyped) }
    def __autosaving__; end

        # Check if there is changes for auto-saving
    # 
    #   document.changed_for_autosave?
    # 
    # Return true if there is changes on self or in
    # ```ruby
    # autosaved associations.
    # ```
    sig { params(doc: T.untyped).returns(T::Boolean) }
    def changed_for_autosave?(doc); end

    # Returns the value of attribute _association.
    sig { returns(T.untyped) }
    attr_accessor :_association

    # This is the superclass for one to one relations and defines the common
    # behavior or those proxies.
    class One < Mongoid::Association::Proxy
      # Clear this relation - same as calling #delete on the document.
      # 
      # _@return_ — If the delete suceeded.
      # 
      # Clear the relation.
      # ```ruby
      # relation.clear
      # ```
      sig { returns(T::Boolean) }
      def clear; end

      # Get all the documents in the relation that are loaded into memory.
      # 
      # _@return_ — The documents in memory.
      # 
      # Get the in memory documents.
      # ```ruby
      # relation.in_memory
      # ```
      sig { returns(T::Array[Document]) }
      def in_memory; end

            # Since method_missing is overridden we should override this as well.
      # 
      # _@param_ `name` — The method name.
      # 
      # _@return_ — If the proxy responds to the method.
      # 
      # Does the proxy respond to the method?
      # ```ruby
      # relation.respond_to?(:name)
      # ```
      sig { params(name: Symbol, include_private: T.untyped).returns(T::Boolean) }
      def respond_to?(name, include_private = false); end

      # Evolve the proxy document into an object id.
      # 
      # _@return_ — The proxy document's id.
      # 
      # Evolve the proxy document.
      # ```ruby
      # proxy.__evolve_object_id__
      # ```
      sig { returns(Object) }
      def __evolve_object_id__; end
    end

    # This is the superclass for all many to one and many to many association
    # proxies.
    class Many < Mongoid::Association::Proxy
      include Enumerable
      extend Forwardable

      # Is the association empty?
      # 
      # _@return_ — If the association is empty or not.
      # 
      # Is the association empty??
      # ```ruby
      # person.addresses.blank?
      # ```
      sig { returns(T::Boolean) }
      def blank?; end

      # Creates a new document on the references many association. This will
      # save the document if the parent has been persisted.
      # 
      # _@param_ `attributes` — The attributes to create with.
      # 
      # _@param_ `type` — The optional type of document to create.
      # 
      # _@return_ — The newly created document.
      # 
      # Create and save the new document.
      # ```ruby
      # person.posts.create(:text => "Testing")
      # ```
      sig { params(attributes: T.nilable(T::Hash[T.untyped, T.untyped]), type: T.nilable(Class), block: T.untyped).returns(Document) }
      def create(attributes = nil, type = nil, &block); end

      # Creates a new document on the references many association. This will
      # save the document if the parent has been persisted and will raise an
      # error if validation fails.
      # 
      # _@param_ `attributes` — The attributes to create with.
      # 
      # _@param_ `type` — The optional type of document to create.
      # 
      # _@return_ — The newly created document.
      # 
      # Create and save the new document.
      # ```ruby
      # person.posts.create!(:text => "Testing")
      # ```
      sig { params(attributes: T.nilable(T::Hash[T.untyped, T.untyped]), type: T.nilable(Class), block: T.untyped).returns(Document) }
      def create!(attributes = nil, type = nil, &block); end

                  # Find the first document given the conditions, or creates a new document
      # with the conditions that were supplied.
      # 
      #  @param [ Hash ] attrs The attributes to search or create with.
      #  @param [ Class ] type The optional type of document to create.
      # 
      # _@return_ — An existing document or newly created one.
      # 
      # Find or create.
      # ```ruby
      # person.posts.find_or_create_by(:title => "Testing")
      # ```
      sig { params(attrs: T.untyped, type: T.untyped, block: T.untyped).returns(Document) }
      def find_or_create_by(attrs = {}, type = nil, &block); end

      # Find the first document given the conditions, or creates a new document
      # with the conditions that were supplied. This will raise an error if validation fails.
      # 
      # _@param_ `attrs` — The attributes to search or create with.
      # 
      # _@param_ `type` — The optional type of document to create.
      # 
      # _@return_ — An existing document or newly created one.
      # 
      # Find or create.
      # ```ruby
      # person.posts.find_or_create_by!(:title => "Testing")
      # ```
      sig { params(attrs: T::Hash[T.untyped, T.untyped], type: T.nilable(Class), block: T.untyped).returns(Document) }
      def find_or_create_by!(attrs = {}, type = nil, &block); end

      # Find the first +Document+ given the conditions, or instantiates a new document
      # with the conditions that were supplied
      # 
      # _@param_ `attrs` — The attributes to search or initialize with.
      # 
      # _@param_ `type` — The optional subclass to build.
      # 
      # _@return_ — An existing document or newly instantiated one.
      # 
      # Find or initialize.
      # ```ruby
      # person.posts.find_or_initialize_by(:title => "Test")
      # ```
      sig { params(attrs: T::Hash[T.untyped, T.untyped], type: T.nilable(Class), block: T.untyped).returns(Document) }
      def find_or_initialize_by(attrs = {}, type = nil, &block); end

      # This proxy can never be nil.
      # 
      # _@return_ — Always false.
      # 
      # Is the proxy nil?
      # ```ruby
      # relation.nil?
      # ```
      sig { returns(T::Boolean) }
      def nil?; end

      # Since method_missing is overridden we should override this as well.
      # 
      # _@param_ `name` — The method name.
      # 
      # _@param_ `include_private` — Whether to include private methods.
      # 
      # _@return_ — If the proxy responds to the method.
      # 
      # Does the proxy respond to the method?
      # ```ruby
      # relation.respond_to?(:name)
      # ```
      sig { params(name: Symbol, include_private: T::Boolean).returns(T::Boolean) }
      def respond_to?(name, include_private = false); end

      # This is public access to the association's criteria.
      # 
      # _@return_ — The scoped criteria.
      # 
      # Get the scoped association.
      # ```ruby
      # relation.scoped
      # ```
      sig { returns(Criteria) }
      def scoped; end

      # Gets the document as a serializable hash, used by ActiveModel's JSON and
      # XML serializers. This override is just to be able to pass the :include
      # and :except options to get associations in the hash.
      # 
      # _@param_ `options` — The options to pass.
      # 
      # _@return_ — The documents, ready to be serialized.
      # 
      # Get the serializable hash.
      # ```ruby
      # relation.serializable_hash
      # ```
      sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Hash[T.untyped, T.untyped]) }
      def serializable_hash(options = {}); end

      # Get a criteria for the embedded documents without the default scoping
      # applied.
      # 
      # _@return_ — The unscoped criteria.
      # 
      # Get the unscoped criteria.
      # ```ruby
      # person.addresses.unscoped
      # ```
      sig { returns(Criteria) }
      def unscoped; end

            sig { returns(T.untyped) }
      def _session; end

                        # Find the first object given the supplied attributes or create/initialize it.
      # 
      # _@return_ — A matching document or a new/created one.
      # 
      # Find or create|initialize.
      # ```ruby
      # person.addresses.find_or(:create, :street => "Bond")
      # 
      # @param [ Symbol ] method The method name, create or new.
      # @param [ Hash ] attrs The attributes to search or build with.
      # @param [ Class ] type The optional subclass to build.
      # ```
      sig do
        params(
          method: T.untyped,
          attrs: T.untyped,
          type: T.untyped,
          block: T.untyped
        ).returns(Document)
      end
      def find_or(method, attrs = {}, type = nil, &block); end
    end

    # This class is the superclass for all association proxy objects, and contains
    # common behavior for all of them.
    class Proxy
      include Mongoid::Threaded::Lifecycle
      include Mongoid::Association::Marshalable
      extend Forwardable

            # Convenience for setting the target and the association metadata properties since
      # all proxies will need to do this.
      # 
      # _@param_ `base` — The base document on the proxy.
      # 
      # _@param_ `target` — The target of the proxy.
      # 
      # _@param_ `association` — The association metadata.
      # 
      # Initialize the proxy.
      # ```ruby
      # proxy.init(person, name, association)
      # ```
      sig { params(base: Document, target: T.any(Document, T::Array[Document]), association: Association).returns(T.untyped) }
      def init(base, target, association); end

                  # Allow extension to be an array and extend each module
      sig { params(extension: T.untyped).returns(T.untyped) }
      def extend_proxies(*extension); end

      # Get the class from the association, or return nil if no association present.
      # 
      # _@return_ — The association class.
      # 
      # Get the class.
      # ```ruby
      # proxy.klass
      # ```
      sig { returns(Class) }
      def klass; end

            # Resets the criteria inside the association proxy. Used by many to many
      # associations to keep the underlying ids array in sync.
      # 
      # Reset the association criteria.
      # ```ruby
      # person.preferences.reset_relation_criteria
      # ```
      sig { returns(T.untyped) }
      def reset_unloaded; end

      # The default substitutable object for an association proxy is the clone of
      # the target.
      # 
      # _@return_ — A clone of the target.
      # 
      # Get the substitutable.
      # ```ruby
      # proxy.substitutable
      # ```
      sig { returns(Object) }
      def substitutable; end

      # sord warn - Collection wasn't able to be resolved to a constant in this project
      # Get the collection from the root of the hierarchy.
      # 
      # _@return_ — The root's collection.
      # 
      # Get the collection.
      # ```ruby
      # relation.collection
      # ```
      sig { returns(Mongo::Collection) }
      def collection; end

            # Takes the supplied document and sets the association on it.
      # 
      # _@param_ `document` — The document to set on.
      # 
      # Set the association metadata.
      # ```ruby
      # proxt.characterize_one(name)
      # ```
      sig { params(document: Document).returns(T.untyped) }
      def characterize_one(document); end

            # Default behavior of method missing should be to delegate all calls
      # to the target of the proxy. This can be overridden in special cases.
      # 
      # _@param_ `name` — The name of the method.
      # 
      # _@param_ `args` — The arguments passed to the method.
      sig { params(name: T.any(String, Symbol), args: T::Array[T.untyped], block: T.untyped).returns(T.untyped) }
      def method_missing(name, *args, &block); end

                  sig { params(name: T.untyped, args: T.untyped).returns(T::Boolean) }
      def respond_to_missing?(name, *args); end

            # When the base document illegally references an embedded document this
      # error will get raised.
      # 
      # Raise the error.
      # ```ruby
      # relation.raise_mixed
      # ```
      sig { returns(T.untyped) }
      def raise_mixed; end

            # When the base is not yet saved and the user calls create or create!
      # on the association, this error will get raised.
      # 
      # _@param_ `doc` — The child document getting created.
      # 
      # Raise the error.
      # ```ruby
      # relation.raise_unsaved(post)
      # ```
      sig { params(doc: Document).returns(T.untyped) }
      def raise_unsaved(doc); end

                  # Executes a callback method
      # 
      # _@param_ `callback` — to be executed
      # 
      # execute the before add callback
      # ```ruby
      # execute_callback(:before_add)
      # ```
      sig { params(callback: Symbol, doc: T.untyped).returns(T.untyped) }
      def execute_callback(callback, doc); end

      # Apply ordering to the criteria if it was defined on the association.
      # 
      # _@param_ `criteria` — The criteria to modify.
      # 
      # _@param_ `association` — The association metadata.
      # 
      # _@return_ — The ordered criteria.
      # 
      # Apply the ordering.
      # ```ruby
      # Proxy.apply_ordering(criteria, association)
      # ```
      sig { params(criteria: Criteria, association: Association).returns(Criteria) }
      def self.apply_ordering(criteria, association); end

      # Provides the data needed to Marshal.dump an association proxy.
      # 
      # _@return_ — The dumped data.
      # 
      # Dump the proxy.
      # ```ruby
      # Marshal.dump(proxy)
      # ```
      sig { returns(T::Array[Object]) }
      def marshal_dump; end

      # Takes the provided data and sets it back on the proxy.
      # 
      # _@param_ `data` — The data to set on the proxy.
      # 
      # _@return_ — The loaded data.
      # 
      # Load the proxy.
      # ```ruby
      # Marshal.load(proxy)
      # ```
      sig { params(data: T::Array[Object]).returns(T::Array[Object]) }
      def marshal_load(data); end

      # Begin the assignment of attributes. While in this block embedded
      # documents will not autosave themselves in order to allow the document to
      # be in a valid state.
      # 
      # _@return_ — The yielded value.
      # 
      # Execute the assignment.
      # ```ruby
      # _assigning do
      #   person.attributes = { :addresses => [ address ] }
      # end
      # ```
      sig { returns(Object) }
      def _assigning; end

      # Is the current thread in assigning mode?
      # 
      # _@return_ — If the thread is assigning.
      # 
      # Is the current thread in assigning mode?
      # ```ruby
      # proxy._assigning?
      # ```
      sig { returns(T::Boolean) }
      def _assigning?; end

      # Execute a block in binding mode.
      # 
      # _@return_ — The return value of the block.
      # 
      # Execute in binding mode.
      # ```ruby
      # binding do
      #   relation.push(doc)
      # end
      # ```
      sig { returns(Object) }
      def _binding; end

      # Is the current thread in binding mode?
      # 
      # _@return_ — If the thread is binding.
      # 
      # Is the current thread in binding mode?
      # ```ruby
      # proxy.binding?
      # ```
      sig { returns(T::Boolean) }
      def _binding?; end

      # Execute a block in building mode.
      # 
      # _@return_ — The return value of the block.
      # 
      # Execute in building mode.
      # ```ruby
      # _building do
      #   relation.push(doc)
      # end
      # ```
      sig { returns(Object) }
      def _building; end

      # Is the current thread in building mode?
      # 
      # _@return_ — If the thread is building.
      # 
      # Is the current thread in building mode?
      # ```ruby
      # proxy._building?
      # ```
      sig { returns(T::Boolean) }
      def _building?; end

      # Is the current thread in creating mode?
      # 
      # _@return_ — If the thread is creating.
      # 
      # Is the current thread in creating mode?
      # ```ruby
      # proxy.creating?
      # ```
      sig { returns(T::Boolean) }
      def _creating?; end

      # Execute a block in loading mode.
      # 
      # _@return_ — The return value of the block.
      # 
      # Execute in loading mode.
      # ```ruby
      # _loading do
      #   relation.push(doc)
      # end
      # ```
      sig { returns(Object) }
      def _loading; end

      # Is the current thread in loading mode?
      # 
      # _@return_ — If the thread is loading.
      # 
      # Is the current thread in loading mode?
      # ```ruby
      # proxy._loading?
      # ```
      sig { returns(T::Boolean) }
      def _loading?; end

            # Model instance for the base of the association.
      # 
      # For example, if a Post embeds_many Comments, _base is a particular
      # instance of the Post model.
      sig { returns(T.untyped) }
      attr_accessor :_base

      # Returns the value of attribute _association.
      sig { returns(T.untyped) }
      attr_accessor :_association

            # Model instance for one to one associations, or array of model instances
      # for one to many associations, for the target of the association.
      # 
      # For example, if a Post embeds_many Comments, _target is an array of
      # Comment models embedded in a particular Post.
      sig { returns(T.untyped) }
      attr_accessor :_target
    end

    # This module contains the core macros for defining associations between
    # documents. They can be either embedded or referenced.
    module Macros
      extend ActiveSupport::Concern

      # This is convenience for libraries still on the old API.
      # 
      # _@return_ — The associations.
      # 
      # Get the associations.
      # ```ruby
      # person.associations
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def associations; end

      module ClassMethods
                # Adds the association back to the parent document. This macro is
        # necessary to set the references from the child back to the parent
        # document. If a child does not define this association calling
        # persistence methods on the child object will cause a save to fail.
        # 
        # _@param_ `name` — The name of the association.
        # 
        # _@param_ `options` — The association options.
        # 
        # _@param_ `block` — Optional block for defining extensions.
        # 
        # Define the association.
        # ```ruby
        # 
        # class Person
        #   include Mongoid::Document
        #   embeds_many :addresses
        # end
        # 
        # class Address
        #   include Mongoid::Document
        #   embedded_in :person
        # end
        # ```
        sig { params(name: Symbol, options: T::Hash[T.untyped, T.untyped], block: T.untyped).returns(T.untyped) }
        def embedded_in(name, options = {}, &block); end

                # Adds the association from a parent document to its children. The name
        # of the association needs to be a pluralized form of the child class
        # name.
        # 
        # _@param_ `name` — The name of the association.
        # 
        # _@param_ `options` — The association options.
        # 
        # _@param_ `block` — Optional block for defining extensions.
        # 
        # Define the association.
        # ```ruby
        # 
        # class Person
        #   include Mongoid::Document
        #   embeds_many :addresses
        # end
        # 
        # class Address
        #   include Mongoid::Document
        #   embedded_in :person
        # end
        # ```
        sig { params(name: Symbol, options: T::Hash[T.untyped, T.untyped], block: T.untyped).returns(T.untyped) }
        def embeds_many(name, options = {}, &block); end

                # Adds the association from a parent document to its child. The name
        # of the association needs to be a singular form of the child class
        # name.
        # 
        # _@param_ `name` — The name of the association.
        # 
        # _@param_ `options` — The association options.
        # 
        # _@param_ `block` — Optional block for defining extensions.
        # 
        # Define the association.
        # ```ruby
        # 
        # class Person
        #   include Mongoid::Document
        #   embeds_one :name
        # end
        # 
        # class Name
        #   include Mongoid::Document
        #   embedded_in :person
        # end
        # ```
        sig { params(name: Symbol, options: T::Hash[T.untyped, T.untyped], block: T.untyped).returns(T.untyped) }
        def embeds_one(name, options = {}, &block); end

                # Adds a referenced association from the child Document to a Document
        # in another database or collection.
        # 
        # _@param_ `name` — The name of the association.
        # 
        # _@param_ `options` — The association options.
        # 
        # _@param_ `block` — Optional block for defining extensions.
        # 
        # Define the association.
        # ```ruby
        # 
        # class Game
        #   include Mongoid::Document
        #   belongs_to :person
        # end
        # 
        # class Person
        #   include Mongoid::Document
        #   has_one :game
        # end
        # ```
        sig { params(name: Symbol, options: T::Hash[T.untyped, T.untyped], block: T.untyped).returns(T.untyped) }
        def belongs_to(name, options = {}, &block); end

                # Adds a referenced association from a parent Document to many
        # Documents in another database or collection.
        # 
        # _@param_ `name` — The name of the association.
        # 
        # _@param_ `options` — The association options.
        # 
        # _@param_ `block` — Optional block for defining extensions.
        # 
        # Define the association.
        # ```ruby
        # 
        # class Person
        #   include Mongoid::Document
        #   has_many :posts
        # end
        # 
        # class Game
        #   include Mongoid::Document
        #   belongs_to :person
        # end
        # ```
        sig { params(name: Symbol, options: T::Hash[T.untyped, T.untyped], block: T.untyped).returns(T.untyped) }
        def has_many(name, options = {}, &block); end

                # Adds a referenced many-to-many association between many of this
        # Document and many of another Document.
        # 
        # _@param_ `name` — The name of the association.
        # 
        # _@param_ `options` — The association options.
        # 
        # _@param_ `block` — Optional block for defining extensions.
        # 
        # Define the association.
        # ```ruby
        # 
        # class Person
        #   include Mongoid::Document
        #   has_and_belongs_to_many :preferences
        # end
        # 
        # class Preference
        #   include Mongoid::Document
        #   has_and_belongs_to_many :people
        # end
        # ```
        sig { params(name: Symbol, options: T::Hash[T.untyped, T.untyped], block: T.untyped).returns(T.untyped) }
        def has_and_belongs_to_many(name, options = {}, &block); end

                # Adds a referenced association from the child Document to a Document
        # in another database or collection.
        # 
        # _@param_ `name` — The name of the association.
        # 
        # _@param_ `options` — The association options.
        # 
        # _@param_ `block` — Optional block for defining extensions.
        # 
        # Define the association.
        # ```ruby
        # 
        # class Game
        #   include Mongoid::Document
        #   belongs_to :person
        # end
        # 
        # class Person
        #   include Mongoid::Document
        #   has_one :game
        # end
        # ```
        sig { params(name: Symbol, options: T::Hash[T.untyped, T.untyped], block: T.untyped).returns(T.untyped) }
        def has_one(name, options = {}, &block); end

                                        sig do
          params(
            macro_name: T.untyped,
            name: T.untyped,
            options: T.untyped,
            block: T.untyped
          ).returns(T.untyped)
        end
        def define_association!(macro_name, name, options = {}, &block); end
      end
    end

    module Nested
      DESTROY_FLAGS = T.let([1, "1", true, "true"].freeze, T.untyped)

      class One
        include Mongoid::Association::Nested::Buildable

        # Builds the association depending on the attributes and the options
        # passed to the macro.
        # 
        # _@param_ `parent` — The parent document.
        # 
        # _@return_ — The built document.
        # 
        # Build a 1-1 nested document.
        # ```ruby
        # one.build(person, as: :admin)
        # ```
        # 
        # _@note_ — This attempts to perform 3 operations, either one of an update of
        # the existing association, a replacement of the association with a new
        # document, or a removal of the association.
        sig { params(parent: Document).returns(Document) }
        def build(parent); end

        # Create the new builder for nested attributes on one-to-one
        # associations.
        # 
        # _@param_ `association` — The association metadata.
        # 
        # _@param_ `attributes` — The attributes hash to attempt to set.
        # 
        # _@param_ `options` — The options defined.
        # 
        # Instantiate the builder.
        # ```ruby
        # One.new(association, attributes)
        # ```
        sig { params(association: Association, attributes: T::Hash[T.untyped, T.untyped], options: T::Hash[T.untyped, T.untyped]).void }
        def initialize(association, attributes, options); end

        # Is the id in the attribtues acceptable for allowing an update to
        # the existing association?
        # 
        # _@return_ — If the id part of the logic will allow an update.
        # 
        # Is the id acceptable?
        # ```ruby
        # one.acceptable_id?
        # ```
        sig { returns(T::Boolean) }
        def acceptable_id?; end

        # Can the existing association be deleted?
        # 
        # _@return_ — If the association should be deleted.
        # 
        # Can the existing object be deleted?
        # ```ruby
        # one.delete?
        # ```
        sig { returns(T::Boolean) }
        def delete?; end

        # Can the existing association potentially be destroyed?
        # 
        # _@return_ — If the association can potentially be
        # destroyed.
        # 
        # Is the object destroyable?
        # ```ruby
        # one.destroyable?({ :_destroy => "1" })
        # ```
        sig { returns(T::Boolean) }
        def destroyable?; end

        # Is the document to be replaced?
        # 
        # _@return_ — If the document should be replaced.
        # 
        # Is the document to be replaced?
        # ```ruby
        # one.replace?
        # ```
        sig { returns(T::Boolean) }
        def replace?; end

        # Should the document be updated?
        # 
        # _@return_ — If the object should have its attributes updated.
        # 
        # Should the document be updated?
        # ```ruby
        # one.update?
        # ```
        sig { returns(T::Boolean) }
        def update?; end

        # Determines if destroys are allowed for this document.
        # 
        # _@return_ — True if the allow destroy option was set.
        # 
        # Do we allow a destroy?
        # ```ruby
        # builder.allow_destroy?
        # ```
        sig { returns(T::Boolean) }
        def allow_destroy?; end

        # Returns the reject if option defined with the macro.
        # 
        # _@param_ `document` — The parent document of the association
        # 
        # _@param_ `attrs` — The attributes to check for rejection.
        # 
        # _@return_ — True and call proc or method if rejectable, false if not.
        # 
        # Is there a reject proc?
        # ```ruby
        # builder.reject?
        # ```
        sig { params(document: Document, attrs: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
        def reject?(document, attrs); end

        # Determines if only updates can occur. Only valid for one-to-one
        # associations.
        # 
        # _@return_ — True if the update_only option was set.
        # 
        # Is this update only?
        # ```ruby
        # builder.update_only?
        # ```
        sig { returns(T::Boolean) }
        def update_only?; end

        # Convert an id to its appropriate type.
        # 
        # _@param_ `klass` — The class we're trying to convert for.
        # 
        # _@param_ `id` — The id, usually coming from the form.
        # 
        # _@return_ — The converted id.
        # 
        # Convert the id.
        # ```ruby
        # builder.convert_id(Person, "4d371b444835d98b8b000010")
        # ```
        sig { params(klass: Class, id: String).returns(T.any(BSON::ObjectId, String, Object)) }
        def convert_id(klass, id); end

        # Returns the value of attribute destroy.
        sig { returns(T.untyped) }
        attr_accessor :destroy
      end

      class Many
        include Mongoid::Association::Nested::Buildable

        # Builds the association depending on the attributes and the options
        # passed to the macro.
        # 
        # This attempts to perform 3 operations, either one of an update of
        # the existing association, a replacement of the association with a new
        # document, or a removal of the association.
        # 
        # _@param_ `parent` — The parent document of the association.
        # 
        # _@param_ `options` — The options.
        # 
        # _@return_ — The attributes.
        # 
        # Build the nested attrs.
        # ```ruby
        # many.build(person)
        # ```
        sig { params(parent: Document, options: T::Hash[T.untyped, T.untyped]).returns(T::Array[T.untyped]) }
        def build(parent, options = {}); end

        # Create the new builder for nested attributes on one-to-many
        # associations.
        # 
        # _@param_ `association` — The association metadata.
        # 
        # _@param_ `attributes` — The attributes hash to attempt to set.
        # 
        # _@param_ `options` — The options defined.
        # 
        # Initialize the builder.
        # ```ruby
        # Many.new(association, attributes, options)
        # ```
        sig { params(association: Association, attributes: T::Hash[T.untyped, T.untyped], options: T::Hash[T.untyped, T.untyped]).void }
        def initialize(association, attributes, options = {}); end

        # Can the existing association potentially be deleted?
        # 
        # _@param_ `attributes` — The attributes to pull the flag from.
        # 
        # _@return_ — If the association can potentially be deleted.
        # 
        # Is the document destroyable?
        # ```ruby
        # destroyable?({ :_destroy => "1" })
        # ```
        sig { params(attributes: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
        def destroyable?(attributes); end

        # Are the supplied attributes of greater number than the supplied
        # limit?
        # 
        # _@param_ `attributes` — The attributes being set.
        # 
        # _@return_ — If the attributes exceed the limit.
        # 
        # Are we over the set limit?
        # ```ruby
        # builder.over_limit?({ "street" => "Bond" })
        # ```
        sig { params(attributes: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
        def over_limit?(attributes); end

                # Process each set of attributes one at a time for each potential
        # new, existing, or ignored document.
        # 
        # _@param_ `parent` — The parent document.
        # 
        # _@param_ `attrs` — The single document attributes to process.
        # 
        # Process the attributes
        # ```ruby
        # builder.process_attributes({ "id" => 1, "street" => "Bond" })
        # ```
        sig { params(parent: Document, attrs: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
        def process_attributes(parent, attrs); end

                # Destroy the child document, needs to do some checking for embedded
        # associations and delay the destroy in case parent validation fails.
        # 
        # _@param_ `parent` — The parent document.
        # 
        # _@param_ `relation` — The association proxy.
        # 
        # _@param_ `doc` — The doc to destroy.
        # 
        # Destroy the child.
        # ```ruby
        # builder.destroy(parent, relation, doc)
        # ```
        sig { params(parent: Document, relation: Proxy, doc: Document).returns(T.untyped) }
        def destroy(parent, relation, doc); end

                # Destroy the document.
        # 
        # _@param_ `relation` — The association proxy.
        # 
        # _@param_ `doc` — The document to delete.
        # 
        # Destroy the document.
        # ```ruby
        # builder.destroy_document(relation, doc)
        # ```
        sig { params(relation: Proxy, doc: Document).returns(T.untyped) }
        def destroy_document(relation, doc); end

                # Update the document.
        # 
        # _@param_ `doc` — The document to update.
        # 
        # _@param_ `attrs` — The attributes.
        # 
        # Update the document.
        # ```ruby
        # builder.update_document(doc, {}, options)
        # ```
        sig { params(doc: Document, attrs: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
        def update_document(doc, attrs); end

                # Update nested association.
        # 
        # _@param_ `parent` — The parent document.
        # 
        # _@param_ `id` — of the related document.
        # 
        # _@param_ `attrs` — The single document attributes to process.
        # 
        # Update nested association.
        # ```ruby
        # builder.update_nested_relation(parent, id, attrs)
        # ```
        sig { params(parent: Document, id: T.any(String, BSON::ObjectId), attrs: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
        def update_nested_relation(parent, id, attrs); end

        # Determines if destroys are allowed for this document.
        # 
        # _@return_ — True if the allow destroy option was set.
        # 
        # Do we allow a destroy?
        # ```ruby
        # builder.allow_destroy?
        # ```
        sig { returns(T::Boolean) }
        def allow_destroy?; end

        # Returns the reject if option defined with the macro.
        # 
        # _@param_ `document` — The parent document of the association
        # 
        # _@param_ `attrs` — The attributes to check for rejection.
        # 
        # _@return_ — True and call proc or method if rejectable, false if not.
        # 
        # Is there a reject proc?
        # ```ruby
        # builder.reject?
        # ```
        sig { params(document: Document, attrs: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
        def reject?(document, attrs); end

        # Determines if only updates can occur. Only valid for one-to-one
        # associations.
        # 
        # _@return_ — True if the update_only option was set.
        # 
        # Is this update only?
        # ```ruby
        # builder.update_only?
        # ```
        sig { returns(T::Boolean) }
        def update_only?; end

        # Convert an id to its appropriate type.
        # 
        # _@param_ `klass` — The class we're trying to convert for.
        # 
        # _@param_ `id` — The id, usually coming from the form.
        # 
        # _@return_ — The converted id.
        # 
        # Convert the id.
        # ```ruby
        # builder.convert_id(Person, "4d371b444835d98b8b000010")
        # ```
        sig { params(klass: Class, id: String).returns(T.any(BSON::ObjectId, String, Object)) }
        def convert_id(klass, id); end
      end

      module Buildable
        # Determines if destroys are allowed for this document.
        # 
        # _@return_ — True if the allow destroy option was set.
        # 
        # Do we allow a destroy?
        # ```ruby
        # builder.allow_destroy?
        # ```
        sig { returns(T::Boolean) }
        def allow_destroy?; end

        # Returns the reject if option defined with the macro.
        # 
        # _@param_ `document` — The parent document of the association
        # 
        # _@param_ `attrs` — The attributes to check for rejection.
        # 
        # _@return_ — True and call proc or method if rejectable, false if not.
        # 
        # Is there a reject proc?
        # ```ruby
        # builder.reject?
        # ```
        sig { params(document: Document, attrs: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
        def reject?(document, attrs); end

        # Determines if only updates can occur. Only valid for one-to-one
        # associations.
        # 
        # _@return_ — True if the update_only option was set.
        # 
        # Is this update only?
        # ```ruby
        # builder.update_only?
        # ```
        sig { returns(T::Boolean) }
        def update_only?; end

        # Convert an id to its appropriate type.
        # 
        # _@param_ `klass` — The class we're trying to convert for.
        # 
        # _@param_ `id` — The id, usually coming from the form.
        # 
        # _@return_ — The converted id.
        # 
        # Convert the id.
        # ```ruby
        # builder.convert_id(Person, "4d371b444835d98b8b000010")
        # ```
        sig { params(klass: Class, id: String).returns(T.any(BSON::ObjectId, String, Object)) }
        def convert_id(klass, id); end

        # Returns the value of attribute attributes.
        sig { returns(T.untyped) }
        attr_accessor :attributes

        # Returns the value of attribute existing.
        sig { returns(T.untyped) }
        attr_accessor :existing

        # Returns the value of attribute association.
        sig { returns(T.untyped) }
        attr_accessor :association

        # Returns the value of attribute options.
        sig { returns(T.untyped) }
        attr_accessor :options
      end
    end

    module Options
      # Returns the name of the parent to a polymorphic child.
      # 
      # _@return_ — The name.
      sig { returns(T.any(String, Symbol)) }
      def as; end

      # Specify what happens to the associated object when the owner is destroyed.
      # 
      # _@return_ — The dependent option.
      sig { returns(String) }
      def dependent; end

      # The custom sorting options on the association.
      # 
      # _@return_ — The custom sorting options.
      sig { returns(Criteria::Queryable::Key) }
      def order; end

      # Whether to index the primary or foreign key field.
      sig { returns(T::Boolean) }
      def indexed?; end

      # Whether the association is autobuilding.
      sig { returns(T::Boolean) }
      def autobuilding?; end

      # Is the association cyclic.
      # 
      # _@return_ — Whether the association is cyclic.
      sig { returns(T::Boolean) }
      def cyclic?; end

      # The name the owning object uses to refer to this association.
      # 
      # _@return_ — The inverse_of option.
      sig { returns(String) }
      def inverse_of; end

      # Mongoid assumes that the field used to hold the primary key of the association is id.
      # You can override this and explicitly specify the primary key with the :primary_key option.
      # 
      # _@return_ — The primary key.
      sig { returns(T.any(Symbol, String)) }
      def primary_key; end

      # Options to save any loaded members and destroy members that are marked for destruction
      # when the parent object is saved.
      # 
      # _@return_ — The autosave option.
      sig { returns(T::Boolean) }
      def autosave; end

      # Whether the association is counter-cached.
      sig { returns(T::Boolean) }
      def counter_cached?; end

      # Whether this association is polymorphic.
      # 
      # _@return_ — Whether the association is polymorphic.
      sig { returns(T::Boolean) }
      def polymorphic?; end

      # Whether the association has callbacks cascaded down from the parent.
      # 
      # _@return_ — Whether callbacks are cascaded.
      sig { returns(T::Boolean) }
      def cascading_callbacks?; end

      # The store_as option.
      # 
      # _@return_ — Default is nil.
      sig { returns(T.nilable(T.any())) }
      def store_as; end

      # Whether the association has forced nil inverse (So no foreign keys are saved).
      # 
      # _@return_ — Default is false.
      sig { returns(T::Boolean) }
      def forced_nil_inverse?; end

      # The field for saving the associated object's type.
      # 
      # _@return_ — Default is nil.
      sig { returns(T.nilable(T.any())) }
      def type; end

      # The field for saving the associated object's type.
      # 
      # _@return_ — Default is nil.
      sig { returns(T.nilable(T.any())) }
      def touch_field; end

      sig { returns(T::Boolean) }
      def touchable?; end
    end

    # Superclass for all objects that bind associations together.
    module Bindable
      include Mongoid::Threaded::Lifecycle

      # Create the new binding.
      # 
      # _@param_ `base` — The base of the binding.
      # 
      # _@param_ `target` — The target of the binding.
      # 
      # _@param_ `association` — The association metadata.
      # 
      # Initialize a binding.
      # ```ruby
      # Binding.new(base, target, association)
      # ```
      sig { params(base: Document, target: T.any(Document, T::Array[Document]), association: Association).void }
      def initialize(base, target, association); end

      # Execute the provided block inside a binding.
      # 
      # _@return_ — The result of the yield.
      # 
      # Execute the binding block.
      # ```ruby
      # binding.binding do
      #   base.foreign_key = 1
      # end
      # ```
      sig { returns(Object) }
      def binding; end

            # Check if the inverse is properly defined.
      # 
      # _@param_ `doc` — The document getting bound.
      # 
      # Check the inverse definition.
      # ```ruby
      # binding.check_inverse!(doc)
      # ```
      sig { params(doc: Document).returns(T.untyped) }
      def check_inverse!(doc); end

            # Set the id of the related document in the foreign key field on the
      # keyed document.
      # 
      # _@param_ `keyed` — The document that stores the foreign key.
      # 
      # _@param_ `id` — The id of the bound document.
      # 
      # Bind the foreign key.
      # ```ruby
      # binding.bind_foreign_key(post, person._id)
      # ```
      sig { params(keyed: Document, id: Object).returns(T.untyped) }
      def bind_foreign_key(keyed, id); end

            # Set the type of the related document on the foreign type field, used
      # when associations are polymorphic.
      # 
      # _@param_ `typed` — The document that stores the type field.
      # 
      # _@param_ `name` — The name of the model.
      # 
      # Bind the polymorphic type.
      # ```ruby
      # binding.bind_polymorphic_type(post, "Person")
      # ```
      sig { params(typed: Document, name: String).returns(T.untyped) }
      def bind_polymorphic_type(typed, name); end

            # Set the type of the related document on the foreign type field, used
      # when associations are polymorphic.
      # 
      # _@param_ `typed` — The document that stores the type field.
      # 
      # _@param_ `name` — The name of the model.
      # 
      # Bind the polymorphic type.
      # ```ruby
      # binding.bind_polymorphic_inverse_type(post, "Person")
      # ```
      sig { params(typed: Document, name: String).returns(T.untyped) }
      def bind_polymorphic_inverse_type(typed, name); end

            # Bind the inverse document to the child document so that the in memory
      # instances are the same.
      # 
      # _@param_ `doc` — The base document.
      # 
      # _@param_ `inverse` — The inverse document.
      # 
      # Bind the inverse.
      # ```ruby
      # binding.bind_inverse(post, person)
      # ```
      sig { params(doc: Document, inverse: Document).returns(T.untyped) }
      def bind_inverse(doc, inverse); end

            # Bind the provided document with the base from the parent association.
      # 
      # _@param_ `doc` — The document to bind.
      # 
      # Bind the document with the base.
      # ```ruby
      # binding.bind_from_relational_parent(doc)
      # ```
      sig { params(doc: Document).returns(T.untyped) }
      def bind_from_relational_parent(doc); end

                  sig { params(_base: T.untyped).returns(T.untyped) }
      def record_id(_base); end

      # Ensure that the association on the base is correct, for the cases
      # where we have multiple belongs to definitions and were are setting
      # different parents in memory in order.
      # 
      # _@return_ — If the association changed.
      # 
      # Set the base association.
      # ```ruby
      # binding.set_base_association
      # ```
      sig { returns(T::Boolean) }
      def set_base_association; end

            # Bind the provided document with the base from the parent association.
      # 
      # _@param_ `doc` — The document to unbind.
      # 
      # Bind the document with the base.
      # ```ruby
      # unbinding.unbind_from_relational_parent(doc)
      # ```
      sig { params(doc: Document).returns(T.untyped) }
      def unbind_from_relational_parent(doc); end

      # Begin the assignment of attributes. While in this block embedded
      # documents will not autosave themselves in order to allow the document to
      # be in a valid state.
      # 
      # _@return_ — The yielded value.
      # 
      # Execute the assignment.
      # ```ruby
      # _assigning do
      #   person.attributes = { :addresses => [ address ] }
      # end
      # ```
      sig { returns(Object) }
      def _assigning; end

      # Is the current thread in assigning mode?
      # 
      # _@return_ — If the thread is assigning.
      # 
      # Is the current thread in assigning mode?
      # ```ruby
      # proxy._assigning?
      # ```
      sig { returns(T::Boolean) }
      def _assigning?; end

      # Execute a block in binding mode.
      # 
      # _@return_ — The return value of the block.
      # 
      # Execute in binding mode.
      # ```ruby
      # binding do
      #   relation.push(doc)
      # end
      # ```
      sig { returns(Object) }
      def _binding; end

      # Is the current thread in binding mode?
      # 
      # _@return_ — If the thread is binding.
      # 
      # Is the current thread in binding mode?
      # ```ruby
      # proxy.binding?
      # ```
      sig { returns(T::Boolean) }
      def _binding?; end

      # Execute a block in building mode.
      # 
      # _@return_ — The return value of the block.
      # 
      # Execute in building mode.
      # ```ruby
      # _building do
      #   relation.push(doc)
      # end
      # ```
      sig { returns(Object) }
      def _building; end

      # Is the current thread in building mode?
      # 
      # _@return_ — If the thread is building.
      # 
      # Is the current thread in building mode?
      # ```ruby
      # proxy._building?
      # ```
      sig { returns(T::Boolean) }
      def _building?; end

      # Is the current thread in creating mode?
      # 
      # _@return_ — If the thread is creating.
      # 
      # Is the current thread in creating mode?
      # ```ruby
      # proxy.creating?
      # ```
      sig { returns(T::Boolean) }
      def _creating?; end

      # Execute a block in loading mode.
      # 
      # _@return_ — The return value of the block.
      # 
      # Execute in loading mode.
      # ```ruby
      # _loading do
      #   relation.push(doc)
      # end
      # ```
      sig { returns(Object) }
      def _loading; end

      # Is the current thread in loading mode?
      # 
      # _@return_ — If the thread is loading.
      # 
      # Is the current thread in loading mode?
      # ```ruby
      # proxy._loading?
      # ```
      sig { returns(T::Boolean) }
      def _loading?; end

            # Returns the value of attribute _base.
      sig { returns(T.untyped) }
      attr_reader :_base

            # Returns the value of attribute _target.
      sig { returns(T.untyped) }
      attr_reader :_target

            # Returns the value of attribute _association.
      sig { returns(T.untyped) }
      attr_reader :_association
    end

    # This module is responsible for defining the build and create methods used
    # in one to one associations.
    # 
    # @example Methods that get created.
    # 
    #   class Person
    #     include Mongoid::Document
    #     embeds_one :name
    #   end
    # 
    #   # The following methods get created:
    #   person.build_name({ :first_name => "Durran" })
    #   person.create_name({ :first_name => "Durran" })
    # 
    # @since 2.0.0.rc.1
    module Builders
      extend ActiveSupport::Concern

      # Parse out the attributes and the options from the args passed to a
      # build_ or create_ methods.
      # 
      # _@param_ `args` — The arguments.
      # 
      # _@return_ — The attributes and options.
      # 
      # Parse the args.
      # ```ruby
      # doc.parse_args(:name => "Joe")
      # ```
      sig { params(args: T::Array[T.untyped]).returns(T::Array[T::Hash[T.untyped, T.untyped]]) }
      def parse_args(*args); end

      # Defines a builder method. This is defined as #build_name.
      # 
      # _@param_ `association` — The association metadata for the association.
      # 
      # _@return_ — The class being set up.
      # 
      # ```ruby
      # Person.define_builder!(association)
      # ```
      sig { params(association: Association).returns(Class) }
      def self.define_builder!(association); end

      # Defines a creator method. This is defined as #create_name.
      # After the object is built it will immediately save.
      # 
      # _@param_ `association` — The association metadata for the association.
      # 
      # _@return_ — The class being set up.
      # 
      # ```ruby
      # Person.define_creator!(association)
      # ```
      sig { params(association: Association).returns(Class) }
      def self.define_creator!(association); end
    end

    # This module contains all the behavior related to accessing associations
    # through the getters and setters, and how to delegate to builders to
    # create new ones.
    module Accessors
      extend ActiveSupport::Concern

      # Builds the related document and creates the association unless the
      # document is nil, then sets the association on this document.
      # 
      # _@param_ `name` — The name of the association.
      # 
      # _@param_ `object` — The id or attributes to use.
      # 
      # _@param_ `association` — The association metadata.
      # 
      # _@param_ `selected_fields` — Fields which were retrieved via #only. If selected_fields is specified, fields not listed in it will not be accessible in the built document.
      # 
      # _@return_ — The association.
      # 
      # Build the association.
      # ```ruby
      # person.__build__(:addresses, { :_id => 1 }, association)
      # ```
      sig do
        params(
          name: T.any(String, Symbol),
          object: T.any(T::Hash[T.untyped, T.untyped], BSON::ObjectId),
          association: Association,
          selected_fields: T.nilable(T::Hash[T.untyped, T.untyped])
        ).returns(Proxy)
      end
      def __build__(name, object, association, selected_fields = nil); end

      # Create an association from an object and association metadata.
      # 
      # _@param_ `object` — The association target.
      # 
      # _@param_ `association` — The association metadata.
      # 
      # _@param_ `selected_fields` — Fields which were retrieved via #only. If selected_fields is specified, fields not listed in it will not be accessible in the created association document.
      # 
      # _@return_ — The association.
      # 
      # Create the association.
      # ```ruby
      # person.create_relation(document, association)
      # ```
      sig { params(object: T.any(Document, T::Array[Document]), association: Association, selected_fields: T.nilable(T::Hash[T.untyped, T.untyped])).returns(Proxy) }
      def create_relation(object, association, selected_fields = nil); end

            # Resets the criteria inside the association proxy. Used by many-to-many
      # associations to keep the underlying ids array in sync.
      # 
      # _@param_ `name` — The name of the association.
      # 
      # Reset the association criteria.
      # ```ruby
      # person.reset_relation_criteria(:preferences)
      # ```
      sig { params(name: Symbol).returns(T.untyped) }
      def reset_relation_criteria(name); end

      # Set the supplied association to an instance variable on the class with the
      # provided name. Used as a helper just for code cleanliness.
      # 
      # _@param_ `name` — The name of the association.
      # 
      # _@param_ `relation` — The association to set.
      # 
      # _@return_ — The association.
      # 
      # Set the proxy on the document.
      # ```ruby
      # person.set(:addresses, addresses)
      # ```
      sig { params(name: T.any(String, Symbol), relation: Proxy).returns(Proxy) }
      def set_relation(name, relation); end

      # Get the association. Extracted out from the getter method to avoid
      # infinite recursion when overriding the getter.
      # 
      # _@param_ `name` — The name of the association.
      # 
      # _@param_ `association` — The association metadata.
      # 
      # _@param_ `object` — The object used to build the association.
      # 
      # _@param_ `reload` — If the association is to be reloaded.
      # 
      # _@return_ — The association.
      # 
      # Get the association.
      # ```ruby
      # document.get_relation(:name, association)
      # ```
      sig do
        params(
          name: Symbol,
          association: Association,
          object: Object,
          reload: T::Boolean
        ).returns(Proxy)
      end
      def get_relation(name, association, object, reload = false); end

      # Returns a subset of __selected_fields attribute applicable to the
      # (embedded) association with the given key, or nil if no projection
      # is to be performed.
      # 
      # For example, if __selected_fields is {'a' => 1, 'b.c' => 2, 'b.c.f' => 3},
      # and assoc_key is 'b', return value would be {'c' => 2, 'c.f' => 3}.
      # 
      # _@param_ `assoc_key`
      sig { params(assoc_key: String).returns(T.nilable(T::Hash[T.untyped, T.untyped])) }
      def _mongoid_filter_selected_fields(assoc_key); end

                  sig { params(object: T.untyped, association: T.untyped).returns(T::Boolean) }
      def needs_no_database_query?(object, association); end

      # Is the current code executing without autobuild functionality?
      # 
      # _@return_ — If autobuild is disabled.
      # 
      # Is autobuild disabled?
      # ```ruby
      # document.without_autobuild?
      # ```
      sig { returns(T::Boolean) }
      def without_autobuild?; end

      # Yield to the block with autobuild functionality turned off.
      # 
      # _@return_ — The result of the yield.
      # 
      # Execute without autobuild.
      # ```ruby
      # document.without_autobuild do
      #   document.name
      # end
      # ```
      sig { returns(Object) }
      def without_autobuild; end

      # Parse out the attributes and the options from the args passed to a
      # build_ or create_ methods.
      # 
      # _@param_ `args` — The arguments.
      # 
      # _@return_ — The attributes and options.
      # 
      # Parse the args.
      # ```ruby
      # doc.parse_args(:name => "Joe")
      # ```
      sig { params(args: T::Array[T.untyped]).returns(T::Array[T::Hash[T.untyped, T.untyped]]) }
      def parse_args(*args); end

      # Adds the existence check for associations.
      # 
      # _@param_ `association` — The association.
      # 
      # _@return_ — The model being set up.
      # 
      # Add the existence check.
      # ```ruby
      # Person.define_existence_check!(association)
      # ```
      # 
      # Check if an association exists.
      # ```ruby
      # person = Person.new
      # person.has_game?
      # person.game?
      # ```
      sig { params(association: Association).returns(Class) }
      def self.define_existence_check!(association); end

      # Defines the getter for the association. Nothing too special here: just
      # return the instance variable for the association if it exists or build
      # the thing.
      # 
      # _@param_ `association` — The association metadata for the association.
      # 
      # _@return_ — The class being set up.
      # 
      # Set up the getter for the association.
      # ```ruby
      # Person.define_getter!(association)
      # ```
      sig { params(association: Association).returns(Class) }
      def self.define_getter!(association); end

      # Defines the getter for the ids of documents in the association. Should
      # be specify only for referenced many associations.
      # 
      # _@param_ `association` — The association metadata for the association.
      # 
      # _@return_ — The class being set up.
      # 
      # Set up the ids getter for the association.
      # ```ruby
      # Person.define_ids_getter!(association)
      # ```
      sig { params(association: Association).returns(Class) }
      def self.define_ids_getter!(association); end

      # Defines the setter for the association. This does a few things based on
      # some conditions. If there is an existing association, a target
      # substitution will take place, otherwise a new association will be
      # created with the supplied target.
      # 
      # _@param_ `association` — The association metadata for the association.
      # 
      # _@return_ — The class being set up.
      # 
      # Set up the setter for the association.
      # ```ruby
      # Person.define_setter!(association)
      # ```
      sig { params(association: Association).returns(Class) }
      def self.define_setter!(association); end

                  # Defines the setter method that allows you to set documents
      # in this association by their ids. The defined setter, finds
      # documents with given ids and invokes regular association setter
      # with found documents. Ids setters should be defined only for
      # referenced many associations.
      # 
      #  @param [ Association ] association The association for the association.
      # 
      #  @return [ Class ] The class being set up.
      # 
      # Set up the id_setter for the association.
      # ```ruby
      # Person.define_ids_setter!(association)
      # ```
      sig { params(association: T.untyped).returns(T.untyped) }
      def self.define_ids_setter!(association); end

      # Defines a builder method for an embeds_one association. This is
      # defined as #build_name.
      # 
      # _@param_ `association` — The association for the association.
      # 
      # _@return_ — The class being set up.
      # 
      # ```ruby
      # Person.define_builder!(association)
      # ```
      sig { params(association: Association).returns(Class) }
      def self.define_builder!(association); end

      # Defines a creator method for an embeds_one association. This is
      # defined as #create_name. After the object is built it will
      # immediately save.
      # 
      # _@param_ `association` — The association for the association.
      # 
      # _@return_ — The class being set up.
      # 
      # ```ruby
      # Person.define_creator!(association)
      # ```
      sig { params(association: Association).returns(Class) }
      def self.define_creator!(association); end
    end

    # This module defines the behavior for setting up cascading deletes and
    # nullifies for associations, and how to delegate to the appropriate strategy.
    module Depending
      extend ActiveSupport::Concern
      STRATEGIES = T.let([
    :delete_all,
    :destroy,
    :nullify,
    :restrict_with_exception,
    :restrict_with_error
], T.untyped)

      # Attempt to add the cascading information for the document to know how
      # to handle associated documents on a removal.
      # 
      # _@param_ `association` — The association metadata.
      # 
      # _@return_ — The class of the document.
      # 
      # Set up cascading information
      # ```ruby
      # Mongoid::Association::Depending.define_dependency!(association)
      # ```
      sig { params(association: Association).returns(Class) }
      def self.define_dependency!(association); end

                  sig { params(association: T.untyped).returns(T.untyped) }
      def self.validate!(association); end

            # Perform all cascading deletes, destroys, or nullifies. Will delegate to
      # the appropriate strategy to perform the operation.
      # 
      # Execute cascades.
      # ```ruby
      # document.apply_delete_dependencies!
      # ```
      sig { returns(T.untyped) }
      def apply_delete_dependencies!; end

                  sig { params(association: T.untyped).returns(T.untyped) }
      def _dependent_delete_all!(association); end

                  sig { params(association: T.untyped).returns(T.untyped) }
      def _dependent_destroy!(association); end

                  sig { params(association: T.untyped).returns(T.untyped) }
      def _dependent_nullify!(association); end

                  sig { params(association: T.untyped).returns(T.untyped) }
      def _dependent_restrict_with_exception!(association); end

                  sig { params(association: T.untyped).returns(T.untyped) }
      def _dependent_restrict_with_error!(association); end
    end

    # This module provides behaviors shared between Association types.
    # 
    # @since 7.0
    module Relatable
      include Mongoid::Association::Constrainable
      include Mongoid::Association::Options
      SHARED_OPTIONS = T.let([
  :class_name,
  :inverse_of,
  :validate,
  :extend
].freeze, T.untyped)
      PRIMARY_KEY_DEFAULT = T.let('_id'.freeze, T.untyped)

      # Initialize the Association.
      # 
      # _@param_ `_class` — The class of the model who owns this association.
      # 
      # _@param_ `name` — The name of the association.
      # 
      # _@param_ `opts` — The association options.
      # 
      # _@param_ `block` — The optional block.
      sig do
        params(
          _class: Class,
          name: Symbol,
          opts: T::Hash[T.untyped, T.untyped],
          block: T.untyped
        ).void
      end
      def initialize(_class, name, opts = {}, &block); end

            # Compare this association to another.
      # 
      # _@return_ — The object to compare to this association.
      sig { params(other: T.untyped).returns(Object) }
      def ==(other); end

      # Get the callbacks for a given type.
      # 
      # _@param_ `callback_type` — The type of callback type.
      # 
      # _@return_ — A list of the callbacks, either method
      # names or Procs.
      sig { params(callback_type: Symbol).returns(T::Array[T.any(Proc, Symbol)]) }
      def get_callbacks(callback_type); end

      # Get the type setter.
      # 
      # _@return_ — The type setter method.
      # 
      # _@note_ — Only relevant for polymorphic associations that take the :as option.
      sig { returns(String) }
      def type_setter; end

      # Whether trying to bind an object using this association should raise
      # an error.
      # 
      # _@param_ `doc` — The document to be bound.
      # 
      # _@return_ — Whether the document can be bound.
      sig { params(doc: Document).returns(T::Boolean) }
      def bindable?(doc); end

      # Get the inverse names.
      # 
      # _@param_ `other` — The other model class or model object to use when determining inverses.
      # 
      # _@return_ — The list of inverse names.
      sig { params(other: T.nilable(Object)).returns(T::Array[Symbol]) }
      def inverses(other = nil); end

      # Get the inverse's association metadata.
      # 
      # _@param_ `other` — The other model class or model object to use when determining inverses.
      # 
      # _@return_ — The inverse's association metadata.
      sig { params(other: T.nilable(Object)).returns(Association) }
      def inverse_association(other = nil); end

      # Get the inverse type.
      # 
      # _@return_ — Default is nil for an association.
      sig { returns(T.nilable(T.any())) }
      def inverse_type; end

      # The class name, possibly unqualified or :: prefixed, of the association
      # object(s).
      # 
      # This method returns the class name as it is used in the association
      # definition. If :class_name option is given in the association, the
      # exact value of that option is returned here. If :class_name option is
      # not given, the name of the class is calculated from association name
      # but is not resolved to the actual class.
      # 
      # The class name returned by this method may not correspond to a defined
      # class, either because the corresponding class has not been loaded yet,
      # or because the association references a non-existent class altogether.
      # To obtain the association class, use +relation_class+ method.
      # 
      # _@return_ — The association objects' class name.
      # 
      # _@note_ — The return value of this method should not be used to determine
      # whether two associations have the same target class, because the
      # return value is not always a fully qualified class name. To compare
      # classes, retrieve the class instance of the association target using
      # the +relation_class+ method.
      sig { returns(String) }
      def relation_class_name; end

      # The class of the association object(s).
      # 
      # This method returns the class instance corresponding to
      # +relation_class_name+, resolved relative to the host document class.
      # 
      # If the class does not exist, this method raises NameError. This can
      # happen because the target class has not yet been defined. Note that
      # polymorphic associations generally do not have a well defined target
      # class because the target class can change from one object to another,
      # and calling this method on a polymorphic association will generally
      # fail with a NameError or produce misleading results (if a class does
      # happen to be defined with the same name as the association name).
      # 
      # _@return_ — The association objects' class.
      sig { returns(String) }
      def relation_class; end

      # The class name of the object owning this association.
      # 
      # _@return_ — The owning objects' class name.
      sig { returns(String) }
      def inverse_class_name; end

      # The class of the object owning this association.
      # 
      # _@return_ — The owning objects' class.
      sig { returns(String) }
      def inverse_class; end

      # The foreign key field if this association stores a foreign key.
      # Otherwise, the primary key.
      # 
      # _@return_ — The primary key.
      sig { returns(T.any(Symbol, String)) }
      def key; end

      # The name of the setter on this object for assigning an associated object.
      # 
      # _@return_ — The setter name.
      sig { returns(String) }
      def setter; end

            # The name of the inverse setter method.
      # 
      # _@return_ — The name of the inverse setter.
      sig { params(other: T.untyped).returns(String) }
      def inverse_setter(other = nil); end

      # The name of the foreign key setter method.
      # 
      # _@return_ — The name of the foreign key setter.
      sig { returns(String) }
      def foreign_key_setter; end

            # The atomic path for this association.
      # 
      # _@return_ — The atomic path object.
      sig { params(document: T.untyped).returns(Mongoid::Atomic::Paths::Root) }
      def path(document); end

      # Gets the setter for the field that sets the type of document on a
      # polymorphic association.
      # 
      # _@return_ — The name of the setter.
      # 
      # Get the inverse type setter.
      # ```ruby
      # association.inverse_type_setter
      # ```
      sig { returns(String) }
      def inverse_type_setter; end

      # Get the name of the method to check if the foreign key has changed.
      # 
      # _@return_ — The foreign key check.
      # 
      # Get the foreign key check method.
      # ```ruby
      # association.foreign_key_check
      # ```
      sig { returns(String) }
      def foreign_key_check; end

      # Create an association proxy object using the owner and target.
      # 
      # _@param_ `owner` — The document this association hangs off of.
      # 
      # _@param_ `target` — The target (parent) of the association.
      sig { params(owner: Document, target: T.any(Document, T::Array[Document])).returns(Proxy) }
      def create_relation(owner, target); end

      # Whether the dependent method is destructive.
      # 
      # _@return_ — If the dependent method is destructive.
      sig { returns(T::Boolean) }
      def destructive?; end

      # Get the counter cache column name.
      # 
      # _@return_ — The counter cache column name.
      sig { returns(String) }
      def counter_cache_column_name; end

      # Get the extension.
      # 
      # _@return_ — The extension module, if one has been defined.
      sig { returns(Module) }
      def extension; end

            # Get the inverse name.
      # 
      # _@return_ — The inverse name.
      sig { params(other: T.untyped).returns(Symbol) }
      def inverse(other = nil); end

      # Whether the associated object(s) should be validated.
      # 
      # _@return_ — If the associated object(s)
      # should be validated.
      sig { returns(T::Boolean) }
      def validate?; end

            # Gets the model classes with inverse associations of this model. This is used to determine
      # the classes on the other end of polymorphic associations with models.
      sig { returns(T.untyped) }
      def inverse_association_classes; end

            sig { returns(T.untyped) }
      def setup_index!; end

            sig { returns(T.untyped) }
      def define_touchable!; end

            sig { returns(T.untyped) }
      def define_autosaver!; end

            sig { returns(T.untyped) }
      def define_builder!; end

            sig { returns(T.untyped) }
      def define_creator!; end

            sig { returns(T.untyped) }
      def define_getter!; end

            sig { returns(T.untyped) }
      def define_setter!; end

            sig { returns(T.untyped) }
      def define_existence_check!; end

            sig { returns(T.untyped) }
      def define_ids_getter!; end

            sig { returns(T.untyped) }
      def define_ids_setter!; end

            sig { returns(T.untyped) }
      def define_counter_cache_callbacks!; end

            sig { returns(T.untyped) }
      def define_dependency!; end

            sig { returns(T.untyped) }
      def validate!; end

            sig { returns(T.untyped) }
      def polymorph!; end

            sig { params(block: T.untyped).returns(T.untyped) }
      def create_extension!(&block); end

            sig { returns(T.untyped) }
      def default_inverse; end

                  # Returns an array of classes/modules forming the namespace hierarchy
      # where symbols referenced in the provided class/module would be looked
      # up by Ruby. For example, if mod is Foo::Bar, this method would return
      # [Foo::Bar, Foo, Object].
      sig { params(mod: T.untyped).returns(T.untyped) }
      def namespace_hierarchy(mod); end

                        # Resolves the given class/module name in the context of the specified
      # module, as Ruby would when a constant is referenced in the source.
      # 
      # _@note_ — This method can swallow exceptions produced during class loading,
      # because it rescues NameError internally. Since this method attempts
      # to load classes, failure during the loading process may also lead to
      # there being incomplete class definitions.
      sig { params(mod: T.untyped, name: T.untyped).returns(T.untyped) }
      def resolve_name(mod, name); end

      # Returns the name of the parent to a polymorphic child.
      # 
      # _@return_ — The name.
      sig { returns(T.any(String, Symbol)) }
      def as; end

      # Specify what happens to the associated object when the owner is destroyed.
      # 
      # _@return_ — The dependent option.
      sig { returns(String) }
      def dependent; end

      # The custom sorting options on the association.
      # 
      # _@return_ — The custom sorting options.
      sig { returns(Criteria::Queryable::Key) }
      def order; end

      # Whether to index the primary or foreign key field.
      sig { returns(T::Boolean) }
      def indexed?; end

      # Whether the association is autobuilding.
      sig { returns(T::Boolean) }
      def autobuilding?; end

      # Is the association cyclic.
      # 
      # _@return_ — Whether the association is cyclic.
      sig { returns(T::Boolean) }
      def cyclic?; end

      # The name the owning object uses to refer to this association.
      # 
      # _@return_ — The inverse_of option.
      sig { returns(String) }
      def inverse_of; end

      # Mongoid assumes that the field used to hold the primary key of the association is id.
      # You can override this and explicitly specify the primary key with the :primary_key option.
      # 
      # _@return_ — The primary key.
      sig { returns(T.any(Symbol, String)) }
      def primary_key; end

      # Options to save any loaded members and destroy members that are marked for destruction
      # when the parent object is saved.
      # 
      # _@return_ — The autosave option.
      sig { returns(T::Boolean) }
      def autosave; end

      # Whether the association is counter-cached.
      sig { returns(T::Boolean) }
      def counter_cached?; end

      # Whether this association is polymorphic.
      # 
      # _@return_ — Whether the association is polymorphic.
      sig { returns(T::Boolean) }
      def polymorphic?; end

      # Whether the association has callbacks cascaded down from the parent.
      # 
      # _@return_ — Whether callbacks are cascaded.
      sig { returns(T::Boolean) }
      def cascading_callbacks?; end

      # The store_as option.
      # 
      # _@return_ — Default is nil.
      sig { returns(T.nilable(T.any())) }
      def store_as; end

      # Whether the association has forced nil inverse (So no foreign keys are saved).
      # 
      # _@return_ — Default is false.
      sig { returns(T::Boolean) }
      def forced_nil_inverse?; end

      # The field for saving the associated object's type.
      # 
      # _@return_ — Default is nil.
      sig { returns(T.nilable(T.any())) }
      def type; end

      # The field for saving the associated object's type.
      # 
      # _@return_ — Default is nil.
      sig { returns(T.nilable(T.any())) }
      def touch_field; end

      sig { returns(T::Boolean) }
      def touchable?; end

      # Convert the supplied object to the appropriate type to set as the
      # foreign key for an association.
      # 
      # _@param_ `object` — The object to convert.
      # 
      # _@return_ — The object cast to the correct type.
      # 
      # Convert the object.
      # ```ruby
      # constraint.convert("12345")
      # ```
      sig { params(object: Object).returns(Object) }
      def convert_to_foreign_key(object); end

                  sig { params(object: T.untyped).returns(T.untyped) }
      def convert_polymorphic(object); end

      # The name of the association.
      # 
      # _@return_ — The name of the association.
      sig { returns(Symbol) }
      attr_reader :name

      # The options on this association.
      # 
      # _@return_ — The options.
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      attr_reader :options
    end

    module Marshalable
      # Provides the data needed to Marshal.dump an association proxy.
      # 
      # _@return_ — The dumped data.
      # 
      # Dump the proxy.
      # ```ruby
      # Marshal.dump(proxy)
      # ```
      sig { returns(T::Array[Object]) }
      def marshal_dump; end

      # Takes the provided data and sets it back on the proxy.
      # 
      # _@param_ `data` — The data to set on the proxy.
      # 
      # _@return_ — The loaded data.
      # 
      # Load the proxy.
      # ```ruby
      # Marshal.load(proxy)
      # ```
      sig { params(data: T::Array[Object]).returns(T::Array[Object]) }
      def marshal_load(data); end
    end

    # The reflections module provides convenience methods that can retrieve
    # useful information about associations.
    module Reflections
      extend ActiveSupport::Concern

      # Returns the association metadata for the supplied name.
      # 
      # _@param_ `name` — The name of the association to find.
      # 
      # _@return_ — The matching association metadata.
      # 
      # Find association metadata by name.
      # ```ruby
      # person.reflect_on_association(:addresses)
      # ```
      sig { params(name: T.any(String, Symbol)).returns(Association) }
      def reflect_on_association(name); end

      # Returns all association metadata for the supplied macros.
      # 
      # _@param_ `macros` — The association macros.
      # 
      # _@return_ — The matching association metadata.
      # 
      # Find multiple association metadata by macro.
      # ```ruby
      # person.reflect_on_all_associations(:embeds_many)
      # ```
      sig { params(macros: T::Array[Symbol]).returns(T::Array[Association]) }
      def reflect_on_all_association(*macros); end

      module ClassMethods
        # Returns the association metadata for the supplied name.
        # 
        # _@param_ `name` — The name of the association to find.
        # 
        # _@return_ — The matching association metadata.
        # 
        # Find association metadata by name.
        # ```ruby
        # Person.reflect_on_association(:addresses)
        # ```
        sig { params(name: T.any(String, Symbol)).returns(Association) }
        def reflect_on_association(name); end

        # Returns all association metadata for the supplied macros.
        # 
        # _@param_ `macros` — The association macros.
        # 
        # _@return_ — The matching association metadata.
        # 
        # Find multiple association metadata by macro.
        # ```ruby
        # Person.reflect_on_all_associations(:embeds_many)
        # ```
        sig { params(macros: T::Array[Symbol]).returns(T::Array[Association]) }
        def reflect_on_all_associations(*macros); end
      end
    end

    # Used for converting foreign key values to the correct type based on the
    # types of ids that the document stores.
    module Constrainable
      # Convert the supplied object to the appropriate type to set as the
      # foreign key for an association.
      # 
      # _@param_ `object` — The object to convert.
      # 
      # _@return_ — The object cast to the correct type.
      # 
      # Convert the object.
      # ```ruby
      # constraint.convert("12345")
      # ```
      sig { params(object: Object).returns(Object) }
      def convert_to_foreign_key(object); end

                  sig { params(object: T.untyped).returns(T.untyped) }
      def convert_polymorphic(object); end
    end

    # This module defines the eager loading behavior for criteria.
    # 
    # @since 7.0
    module EagerLoadable
      sig { returns(T::Boolean) }
      def eager_loadable?; end

                  sig { params(docs: T.untyped).returns(T.untyped) }
      def eager_load(docs); end

                        sig { params(relations: T.untyped, docs: T.untyped).returns(T.untyped) }
      def preload(relations, docs); end
    end

    module Embedded
      # This module provides convenience macros for using cyclic embedded
      # associations.
      module Cyclic
        extend ActiveSupport::Concern

        module ClassMethods
                              # Create a cyclic embedded association that creates a tree hierarchy for
          # the document and many embedded child documents.
          # 
          # This provides the default nomenclature for accessing a parent document
          # or its children.
          # 
          # Set up a recursive embeds many.
          # ```ruby
          # 
          # class Role
          #   include Mongoid::Document
          #   recursively_embeds_many
          # end
          # ```
          # 
          # The previous example is a shorcut for this.
          # ```ruby
          # 
          # class Role
          #   include Mongoid::Document
          #   embeds_many :child_roles, :class_name => "Role", :cyclic => true
          #   embedded_in :parent_role, :class_name => "Role", :cyclic => true
          # end
          # ```
          sig { params(options: T.untyped).returns(T.untyped) }
          def recursively_embeds_many(options = {}); end

                              # Create a cyclic embedded association that creates a single self
          # referencing relationship for a parent and a single child.
          # 
          # This provides the default nomenclature for accessing a parent document
          # or its children.
          # 
          # Set up a recursive embeds one.
          # ```ruby
          # 
          # class Role
          #   include Mongoid::Document
          #   recursively_embeds_one
          # end
          # ```
          # 
          # The previous example is a shorcut for this.
          # ```ruby
          # 
          # class Role
          #   include Mongoid::Document
          #   embeds_one :child_role, :class_name => "Role", :cyclic => true
          #   embedded_in :parent_role, :class_name => "Role", :cyclic => true
          # end
          # ```
          sig { params(options: T.untyped).returns(T.untyped) }
          def recursively_embeds_one(options = {}); end

          # Determines the parent name given the class.
          # 
          # _@return_ — "parent_" plus the class name underscored.
          # 
          # Determine the parent name.
          # ```ruby
          # Role.cyclic_parent_name
          # ```
          sig { returns(String) }
          def cyclic_parent_name; end

          # Determines the child name given the class.
          # 
          # _@param_ `many` — Is the a many association?
          # 
          # _@return_ — "child_" plus the class name underscored in
          # singular or plural form.
          # 
          # Determine the child name.
          # ```ruby
          # Role.cyclic_child_name
          # ```
          sig { params(many: T::Boolean).returns(String) }
          def cyclic_child_name(many = true); end
        end
      end

      # Contains behavior for executing operations in batch on embedded
      # documents.
      module Batchable
        include Mongoid::Positional

        # Insert new documents as a batch push ($push with $each). This ensures that
        # all callbacks are run at the appropriate time and only 1 request is
        # made to the database.
        # 
        # _@param_ `docs` — The docs to add.
        # 
        # _@return_ — The inserts.
        # 
        # Execute the batch push.
        # ```ruby
        # batchable.batch_insert([ doc_one, doc_two ])
        # ```
        sig { params(docs: T::Array[Document]).returns(T::Array[T::Hash[T.untyped, T.untyped]]) }
        def batch_insert(docs); end

        # Clear all of the docs out of the association in a single swipe.
        # 
        # _@param_ `docs` — The docs to clear.
        # 
        # _@return_ — The empty array.
        # 
        # Clear all docs.
        # ```ruby
        # batchable.batch_clear(docs)
        # ```
        sig { params(docs: T::Array[Document]).returns(T::Array[T.untyped]) }
        def batch_clear(docs); end

                # Batch remove the provided documents as a $pullAll.
        # 
        # _@param_ `docs` — The docs to remove.
        # 
        # _@param_ `method` — Delete or destroy.
        # 
        # Batch remove the documents.
        # ```ruby
        # batchable.batch_remove([ doc_one, doc_two ])
        # ```
        sig { params(docs: T::Array[Document], method: Symbol).returns(T.untyped) }
        def batch_remove(docs, method = :delete); end

        # Batch replace the provided documents as a $set.
        # 
        # _@param_ `docs` — The docs to replace with.
        # 
        # _@return_ — The inserts.
        # 
        # Batch replace the documents.
        # ```ruby
        # batchable.batch_replace([ doc_one, doc_two ])
        # ```
        sig { params(docs: T::Array[Document]).returns(T::Array[T::Hash[T.untyped, T.untyped]]) }
        def batch_replace(docs); end

                # Add the atomic sets to the base document.
        # 
        # _@param_ `sets` — The atomic sets.
        # 
        # Add the atomic sets.
        # ```ruby
        # batchable.add_atomic_sets([{ field: value }])
        # ```
        sig { params(sets: T::Array[T::Hash[T.untyped, T.untyped]]).returns(T.untyped) }
        def add_atomic_sets(sets); end

        # Perform a batch persist of the provided documents with a $set.
        # 
        # _@param_ `docs` — The docs to persist.
        # 
        # _@return_ — The inserts.
        # 
        # Perform a batch $set.
        # ```ruby
        # batchable.execute_batch_set(docs)
        # ```
        sig { params(docs: T::Array[Document]).returns(T::Array[T::Hash[T.untyped, T.untyped]]) }
        def execute_batch_set(docs); end

        # Perform a batch persist of the provided documents with $push and $each.
        # 
        # _@param_ `docs` — The docs to persist.
        # 
        # _@return_ — The inserts.
        # 
        # Perform a batch push.
        # ```ruby
        # batchable.execute_batch_push(docs)
        # ```
        sig { params(docs: T::Array[Document]).returns(T::Array[T::Hash[T.untyped, T.untyped]]) }
        def execute_batch_push(docs); end

        # Are we in a state to be able to batch insert?
        # 
        # _@return_ — If inserts can be performed.
        # 
        # Can inserts be performed?
        # ```ruby
        # batchable.insertable?
        # ```
        sig { returns(T::Boolean) }
        def insertable?; end

        # Are the inserts currently valid?
        # 
        # _@return_ — If inserts are currently valid.
        # 
        # Are the inserts currently valid.
        # ```ruby
        # batchable.inserts_valid
        # ```
        sig { returns(T::Boolean) }
        def inserts_valid; end

        # Set the inserts valid flag.
        # 
        # _@param_ `value` — The flag.
        # 
        # _@return_ — The flag.
        # 
        # Set the flag.
        # ```ruby
        # batchable.inserts_valid = true
        # ```
        sig { params(value: T::Boolean).returns(T::Boolean) }
        def inserts_valid=(value); end

        # Normalize the documents, in case they were provided as an array of
        # hashes.
        # 
        # _@param_ `docs` — The docs to normalize.
        # 
        # _@return_ — The docs.
        # 
        # Normalize the docs.
        # ```ruby
        # batchable.normalize_docs(docs)
        # ```
        sig { params(docs: T::Array[T.any(T::Hash[T.untyped, T.untyped], Document)]).returns(T::Array[Document]) }
        def normalize_docs(docs); end

        # Get the atomic path.
        # 
        # _@return_ — The atomic path.
        # 
        # Get the atomic path.
        # ```ruby
        # batchable.path
        # ```
        sig { returns(String) }
        def path; end

        # Set the atomic path.
        # 
        # _@param_ `value` — The path.
        # 
        # _@return_ — The path.
        # 
        # Set the atomic path.
        # ```ruby
        # batchable.path = "addresses"
        # ```
        sig { params(value: String).returns(String) }
        def path=(value); end

        # Get the selector for executing atomic operations on the collection.
        # 
        # _@return_ — The atomic selector.
        # 
        # Get the selector.
        # ```ruby
        # batchable.selector
        # ```
        sig { returns(T::Hash[T.untyped, T.untyped]) }
        def selector; end

        # Pre processes the batch insert for the provided documents.
        # 
        # _@param_ `docs` — The documents.
        # 
        # _@return_ — The documents as an array of hashes.
        # 
        # Pre process the documents.
        # ```ruby
        # batchable.pre_process_batch_insert(docs)
        # ```
        sig { params(docs: T::Array[Document]).returns(T::Array[T::Hash[T.untyped, T.untyped]]) }
        def pre_process_batch_insert(docs); end

        # Pre process the batch removal.
        # 
        # _@param_ `docs` — The documents.
        # 
        # _@param_ `method` — Delete or destroy.
        # 
        # _@return_ — The documents as hashes.
        # 
        # Pre process the documents.
        # ```ruby
        # batchable.pre_process_batch_remove(docs, :delete)
        # ```
        sig { params(docs: T::Array[Document], method: Symbol).returns(T::Array[T::Hash[T.untyped, T.untyped]]) }
        def pre_process_batch_remove(docs, method); end

        # sord warn - Documents wasn't able to be resolved to a constant in this project
        # Post process the documents after batch insert.
        # 
        # _@param_ `docs` — The inserted docs.
        # 
        # _@return_ — The document enum.
        # 
        # Post process the documents.
        # ```ruby
        # batchable.post_process_batch_insert(docs)
        # ```
        sig { params(docs: T::Array[Document]).returns(T::Enumerable[T.untyped]) }
        def post_process_batch_insert(docs); end

        # Post process the batch removal.
        # 
        # _@param_ `docs` — The documents.
        # 
        # _@param_ `method` — Delete or destroy.
        # 
        # _@return_ — The documents.
        # 
        # Post process the documents.
        # ```ruby
        # batchable.post_process_batch_remove(docs, :delete)
        # ```
        sig { params(docs: T::Array[Document], method: Symbol).returns(T::Array[Document]) }
        def post_process_batch_remove(docs, method); end

        # Takes the provided selector and atomic operations and replaces the
        # indexes of the embedded documents with the positional operator when
        # needed.
        # 
        # _@param_ `selector` — The selector.
        # 
        # _@param_ `operations` — The update operations.
        # 
        # _@param_ `processed` — The processed update operations.
        # 
        # _@return_ — The new operations.
        # 
        # Process the operations.
        # ```ruby
        # positionally(
        #   { "_id" => 1, "addresses._id" => 2 },
        #   { "$set" => { "addresses.0.street" => "hobrecht" }}
        # )
        # ```
        # 
        # _@note_ — The only time we can accurately know when to use the positional
        # operator is at the exact time we are going to persist something. So
        # we can tell by the selector that we are sending if it is actually
        # possible to use the positional operator at all. For example, if the
        # selector is: { "_id" => 1 }, then we could not use the positional
        # operator for updating embedded documents since there would never be a
        # match - we base whether we can based on the number of levels deep the
        # selector goes, and if the id values are not nil.
        sig { params(selector: T::Hash[T.untyped, T.untyped], operations: T::Hash[T.untyped, T.untyped], processed: T::Hash[T.untyped, T.untyped]).returns(T::Hash[T.untyped, T.untyped]) }
        def positionally(selector, operations, processed = {}); end

                                        sig { params(keys: T.untyped, operations: T.untyped, processed: T.untyped).returns(T.untyped) }
        def process_operations(keys, operations, processed); end

                                        sig { params(keys: T.untyped, update: T.untyped, updates: T.untyped).returns(T.untyped) }
        def process_updates(keys, update, updates = {}); end

                                sig { params(keys: T.untyped, position: T.untyped).returns(T.untyped) }
        def replace_index(keys, position); end
      end

      # The EmbedsOne type association.
      # 
      # @since 7.0
      class EmbedsOne
        include Mongoid::Association::Relatable
        include Mongoid::Association::Embedded::EmbedsOne::Buildable
        ASSOCIATION_OPTIONS = T.let([
    :autobuild,
    :as,
    :cascade_callbacks,
    :cyclic,
    :store_as
], T.untyped)
        VALID_OPTIONS = T.let((ASSOCIATION_OPTIONS + SHARED_OPTIONS).freeze, T.untyped)
        SHARED_OPTIONS = T.let([
  :class_name,
  :inverse_of,
  :validate,
  :extend
].freeze, T.untyped)
        PRIMARY_KEY_DEFAULT = T.let('_id'.freeze, T.untyped)

        # Setup the instance methods, fields, etc. on the association owning class.
        sig { returns(T.self_type) }
        def setup!; end

        # The field key used to store the association object.
        # 
        # _@return_ — The field name.
        sig { returns(String) }
        def store_as; end

        # The key that is used to get the attributes for the associated object.
        # 
        # _@return_ — The name of the field used to store the association.
        sig { returns(String) }
        def key; end

        # Is this association type embedded?
        # 
        # _@return_ — Always true.
        sig { returns(T::Boolean) }
        def embedded?; end

        # Get the default validation setting for the association. Determines if
        # by default a validates associated will occur.
        # 
        # _@return_ — The validation default.
        # 
        # Get the validation default.
        # ```ruby
        # Proxy.validation_default
        # ```
        sig { returns(T::Boolean) }
        def validation_default; end

        # Does this association type store the foreign key?
        # 
        # _@return_ — Always false.
        sig { returns(T::Boolean) }
        def stores_foreign_key?; end

        # The primary key
        # 
        # _@return_ — Not relevant for this association
        sig { returns(T.nilable(T.any())) }
        def primary_key; end

        # Get the association proxy class for this association type.
        # 
        # _@return_ — The proxy class.
        sig { returns(Association::Embedded::EmbedsMany::Proxy) }
        def relation; end

        # Is this association polymorphic?
        # 
        # _@return_ — Whether this association is polymorphic.
        sig { returns(T::Boolean) }
        def polymorphic?; end

        # The field used to store the type of the related object.
        # 
        # _@return_ — The field for storing the associated object's type.
        # 
        # _@note_ — Only relevant if the association is polymorphic.
        sig { returns(T.nilable(String)) }
        def type; end

        # The nested builder object.
        # 
        # _@param_ `attributes` — The attributes to use to build the association object.
        # 
        # _@param_ `options` — The options for the association.
        # 
        # _@return_ — The Nested Builder object.
        sig { params(attributes: T::Hash[T.untyped, T.untyped], options: T::Hash[T.untyped, T.untyped]).returns(Association::Nested::One) }
        def nested_builder(attributes, options); end

                sig { returns(T.untyped) }
        def setup_instance_methods!; end

                sig { returns(T.untyped) }
        def relation_complements; end

                        sig { params(other: T.untyped).returns(T.untyped) }
        def polymorphic_inverses(other = nil); end

                        sig { params(other: T.untyped).returns(T.untyped) }
        def determine_inverses(other); end

        # Builds the document out of the attributes using the provided
        # association metadata on the association. Instantiates through the factory in order
        # to make sure subclasses and allocation are used if fitting.
        # 
        # _@param_ `base` — The document this association hangs off of.
        # 
        # _@param_ `object` — The related document.
        # 
        # _@param_ `_type` — Not used in this context.
        # 
        # _@param_ `selected_fields` — Fields which were retrieved via #only. If selected_fields are specified, fields not listed in it will not be accessible in the built document.
        # 
        # _@return_ — A single document.
        # 
        # Build the document.
        # ```ruby
        # Builder.new(meta, attrs).build
        # ```
        sig do
          params(
            base: Document,
            object: Document,
            _type: T.nilable(String),
            selected_fields: T.nilable(T::Hash[T.untyped, T.untyped])
          ).returns(Document)
        end
        def build(base, object, _type = nil, selected_fields = nil); end

        # Begin the assignment of attributes. While in this block embedded
        # documents will not autosave themselves in order to allow the document to
        # be in a valid state.
        # 
        # _@return_ — The yielded value.
        # 
        # Execute the assignment.
        # ```ruby
        # _assigning do
        #   person.attributes = { :addresses => [ address ] }
        # end
        # ```
        sig { returns(Object) }
        def _assigning; end

        # Is the current thread in assigning mode?
        # 
        # _@return_ — If the thread is assigning.
        # 
        # Is the current thread in assigning mode?
        # ```ruby
        # proxy._assigning?
        # ```
        sig { returns(T::Boolean) }
        def _assigning?; end

        # Execute a block in binding mode.
        # 
        # _@return_ — The return value of the block.
        # 
        # Execute in binding mode.
        # ```ruby
        # binding do
        #   relation.push(doc)
        # end
        # ```
        sig { returns(Object) }
        def _binding; end

        # Is the current thread in binding mode?
        # 
        # _@return_ — If the thread is binding.
        # 
        # Is the current thread in binding mode?
        # ```ruby
        # proxy.binding?
        # ```
        sig { returns(T::Boolean) }
        def _binding?; end

        # Execute a block in building mode.
        # 
        # _@return_ — The return value of the block.
        # 
        # Execute in building mode.
        # ```ruby
        # _building do
        #   relation.push(doc)
        # end
        # ```
        sig { returns(Object) }
        def _building; end

        # Is the current thread in building mode?
        # 
        # _@return_ — If the thread is building.
        # 
        # Is the current thread in building mode?
        # ```ruby
        # proxy._building?
        # ```
        sig { returns(T::Boolean) }
        def _building?; end

        # Is the current thread in creating mode?
        # 
        # _@return_ — If the thread is creating.
        # 
        # Is the current thread in creating mode?
        # ```ruby
        # proxy.creating?
        # ```
        sig { returns(T::Boolean) }
        def _creating?; end

        # Execute a block in loading mode.
        # 
        # _@return_ — The return value of the block.
        # 
        # Execute in loading mode.
        # ```ruby
        # _loading do
        #   relation.push(doc)
        # end
        # ```
        sig { returns(Object) }
        def _loading; end

        # Is the current thread in loading mode?
        # 
        # _@return_ — If the thread is loading.
        # 
        # Is the current thread in loading mode?
        # ```ruby
        # proxy._loading?
        # ```
        sig { returns(T::Boolean) }
        def _loading?; end

        # Initialize the Association.
        # 
        # _@param_ `_class` — The class of the model who owns this association.
        # 
        # _@param_ `name` — The name of the association.
        # 
        # _@param_ `opts` — The association options.
        # 
        # _@param_ `block` — The optional block.
        sig do
          params(
            _class: Class,
            name: Symbol,
            opts: T::Hash[T.untyped, T.untyped],
            block: T.untyped
          ).void
        end
        def initialize(_class, name, opts = {}, &block); end

                # Compare this association to another.
        # 
        # _@return_ — The object to compare to this association.
        sig { params(other: T.untyped).returns(Object) }
        def ==(other); end

        # Get the callbacks for a given type.
        # 
        # _@param_ `callback_type` — The type of callback type.
        # 
        # _@return_ — A list of the callbacks, either method
        # names or Procs.
        sig { params(callback_type: Symbol).returns(T::Array[T.any(Proc, Symbol)]) }
        def get_callbacks(callback_type); end

        # Get the type setter.
        # 
        # _@return_ — The type setter method.
        # 
        # _@note_ — Only relevant for polymorphic associations that take the :as option.
        sig { returns(String) }
        def type_setter; end

        # Whether trying to bind an object using this association should raise
        # an error.
        # 
        # _@param_ `doc` — The document to be bound.
        # 
        # _@return_ — Whether the document can be bound.
        sig { params(doc: Document).returns(T::Boolean) }
        def bindable?(doc); end

        # Get the inverse names.
        # 
        # _@param_ `other` — The other model class or model object to use when determining inverses.
        # 
        # _@return_ — The list of inverse names.
        sig { params(other: T.nilable(Object)).returns(T::Array[Symbol]) }
        def inverses(other = nil); end

        # Get the inverse's association metadata.
        # 
        # _@param_ `other` — The other model class or model object to use when determining inverses.
        # 
        # _@return_ — The inverse's association metadata.
        sig { params(other: T.nilable(Object)).returns(Association) }
        def inverse_association(other = nil); end

        # Get the inverse type.
        # 
        # _@return_ — Default is nil for an association.
        sig { returns(T.nilable(T.any())) }
        def inverse_type; end

        # The class name, possibly unqualified or :: prefixed, of the association
        # object(s).
        # 
        # This method returns the class name as it is used in the association
        # definition. If :class_name option is given in the association, the
        # exact value of that option is returned here. If :class_name option is
        # not given, the name of the class is calculated from association name
        # but is not resolved to the actual class.
        # 
        # The class name returned by this method may not correspond to a defined
        # class, either because the corresponding class has not been loaded yet,
        # or because the association references a non-existent class altogether.
        # To obtain the association class, use +relation_class+ method.
        # 
        # _@return_ — The association objects' class name.
        # 
        # _@note_ — The return value of this method should not be used to determine
        # whether two associations have the same target class, because the
        # return value is not always a fully qualified class name. To compare
        # classes, retrieve the class instance of the association target using
        # the +relation_class+ method.
        sig { returns(String) }
        def relation_class_name; end

        # The class of the association object(s).
        # 
        # This method returns the class instance corresponding to
        # +relation_class_name+, resolved relative to the host document class.
        # 
        # If the class does not exist, this method raises NameError. This can
        # happen because the target class has not yet been defined. Note that
        # polymorphic associations generally do not have a well defined target
        # class because the target class can change from one object to another,
        # and calling this method on a polymorphic association will generally
        # fail with a NameError or produce misleading results (if a class does
        # happen to be defined with the same name as the association name).
        # 
        # _@return_ — The association objects' class.
        sig { returns(String) }
        def relation_class; end

        # The class name of the object owning this association.
        # 
        # _@return_ — The owning objects' class name.
        sig { returns(String) }
        def inverse_class_name; end

        # The class of the object owning this association.
        # 
        # _@return_ — The owning objects' class.
        sig { returns(String) }
        def inverse_class; end

        # The name of the setter on this object for assigning an associated object.
        # 
        # _@return_ — The setter name.
        sig { returns(String) }
        def setter; end

                # The name of the inverse setter method.
        # 
        # _@return_ — The name of the inverse setter.
        sig { params(other: T.untyped).returns(String) }
        def inverse_setter(other = nil); end

        # The name of the foreign key setter method.
        # 
        # _@return_ — The name of the foreign key setter.
        sig { returns(String) }
        def foreign_key_setter; end

                # The atomic path for this association.
        # 
        # _@return_ — The atomic path object.
        sig { params(document: T.untyped).returns(Mongoid::Atomic::Paths::Root) }
        def path(document); end

        # Gets the setter for the field that sets the type of document on a
        # polymorphic association.
        # 
        # _@return_ — The name of the setter.
        # 
        # Get the inverse type setter.
        # ```ruby
        # association.inverse_type_setter
        # ```
        sig { returns(String) }
        def inverse_type_setter; end

        # Get the name of the method to check if the foreign key has changed.
        # 
        # _@return_ — The foreign key check.
        # 
        # Get the foreign key check method.
        # ```ruby
        # association.foreign_key_check
        # ```
        sig { returns(String) }
        def foreign_key_check; end

        # Create an association proxy object using the owner and target.
        # 
        # _@param_ `owner` — The document this association hangs off of.
        # 
        # _@param_ `target` — The target (parent) of the association.
        sig { params(owner: Document, target: T.any(Document, T::Array[Document])).returns(Proxy) }
        def create_relation(owner, target); end

        # Whether the dependent method is destructive.
        # 
        # _@return_ — If the dependent method is destructive.
        sig { returns(T::Boolean) }
        def destructive?; end

        # Get the counter cache column name.
        # 
        # _@return_ — The counter cache column name.
        sig { returns(String) }
        def counter_cache_column_name; end

        # Get the extension.
        # 
        # _@return_ — The extension module, if one has been defined.
        sig { returns(Module) }
        def extension; end

                # Get the inverse name.
        # 
        # _@return_ — The inverse name.
        sig { params(other: T.untyped).returns(Symbol) }
        def inverse(other = nil); end

        # Whether the associated object(s) should be validated.
        # 
        # _@return_ — If the associated object(s)
        # should be validated.
        sig { returns(T::Boolean) }
        def validate?; end

                # Gets the model classes with inverse associations of this model. This is used to determine
        # the classes on the other end of polymorphic associations with models.
        sig { returns(T.untyped) }
        def inverse_association_classes; end

                sig { returns(T.untyped) }
        def setup_index!; end

                sig { returns(T.untyped) }
        def define_touchable!; end

                sig { returns(T.untyped) }
        def define_autosaver!; end

                sig { returns(T.untyped) }
        def define_builder!; end

                sig { returns(T.untyped) }
        def define_creator!; end

                sig { returns(T.untyped) }
        def define_getter!; end

                sig { returns(T.untyped) }
        def define_setter!; end

                sig { returns(T.untyped) }
        def define_existence_check!; end

                sig { returns(T.untyped) }
        def define_ids_getter!; end

                sig { returns(T.untyped) }
        def define_ids_setter!; end

                sig { returns(T.untyped) }
        def define_counter_cache_callbacks!; end

                sig { returns(T.untyped) }
        def define_dependency!; end

                sig { returns(T.untyped) }
        def validate!; end

                sig { returns(T.untyped) }
        def polymorph!; end

                sig { params(block: T.untyped).returns(T.untyped) }
        def create_extension!(&block); end

                sig { returns(T.untyped) }
        def default_inverse; end

                        # Returns an array of classes/modules forming the namespace hierarchy
        # where symbols referenced in the provided class/module would be looked
        # up by Ruby. For example, if mod is Foo::Bar, this method would return
        # [Foo::Bar, Foo, Object].
        sig { params(mod: T.untyped).returns(T.untyped) }
        def namespace_hierarchy(mod); end

                                # Resolves the given class/module name in the context of the specified
        # module, as Ruby would when a constant is referenced in the source.
        # 
        # _@note_ — This method can swallow exceptions produced during class loading,
        # because it rescues NameError internally. Since this method attempts
        # to load classes, failure during the loading process may also lead to
        # there being incomplete class definitions.
        sig { params(mod: T.untyped, name: T.untyped).returns(T.untyped) }
        def resolve_name(mod, name); end

        # Returns the name of the parent to a polymorphic child.
        # 
        # _@return_ — The name.
        sig { returns(T.any(String, Symbol)) }
        def as; end

        # Specify what happens to the associated object when the owner is destroyed.
        # 
        # _@return_ — The dependent option.
        sig { returns(String) }
        def dependent; end

        # The custom sorting options on the association.
        # 
        # _@return_ — The custom sorting options.
        sig { returns(Criteria::Queryable::Key) }
        def order; end

        # Whether to index the primary or foreign key field.
        sig { returns(T::Boolean) }
        def indexed?; end

        # Whether the association is autobuilding.
        sig { returns(T::Boolean) }
        def autobuilding?; end

        # Is the association cyclic.
        # 
        # _@return_ — Whether the association is cyclic.
        sig { returns(T::Boolean) }
        def cyclic?; end

        # The name the owning object uses to refer to this association.
        # 
        # _@return_ — The inverse_of option.
        sig { returns(String) }
        def inverse_of; end

        # Options to save any loaded members and destroy members that are marked for destruction
        # when the parent object is saved.
        # 
        # _@return_ — The autosave option.
        sig { returns(T::Boolean) }
        def autosave; end

        # Whether the association is counter-cached.
        sig { returns(T::Boolean) }
        def counter_cached?; end

        # Whether the association has callbacks cascaded down from the parent.
        # 
        # _@return_ — Whether callbacks are cascaded.
        sig { returns(T::Boolean) }
        def cascading_callbacks?; end

        # Whether the association has forced nil inverse (So no foreign keys are saved).
        # 
        # _@return_ — Default is false.
        sig { returns(T::Boolean) }
        def forced_nil_inverse?; end

        # The field for saving the associated object's type.
        # 
        # _@return_ — Default is nil.
        sig { returns(T.nilable(T.any())) }
        def touch_field; end

        sig { returns(T::Boolean) }
        def touchable?; end

        # Convert the supplied object to the appropriate type to set as the
        # foreign key for an association.
        # 
        # _@param_ `object` — The object to convert.
        # 
        # _@return_ — The object cast to the correct type.
        # 
        # Convert the object.
        # ```ruby
        # constraint.convert("12345")
        # ```
        sig { params(object: Object).returns(Object) }
        def convert_to_foreign_key(object); end

                        sig { params(object: T.untyped).returns(T.untyped) }
        def convert_polymorphic(object); end

        class Proxy < Mongoid::Association::One
          VALID_OPTIONS = T.let([
    :autobuild,
    :as,
    :cascade_callbacks,
    :cyclic,
    :store_as
].freeze, T.untyped)

          # Instantiate a new embeds_one association.
          # 
          # _@param_ `base` — The document this association hangs off of.
          # 
          # _@param_ `target` — The child document in the association.
          # 
          # _@param_ `association` — The association metadata.
          # 
          # Create the new proxy.
          # ```ruby
          # One.new(person, name, association)
          # ```
          sig { params(base: Document, target: Document, association: Association).void }
          def initialize(base, target, association); end

          # Substitutes the supplied target documents for the existing document
          # in the association.
          # 
          # _@param_ `replacement` — A document to replace the target.
          # 
          # _@return_ — The association or nil.
          # 
          # Substitute the new document.
          # ```ruby
          # person.name.substitute(new_name)
          # ```
          sig { params(replacement: Document).returns(T.nilable(Document)) }
          def substitute(replacement); end

          # sord warn - Binding wasn't able to be resolved to a constant in this project
          # Instantiate the binding associated with this association.
          # 
          # _@return_ — The association's binding.
          # 
          # Get the binding.
          # ```ruby
          # relation.binding([ address ])
          # ```
          sig { returns(Binding) }
          def binding; end

          # Are we able to persist this association?
          # 
          # _@return_ — If the association is persistable.
          # 
          # Can we persist the association?
          # ```ruby
          # relation.persistable?
          # ```
          sig { returns(T::Boolean) }
          def persistable?; end

          # Returns true if the association is an embedded one. In this case
          # always true.
          # 
          # _@return_ — true.
          # 
          # Is this association embedded?
          # ```ruby
          # Association::Embedded::EmbedsOne.embedded?
          # ```
          sig { returns(T::Boolean) }
          def self.embedded?; end

          # Get the path calculator for the supplied document.
          # 
          # _@param_ `document` — The document to calculate on.
          # 
          # _@return_ — The embedded one atomic path calculator.
          # 
          # Get the path calculator.
          # ```ruby
          # Proxy.path(document)
          # ```
          sig { params(document: Document).returns(Mongoid::Atomic::Paths::Embedded::One) }
          def self.path(document); end
        end

        # Binding class for all embeds_one associations.
        # 
        # @since 7.0
        class Binding
          include Mongoid::Association::Bindable

                    # Binds the base object to the inverse of the association. This is so we
          # are referenced to the actual objects themselves on both sides.
          # 
          # This case sets the association metadata on the inverse object as well as the
          # document itself.
          # 
          # Bind the document.
          # ```ruby
          # person.name.bind(:continue => true)
          # person.name = Name.new
          # ```
          sig { returns(T.untyped) }
          def bind_one; end

                    # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          # 
          # Unbind the document.
          # ```ruby
          # person.name.unbind(:continue => true)
          # person.name = nil
          # ```
          sig { returns(T.untyped) }
          def unbind_one; end

          # Create the new binding.
          # 
          # _@param_ `base` — The base of the binding.
          # 
          # _@param_ `target` — The target of the binding.
          # 
          # _@param_ `association` — The association metadata.
          # 
          # Initialize a binding.
          # ```ruby
          # Binding.new(base, target, association)
          # ```
          sig { params(base: Document, target: T.any(Document, T::Array[Document]), association: Association).void }
          def initialize(base, target, association); end

          # Execute the provided block inside a binding.
          # 
          # _@return_ — The result of the yield.
          # 
          # Execute the binding block.
          # ```ruby
          # binding.binding do
          #   base.foreign_key = 1
          # end
          # ```
          sig { returns(Object) }
          def binding; end

                    # Check if the inverse is properly defined.
          # 
          # _@param_ `doc` — The document getting bound.
          # 
          # Check the inverse definition.
          # ```ruby
          # binding.check_inverse!(doc)
          # ```
          sig { params(doc: Document).returns(T.untyped) }
          def check_inverse!(doc); end

                    # Set the id of the related document in the foreign key field on the
          # keyed document.
          # 
          # _@param_ `keyed` — The document that stores the foreign key.
          # 
          # _@param_ `id` — The id of the bound document.
          # 
          # Bind the foreign key.
          # ```ruby
          # binding.bind_foreign_key(post, person._id)
          # ```
          sig { params(keyed: Document, id: Object).returns(T.untyped) }
          def bind_foreign_key(keyed, id); end

                    # Set the type of the related document on the foreign type field, used
          # when associations are polymorphic.
          # 
          # _@param_ `typed` — The document that stores the type field.
          # 
          # _@param_ `name` — The name of the model.
          # 
          # Bind the polymorphic type.
          # ```ruby
          # binding.bind_polymorphic_type(post, "Person")
          # ```
          sig { params(typed: Document, name: String).returns(T.untyped) }
          def bind_polymorphic_type(typed, name); end

                    # Set the type of the related document on the foreign type field, used
          # when associations are polymorphic.
          # 
          # _@param_ `typed` — The document that stores the type field.
          # 
          # _@param_ `name` — The name of the model.
          # 
          # Bind the polymorphic type.
          # ```ruby
          # binding.bind_polymorphic_inverse_type(post, "Person")
          # ```
          sig { params(typed: Document, name: String).returns(T.untyped) }
          def bind_polymorphic_inverse_type(typed, name); end

                    # Bind the inverse document to the child document so that the in memory
          # instances are the same.
          # 
          # _@param_ `doc` — The base document.
          # 
          # _@param_ `inverse` — The inverse document.
          # 
          # Bind the inverse.
          # ```ruby
          # binding.bind_inverse(post, person)
          # ```
          sig { params(doc: Document, inverse: Document).returns(T.untyped) }
          def bind_inverse(doc, inverse); end

                    # Bind the provided document with the base from the parent association.
          # 
          # _@param_ `doc` — The document to bind.
          # 
          # Bind the document with the base.
          # ```ruby
          # binding.bind_from_relational_parent(doc)
          # ```
          sig { params(doc: Document).returns(T.untyped) }
          def bind_from_relational_parent(doc); end

                              sig { params(_base: T.untyped).returns(T.untyped) }
          def record_id(_base); end

          # Ensure that the association on the base is correct, for the cases
          # where we have multiple belongs to definitions and were are setting
          # different parents in memory in order.
          # 
          # _@return_ — If the association changed.
          # 
          # Set the base association.
          # ```ruby
          # binding.set_base_association
          # ```
          sig { returns(T::Boolean) }
          def set_base_association; end

                    # Bind the provided document with the base from the parent association.
          # 
          # _@param_ `doc` — The document to unbind.
          # 
          # Bind the document with the base.
          # ```ruby
          # unbinding.unbind_from_relational_parent(doc)
          # ```
          sig { params(doc: Document).returns(T.untyped) }
          def unbind_from_relational_parent(doc); end

          # Begin the assignment of attributes. While in this block embedded
          # documents will not autosave themselves in order to allow the document to
          # be in a valid state.
          # 
          # _@return_ — The yielded value.
          # 
          # Execute the assignment.
          # ```ruby
          # _assigning do
          #   person.attributes = { :addresses => [ address ] }
          # end
          # ```
          sig { returns(Object) }
          def _assigning; end

          # Is the current thread in assigning mode?
          # 
          # _@return_ — If the thread is assigning.
          # 
          # Is the current thread in assigning mode?
          # ```ruby
          # proxy._assigning?
          # ```
          sig { returns(T::Boolean) }
          def _assigning?; end

          # Execute a block in binding mode.
          # 
          # _@return_ — The return value of the block.
          # 
          # Execute in binding mode.
          # ```ruby
          # binding do
          #   relation.push(doc)
          # end
          # ```
          sig { returns(Object) }
          def _binding; end

          # Is the current thread in binding mode?
          # 
          # _@return_ — If the thread is binding.
          # 
          # Is the current thread in binding mode?
          # ```ruby
          # proxy.binding?
          # ```
          sig { returns(T::Boolean) }
          def _binding?; end

          # Execute a block in building mode.
          # 
          # _@return_ — The return value of the block.
          # 
          # Execute in building mode.
          # ```ruby
          # _building do
          #   relation.push(doc)
          # end
          # ```
          sig { returns(Object) }
          def _building; end

          # Is the current thread in building mode?
          # 
          # _@return_ — If the thread is building.
          # 
          # Is the current thread in building mode?
          # ```ruby
          # proxy._building?
          # ```
          sig { returns(T::Boolean) }
          def _building?; end

          # Is the current thread in creating mode?
          # 
          # _@return_ — If the thread is creating.
          # 
          # Is the current thread in creating mode?
          # ```ruby
          # proxy.creating?
          # ```
          sig { returns(T::Boolean) }
          def _creating?; end

          # Execute a block in loading mode.
          # 
          # _@return_ — The return value of the block.
          # 
          # Execute in loading mode.
          # ```ruby
          # _loading do
          #   relation.push(doc)
          # end
          # ```
          sig { returns(Object) }
          def _loading; end

          # Is the current thread in loading mode?
          # 
          # _@return_ — If the thread is loading.
          # 
          # Is the current thread in loading mode?
          # ```ruby
          # proxy._loading?
          # ```
          sig { returns(T::Boolean) }
          def _loading?; end
        end

        # Builder class for embeds_one associations.
        # 
        # @since 7.0
        module Buildable
          include Mongoid::Threaded::Lifecycle

          # Builds the document out of the attributes using the provided
          # association metadata on the association. Instantiates through the factory in order
          # to make sure subclasses and allocation are used if fitting.
          # 
          # _@param_ `base` — The document this association hangs off of.
          # 
          # _@param_ `object` — The related document.
          # 
          # _@param_ `_type` — Not used in this context.
          # 
          # _@param_ `selected_fields` — Fields which were retrieved via #only. If selected_fields are specified, fields not listed in it will not be accessible in the built document.
          # 
          # _@return_ — A single document.
          # 
          # Build the document.
          # ```ruby
          # Builder.new(meta, attrs).build
          # ```
          sig do
            params(
              base: Document,
              object: Document,
              _type: T.nilable(String),
              selected_fields: T.nilable(T::Hash[T.untyped, T.untyped])
            ).returns(Document)
          end
          def build(base, object, _type = nil, selected_fields = nil); end

          # Begin the assignment of attributes. While in this block embedded
          # documents will not autosave themselves in order to allow the document to
          # be in a valid state.
          # 
          # _@return_ — The yielded value.
          # 
          # Execute the assignment.
          # ```ruby
          # _assigning do
          #   person.attributes = { :addresses => [ address ] }
          # end
          # ```
          sig { returns(Object) }
          def _assigning; end

          # Is the current thread in assigning mode?
          # 
          # _@return_ — If the thread is assigning.
          # 
          # Is the current thread in assigning mode?
          # ```ruby
          # proxy._assigning?
          # ```
          sig { returns(T::Boolean) }
          def _assigning?; end

          # Execute a block in binding mode.
          # 
          # _@return_ — The return value of the block.
          # 
          # Execute in binding mode.
          # ```ruby
          # binding do
          #   relation.push(doc)
          # end
          # ```
          sig { returns(Object) }
          def _binding; end

          # Is the current thread in binding mode?
          # 
          # _@return_ — If the thread is binding.
          # 
          # Is the current thread in binding mode?
          # ```ruby
          # proxy.binding?
          # ```
          sig { returns(T::Boolean) }
          def _binding?; end

          # Execute a block in building mode.
          # 
          # _@return_ — The return value of the block.
          # 
          # Execute in building mode.
          # ```ruby
          # _building do
          #   relation.push(doc)
          # end
          # ```
          sig { returns(Object) }
          def _building; end

          # Is the current thread in building mode?
          # 
          # _@return_ — If the thread is building.
          # 
          # Is the current thread in building mode?
          # ```ruby
          # proxy._building?
          # ```
          sig { returns(T::Boolean) }
          def _building?; end

          # Is the current thread in creating mode?
          # 
          # _@return_ — If the thread is creating.
          # 
          # Is the current thread in creating mode?
          # ```ruby
          # proxy.creating?
          # ```
          sig { returns(T::Boolean) }
          def _creating?; end

          # Execute a block in loading mode.
          # 
          # _@return_ — The return value of the block.
          # 
          # Execute in loading mode.
          # ```ruby
          # _loading do
          #   relation.push(doc)
          # end
          # ```
          sig { returns(Object) }
          def _loading; end

          # Is the current thread in loading mode?
          # 
          # _@return_ — If the thread is loading.
          # 
          # Is the current thread in loading mode?
          # ```ruby
          # proxy._loading?
          # ```
          sig { returns(T::Boolean) }
          def _loading?; end
        end
      end

      # The EmbeddedIn type association.
      # 
      # @since 7.0
      class EmbeddedIn
        include Mongoid::Association::Relatable
        include Mongoid::Association::Embedded::EmbeddedIn::Buildable
        ASSOCIATION_OPTIONS = T.let([
    :autobuild,
    :cyclic,
    :polymorphic,
    :touch,
].freeze, T.untyped)
        VALID_OPTIONS = T.let((ASSOCIATION_OPTIONS + SHARED_OPTIONS).freeze, T.untyped)
        SHARED_OPTIONS = T.let([
  :class_name,
  :inverse_of,
  :validate,
  :extend
].freeze, T.untyped)
        PRIMARY_KEY_DEFAULT = T.let('_id'.freeze, T.untyped)

        # Setup the instance methods, fields, etc. on the association owning class.
        sig { returns(T.self_type) }
        def setup!; end

        # Is this association type embedded?
        # 
        # _@return_ — Always true.
        sig { returns(T::Boolean) }
        def embedded?; end

        # The primary key
        # 
        # _@return_ — Not relevant for this association
        sig { returns(T.nilable(T.any())) }
        def primary_key; end

        # Does this association type store the foreign key?
        # 
        # _@return_ — Always false.
        sig { returns(T::Boolean) }
        def stores_foreign_key?; end

        # The default for validating the association object.
        # 
        # _@return_ — Always false.
        sig { returns(T::Boolean) }
        def validation_default; end

        # The key that is used to get the attributes for the associated object.
        # 
        # _@return_ — The name of the association.
        sig { returns(String) }
        def key; end

        # Get the association proxy class for this association type.
        # 
        # _@return_ — The proxy class.
        sig { returns(Association::Embedded::EmbeddedIn::Proxy) }
        def relation; end

        # Is this association polymorphic?
        # 
        # _@return_ — Whether this association is polymorphic.
        sig { returns(T::Boolean) }
        def polymorphic?; end

        # The nested builder object.
        # 
        # _@param_ `attributes` — The attributes to use to build the association object.
        # 
        # _@param_ `options` — The options for the association.
        # 
        # _@return_ — The Nested Builder object.
        sig { params(attributes: T::Hash[T.untyped, T.untyped], options: T::Hash[T.untyped, T.untyped]).returns(Association::Nested::One) }
        def nested_builder(attributes, options); end

                sig { returns(T.untyped) }
        def setup_instance_methods!; end

                sig { returns(T.untyped) }
        def relation_complements; end

                        sig { params(other: T.untyped).returns(T.untyped) }
        def polymorphic_inverses(other = nil); end

                        sig { params(other: T.untyped).returns(T.untyped) }
        def determine_inverses(other); end

        # This builder doesn't actually build anything, just returns the
        # parent since it should already be instantiated.
        # 
        # _@param_ `base` — The object.
        # 
        # _@param_ `object` — The parent hash or document.
        # 
        # _@param_ `type` — Not used in this context.
        # 
        # _@param_ `selected_fields` — Fields which were retrieved via #only. If selected_fields are specified, fields not listed in it will not be accessible in the built document.
        # 
        # _@return_ — A single document.
        # 
        # Build the document.
        # ```ruby
        # Builder.new(meta, attrs).build
        # ```
        sig do
          params(
            base: Object,
            object: Object,
            type: T.nilable(String),
            selected_fields: T.nilable(T::Hash[T.untyped, T.untyped])
          ).returns(Document)
        end
        def build(base, object, type = nil, selected_fields = nil); end

        # Begin the assignment of attributes. While in this block embedded
        # documents will not autosave themselves in order to allow the document to
        # be in a valid state.
        # 
        # _@return_ — The yielded value.
        # 
        # Execute the assignment.
        # ```ruby
        # _assigning do
        #   person.attributes = { :addresses => [ address ] }
        # end
        # ```
        sig { returns(Object) }
        def _assigning; end

        # Is the current thread in assigning mode?
        # 
        # _@return_ — If the thread is assigning.
        # 
        # Is the current thread in assigning mode?
        # ```ruby
        # proxy._assigning?
        # ```
        sig { returns(T::Boolean) }
        def _assigning?; end

        # Execute a block in binding mode.
        # 
        # _@return_ — The return value of the block.
        # 
        # Execute in binding mode.
        # ```ruby
        # binding do
        #   relation.push(doc)
        # end
        # ```
        sig { returns(Object) }
        def _binding; end

        # Is the current thread in binding mode?
        # 
        # _@return_ — If the thread is binding.
        # 
        # Is the current thread in binding mode?
        # ```ruby
        # proxy.binding?
        # ```
        sig { returns(T::Boolean) }
        def _binding?; end

        # Execute a block in building mode.
        # 
        # _@return_ — The return value of the block.
        # 
        # Execute in building mode.
        # ```ruby
        # _building do
        #   relation.push(doc)
        # end
        # ```
        sig { returns(Object) }
        def _building; end

        # Is the current thread in building mode?
        # 
        # _@return_ — If the thread is building.
        # 
        # Is the current thread in building mode?
        # ```ruby
        # proxy._building?
        # ```
        sig { returns(T::Boolean) }
        def _building?; end

        # Is the current thread in creating mode?
        # 
        # _@return_ — If the thread is creating.
        # 
        # Is the current thread in creating mode?
        # ```ruby
        # proxy.creating?
        # ```
        sig { returns(T::Boolean) }
        def _creating?; end

        # Execute a block in loading mode.
        # 
        # _@return_ — The return value of the block.
        # 
        # Execute in loading mode.
        # ```ruby
        # _loading do
        #   relation.push(doc)
        # end
        # ```
        sig { returns(Object) }
        def _loading; end

        # Is the current thread in loading mode?
        # 
        # _@return_ — If the thread is loading.
        # 
        # Is the current thread in loading mode?
        # ```ruby
        # proxy._loading?
        # ```
        sig { returns(T::Boolean) }
        def _loading?; end

        # Initialize the Association.
        # 
        # _@param_ `_class` — The class of the model who owns this association.
        # 
        # _@param_ `name` — The name of the association.
        # 
        # _@param_ `opts` — The association options.
        # 
        # _@param_ `block` — The optional block.
        sig do
          params(
            _class: Class,
            name: Symbol,
            opts: T::Hash[T.untyped, T.untyped],
            block: T.untyped
          ).void
        end
        def initialize(_class, name, opts = {}, &block); end

                # Compare this association to another.
        # 
        # _@return_ — The object to compare to this association.
        sig { params(other: T.untyped).returns(Object) }
        def ==(other); end

        # Get the callbacks for a given type.
        # 
        # _@param_ `callback_type` — The type of callback type.
        # 
        # _@return_ — A list of the callbacks, either method
        # names or Procs.
        sig { params(callback_type: Symbol).returns(T::Array[T.any(Proc, Symbol)]) }
        def get_callbacks(callback_type); end

        # Get the type setter.
        # 
        # _@return_ — The type setter method.
        # 
        # _@note_ — Only relevant for polymorphic associations that take the :as option.
        sig { returns(String) }
        def type_setter; end

        # Whether trying to bind an object using this association should raise
        # an error.
        # 
        # _@param_ `doc` — The document to be bound.
        # 
        # _@return_ — Whether the document can be bound.
        sig { params(doc: Document).returns(T::Boolean) }
        def bindable?(doc); end

        # Get the inverse names.
        # 
        # _@param_ `other` — The other model class or model object to use when determining inverses.
        # 
        # _@return_ — The list of inverse names.
        sig { params(other: T.nilable(Object)).returns(T::Array[Symbol]) }
        def inverses(other = nil); end

        # Get the inverse's association metadata.
        # 
        # _@param_ `other` — The other model class or model object to use when determining inverses.
        # 
        # _@return_ — The inverse's association metadata.
        sig { params(other: T.nilable(Object)).returns(Association) }
        def inverse_association(other = nil); end

        # Get the inverse type.
        # 
        # _@return_ — Default is nil for an association.
        sig { returns(T.nilable(T.any())) }
        def inverse_type; end

        # The class name, possibly unqualified or :: prefixed, of the association
        # object(s).
        # 
        # This method returns the class name as it is used in the association
        # definition. If :class_name option is given in the association, the
        # exact value of that option is returned here. If :class_name option is
        # not given, the name of the class is calculated from association name
        # but is not resolved to the actual class.
        # 
        # The class name returned by this method may not correspond to a defined
        # class, either because the corresponding class has not been loaded yet,
        # or because the association references a non-existent class altogether.
        # To obtain the association class, use +relation_class+ method.
        # 
        # _@return_ — The association objects' class name.
        # 
        # _@note_ — The return value of this method should not be used to determine
        # whether two associations have the same target class, because the
        # return value is not always a fully qualified class name. To compare
        # classes, retrieve the class instance of the association target using
        # the +relation_class+ method.
        sig { returns(String) }
        def relation_class_name; end

        # The class of the association object(s).
        # 
        # This method returns the class instance corresponding to
        # +relation_class_name+, resolved relative to the host document class.
        # 
        # If the class does not exist, this method raises NameError. This can
        # happen because the target class has not yet been defined. Note that
        # polymorphic associations generally do not have a well defined target
        # class because the target class can change from one object to another,
        # and calling this method on a polymorphic association will generally
        # fail with a NameError or produce misleading results (if a class does
        # happen to be defined with the same name as the association name).
        # 
        # _@return_ — The association objects' class.
        sig { returns(String) }
        def relation_class; end

        # The class name of the object owning this association.
        # 
        # _@return_ — The owning objects' class name.
        sig { returns(String) }
        def inverse_class_name; end

        # The class of the object owning this association.
        # 
        # _@return_ — The owning objects' class.
        sig { returns(String) }
        def inverse_class; end

        # The name of the setter on this object for assigning an associated object.
        # 
        # _@return_ — The setter name.
        sig { returns(String) }
        def setter; end

                # The name of the inverse setter method.
        # 
        # _@return_ — The name of the inverse setter.
        sig { params(other: T.untyped).returns(String) }
        def inverse_setter(other = nil); end

        # The name of the foreign key setter method.
        # 
        # _@return_ — The name of the foreign key setter.
        sig { returns(String) }
        def foreign_key_setter; end

                # The atomic path for this association.
        # 
        # _@return_ — The atomic path object.
        sig { params(document: T.untyped).returns(Mongoid::Atomic::Paths::Root) }
        def path(document); end

        # Gets the setter for the field that sets the type of document on a
        # polymorphic association.
        # 
        # _@return_ — The name of the setter.
        # 
        # Get the inverse type setter.
        # ```ruby
        # association.inverse_type_setter
        # ```
        sig { returns(String) }
        def inverse_type_setter; end

        # Get the name of the method to check if the foreign key has changed.
        # 
        # _@return_ — The foreign key check.
        # 
        # Get the foreign key check method.
        # ```ruby
        # association.foreign_key_check
        # ```
        sig { returns(String) }
        def foreign_key_check; end

        # Create an association proxy object using the owner and target.
        # 
        # _@param_ `owner` — The document this association hangs off of.
        # 
        # _@param_ `target` — The target (parent) of the association.
        sig { params(owner: Document, target: T.any(Document, T::Array[Document])).returns(Proxy) }
        def create_relation(owner, target); end

        # Whether the dependent method is destructive.
        # 
        # _@return_ — If the dependent method is destructive.
        sig { returns(T::Boolean) }
        def destructive?; end

        # Get the counter cache column name.
        # 
        # _@return_ — The counter cache column name.
        sig { returns(String) }
        def counter_cache_column_name; end

        # Get the extension.
        # 
        # _@return_ — The extension module, if one has been defined.
        sig { returns(Module) }
        def extension; end

                # Get the inverse name.
        # 
        # _@return_ — The inverse name.
        sig { params(other: T.untyped).returns(Symbol) }
        def inverse(other = nil); end

        # Whether the associated object(s) should be validated.
        # 
        # _@return_ — If the associated object(s)
        # should be validated.
        sig { returns(T::Boolean) }
        def validate?; end

                # Gets the model classes with inverse associations of this model. This is used to determine
        # the classes on the other end of polymorphic associations with models.
        sig { returns(T.untyped) }
        def inverse_association_classes; end

                sig { returns(T.untyped) }
        def setup_index!; end

                sig { returns(T.untyped) }
        def define_touchable!; end

                sig { returns(T.untyped) }
        def define_autosaver!; end

                sig { returns(T.untyped) }
        def define_builder!; end

                sig { returns(T.untyped) }
        def define_creator!; end

                sig { returns(T.untyped) }
        def define_getter!; end

                sig { returns(T.untyped) }
        def define_setter!; end

                sig { returns(T.untyped) }
        def define_existence_check!; end

                sig { returns(T.untyped) }
        def define_ids_getter!; end

                sig { returns(T.untyped) }
        def define_ids_setter!; end

                sig { returns(T.untyped) }
        def define_counter_cache_callbacks!; end

                sig { returns(T.untyped) }
        def define_dependency!; end

                sig { returns(T.untyped) }
        def validate!; end

                sig { returns(T.untyped) }
        def polymorph!; end

                sig { params(block: T.untyped).returns(T.untyped) }
        def create_extension!(&block); end

                sig { returns(T.untyped) }
        def default_inverse; end

                        # Returns an array of classes/modules forming the namespace hierarchy
        # where symbols referenced in the provided class/module would be looked
        # up by Ruby. For example, if mod is Foo::Bar, this method would return
        # [Foo::Bar, Foo, Object].
        sig { params(mod: T.untyped).returns(T.untyped) }
        def namespace_hierarchy(mod); end

                                # Resolves the given class/module name in the context of the specified
        # module, as Ruby would when a constant is referenced in the source.
        # 
        # _@note_ — This method can swallow exceptions produced during class loading,
        # because it rescues NameError internally. Since this method attempts
        # to load classes, failure during the loading process may also lead to
        # there being incomplete class definitions.
        sig { params(mod: T.untyped, name: T.untyped).returns(T.untyped) }
        def resolve_name(mod, name); end

        # Returns the name of the parent to a polymorphic child.
        # 
        # _@return_ — The name.
        sig { returns(T.any(String, Symbol)) }
        def as; end

        # Specify what happens to the associated object when the owner is destroyed.
        # 
        # _@return_ — The dependent option.
        sig { returns(String) }
        def dependent; end

        # The custom sorting options on the association.
        # 
        # _@return_ — The custom sorting options.
        sig { returns(Criteria::Queryable::Key) }
        def order; end

        # Whether to index the primary or foreign key field.
        sig { returns(T::Boolean) }
        def indexed?; end

        # Whether the association is autobuilding.
        sig { returns(T::Boolean) }
        def autobuilding?; end

        # Is the association cyclic.
        # 
        # _@return_ — Whether the association is cyclic.
        sig { returns(T::Boolean) }
        def cyclic?; end

        # The name the owning object uses to refer to this association.
        # 
        # _@return_ — The inverse_of option.
        sig { returns(String) }
        def inverse_of; end

        # Options to save any loaded members and destroy members that are marked for destruction
        # when the parent object is saved.
        # 
        # _@return_ — The autosave option.
        sig { returns(T::Boolean) }
        def autosave; end

        # Whether the association is counter-cached.
        sig { returns(T::Boolean) }
        def counter_cached?; end

        # Whether the association has callbacks cascaded down from the parent.
        # 
        # _@return_ — Whether callbacks are cascaded.
        sig { returns(T::Boolean) }
        def cascading_callbacks?; end

        # The store_as option.
        # 
        # _@return_ — Default is nil.
        sig { returns(T.nilable(T.any())) }
        def store_as; end

        # Whether the association has forced nil inverse (So no foreign keys are saved).
        # 
        # _@return_ — Default is false.
        sig { returns(T::Boolean) }
        def forced_nil_inverse?; end

        # The field for saving the associated object's type.
        # 
        # _@return_ — Default is nil.
        sig { returns(T.nilable(T.any())) }
        def type; end

        # The field for saving the associated object's type.
        # 
        # _@return_ — Default is nil.
        sig { returns(T.nilable(T.any())) }
        def touch_field; end

        sig { returns(T::Boolean) }
        def touchable?; end

        # Convert the supplied object to the appropriate type to set as the
        # foreign key for an association.
        # 
        # _@param_ `object` — The object to convert.
        # 
        # _@return_ — The object cast to the correct type.
        # 
        # Convert the object.
        # ```ruby
        # constraint.convert("12345")
        # ```
        sig { params(object: Object).returns(Object) }
        def convert_to_foreign_key(object); end

                        sig { params(object: T.untyped).returns(T.untyped) }
        def convert_polymorphic(object); end

        class Proxy < Mongoid::Association::One
          # Instantiate a new embedded_in association.
          # 
          # _@param_ `base` — The document the association hangs off of.
          # 
          # _@param_ `target` — The target (parent) of the association.
          # 
          # _@param_ `association` — The association metadata.
          # 
          # _@return_ — The proxy.
          # 
          # Create the new association.
          # ```ruby
          # Association::Embedded::EmbeddedIn.new(person, address, association)
          # ```
          sig { params(base: Document, target: Document, association: Association).void }
          def initialize(base, target, association); end

          # Substitutes the supplied target documents for the existing document
          # in the association.
          # 
          # _@param_ `replacement` — A document to replace the target.
          # 
          # _@return_ — The association or nil.
          # 
          # Substitute the new document.
          # ```ruby
          # person.name.substitute(new_name)
          # ```
          sig { params(replacement: Document).returns(T.nilable(Document)) }
          def substitute(replacement); end

          # sord warn - Binding wasn't able to be resolved to a constant in this project
          # Instantiate the binding associated with this association.
          # 
          # _@return_ — A binding object.
          # 
          # Get the binding.
          # ```ruby
          # binding([ address ])
          # ```
          sig { returns(Binding) }
          def binding; end

                    # Characterize the document.
          # 
          # _@param_ `document` — The document to set the association metadata on.
          # 
          # Set the base association.
          # ```ruby
          # object.characterize_one(document)
          # ```
          sig { params(document: Document).returns(T.untyped) }
          def characterize_one(document); end

          # Are we able to persist this association?
          # 
          # _@return_ — If the association is persistable.
          # 
          # Can we persist the association?
          # ```ruby
          # relation.persistable?
          # ```
          sig { returns(T::Boolean) }
          def persistable?; end

          # Returns true if the association is an embedded one. In this case
          # always true.
          # 
          # _@return_ — true.
          # 
          # Is this association embedded?
          # ```ruby
          # Association::Embedded::EmbeddedIn.embedded?
          # ```
          sig { returns(T::Boolean) }
          def self.embedded?; end

          # sord infer - Root was resolved to Mongoid::Atomic::Paths::Root
          # Get the path calculator for the supplied document.
          # 
          # _@param_ `document` — The document to calculate on.
          # 
          # _@return_ — The root atomic path calculator.
          # 
          # Get the path calculator.
          # ```ruby
          # Proxy.path(document)
          # ```
          sig { params(document: Document).returns(Mongoid::Atomic::Paths::Root) }
          def self.path(document); end
        end

        # The Binding object for embedded_in associations.
        # 
        # @since 7.0
        class Binding
          include Mongoid::Association::Bindable

                    # Binds the base object to the inverse of the association. This is so we
          # are referenced to the actual objects themselves on both sides.
          # 
          # This case sets the association metadata on the inverse object as well as the
          # document itself.
          # 
          # Bind the documents.
          # ```ruby
          # name.person.bind(:continue => true)
          # name.person = Person.new
          # ```
          sig { returns(T.untyped) }
          def bind_one; end

                    # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          # 
          # Unbind the document.
          # ```ruby
          # name.person.unbind(:continue => true)
          # name.person = nil
          # ```
          sig { returns(T.untyped) }
          def unbind_one; end

          # Create the new binding.
          # 
          # _@param_ `base` — The base of the binding.
          # 
          # _@param_ `target` — The target of the binding.
          # 
          # _@param_ `association` — The association metadata.
          # 
          # Initialize a binding.
          # ```ruby
          # Binding.new(base, target, association)
          # ```
          sig { params(base: Document, target: T.any(Document, T::Array[Document]), association: Association).void }
          def initialize(base, target, association); end

          # Execute the provided block inside a binding.
          # 
          # _@return_ — The result of the yield.
          # 
          # Execute the binding block.
          # ```ruby
          # binding.binding do
          #   base.foreign_key = 1
          # end
          # ```
          sig { returns(Object) }
          def binding; end

                    # Check if the inverse is properly defined.
          # 
          # _@param_ `doc` — The document getting bound.
          # 
          # Check the inverse definition.
          # ```ruby
          # binding.check_inverse!(doc)
          # ```
          sig { params(doc: Document).returns(T.untyped) }
          def check_inverse!(doc); end

                    # Set the id of the related document in the foreign key field on the
          # keyed document.
          # 
          # _@param_ `keyed` — The document that stores the foreign key.
          # 
          # _@param_ `id` — The id of the bound document.
          # 
          # Bind the foreign key.
          # ```ruby
          # binding.bind_foreign_key(post, person._id)
          # ```
          sig { params(keyed: Document, id: Object).returns(T.untyped) }
          def bind_foreign_key(keyed, id); end

                    # Set the type of the related document on the foreign type field, used
          # when associations are polymorphic.
          # 
          # _@param_ `typed` — The document that stores the type field.
          # 
          # _@param_ `name` — The name of the model.
          # 
          # Bind the polymorphic type.
          # ```ruby
          # binding.bind_polymorphic_type(post, "Person")
          # ```
          sig { params(typed: Document, name: String).returns(T.untyped) }
          def bind_polymorphic_type(typed, name); end

                    # Set the type of the related document on the foreign type field, used
          # when associations are polymorphic.
          # 
          # _@param_ `typed` — The document that stores the type field.
          # 
          # _@param_ `name` — The name of the model.
          # 
          # Bind the polymorphic type.
          # ```ruby
          # binding.bind_polymorphic_inverse_type(post, "Person")
          # ```
          sig { params(typed: Document, name: String).returns(T.untyped) }
          def bind_polymorphic_inverse_type(typed, name); end

                    # Bind the inverse document to the child document so that the in memory
          # instances are the same.
          # 
          # _@param_ `doc` — The base document.
          # 
          # _@param_ `inverse` — The inverse document.
          # 
          # Bind the inverse.
          # ```ruby
          # binding.bind_inverse(post, person)
          # ```
          sig { params(doc: Document, inverse: Document).returns(T.untyped) }
          def bind_inverse(doc, inverse); end

                    # Bind the provided document with the base from the parent association.
          # 
          # _@param_ `doc` — The document to bind.
          # 
          # Bind the document with the base.
          # ```ruby
          # binding.bind_from_relational_parent(doc)
          # ```
          sig { params(doc: Document).returns(T.untyped) }
          def bind_from_relational_parent(doc); end

                              sig { params(_base: T.untyped).returns(T.untyped) }
          def record_id(_base); end

          # Ensure that the association on the base is correct, for the cases
          # where we have multiple belongs to definitions and were are setting
          # different parents in memory in order.
          # 
          # _@return_ — If the association changed.
          # 
          # Set the base association.
          # ```ruby
          # binding.set_base_association
          # ```
          sig { returns(T::Boolean) }
          def set_base_association; end

                    # Bind the provided document with the base from the parent association.
          # 
          # _@param_ `doc` — The document to unbind.
          # 
          # Bind the document with the base.
          # ```ruby
          # unbinding.unbind_from_relational_parent(doc)
          # ```
          sig { params(doc: Document).returns(T.untyped) }
          def unbind_from_relational_parent(doc); end

          # Begin the assignment of attributes. While in this block embedded
          # documents will not autosave themselves in order to allow the document to
          # be in a valid state.
          # 
          # _@return_ — The yielded value.
          # 
          # Execute the assignment.
          # ```ruby
          # _assigning do
          #   person.attributes = { :addresses => [ address ] }
          # end
          # ```
          sig { returns(Object) }
          def _assigning; end

          # Is the current thread in assigning mode?
          # 
          # _@return_ — If the thread is assigning.
          # 
          # Is the current thread in assigning mode?
          # ```ruby
          # proxy._assigning?
          # ```
          sig { returns(T::Boolean) }
          def _assigning?; end

          # Execute a block in binding mode.
          # 
          # _@return_ — The return value of the block.
          # 
          # Execute in binding mode.
          # ```ruby
          # binding do
          #   relation.push(doc)
          # end
          # ```
          sig { returns(Object) }
          def _binding; end

          # Is the current thread in binding mode?
          # 
          # _@return_ — If the thread is binding.
          # 
          # Is the current thread in binding mode?
          # ```ruby
          # proxy.binding?
          # ```
          sig { returns(T::Boolean) }
          def _binding?; end

          # Execute a block in building mode.
          # 
          # _@return_ — The return value of the block.
          # 
          # Execute in building mode.
          # ```ruby
          # _building do
          #   relation.push(doc)
          # end
          # ```
          sig { returns(Object) }
          def _building; end

          # Is the current thread in building mode?
          # 
          # _@return_ — If the thread is building.
          # 
          # Is the current thread in building mode?
          # ```ruby
          # proxy._building?
          # ```
          sig { returns(T::Boolean) }
          def _building?; end

          # Is the current thread in creating mode?
          # 
          # _@return_ — If the thread is creating.
          # 
          # Is the current thread in creating mode?
          # ```ruby
          # proxy.creating?
          # ```
          sig { returns(T::Boolean) }
          def _creating?; end

          # Execute a block in loading mode.
          # 
          # _@return_ — The return value of the block.
          # 
          # Execute in loading mode.
          # ```ruby
          # _loading do
          #   relation.push(doc)
          # end
          # ```
          sig { returns(Object) }
          def _loading; end

          # Is the current thread in loading mode?
          # 
          # _@return_ — If the thread is loading.
          # 
          # Is the current thread in loading mode?
          # ```ruby
          # proxy._loading?
          # ```
          sig { returns(T::Boolean) }
          def _loading?; end
        end

        # The Builder behavior for embedded_in associations.
        # 
        # @since 7.0
        module Buildable
          include Mongoid::Threaded::Lifecycle

          # This builder doesn't actually build anything, just returns the
          # parent since it should already be instantiated.
          # 
          # _@param_ `base` — The object.
          # 
          # _@param_ `object` — The parent hash or document.
          # 
          # _@param_ `type` — Not used in this context.
          # 
          # _@param_ `selected_fields` — Fields which were retrieved via #only. If selected_fields are specified, fields not listed in it will not be accessible in the built document.
          # 
          # _@return_ — A single document.
          # 
          # Build the document.
          # ```ruby
          # Builder.new(meta, attrs).build
          # ```
          sig do
            params(
              base: Object,
              object: Object,
              type: T.nilable(String),
              selected_fields: T.nilable(T::Hash[T.untyped, T.untyped])
            ).returns(Document)
          end
          def build(base, object, type = nil, selected_fields = nil); end

          # Begin the assignment of attributes. While in this block embedded
          # documents will not autosave themselves in order to allow the document to
          # be in a valid state.
          # 
          # _@return_ — The yielded value.
          # 
          # Execute the assignment.
          # ```ruby
          # _assigning do
          #   person.attributes = { :addresses => [ address ] }
          # end
          # ```
          sig { returns(Object) }
          def _assigning; end

          # Is the current thread in assigning mode?
          # 
          # _@return_ — If the thread is assigning.
          # 
          # Is the current thread in assigning mode?
          # ```ruby
          # proxy._assigning?
          # ```
          sig { returns(T::Boolean) }
          def _assigning?; end

          # Execute a block in binding mode.
          # 
          # _@return_ — The return value of the block.
          # 
          # Execute in binding mode.
          # ```ruby
          # binding do
          #   relation.push(doc)
          # end
          # ```
          sig { returns(Object) }
          def _binding; end

          # Is the current thread in binding mode?
          # 
          # _@return_ — If the thread is binding.
          # 
          # Is the current thread in binding mode?
          # ```ruby
          # proxy.binding?
          # ```
          sig { returns(T::Boolean) }
          def _binding?; end

          # Execute a block in building mode.
          # 
          # _@return_ — The return value of the block.
          # 
          # Execute in building mode.
          # ```ruby
          # _building do
          #   relation.push(doc)
          # end
          # ```
          sig { returns(Object) }
          def _building; end

          # Is the current thread in building mode?
          # 
          # _@return_ — If the thread is building.
          # 
          # Is the current thread in building mode?
          # ```ruby
          # proxy._building?
          # ```
          sig { returns(T::Boolean) }
          def _building?; end

          # Is the current thread in creating mode?
          # 
          # _@return_ — If the thread is creating.
          # 
          # Is the current thread in creating mode?
          # ```ruby
          # proxy.creating?
          # ```
          sig { returns(T::Boolean) }
          def _creating?; end

          # Execute a block in loading mode.
          # 
          # _@return_ — The return value of the block.
          # 
          # Execute in loading mode.
          # ```ruby
          # _loading do
          #   relation.push(doc)
          # end
          # ```
          sig { returns(Object) }
          def _loading; end

          # Is the current thread in loading mode?
          # 
          # _@return_ — If the thread is loading.
          # 
          # Is the current thread in loading mode?
          # ```ruby
          # proxy._loading?
          # ```
          sig { returns(T::Boolean) }
          def _loading?; end
        end
      end

      # The EmbedsMany type association.
      # 
      # @since 7.0
      class EmbedsMany
        include Mongoid::Association::Relatable
        include Mongoid::Association::Embedded::EmbedsMany::Buildable
        ASSOCIATION_OPTIONS = T.let([
    :as,
    :cascade_callbacks,
    :cyclic,
    :order,
    :store_as,
    :before_add,
    :after_add,
    :before_remove,
    :after_remove
], T.untyped)
        VALID_OPTIONS = T.let((ASSOCIATION_OPTIONS + SHARED_OPTIONS).freeze, T.untyped)
        SHARED_OPTIONS = T.let([
  :class_name,
  :inverse_of,
  :validate,
  :extend
].freeze, T.untyped)
        PRIMARY_KEY_DEFAULT = T.let('_id'.freeze, T.untyped)

        # Setup the instance methods, fields, etc. on the association owning class.
        sig { returns(T.self_type) }
        def setup!; end

        # The field key used to store the list of association objects.
        # 
        # _@return_ — The field name.
        sig { returns(String) }
        def store_as; end

        # The key that is used to get the attributes for the associated object.
        # 
        # _@return_ — The name of the field used to store the association.
        sig { returns(String) }
        def key; end

        # Is this association type embedded?
        # 
        # _@return_ — Always true.
        sig { returns(T::Boolean) }
        def embedded?; end

        # Get the default validation setting for the association. Determines if
        # by default a validates associated will occur.
        # 
        # _@return_ — Always true.
        # 
        # Get the validation default.
        # ```ruby
        # Proxy.validation_default
        # ```
        sig { returns(T::Boolean) }
        def validation_default; end

        # Does this association type store the foreign key?
        # 
        # _@return_ — Always false.
        sig { returns(T::Boolean) }
        def stores_foreign_key?; end

        # The primary key
        # 
        # _@return_ — Not relevant for this association
        sig { returns(T.nilable(T.any())) }
        def primary_key; end

        # Get the association proxy class for this association type.
        # 
        # _@return_ — The proxy class.
        sig { returns(Association::Embedded::EmbedsMany::Proxy) }
        def relation; end

        # Is this association polymorphic?
        # 
        # _@return_ — Whether this association is polymorphic.
        sig { returns(T::Boolean) }
        def polymorphic?; end

        # The field used to store the type of the related object.
        # 
        # _@return_ — The field for storing the associated object's type.
        # 
        # _@note_ — Only relevant if the association is polymorphic.
        sig { returns(T.nilable(String)) }
        def type; end

        # The nested builder object.
        # 
        # _@param_ `attributes` — The attributes to use to build the association object.
        # 
        # _@param_ `options` — The options for the association.
        # 
        # _@return_ — The Nested Builder object.
        sig { params(attributes: T::Hash[T.untyped, T.untyped], options: T::Hash[T.untyped, T.untyped]).returns(Association::Nested::Many) }
        def nested_builder(attributes, options); end

        # Get the path calculator for the supplied document.
        # 
        # _@param_ `document` — The document to calculate on.
        # 
        # _@return_ — The embedded many atomic path calculator.
        # 
        # Get the path calculator.
        # ```ruby
        # Proxy.path(document)
        # ```
        sig { params(document: Document).returns(Mongoid::Atomic::Paths::Embedded::Many) }
        def path(document); end

                # Get a criteria object for searching given a parent and children documents.
        # 
        # _@param_ `base` — The base document.
        # 
        # _@param_ `target` — The children documents.
        sig { params(base: Document, target: Document).returns(T.untyped) }
        def criteria(base, target); end

                        sig { params(criteria: T.untyped).returns(T.untyped) }
        def apply_ordering(criteria); end

                sig { returns(T.untyped) }
        def setup_instance_methods!; end

                sig { returns(T.untyped) }
        def relation_complements; end

                        sig { params(other: T.untyped).returns(T.untyped) }
        def polymorphic_inverses(other = nil); end

                        sig { params(other: T.untyped).returns(T.untyped) }
        def determine_inverses(other); end

        # Builds the document out of the attributes using the provided
        # association metadata. Instantiates through the factory in order
        # to make sure subclasses and allocation are used if fitting. This
        # case will return many documents.
        # 
        # _@param_ `base` — The base object.
        # 
        # _@param_ `object` — The object to use to build the association.
        # 
        # _@param_ `type` — Not used in this context.
        # 
        # _@param_ `selected_fields` — Fields which were retrieved via #only. If selected_fields are specified, fields not listed in it will not be accessible in the built documents.
        # 
        # _@return_ — The documents.
        # 
        # Build the documents.
        # ```ruby
        # Builder.new(meta, attrs).build
        # ```
        sig do
          params(
            base: Object,
            object: Object,
            type: T.nilable(String),
            selected_fields: T.nilable(T::Hash[T.untyped, T.untyped])
          ).returns(T::Array[Document])
        end
        def build(base, object, type = nil, selected_fields = nil); end

        # Begin the assignment of attributes. While in this block embedded
        # documents will not autosave themselves in order to allow the document to
        # be in a valid state.
        # 
        # _@return_ — The yielded value.
        # 
        # Execute the assignment.
        # ```ruby
        # _assigning do
        #   person.attributes = { :addresses => [ address ] }
        # end
        # ```
        sig { returns(Object) }
        def _assigning; end

        # Is the current thread in assigning mode?
        # 
        # _@return_ — If the thread is assigning.
        # 
        # Is the current thread in assigning mode?
        # ```ruby
        # proxy._assigning?
        # ```
        sig { returns(T::Boolean) }
        def _assigning?; end

        # Execute a block in binding mode.
        # 
        # _@return_ — The return value of the block.
        # 
        # Execute in binding mode.
        # ```ruby
        # binding do
        #   relation.push(doc)
        # end
        # ```
        sig { returns(Object) }
        def _binding; end

        # Is the current thread in binding mode?
        # 
        # _@return_ — If the thread is binding.
        # 
        # Is the current thread in binding mode?
        # ```ruby
        # proxy.binding?
        # ```
        sig { returns(T::Boolean) }
        def _binding?; end

        # Execute a block in building mode.
        # 
        # _@return_ — The return value of the block.
        # 
        # Execute in building mode.
        # ```ruby
        # _building do
        #   relation.push(doc)
        # end
        # ```
        sig { returns(Object) }
        def _building; end

        # Is the current thread in building mode?
        # 
        # _@return_ — If the thread is building.
        # 
        # Is the current thread in building mode?
        # ```ruby
        # proxy._building?
        # ```
        sig { returns(T::Boolean) }
        def _building?; end

        # Is the current thread in creating mode?
        # 
        # _@return_ — If the thread is creating.
        # 
        # Is the current thread in creating mode?
        # ```ruby
        # proxy.creating?
        # ```
        sig { returns(T::Boolean) }
        def _creating?; end

        # Execute a block in loading mode.
        # 
        # _@return_ — The return value of the block.
        # 
        # Execute in loading mode.
        # ```ruby
        # _loading do
        #   relation.push(doc)
        # end
        # ```
        sig { returns(Object) }
        def _loading; end

        # Is the current thread in loading mode?
        # 
        # _@return_ — If the thread is loading.
        # 
        # Is the current thread in loading mode?
        # ```ruby
        # proxy._loading?
        # ```
        sig { returns(T::Boolean) }
        def _loading?; end

        # Initialize the Association.
        # 
        # _@param_ `_class` — The class of the model who owns this association.
        # 
        # _@param_ `name` — The name of the association.
        # 
        # _@param_ `opts` — The association options.
        # 
        # _@param_ `block` — The optional block.
        sig do
          params(
            _class: Class,
            name: Symbol,
            opts: T::Hash[T.untyped, T.untyped],
            block: T.untyped
          ).void
        end
        def initialize(_class, name, opts = {}, &block); end

                # Compare this association to another.
        # 
        # _@return_ — The object to compare to this association.
        sig { params(other: T.untyped).returns(Object) }
        def ==(other); end

        # Get the callbacks for a given type.
        # 
        # _@param_ `callback_type` — The type of callback type.
        # 
        # _@return_ — A list of the callbacks, either method
        # names or Procs.
        sig { params(callback_type: Symbol).returns(T::Array[T.any(Proc, Symbol)]) }
        def get_callbacks(callback_type); end

        # Get the type setter.
        # 
        # _@return_ — The type setter method.
        # 
        # _@note_ — Only relevant for polymorphic associations that take the :as option.
        sig { returns(String) }
        def type_setter; end

        # Whether trying to bind an object using this association should raise
        # an error.
        # 
        # _@param_ `doc` — The document to be bound.
        # 
        # _@return_ — Whether the document can be bound.
        sig { params(doc: Document).returns(T::Boolean) }
        def bindable?(doc); end

        # Get the inverse names.
        # 
        # _@param_ `other` — The other model class or model object to use when determining inverses.
        # 
        # _@return_ — The list of inverse names.
        sig { params(other: T.nilable(Object)).returns(T::Array[Symbol]) }
        def inverses(other = nil); end

        # Get the inverse's association metadata.
        # 
        # _@param_ `other` — The other model class or model object to use when determining inverses.
        # 
        # _@return_ — The inverse's association metadata.
        sig { params(other: T.nilable(Object)).returns(Association) }
        def inverse_association(other = nil); end

        # Get the inverse type.
        # 
        # _@return_ — Default is nil for an association.
        sig { returns(T.nilable(T.any())) }
        def inverse_type; end

        # The class name, possibly unqualified or :: prefixed, of the association
        # object(s).
        # 
        # This method returns the class name as it is used in the association
        # definition. If :class_name option is given in the association, the
        # exact value of that option is returned here. If :class_name option is
        # not given, the name of the class is calculated from association name
        # but is not resolved to the actual class.
        # 
        # The class name returned by this method may not correspond to a defined
        # class, either because the corresponding class has not been loaded yet,
        # or because the association references a non-existent class altogether.
        # To obtain the association class, use +relation_class+ method.
        # 
        # _@return_ — The association objects' class name.
        # 
        # _@note_ — The return value of this method should not be used to determine
        # whether two associations have the same target class, because the
        # return value is not always a fully qualified class name. To compare
        # classes, retrieve the class instance of the association target using
        # the +relation_class+ method.
        sig { returns(String) }
        def relation_class_name; end

        # The class of the association object(s).
        # 
        # This method returns the class instance corresponding to
        # +relation_class_name+, resolved relative to the host document class.
        # 
        # If the class does not exist, this method raises NameError. This can
        # happen because the target class has not yet been defined. Note that
        # polymorphic associations generally do not have a well defined target
        # class because the target class can change from one object to another,
        # and calling this method on a polymorphic association will generally
        # fail with a NameError or produce misleading results (if a class does
        # happen to be defined with the same name as the association name).
        # 
        # _@return_ — The association objects' class.
        sig { returns(String) }
        def relation_class; end

        # The class name of the object owning this association.
        # 
        # _@return_ — The owning objects' class name.
        sig { returns(String) }
        def inverse_class_name; end

        # The class of the object owning this association.
        # 
        # _@return_ — The owning objects' class.
        sig { returns(String) }
        def inverse_class; end

        # The name of the setter on this object for assigning an associated object.
        # 
        # _@return_ — The setter name.
        sig { returns(String) }
        def setter; end

                # The name of the inverse setter method.
        # 
        # _@return_ — The name of the inverse setter.
        sig { params(other: T.untyped).returns(String) }
        def inverse_setter(other = nil); end

        # The name of the foreign key setter method.
        # 
        # _@return_ — The name of the foreign key setter.
        sig { returns(String) }
        def foreign_key_setter; end

        # Gets the setter for the field that sets the type of document on a
        # polymorphic association.
        # 
        # _@return_ — The name of the setter.
        # 
        # Get the inverse type setter.
        # ```ruby
        # association.inverse_type_setter
        # ```
        sig { returns(String) }
        def inverse_type_setter; end

        # Get the name of the method to check if the foreign key has changed.
        # 
        # _@return_ — The foreign key check.
        # 
        # Get the foreign key check method.
        # ```ruby
        # association.foreign_key_check
        # ```
        sig { returns(String) }
        def foreign_key_check; end

        # Create an association proxy object using the owner and target.
        # 
        # _@param_ `owner` — The document this association hangs off of.
        # 
        # _@param_ `target` — The target (parent) of the association.
        sig { params(owner: Document, target: T.any(Document, T::Array[Document])).returns(Proxy) }
        def create_relation(owner, target); end

        # Whether the dependent method is destructive.
        # 
        # _@return_ — If the dependent method is destructive.
        sig { returns(T::Boolean) }
        def destructive?; end

        # Get the counter cache column name.
        # 
        # _@return_ — The counter cache column name.
        sig { returns(String) }
        def counter_cache_column_name; end

        # Get the extension.
        # 
        # _@return_ — The extension module, if one has been defined.
        sig { returns(Module) }
        def extension; end

                # Get the inverse name.
        # 
        # _@return_ — The inverse name.
        sig { params(other: T.untyped).returns(Symbol) }
        def inverse(other = nil); end

        # Whether the associated object(s) should be validated.
        # 
        # _@return_ — If the associated object(s)
        # should be validated.
        sig { returns(T::Boolean) }
        def validate?; end

                # Gets the model classes with inverse associations of this model. This is used to determine
        # the classes on the other end of polymorphic associations with models.
        sig { returns(T.untyped) }
        def inverse_association_classes; end

                sig { returns(T.untyped) }
        def setup_index!; end

                sig { returns(T.untyped) }
        def define_touchable!; end

                sig { returns(T.untyped) }
        def define_autosaver!; end

                sig { returns(T.untyped) }
        def define_builder!; end

                sig { returns(T.untyped) }
        def define_creator!; end

                sig { returns(T.untyped) }
        def define_getter!; end

                sig { returns(T.untyped) }
        def define_setter!; end

                sig { returns(T.untyped) }
        def define_existence_check!; end

                sig { returns(T.untyped) }
        def define_ids_getter!; end

                sig { returns(T.untyped) }
        def define_ids_setter!; end

                sig { returns(T.untyped) }
        def define_counter_cache_callbacks!; end

                sig { returns(T.untyped) }
        def define_dependency!; end

                sig { returns(T.untyped) }
        def validate!; end

                sig { returns(T.untyped) }
        def polymorph!; end

                sig { params(block: T.untyped).returns(T.untyped) }
        def create_extension!(&block); end

                sig { returns(T.untyped) }
        def default_inverse; end

                        # Returns an array of classes/modules forming the namespace hierarchy
        # where symbols referenced in the provided class/module would be looked
        # up by Ruby. For example, if mod is Foo::Bar, this method would return
        # [Foo::Bar, Foo, Object].
        sig { params(mod: T.untyped).returns(T.untyped) }
        def namespace_hierarchy(mod); end

                                # Resolves the given class/module name in the context of the specified
        # module, as Ruby would when a constant is referenced in the source.
        # 
        # _@note_ — This method can swallow exceptions produced during class loading,
        # because it rescues NameError internally. Since this method attempts
        # to load classes, failure during the loading process may also lead to
        # there being incomplete class definitions.
        sig { params(mod: T.untyped, name: T.untyped).returns(T.untyped) }
        def resolve_name(mod, name); end

        # Returns the name of the parent to a polymorphic child.
        # 
        # _@return_ — The name.
        sig { returns(T.any(String, Symbol)) }
        def as; end

        # Specify what happens to the associated object when the owner is destroyed.
        # 
        # _@return_ — The dependent option.
        sig { returns(String) }
        def dependent; end

        # The custom sorting options on the association.
        # 
        # _@return_ — The custom sorting options.
        sig { returns(Criteria::Queryable::Key) }
        def order; end

        # Whether to index the primary or foreign key field.
        sig { returns(T::Boolean) }
        def indexed?; end

        # Whether the association is autobuilding.
        sig { returns(T::Boolean) }
        def autobuilding?; end

        # Is the association cyclic.
        # 
        # _@return_ — Whether the association is cyclic.
        sig { returns(T::Boolean) }
        def cyclic?; end

        # The name the owning object uses to refer to this association.
        # 
        # _@return_ — The inverse_of option.
        sig { returns(String) }
        def inverse_of; end

        # Options to save any loaded members and destroy members that are marked for destruction
        # when the parent object is saved.
        # 
        # _@return_ — The autosave option.
        sig { returns(T::Boolean) }
        def autosave; end

        # Whether the association is counter-cached.
        sig { returns(T::Boolean) }
        def counter_cached?; end

        # Whether the association has callbacks cascaded down from the parent.
        # 
        # _@return_ — Whether callbacks are cascaded.
        sig { returns(T::Boolean) }
        def cascading_callbacks?; end

        # Whether the association has forced nil inverse (So no foreign keys are saved).
        # 
        # _@return_ — Default is false.
        sig { returns(T::Boolean) }
        def forced_nil_inverse?; end

        # The field for saving the associated object's type.
        # 
        # _@return_ — Default is nil.
        sig { returns(T.nilable(T.any())) }
        def touch_field; end

        sig { returns(T::Boolean) }
        def touchable?; end

        # Convert the supplied object to the appropriate type to set as the
        # foreign key for an association.
        # 
        # _@param_ `object` — The object to convert.
        # 
        # _@return_ — The object cast to the correct type.
        # 
        # Convert the object.
        # ```ruby
        # constraint.convert("12345")
        # ```
        sig { params(object: Object).returns(Object) }
        def convert_to_foreign_key(object); end

                        sig { params(object: T.untyped).returns(T.untyped) }
        def convert_polymorphic(object); end

        class Proxy < Mongoid::Association::Many
          include Mongoid::Association::Embedded::Batchable

                    # Appends a document or array of documents to the association. Will set
          # the parent and update the index in the process.
          # 
          # _@param_ `args` — Any number of documents.
          # 
          # Append a document.
          # ```ruby
          # person.addresses << address
          # ```
          # 
          # Push a document.
          # ```ruby
          # person.addresses.push(address)
          # ```
          sig { params(args: T.any(Document, T::Array[Document])).returns(T.untyped) }
          def <<(*args); end

          # Get this association as as its representation in the database.
          # 
          # _@return_ — The association as stored in the db.
          # 
          # Convert the association to an attributes hash.
          # ```ruby
          # person.addresses.as_document
          # ```
          sig { returns(T::Array[T::Hash[T.untyped, T.untyped]]) }
          def as_document; end

          # Appends an array of documents to the association. Performs a batch
          # insert of the documents instead of persisting one at a time.
          # 
          # _@param_ `docs` — The docs to add.
          # 
          # _@return_ — The documents.
          # 
          # Concat with other documents.
          # ```ruby
          # person.addresses.concat([ address_one, address_two ])
          # ```
          sig { params(docs: T::Array[Document]).returns(T::Array[Document]) }
          def concat(docs); end

          # Builds a new document in the association and appends it to the target.
          # Takes an optional type if you want to specify a subclass.
          # 
          # _@param_ `attributes` — The attributes to build the document with.
          # 
          # _@param_ `type` — Optional class to build the document with.
          # 
          # _@return_ — The new document.
          # 
          # Build a new document on the association.
          # ```ruby
          # person.people.build(:name => "Bozo")
          # ```
          sig { params(attributes: T::Hash[T.untyped, T.untyped], type: T.nilable(Class)).returns(Document) }
          def build(attributes = {}, type = nil); end

          # Clear the association. Will delete the documents from the db if they are
          # already persisted.
          # 
          # _@return_ — The empty association.
          # 
          # Clear the association.
          # ```ruby
          # person.addresses.clear
          # ```
          sig { returns(T.self_type) }
          def clear; end

          # Returns a count of the number of documents in the association that have
          # actually been persisted to the database.
          # 
          # Use #size if you want the total number of documents.
          # 
          # _@return_ — The total number of persisted embedded docs, as
          # flagged by the #persisted? method.
          # 
          # Get the count of persisted documents.
          # ```ruby
          # person.addresses.count
          # ```
          sig { returns(Integer) }
          def count; end

          # Delete the supplied document from the target. This method is proxied
          # in order to reindex the array after the operation occurs.
          # 
          # _@param_ `document` — The document to be deleted.
          # 
          # _@return_ — The deleted document or nil if nothing deleted.
          # 
          # Delete the document from the association.
          # ```ruby
          # person.addresses.delete(address)
          # ```
          sig { params(document: Document).returns(T.nilable(Document)) }
          def delete(document); end

          # Delete all the documents in the association without running callbacks.
          # 
          # _@param_ `conditions` — Conditions on which documents to delete.
          # 
          # _@return_ — The number of documents deleted.
          # 
          # Delete all documents from the association.
          # ```ruby
          # person.addresses.delete_all
          # ```
          # 
          # Conditionally delete documents from the association.
          # ```ruby
          # person.addresses.delete_all({ :street => "Bond" })
          # ```
          sig { params(conditions: T::Hash[T.untyped, T.untyped]).returns(Integer) }
          def delete_all(conditions = {}); end

          # Delete all the documents for which the provided block returns true.
          # 
          # _@return_ — The association or an enumerator if no
          # block was provided.
          # 
          # Delete the matching documents.
          # ```ruby
          # person.addresses.delete_if do |doc|
          #   doc.state == "GA"
          # end
          # ```
          sig { returns(T.any(Many, T::Enumerator[T.untyped])) }
          def delete_if; end

          # Destroy all the documents in the association whilst running callbacks.
          # 
          # _@param_ `conditions` — Conditions on which documents to destroy.
          # 
          # _@return_ — The number of documents destroyed.
          # 
          # Destroy all documents from the association.
          # ```ruby
          # person.addresses.destroy_all
          # ```
          # 
          # Conditionally destroy documents from the association.
          # ```ruby
          # person.addresses.destroy_all({ :street => "Bond" })
          # ```
          sig { params(conditions: T::Hash[T.untyped, T.untyped]).returns(Integer) }
          def destroy_all(conditions = {}); end

          # Determine if any documents in this association exist in the database.
          # 
          # _@return_ — True is persisted documents exist, false if not.
          # 
          # Are there persisted documents?
          # ```ruby
          # person.posts.exists?
          # ```
          sig { returns(T::Boolean) }
          def exists?; end

          # Finds a document in this association through several different
          # methods.
          # 
          # _@param_ `args` — Various arguments.
          # 
          # _@return_ — A single or multiple documents.
          # 
          # Find a document by its id.
          # ```ruby
          # person.addresses.find(BSON::ObjectId.new)
          # ```
          # 
          # Find documents for multiple ids.
          # ```ruby
          # person.addresses.find([ BSON::ObjectId.new, BSON::ObjectId.new ])
          # ```
          sig { params(args: T::Array[Object]).returns(T.any(T::Array[Document], Document)) }
          def find(*args); end

          # Instantiate a new embeds_many association.
          # 
          # _@param_ `base` — The document this association hangs off of.
          # 
          # _@param_ `target` — The child documents of the association.
          # 
          # _@param_ `association` — The association metadata
          # 
          # _@return_ — The proxy.
          # 
          # Create the new association.
          # ```ruby
          # Many.new(person, addresses, association)
          # ```
          sig { params(base: Document, target: T::Array[Document], association: Association).void }
          def initialize(base, target, association); end

          # Get all the documents in the association that are loaded into memory.
          # 
          # _@return_ — The documents in memory.
          # 
          # Get the in memory documents.
          # ```ruby
          # relation.in_memory
          # ```
          sig { returns(T::Array[Document]) }
          def in_memory; end

          # Pop documents off the association. This can be a single document or
          # multiples, and will automatically persist the changes.
          # 
          # _@param_ `count` — The number of documents to pop, or 1 if not provided.
          # 
          # _@return_ — The popped document(s).
          # 
          # Pop a single document.
          # ```ruby
          # relation.pop
          # ```
          # 
          # Pop multiple documents.
          # ```ruby
          # relation.pop(3)
          # ```
          sig { params(count: T.nilable(Integer)).returns(T.any(Document, T::Array[Document])) }
          def pop(count = nil); end

          # Shift documents off the association. This can be a single document or
          # multiples, and will automatically persist the changes.
          # 
          # _@param_ `count` — The number of documents to shift, or 1 if not provided.
          # 
          # _@return_ — The shifted document(s).
          # 
          # Shift a single document.
          # ```ruby
          # relation.shift
          # ```
          # 
          # Shift multiple documents.
          # ```ruby
          # relation.shift(3)
          # ```
          sig { params(count: T.nilable(Integer)).returns(T.any(Document, T::Array[Document])) }
          def shift(count = nil); end

          # Substitutes the supplied target documents for the existing documents
          # in the relation.
          # 
          # _@param_ `docs` — The replacement docs.
          # 
          # _@return_ — The proxied association.
          # 
          # Substitute the association's target.
          # ```ruby
          # person.addresses.substitute([ address ])
          # ```
          sig { params(docs: T::Array[Document]).returns(Many) }
          def substitute(docs); end

          # Return the association with all previous scoping removed. This is the
          # exact representation of the docs in the database.
          # 
          # _@return_ — The unscoped association.
          # 
          # Get the unscoped documents.
          # ```ruby
          # person.addresses.unscoped
          # ```
          sig { returns(Criteria) }
          def unscoped; end

                    sig { params(document: T.untyped).returns(T::Boolean) }
          def object_already_related?(document); end

                    # Appends the document to the target array, updating the index on the
          # document at the same time.
          # 
          # _@param_ `document` — The document to append to the target.
          # 
          # Append to the document.
          # ```ruby
          # relation.append(document)
          # ```
          sig { params(document: Document).returns(T.untyped) }
          def append(document); end

          # sord warn - Binding wasn't able to be resolved to a constant in this project
          # Instantiate the binding associated with this association.
          # 
          # _@return_ — The many binding.
          # 
          # Create the binding.
          # ```ruby
          # relation.binding([ address ])
          # ```
          sig { returns(Binding) }
          def binding; end

          # Returns the +Criteria+ object for the target class with its
          # documents set to the list of target documents in the association.
          # 
          # _@return_ — A new criteria.
          sig { returns(Criteria) }
          def criteria; end

                    # Deletes one document from the target and unscoped.
          # 
          # _@param_ `document` — The document to delete.
          # 
          # Delete one document.
          # ```ruby
          # relation.delete_one(doc)
          # ```
          sig { params(document: Document).returns(T.untyped) }
          def delete_one(document); end

                    # Integrate the document into the association. will set its metadata and
          # attempt to bind the inverse.
          # 
          # _@param_ `document` — The document to integrate.
          # 
          # Integrate the document.
          # ```ruby
          # relation.integrate(document)
          # ```
          sig { params(document: Document).returns(T.untyped) }
          def integrate(document); end

          # If the target array does not respond to the supplied method then try to
          # find a named scope or criteria on the class and send the call there.
          # 
          # If the method exists on the array, use the default proxy behavior.
          # 
          # _@param_ `name` — The name of the method.
          # 
          # _@param_ `args` — The method args
          # 
          # _@param_ `block` — Optional block to pass.
          # 
          # _@return_ — A Criteria or return value from the target.
          sig { params(name: T.any(Symbol, String), args: T::Array[T.untyped], block: T.untyped).returns(T.any(Criteria, Object)) }
          def method_missing(name, *args, &block); end

          # Are we able to persist this association?
          # 
          # _@return_ — If the association is persistable.
          # 
          # Can we persist the association?
          # ```ruby
          # relation.persistable?
          # ```
          sig { returns(T::Boolean) }
          def persistable?; end

                    # Reindex all the target elements. This is useful when performing
          # operations on the proxied target directly and the indices need to
          # match that on the database side.
          # 
          # Reindex the association.
          # ```ruby
          # person.addresses.reindex
          # ```
          sig { returns(T.untyped) }
          def reindex; end

          # Apply the association ordering and default scoping (defined on
          # association's target class) to the provided documents.
          # 
          # _@param_ `docs` — The documents to scope.
          # 
          # _@return_ — The scoped docs.
          # 
          # Apply scoping.
          # ```ruby
          # person.addresses.scope(target)
          # ```
          sig { params(docs: T::Array[Document]).returns(T::Array[Document]) }
          def scope(docs); end

          # Remove all documents from the association, either with a delete or a
          # destroy depending on what this was called through.
          # 
          # _@param_ `conditions` — Conditions to filter by.
          # 
          # _@param_ `method` — :delete or :destroy.
          # 
          # _@return_ — The number of documents removed.
          # 
          # Destroy documents from the association.
          # ```ruby
          # relation.remove_all({ :num => 1 }, true)
          # ```
          sig { params(conditions: T::Hash[T.untyped, T.untyped], method: T::Boolean).returns(Integer) }
          def remove_all(conditions = {}, method = :delete); end

          # Get the internal unscoped documents.
          # 
          # _@return_ — The unscoped documents.
          # 
          # Get the unscoped documents.
          # ```ruby
          # relation._unscoped
          # ```
          sig { returns(T::Array[Document]) }
          def _unscoped; end

          # Set the internal unscoped documents.
          # 
          # _@param_ `docs` — The documents.
          # 
          # _@return_ — The unscoped docs.
          # 
          # Set the unscoped documents.
          # ```ruby
          # relation._unscoped = docs
          # ```
          sig { params(docs: T::Array[Document]).returns(T::Array[Document]) }
          def _unscoped=(docs); end

                    sig { returns(T.untyped) }
          def as_attributes; end

          # Returns true if the association is an embedded one. In this case
          # always true.
          # 
          # _@return_ — true.
          # 
          # Is the association embedded?
          # ```ruby
          # Association::Embedded::EmbedsMany.embedded?
          # ```
          sig { returns(T::Boolean) }
          def self.embedded?; end

          # Returns the suffix of the foreign key field, either "_id" or "_ids".
          # 
          # _@return_ — nil.
          # 
          # Get the suffix for the foreign key.
          # ```ruby
          # Association::Embedded::EmbedsMany.foreign_key_suffix
          # ```
          sig { returns(T.nilable(T.any())) }
          def self.foreign_key_suffix; end

          # Insert new documents as a batch push ($push with $each). This ensures that
          # all callbacks are run at the appropriate time and only 1 request is
          # made to the database.
          # 
          # _@param_ `docs` — The docs to add.
          # 
          # _@return_ — The inserts.
          # 
          # Execute the batch push.
          # ```ruby
          # batchable.batch_insert([ doc_one, doc_two ])
          # ```
          sig { params(docs: T::Array[Document]).returns(T::Array[T::Hash[T.untyped, T.untyped]]) }
          def batch_insert(docs); end

          # Clear all of the docs out of the association in a single swipe.
          # 
          # _@param_ `docs` — The docs to clear.
          # 
          # _@return_ — The empty array.
          # 
          # Clear all docs.
          # ```ruby
          # batchable.batch_clear(docs)
          # ```
          sig { params(docs: T::Array[Document]).returns(T::Array[T.untyped]) }
          def batch_clear(docs); end

                    # Batch remove the provided documents as a $pullAll.
          # 
          # _@param_ `docs` — The docs to remove.
          # 
          # _@param_ `method` — Delete or destroy.
          # 
          # Batch remove the documents.
          # ```ruby
          # batchable.batch_remove([ doc_one, doc_two ])
          # ```
          sig { params(docs: T::Array[Document], method: Symbol).returns(T.untyped) }
          def batch_remove(docs, method = :delete); end

          # Batch replace the provided documents as a $set.
          # 
          # _@param_ `docs` — The docs to replace with.
          # 
          # _@return_ — The inserts.
          # 
          # Batch replace the documents.
          # ```ruby
          # batchable.batch_replace([ doc_one, doc_two ])
          # ```
          sig { params(docs: T::Array[Document]).returns(T::Array[T::Hash[T.untyped, T.untyped]]) }
          def batch_replace(docs); end

                    # Add the atomic sets to the base document.
          # 
          # _@param_ `sets` — The atomic sets.
          # 
          # Add the atomic sets.
          # ```ruby
          # batchable.add_atomic_sets([{ field: value }])
          # ```
          sig { params(sets: T::Array[T::Hash[T.untyped, T.untyped]]).returns(T.untyped) }
          def add_atomic_sets(sets); end

          # Perform a batch persist of the provided documents with a $set.
          # 
          # _@param_ `docs` — The docs to persist.
          # 
          # _@return_ — The inserts.
          # 
          # Perform a batch $set.
          # ```ruby
          # batchable.execute_batch_set(docs)
          # ```
          sig { params(docs: T::Array[Document]).returns(T::Array[T::Hash[T.untyped, T.untyped]]) }
          def execute_batch_set(docs); end

          # Perform a batch persist of the provided documents with $push and $each.
          # 
          # _@param_ `docs` — The docs to persist.
          # 
          # _@return_ — The inserts.
          # 
          # Perform a batch push.
          # ```ruby
          # batchable.execute_batch_push(docs)
          # ```
          sig { params(docs: T::Array[Document]).returns(T::Array[T::Hash[T.untyped, T.untyped]]) }
          def execute_batch_push(docs); end

          # Are we in a state to be able to batch insert?
          # 
          # _@return_ — If inserts can be performed.
          # 
          # Can inserts be performed?
          # ```ruby
          # batchable.insertable?
          # ```
          sig { returns(T::Boolean) }
          def insertable?; end

          # Are the inserts currently valid?
          # 
          # _@return_ — If inserts are currently valid.
          # 
          # Are the inserts currently valid.
          # ```ruby
          # batchable.inserts_valid
          # ```
          sig { returns(T::Boolean) }
          def inserts_valid; end

          # Set the inserts valid flag.
          # 
          # _@param_ `value` — The flag.
          # 
          # _@return_ — The flag.
          # 
          # Set the flag.
          # ```ruby
          # batchable.inserts_valid = true
          # ```
          sig { params(value: T::Boolean).returns(T::Boolean) }
          def inserts_valid=(value); end

          # Normalize the documents, in case they were provided as an array of
          # hashes.
          # 
          # _@param_ `docs` — The docs to normalize.
          # 
          # _@return_ — The docs.
          # 
          # Normalize the docs.
          # ```ruby
          # batchable.normalize_docs(docs)
          # ```
          sig { params(docs: T::Array[T.any(T::Hash[T.untyped, T.untyped], Document)]).returns(T::Array[Document]) }
          def normalize_docs(docs); end

          # Get the atomic path.
          # 
          # _@return_ — The atomic path.
          # 
          # Get the atomic path.
          # ```ruby
          # batchable.path
          # ```
          sig { returns(String) }
          def path; end

          # Set the atomic path.
          # 
          # _@param_ `value` — The path.
          # 
          # _@return_ — The path.
          # 
          # Set the atomic path.
          # ```ruby
          # batchable.path = "addresses"
          # ```
          sig { params(value: String).returns(String) }
          def path=(value); end

          # Get the selector for executing atomic operations on the collection.
          # 
          # _@return_ — The atomic selector.
          # 
          # Get the selector.
          # ```ruby
          # batchable.selector
          # ```
          sig { returns(T::Hash[T.untyped, T.untyped]) }
          def selector; end

          # Pre processes the batch insert for the provided documents.
          # 
          # _@param_ `docs` — The documents.
          # 
          # _@return_ — The documents as an array of hashes.
          # 
          # Pre process the documents.
          # ```ruby
          # batchable.pre_process_batch_insert(docs)
          # ```
          sig { params(docs: T::Array[Document]).returns(T::Array[T::Hash[T.untyped, T.untyped]]) }
          def pre_process_batch_insert(docs); end

          # Pre process the batch removal.
          # 
          # _@param_ `docs` — The documents.
          # 
          # _@param_ `method` — Delete or destroy.
          # 
          # _@return_ — The documents as hashes.
          # 
          # Pre process the documents.
          # ```ruby
          # batchable.pre_process_batch_remove(docs, :delete)
          # ```
          sig { params(docs: T::Array[Document], method: Symbol).returns(T::Array[T::Hash[T.untyped, T.untyped]]) }
          def pre_process_batch_remove(docs, method); end

          # sord warn - Documents wasn't able to be resolved to a constant in this project
          # Post process the documents after batch insert.
          # 
          # _@param_ `docs` — The inserted docs.
          # 
          # _@return_ — The document enum.
          # 
          # Post process the documents.
          # ```ruby
          # batchable.post_process_batch_insert(docs)
          # ```
          sig { params(docs: T::Array[Document]).returns(T::Enumerable[T.untyped]) }
          def post_process_batch_insert(docs); end

          # Post process the batch removal.
          # 
          # _@param_ `docs` — The documents.
          # 
          # _@param_ `method` — Delete or destroy.
          # 
          # _@return_ — The documents.
          # 
          # Post process the documents.
          # ```ruby
          # batchable.post_process_batch_remove(docs, :delete)
          # ```
          sig { params(docs: T::Array[Document], method: Symbol).returns(T::Array[Document]) }
          def post_process_batch_remove(docs, method); end

          # Takes the provided selector and atomic operations and replaces the
          # indexes of the embedded documents with the positional operator when
          # needed.
          # 
          # _@param_ `selector` — The selector.
          # 
          # _@param_ `operations` — The update operations.
          # 
          # _@param_ `processed` — The processed update operations.
          # 
          # _@return_ — The new operations.
          # 
          # Process the operations.
          # ```ruby
          # positionally(
          #   { "_id" => 1, "addresses._id" => 2 },
          #   { "$set" => { "addresses.0.street" => "hobrecht" }}
          # )
          # ```
          # 
          # _@note_ — The only time we can accurately know when to use the positional
          # operator is at the exact time we are going to persist something. So
          # we can tell by the selector that we are sending if it is actually
          # possible to use the positional operator at all. For example, if the
          # selector is: { "_id" => 1 }, then we could not use the positional
          # operator for updating embedded documents since there would never be a
          # match - we base whether we can based on the number of levels deep the
          # selector goes, and if the id values are not nil.
          sig { params(selector: T::Hash[T.untyped, T.untyped], operations: T::Hash[T.untyped, T.untyped], processed: T::Hash[T.untyped, T.untyped]).returns(T::Hash[T.untyped, T.untyped]) }
          def positionally(selector, operations, processed = {}); end

                                                  sig { params(keys: T.untyped, operations: T.untyped, processed: T.untyped).returns(T.untyped) }
          def process_operations(keys, operations, processed); end

                                                  sig { params(keys: T.untyped, update: T.untyped, updates: T.untyped).returns(T.untyped) }
          def process_updates(keys, update, updates = {}); end

                                        sig { params(keys: T.untyped, position: T.untyped).returns(T.untyped) }
          def replace_index(keys, position); end
        end

        # Binding class for all embeds_many associations.
        # 
        # @since 7.0
        class Binding
          include Mongoid::Association::Bindable

                    # Binds a single document with the inverse association. Used
          # specifically when appending to the proxy.
          # 
          # _@param_ `doc` — The single document to bind.
          # 
          # Bind one document.
          # ```ruby
          # person.addresses.bind_one(address)
          # ```
          sig { params(doc: Document).returns(T.untyped) }
          def bind_one(doc); end

                    # Unbind a single document.
          # 
          # _@param_ `doc` — The single document to unbind.
          # 
          # Unbind the document.
          # ```ruby
          # person.addresses.unbind_one(document)
          # ```
          sig { params(doc: Document).returns(T.untyped) }
          def unbind_one(doc); end

          # Create the new binding.
          # 
          # _@param_ `base` — The base of the binding.
          # 
          # _@param_ `target` — The target of the binding.
          # 
          # _@param_ `association` — The association metadata.
          # 
          # Initialize a binding.
          # ```ruby
          # Binding.new(base, target, association)
          # ```
          sig { params(base: Document, target: T.any(Document, T::Array[Document]), association: Association).void }
          def initialize(base, target, association); end

          # Execute the provided block inside a binding.
          # 
          # _@return_ — The result of the yield.
          # 
          # Execute the binding block.
          # ```ruby
          # binding.binding do
          #   base.foreign_key = 1
          # end
          # ```
          sig { returns(Object) }
          def binding; end

                    # Check if the inverse is properly defined.
          # 
          # _@param_ `doc` — The document getting bound.
          # 
          # Check the inverse definition.
          # ```ruby
          # binding.check_inverse!(doc)
          # ```
          sig { params(doc: Document).returns(T.untyped) }
          def check_inverse!(doc); end

                    # Set the id of the related document in the foreign key field on the
          # keyed document.
          # 
          # _@param_ `keyed` — The document that stores the foreign key.
          # 
          # _@param_ `id` — The id of the bound document.
          # 
          # Bind the foreign key.
          # ```ruby
          # binding.bind_foreign_key(post, person._id)
          # ```
          sig { params(keyed: Document, id: Object).returns(T.untyped) }
          def bind_foreign_key(keyed, id); end

                    # Set the type of the related document on the foreign type field, used
          # when associations are polymorphic.
          # 
          # _@param_ `typed` — The document that stores the type field.
          # 
          # _@param_ `name` — The name of the model.
          # 
          # Bind the polymorphic type.
          # ```ruby
          # binding.bind_polymorphic_type(post, "Person")
          # ```
          sig { params(typed: Document, name: String).returns(T.untyped) }
          def bind_polymorphic_type(typed, name); end

                    # Set the type of the related document on the foreign type field, used
          # when associations are polymorphic.
          # 
          # _@param_ `typed` — The document that stores the type field.
          # 
          # _@param_ `name` — The name of the model.
          # 
          # Bind the polymorphic type.
          # ```ruby
          # binding.bind_polymorphic_inverse_type(post, "Person")
          # ```
          sig { params(typed: Document, name: String).returns(T.untyped) }
          def bind_polymorphic_inverse_type(typed, name); end

                    # Bind the inverse document to the child document so that the in memory
          # instances are the same.
          # 
          # _@param_ `doc` — The base document.
          # 
          # _@param_ `inverse` — The inverse document.
          # 
          # Bind the inverse.
          # ```ruby
          # binding.bind_inverse(post, person)
          # ```
          sig { params(doc: Document, inverse: Document).returns(T.untyped) }
          def bind_inverse(doc, inverse); end

                    # Bind the provided document with the base from the parent association.
          # 
          # _@param_ `doc` — The document to bind.
          # 
          # Bind the document with the base.
          # ```ruby
          # binding.bind_from_relational_parent(doc)
          # ```
          sig { params(doc: Document).returns(T.untyped) }
          def bind_from_relational_parent(doc); end

                              sig { params(_base: T.untyped).returns(T.untyped) }
          def record_id(_base); end

          # Ensure that the association on the base is correct, for the cases
          # where we have multiple belongs to definitions and were are setting
          # different parents in memory in order.
          # 
          # _@return_ — If the association changed.
          # 
          # Set the base association.
          # ```ruby
          # binding.set_base_association
          # ```
          sig { returns(T::Boolean) }
          def set_base_association; end

                    # Bind the provided document with the base from the parent association.
          # 
          # _@param_ `doc` — The document to unbind.
          # 
          # Bind the document with the base.
          # ```ruby
          # unbinding.unbind_from_relational_parent(doc)
          # ```
          sig { params(doc: Document).returns(T.untyped) }
          def unbind_from_relational_parent(doc); end

          # Begin the assignment of attributes. While in this block embedded
          # documents will not autosave themselves in order to allow the document to
          # be in a valid state.
          # 
          # _@return_ — The yielded value.
          # 
          # Execute the assignment.
          # ```ruby
          # _assigning do
          #   person.attributes = { :addresses => [ address ] }
          # end
          # ```
          sig { returns(Object) }
          def _assigning; end

          # Is the current thread in assigning mode?
          # 
          # _@return_ — If the thread is assigning.
          # 
          # Is the current thread in assigning mode?
          # ```ruby
          # proxy._assigning?
          # ```
          sig { returns(T::Boolean) }
          def _assigning?; end

          # Execute a block in binding mode.
          # 
          # _@return_ — The return value of the block.
          # 
          # Execute in binding mode.
          # ```ruby
          # binding do
          #   relation.push(doc)
          # end
          # ```
          sig { returns(Object) }
          def _binding; end

          # Is the current thread in binding mode?
          # 
          # _@return_ — If the thread is binding.
          # 
          # Is the current thread in binding mode?
          # ```ruby
          # proxy.binding?
          # ```
          sig { returns(T::Boolean) }
          def _binding?; end

          # Execute a block in building mode.
          # 
          # _@return_ — The return value of the block.
          # 
          # Execute in building mode.
          # ```ruby
          # _building do
          #   relation.push(doc)
          # end
          # ```
          sig { returns(Object) }
          def _building; end

          # Is the current thread in building mode?
          # 
          # _@return_ — If the thread is building.
          # 
          # Is the current thread in building mode?
          # ```ruby
          # proxy._building?
          # ```
          sig { returns(T::Boolean) }
          def _building?; end

          # Is the current thread in creating mode?
          # 
          # _@return_ — If the thread is creating.
          # 
          # Is the current thread in creating mode?
          # ```ruby
          # proxy.creating?
          # ```
          sig { returns(T::Boolean) }
          def _creating?; end

          # Execute a block in loading mode.
          # 
          # _@return_ — The return value of the block.
          # 
          # Execute in loading mode.
          # ```ruby
          # _loading do
          #   relation.push(doc)
          # end
          # ```
          sig { returns(Object) }
          def _loading; end

          # Is the current thread in loading mode?
          # 
          # _@return_ — If the thread is loading.
          # 
          # Is the current thread in loading mode?
          # ```ruby
          # proxy._loading?
          # ```
          sig { returns(T::Boolean) }
          def _loading?; end
        end

        # Builder class for embeds_many associations.
        # 
        # @since 7.0
        module Buildable
          include Mongoid::Threaded::Lifecycle

          # Builds the document out of the attributes using the provided
          # association metadata. Instantiates through the factory in order
          # to make sure subclasses and allocation are used if fitting. This
          # case will return many documents.
          # 
          # _@param_ `base` — The base object.
          # 
          # _@param_ `object` — The object to use to build the association.
          # 
          # _@param_ `type` — Not used in this context.
          # 
          # _@param_ `selected_fields` — Fields which were retrieved via #only. If selected_fields are specified, fields not listed in it will not be accessible in the built documents.
          # 
          # _@return_ — The documents.
          # 
          # Build the documents.
          # ```ruby
          # Builder.new(meta, attrs).build
          # ```
          sig do
            params(
              base: Object,
              object: Object,
              type: T.nilable(String),
              selected_fields: T.nilable(T::Hash[T.untyped, T.untyped])
            ).returns(T::Array[Document])
          end
          def build(base, object, type = nil, selected_fields = nil); end

          # Begin the assignment of attributes. While in this block embedded
          # documents will not autosave themselves in order to allow the document to
          # be in a valid state.
          # 
          # _@return_ — The yielded value.
          # 
          # Execute the assignment.
          # ```ruby
          # _assigning do
          #   person.attributes = { :addresses => [ address ] }
          # end
          # ```
          sig { returns(Object) }
          def _assigning; end

          # Is the current thread in assigning mode?
          # 
          # _@return_ — If the thread is assigning.
          # 
          # Is the current thread in assigning mode?
          # ```ruby
          # proxy._assigning?
          # ```
          sig { returns(T::Boolean) }
          def _assigning?; end

          # Execute a block in binding mode.
          # 
          # _@return_ — The return value of the block.
          # 
          # Execute in binding mode.
          # ```ruby
          # binding do
          #   relation.push(doc)
          # end
          # ```
          sig { returns(Object) }
          def _binding; end

          # Is the current thread in binding mode?
          # 
          # _@return_ — If the thread is binding.
          # 
          # Is the current thread in binding mode?
          # ```ruby
          # proxy.binding?
          # ```
          sig { returns(T::Boolean) }
          def _binding?; end

          # Execute a block in building mode.
          # 
          # _@return_ — The return value of the block.
          # 
          # Execute in building mode.
          # ```ruby
          # _building do
          #   relation.push(doc)
          # end
          # ```
          sig { returns(Object) }
          def _building; end

          # Is the current thread in building mode?
          # 
          # _@return_ — If the thread is building.
          # 
          # Is the current thread in building mode?
          # ```ruby
          # proxy._building?
          # ```
          sig { returns(T::Boolean) }
          def _building?; end

          # Is the current thread in creating mode?
          # 
          # _@return_ — If the thread is creating.
          # 
          # Is the current thread in creating mode?
          # ```ruby
          # proxy.creating?
          # ```
          sig { returns(T::Boolean) }
          def _creating?; end

          # Execute a block in loading mode.
          # 
          # _@return_ — The return value of the block.
          # 
          # Execute in loading mode.
          # ```ruby
          # _loading do
          #   relation.push(doc)
          # end
          # ```
          sig { returns(Object) }
          def _loading; end

          # Is the current thread in loading mode?
          # 
          # _@return_ — If the thread is loading.
          # 
          # Is the current thread in loading mode?
          # ```ruby
          # proxy._loading?
          # ```
          sig { returns(T::Boolean) }
          def _loading?; end
        end
      end
    end

    module Referenced
      module Eager
        # Base class for eager load preload functions.
        # 
        # @since 4.0.0
        class Base
          # Instantiate the eager load class.
          # 
          # _@param_ `associations` — Associations to eager load
          # 
          # _@param_ `docs` — Documents to preload the associations
          # 
          # _@return_ — The eager load preloader
          # 
          # Create the new belongs to eager load preloader.
          # ```ruby
          # BelongsTo.new(association, parent_docs)
          # ```
          sig { params(associations: T::Array[Association], docs: T::Array[Document]).void }
          def initialize(associations, docs); end

          # Run the preloader.
          # 
          # _@return_ — The list of documents given.
          # 
          # Preload the associations into the documents.
          # ```ruby
          # loader.run
          # ```
          sig { returns(T::Array[T.untyped]) }
          def run; end

                    # Preload the current association.
          # 
          # This method should be implemented in the subclass
          # 
          # Preload the current association into the documents.
          # ```ruby
          # loader.preload
          # ```
          sig { returns(T.untyped) }
          def preload; end

                    # Retrieves the documents referenced by the association, and
          # yields each one sequentially to the provided block. If the
          # association is not polymorphic, all documents are retrieved in
          # a single query. If the association is polymorphic, one query is
          # issued per association target class.
          sig { params(block: T.untyped).returns(T.untyped) }
          def each_loaded_document(&block); end

                                        # Retrieves the documents of the specified class, that have the
          # foreign key included in the specified list of keys.
          # 
          # When the documents are retrieved, the set of inclusions applied
          # is the set of inclusions applied to the host document minus the
          # association that is being eagerly loaded.
          sig { params(cls: T.untyped, keys: T.untyped).returns(T.untyped) }
          def each_loaded_document_of_class(cls, keys); end

          # sord infer - ObjectId was resolved to BSON::ObjectId
                    # Set the pre-loaded document into its parent.
          # 
          # _@param_ `id` — parent`s id
          # 
          # _@param_ `element` — to push into the parent
          # 
          # Set docs into parent with pk = "foo"
          # ```ruby
          # loader.set_on_parent("foo", docs)
          # ```
          sig { params(id: BSON::ObjectId, element: T.any(Document, T::Array[T.untyped])).returns(T.untyped) }
          def set_on_parent(id, element); end

          # Return a hash with the current documents grouped by key.
          # 
          # Documents that do not have a value for the association being loaded
          # are not returned.
          # 
          # _@return_ — hash with grouped documents.
          # 
          # Return a hash with the current documents grouped by key.
          # ```ruby
          # loader.grouped_docs
          # ```
          sig { returns(T::Hash[T.untyped, T.untyped]) }
          def grouped_docs; end

          # Group the documents and return the keys.
          # 
          # This method omits nil keys (i.e. keys from documents that do not
          # have a value for the association being loaded).
          # 
          # _@return_ — keys, ids
          # 
          # ```ruby
          # loader.keys_from_docs
          # ```
          sig { returns(T::Array[T.untyped]) }
          def keys_from_docs; end

          # Return the key to group the current documents.
          # 
          # This method should be implemented in the subclass
          # 
          # _@return_ — Key to group by the current documents.
          # 
          # Return the key for group
          # ```ruby
          # loader.group_by_key
          # ```
          sig { returns(Symbol) }
          def group_by_key; end

                    # Set the pre-loaded document into its parent.
          # 
          # _@param_ `doc` — The object to set the association on
          # 
          # _@param_ `element` — to set into the parent
          # 
          # Set docs into parent using the current association name.
          # ```ruby
          # loader.set_relation(doc, docs)
          # ```
          sig { params(doc: Document, element: T.any(Document, T::Array[T.untyped])).returns(T.untyped) }
          def set_relation(doc, element); end

          # Shift the current association metadata
          # 
          # _@return_ — The association object.
          # 
          # Shift the current association.
          # ```ruby
          # loader.shift_association
          # ```
          sig { returns(Association) }
          def shift_association; end
        end
      end

      # The has_one association.
      # 
      # @since 7.0
      class HasOne
        include Mongoid::Association::Relatable
        include Mongoid::Association::Referenced::HasOne::Buildable
        ASSOCIATION_OPTIONS = T.let([
    :as,
    :autobuild,
    :autosave,
    :dependent,
    :foreign_key,
    :primary_key
].freeze, T.untyped)
        VALID_OPTIONS = T.let((ASSOCIATION_OPTIONS + SHARED_OPTIONS).freeze, T.untyped)
        FOREIGN_KEY_SUFFIX = T.let('_id'.freeze, T.untyped)
        SHARED_OPTIONS = T.let([
  :class_name,
  :inverse_of,
  :validate,
  :extend
].freeze, T.untyped)
        PRIMARY_KEY_DEFAULT = T.let('_id'.freeze, T.untyped)

        # The list of association complements.
        # 
        # _@return_ — The association complements.
        sig { returns(T::Array[Association]) }
        def relation_complements; end

        # Setup the instance methods, fields, etc. on the association owning class.
        sig { returns(T.self_type) }
        def setup!; end

        # Get the foreign key field for saving the association reference.
        # 
        # _@return_ — The foreign key field for saving the
        # association reference.
        sig { returns(String) }
        def foreign_key; end

        # Is this association type embedded?
        # 
        # _@return_ — Always false.
        sig { returns(T::Boolean) }
        def embedded?; end

        # The default for validation the association object.
        # 
        # _@return_ — Always true.
        sig { returns(T::Boolean) }
        def validation_default; end

        # sord warn - Association::HasOne::Proxy wasn't able to be resolved to a constant in this project
        # Get the association proxy class for this association type.
        # 
        # _@return_ — The proxy class.
        sig { returns(Mongoid::Association::Referenced::HasOne::Proxy) }
        def relation; end

        # The nested builder object.
        # 
        # _@param_ `attributes` — The attributes to use to build the association object.
        # 
        # _@param_ `options` — The options for the association.
        # 
        # _@return_ — The Nested Builder object.
        sig { params(attributes: T::Hash[T.untyped, T.untyped], options: T::Hash[T.untyped, T.untyped]).returns(Association::Nested::Many) }
        def nested_builder(attributes, options); end

        # Is this association polymorphic?
        # 
        # _@return_ — Whether this association is polymorphic.
        sig { returns(T::Boolean) }
        def polymorphic?; end

        # The type of this association if it's polymorphic.
        # 
        # _@return_ — The type field.
        # 
        # _@note_ — Only relevant for polymorphic associations.
        sig { returns(T.nilable(String)) }
        def type; end

        # Whether trying to bind an object using this association should raise
        # an error.
        # 
        # _@param_ `doc` — The document to be bound.
        # 
        # _@return_ — Whether the document can be bound.
        sig { params(doc: Document).returns(T::Boolean) }
        def bindable?(doc); end

        sig { returns(T::Boolean) }
        def stores_foreign_key?; end

        # sord infer - Root was resolved to Mongoid::Atomic::Paths::Root
        # Get the path calculator for the supplied document.
        # 
        # _@param_ `document` — The document to calculate on.
        # 
        # _@return_ — The root atomic path calculator.
        # 
        # Get the path calculator.
        # ```ruby
        # Proxy.path(document)
        # ```
        sig { params(document: Document).returns(Mongoid::Atomic::Paths::Root) }
        def path(document); end

        # Setup the instance methods on the class having this association type.
        sig { returns(T.self_type) }
        def setup_instance_methods!; end

                sig { returns(T.untyped) }
        def default_foreign_key_field; end

                        sig { params(other: T.untyped).returns(T.untyped) }
        def polymorphic_inverses(other); end

                        sig { params(other: T.untyped).returns(T.untyped) }
        def determine_inverses(other); end

                sig { returns(T.untyped) }
        def default_primary_key; end

        # This method either takes an _id or an object and queries for the
        # inverse side using the id or sets the object after clearing the
        # associated object.
        # 
        # _@param_ `base` — The base object.
        # 
        # _@param_ `object` — The object to use to build the association.
        # 
        # _@param_ `type` — The type of the association.
        # 
        # _@param_ `selected_fields` — Must be nil.
        # 
        # _@return_ — A single document.
        sig do
          params(
            base: Object,
            object: Object,
            type: T.nilable(String),
            selected_fields: T.nilable(T.any())
          ).returns(Document)
        end
        def build(base, object, type = nil, selected_fields = nil); end

                        sig { params(object: T.untyped).returns(T.untyped) }
        def clear_associated(object); end

                                sig { params(object: T.untyped, base: T.untyped).returns(T.untyped) }
        def query_criteria(object, base); end

                                sig { params(object: T.untyped, base: T.untyped).returns(T.untyped) }
        def execute_query(object, base); end

                                sig { params(criteria: T.untyped, base: T.untyped).returns(T.untyped) }
        def with_polymorphic_criterion(criteria, base); end

                sig { params(object: T.untyped).returns(T::Boolean) }
        def query?(object); end

        # Initialize the Association.
        # 
        # _@param_ `_class` — The class of the model who owns this association.
        # 
        # _@param_ `name` — The name of the association.
        # 
        # _@param_ `opts` — The association options.
        # 
        # _@param_ `block` — The optional block.
        sig do
          params(
            _class: Class,
            name: Symbol,
            opts: T::Hash[T.untyped, T.untyped],
            block: T.untyped
          ).void
        end
        def initialize(_class, name, opts = {}, &block); end

                # Compare this association to another.
        # 
        # _@return_ — The object to compare to this association.
        sig { params(other: T.untyped).returns(Object) }
        def ==(other); end

        # Get the callbacks for a given type.
        # 
        # _@param_ `callback_type` — The type of callback type.
        # 
        # _@return_ — A list of the callbacks, either method
        # names or Procs.
        sig { params(callback_type: Symbol).returns(T::Array[T.any(Proc, Symbol)]) }
        def get_callbacks(callback_type); end

        # Get the type setter.
        # 
        # _@return_ — The type setter method.
        # 
        # _@note_ — Only relevant for polymorphic associations that take the :as option.
        sig { returns(String) }
        def type_setter; end

        # Get the inverse names.
        # 
        # _@param_ `other` — The other model class or model object to use when determining inverses.
        # 
        # _@return_ — The list of inverse names.
        sig { params(other: T.nilable(Object)).returns(T::Array[Symbol]) }
        def inverses(other = nil); end

        # Get the inverse's association metadata.
        # 
        # _@param_ `other` — The other model class or model object to use when determining inverses.
        # 
        # _@return_ — The inverse's association metadata.
        sig { params(other: T.nilable(Object)).returns(Association) }
        def inverse_association(other = nil); end

        # Get the inverse type.
        # 
        # _@return_ — Default is nil for an association.
        sig { returns(T.nilable(T.any())) }
        def inverse_type; end

        # The class name, possibly unqualified or :: prefixed, of the association
        # object(s).
        # 
        # This method returns the class name as it is used in the association
        # definition. If :class_name option is given in the association, the
        # exact value of that option is returned here. If :class_name option is
        # not given, the name of the class is calculated from association name
        # but is not resolved to the actual class.
        # 
        # The class name returned by this method may not correspond to a defined
        # class, either because the corresponding class has not been loaded yet,
        # or because the association references a non-existent class altogether.
        # To obtain the association class, use +relation_class+ method.
        # 
        # _@return_ — The association objects' class name.
        # 
        # _@note_ — The return value of this method should not be used to determine
        # whether two associations have the same target class, because the
        # return value is not always a fully qualified class name. To compare
        # classes, retrieve the class instance of the association target using
        # the +relation_class+ method.
        sig { returns(String) }
        def relation_class_name; end

        # The class of the association object(s).
        # 
        # This method returns the class instance corresponding to
        # +relation_class_name+, resolved relative to the host document class.
        # 
        # If the class does not exist, this method raises NameError. This can
        # happen because the target class has not yet been defined. Note that
        # polymorphic associations generally do not have a well defined target
        # class because the target class can change from one object to another,
        # and calling this method on a polymorphic association will generally
        # fail with a NameError or produce misleading results (if a class does
        # happen to be defined with the same name as the association name).
        # 
        # _@return_ — The association objects' class.
        sig { returns(String) }
        def relation_class; end

        # The class name of the object owning this association.
        # 
        # _@return_ — The owning objects' class name.
        sig { returns(String) }
        def inverse_class_name; end

        # The class of the object owning this association.
        # 
        # _@return_ — The owning objects' class.
        sig { returns(String) }
        def inverse_class; end

        # The foreign key field if this association stores a foreign key.
        # Otherwise, the primary key.
        # 
        # _@return_ — The primary key.
        sig { returns(T.any(Symbol, String)) }
        def key; end

        # The name of the setter on this object for assigning an associated object.
        # 
        # _@return_ — The setter name.
        sig { returns(String) }
        def setter; end

                # The name of the inverse setter method.
        # 
        # _@return_ — The name of the inverse setter.
        sig { params(other: T.untyped).returns(String) }
        def inverse_setter(other = nil); end

        # The name of the foreign key setter method.
        # 
        # _@return_ — The name of the foreign key setter.
        sig { returns(String) }
        def foreign_key_setter; end

        # Gets the setter for the field that sets the type of document on a
        # polymorphic association.
        # 
        # _@return_ — The name of the setter.
        # 
        # Get the inverse type setter.
        # ```ruby
        # association.inverse_type_setter
        # ```
        sig { returns(String) }
        def inverse_type_setter; end

        # Get the name of the method to check if the foreign key has changed.
        # 
        # _@return_ — The foreign key check.
        # 
        # Get the foreign key check method.
        # ```ruby
        # association.foreign_key_check
        # ```
        sig { returns(String) }
        def foreign_key_check; end

        # Create an association proxy object using the owner and target.
        # 
        # _@param_ `owner` — The document this association hangs off of.
        # 
        # _@param_ `target` — The target (parent) of the association.
        sig { params(owner: Document, target: T.any(Document, T::Array[Document])).returns(Proxy) }
        def create_relation(owner, target); end

        # Whether the dependent method is destructive.
        # 
        # _@return_ — If the dependent method is destructive.
        sig { returns(T::Boolean) }
        def destructive?; end

        # Get the counter cache column name.
        # 
        # _@return_ — The counter cache column name.
        sig { returns(String) }
        def counter_cache_column_name; end

        # Get the extension.
        # 
        # _@return_ — The extension module, if one has been defined.
        sig { returns(Module) }
        def extension; end

                # Get the inverse name.
        # 
        # _@return_ — The inverse name.
        sig { params(other: T.untyped).returns(Symbol) }
        def inverse(other = nil); end

        # Whether the associated object(s) should be validated.
        # 
        # _@return_ — If the associated object(s)
        # should be validated.
        sig { returns(T::Boolean) }
        def validate?; end

                # Gets the model classes with inverse associations of this model. This is used to determine
        # the classes on the other end of polymorphic associations with models.
        sig { returns(T.untyped) }
        def inverse_association_classes; end

                sig { returns(T.untyped) }
        def setup_index!; end

                sig { returns(T.untyped) }
        def define_touchable!; end

                sig { returns(T.untyped) }
        def define_autosaver!; end

                sig { returns(T.untyped) }
        def define_builder!; end

                sig { returns(T.untyped) }
        def define_creator!; end

                sig { returns(T.untyped) }
        def define_getter!; end

                sig { returns(T.untyped) }
        def define_setter!; end

                sig { returns(T.untyped) }
        def define_existence_check!; end

                sig { returns(T.untyped) }
        def define_ids_getter!; end

                sig { returns(T.untyped) }
        def define_ids_setter!; end

                sig { returns(T.untyped) }
        def define_counter_cache_callbacks!; end

                sig { returns(T.untyped) }
        def define_dependency!; end

                sig { returns(T.untyped) }
        def validate!; end

                sig { returns(T.untyped) }
        def polymorph!; end

                sig { params(block: T.untyped).returns(T.untyped) }
        def create_extension!(&block); end

                sig { returns(T.untyped) }
        def default_inverse; end

                        # Returns an array of classes/modules forming the namespace hierarchy
        # where symbols referenced in the provided class/module would be looked
        # up by Ruby. For example, if mod is Foo::Bar, this method would return
        # [Foo::Bar, Foo, Object].
        sig { params(mod: T.untyped).returns(T.untyped) }
        def namespace_hierarchy(mod); end

                                # Resolves the given class/module name in the context of the specified
        # module, as Ruby would when a constant is referenced in the source.
        # 
        # _@note_ — This method can swallow exceptions produced during class loading,
        # because it rescues NameError internally. Since this method attempts
        # to load classes, failure during the loading process may also lead to
        # there being incomplete class definitions.
        sig { params(mod: T.untyped, name: T.untyped).returns(T.untyped) }
        def resolve_name(mod, name); end

        # Returns the name of the parent to a polymorphic child.
        # 
        # _@return_ — The name.
        sig { returns(T.any(String, Symbol)) }
        def as; end

        # Specify what happens to the associated object when the owner is destroyed.
        # 
        # _@return_ — The dependent option.
        sig { returns(String) }
        def dependent; end

        # The custom sorting options on the association.
        # 
        # _@return_ — The custom sorting options.
        sig { returns(Criteria::Queryable::Key) }
        def order; end

        # Whether to index the primary or foreign key field.
        sig { returns(T::Boolean) }
        def indexed?; end

        # Whether the association is autobuilding.
        sig { returns(T::Boolean) }
        def autobuilding?; end

        # Is the association cyclic.
        # 
        # _@return_ — Whether the association is cyclic.
        sig { returns(T::Boolean) }
        def cyclic?; end

        # The name the owning object uses to refer to this association.
        # 
        # _@return_ — The inverse_of option.
        sig { returns(String) }
        def inverse_of; end

        # Mongoid assumes that the field used to hold the primary key of the association is id.
        # You can override this and explicitly specify the primary key with the :primary_key option.
        # 
        # _@return_ — The primary key.
        sig { returns(T.any(Symbol, String)) }
        def primary_key; end

        # Options to save any loaded members and destroy members that are marked for destruction
        # when the parent object is saved.
        # 
        # _@return_ — The autosave option.
        sig { returns(T::Boolean) }
        def autosave; end

        # Whether the association is counter-cached.
        sig { returns(T::Boolean) }
        def counter_cached?; end

        # Whether the association has callbacks cascaded down from the parent.
        # 
        # _@return_ — Whether callbacks are cascaded.
        sig { returns(T::Boolean) }
        def cascading_callbacks?; end

        # The store_as option.
        # 
        # _@return_ — Default is nil.
        sig { returns(T.nilable(T.any())) }
        def store_as; end

        # Whether the association has forced nil inverse (So no foreign keys are saved).
        # 
        # _@return_ — Default is false.
        sig { returns(T::Boolean) }
        def forced_nil_inverse?; end

        # The field for saving the associated object's type.
        # 
        # _@return_ — Default is nil.
        sig { returns(T.nilable(T.any())) }
        def touch_field; end

        sig { returns(T::Boolean) }
        def touchable?; end

        # Convert the supplied object to the appropriate type to set as the
        # foreign key for an association.
        # 
        # _@param_ `object` — The object to convert.
        # 
        # _@return_ — The object cast to the correct type.
        # 
        # Convert the object.
        # ```ruby
        # constraint.convert("12345")
        # ```
        sig { params(object: Object).returns(Object) }
        def convert_to_foreign_key(object); end

                        sig { params(object: T.untyped).returns(T.untyped) }
        def convert_polymorphic(object); end

        class Eager < Mongoid::Association::Referenced::Eager::Base
                    sig { returns(T.untyped) }
          def preload; end

                    sig { returns(T.untyped) }
          def group_by_key; end

                    sig { returns(T.untyped) }
          def key; end
        end

        # This class defines the behavior for all associations that are a
        # one-to-one between documents in different collections.
        class Proxy < Mongoid::Association::One
          # Instantiate a new references_one association. Will set the foreign key
          # and the base on the inverse object.
          # 
          # _@param_ `base` — The document this association hangs off of.
          # 
          # _@param_ `target` — The target (child) of the association.
          # 
          # _@param_ `association` — The association metadata.
          # 
          # Create the new association.
          # ```ruby
          # Referenced::One.new(base, target, association)
          # ```
          sig { params(base: Document, target: Document, association: Association).void }
          def initialize(base, target, association); end

                    # Removes the association between the base document and the target
          # document by deleting the foreign key and the reference, orphaning
          # the target document in the process.
          # 
          # Nullify the association.
          # ```ruby
          # person.game.nullify
          # ```
          sig { returns(T.untyped) }
          def nullify; end

          # Substitutes the supplied target document for the existing document
          # in the association. If the new target is nil, perform the necessary
          # deletion.
          # 
          # _@param_ `replacement` — The replacement target.
          # 
          # _@return_ — The association.
          # 
          # Replace the association.
          # ```ruby
          # person.game.substitute(new_game)
          # ```
          sig { params(replacement: T::Array[Document]).returns(One) }
          def substitute(replacement); end

          # sord warn - Binding wasn't able to be resolved to a constant in this project
          # Instantiate the binding associated with this association.
          # 
          # _@return_ — The binding object.
          # 
          # Get the binding.
          # ```ruby
          # relation.binding([ address ])
          # ```
          sig { returns(Binding) }
          def binding; end

          # Are we able to persist this association?
          # 
          # _@return_ — If the association is persistable.
          # 
          # Can we persist the association?
          # ```ruby
          # relation.persistable?
          # ```
          sig { returns(T::Boolean) }
          def persistable?; end

                                        sig { params(association: T.untyped, docs: T.untyped).returns(T.untyped) }
          def self.eager_loader(association, docs); end

          # Returns true if the association is an embedded one. In this case
          # always false.
          # 
          # _@return_ — Always false.
          # 
          # Is this association embedded?
          # ```ruby
          # Referenced::One.embedded?
          # ```
          sig { returns(T::Boolean) }
          def self.embedded?; end
        end

        # Binding class for has_one associations.
        # 
        # @since 7.0
        class Binding
          include Mongoid::Association::Bindable

                    # Binds the base object to the inverse of the association. This is so we
          # are referenced to the actual objects themselves on both sides.
          # 
          # This case sets the association metadata on the inverse object as well as the
          # document itself.
          # 
          # Bind the document.
          # ```ruby
          # person.game.bind(:continue => true)
          # person.game = Game.new
          # ```
          sig { returns(T.untyped) }
          def bind_one; end

                    # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          # 
          # Unbind the document.
          # ```ruby
          # person.game.unbind(:continue => true)
          # person.game = nil
          # ```
          sig { returns(T.untyped) }
          def unbind_one; end

          # Create the new binding.
          # 
          # _@param_ `base` — The base of the binding.
          # 
          # _@param_ `target` — The target of the binding.
          # 
          # _@param_ `association` — The association metadata.
          # 
          # Initialize a binding.
          # ```ruby
          # Binding.new(base, target, association)
          # ```
          sig { params(base: Document, target: T.any(Document, T::Array[Document]), association: Association).void }
          def initialize(base, target, association); end

          # Execute the provided block inside a binding.
          # 
          # _@return_ — The result of the yield.
          # 
          # Execute the binding block.
          # ```ruby
          # binding.binding do
          #   base.foreign_key = 1
          # end
          # ```
          sig { returns(Object) }
          def binding; end

                    # Check if the inverse is properly defined.
          # 
          # _@param_ `doc` — The document getting bound.
          # 
          # Check the inverse definition.
          # ```ruby
          # binding.check_inverse!(doc)
          # ```
          sig { params(doc: Document).returns(T.untyped) }
          def check_inverse!(doc); end

                    # Set the id of the related document in the foreign key field on the
          # keyed document.
          # 
          # _@param_ `keyed` — The document that stores the foreign key.
          # 
          # _@param_ `id` — The id of the bound document.
          # 
          # Bind the foreign key.
          # ```ruby
          # binding.bind_foreign_key(post, person._id)
          # ```
          sig { params(keyed: Document, id: Object).returns(T.untyped) }
          def bind_foreign_key(keyed, id); end

                    # Set the type of the related document on the foreign type field, used
          # when associations are polymorphic.
          # 
          # _@param_ `typed` — The document that stores the type field.
          # 
          # _@param_ `name` — The name of the model.
          # 
          # Bind the polymorphic type.
          # ```ruby
          # binding.bind_polymorphic_type(post, "Person")
          # ```
          sig { params(typed: Document, name: String).returns(T.untyped) }
          def bind_polymorphic_type(typed, name); end

                    # Set the type of the related document on the foreign type field, used
          # when associations are polymorphic.
          # 
          # _@param_ `typed` — The document that stores the type field.
          # 
          # _@param_ `name` — The name of the model.
          # 
          # Bind the polymorphic type.
          # ```ruby
          # binding.bind_polymorphic_inverse_type(post, "Person")
          # ```
          sig { params(typed: Document, name: String).returns(T.untyped) }
          def bind_polymorphic_inverse_type(typed, name); end

                    # Bind the inverse document to the child document so that the in memory
          # instances are the same.
          # 
          # _@param_ `doc` — The base document.
          # 
          # _@param_ `inverse` — The inverse document.
          # 
          # Bind the inverse.
          # ```ruby
          # binding.bind_inverse(post, person)
          # ```
          sig { params(doc: Document, inverse: Document).returns(T.untyped) }
          def bind_inverse(doc, inverse); end

                    # Bind the provided document with the base from the parent association.
          # 
          # _@param_ `doc` — The document to bind.
          # 
          # Bind the document with the base.
          # ```ruby
          # binding.bind_from_relational_parent(doc)
          # ```
          sig { params(doc: Document).returns(T.untyped) }
          def bind_from_relational_parent(doc); end

                              sig { params(_base: T.untyped).returns(T.untyped) }
          def record_id(_base); end

          # Ensure that the association on the base is correct, for the cases
          # where we have multiple belongs to definitions and were are setting
          # different parents in memory in order.
          # 
          # _@return_ — If the association changed.
          # 
          # Set the base association.
          # ```ruby
          # binding.set_base_association
          # ```
          sig { returns(T::Boolean) }
          def set_base_association; end

                    # Bind the provided document with the base from the parent association.
          # 
          # _@param_ `doc` — The document to unbind.
          # 
          # Bind the document with the base.
          # ```ruby
          # unbinding.unbind_from_relational_parent(doc)
          # ```
          sig { params(doc: Document).returns(T.untyped) }
          def unbind_from_relational_parent(doc); end

          # Begin the assignment of attributes. While in this block embedded
          # documents will not autosave themselves in order to allow the document to
          # be in a valid state.
          # 
          # _@return_ — The yielded value.
          # 
          # Execute the assignment.
          # ```ruby
          # _assigning do
          #   person.attributes = { :addresses => [ address ] }
          # end
          # ```
          sig { returns(Object) }
          def _assigning; end

          # Is the current thread in assigning mode?
          # 
          # _@return_ — If the thread is assigning.
          # 
          # Is the current thread in assigning mode?
          # ```ruby
          # proxy._assigning?
          # ```
          sig { returns(T::Boolean) }
          def _assigning?; end

          # Execute a block in binding mode.
          # 
          # _@return_ — The return value of the block.
          # 
          # Execute in binding mode.
          # ```ruby
          # binding do
          #   relation.push(doc)
          # end
          # ```
          sig { returns(Object) }
          def _binding; end

          # Is the current thread in binding mode?
          # 
          # _@return_ — If the thread is binding.
          # 
          # Is the current thread in binding mode?
          # ```ruby
          # proxy.binding?
          # ```
          sig { returns(T::Boolean) }
          def _binding?; end

          # Execute a block in building mode.
          # 
          # _@return_ — The return value of the block.
          # 
          # Execute in building mode.
          # ```ruby
          # _building do
          #   relation.push(doc)
          # end
          # ```
          sig { returns(Object) }
          def _building; end

          # Is the current thread in building mode?
          # 
          # _@return_ — If the thread is building.
          # 
          # Is the current thread in building mode?
          # ```ruby
          # proxy._building?
          # ```
          sig { returns(T::Boolean) }
          def _building?; end

          # Is the current thread in creating mode?
          # 
          # _@return_ — If the thread is creating.
          # 
          # Is the current thread in creating mode?
          # ```ruby
          # proxy.creating?
          # ```
          sig { returns(T::Boolean) }
          def _creating?; end

          # Execute a block in loading mode.
          # 
          # _@return_ — The return value of the block.
          # 
          # Execute in loading mode.
          # ```ruby
          # _loading do
          #   relation.push(doc)
          # end
          # ```
          sig { returns(Object) }
          def _loading; end

          # Is the current thread in loading mode?
          # 
          # _@return_ — If the thread is loading.
          # 
          # Is the current thread in loading mode?
          # ```ruby
          # proxy._loading?
          # ```
          sig { returns(T::Boolean) }
          def _loading?; end
        end

        # The Builder behavior for has_one associations.
        # 
        # @since 7.0
        module Buildable
          # This method either takes an _id or an object and queries for the
          # inverse side using the id or sets the object after clearing the
          # associated object.
          # 
          # _@param_ `base` — The base object.
          # 
          # _@param_ `object` — The object to use to build the association.
          # 
          # _@param_ `type` — The type of the association.
          # 
          # _@param_ `selected_fields` — Must be nil.
          # 
          # _@return_ — A single document.
          sig do
            params(
              base: Object,
              object: Object,
              type: T.nilable(String),
              selected_fields: T.nilable(T.any())
            ).returns(Document)
          end
          def build(base, object, type = nil, selected_fields = nil); end

                              sig { params(object: T.untyped).returns(T.untyped) }
          def clear_associated(object); end

                                        sig { params(object: T.untyped, base: T.untyped).returns(T.untyped) }
          def query_criteria(object, base); end

                                        sig { params(object: T.untyped, base: T.untyped).returns(T.untyped) }
          def execute_query(object, base); end

                                        sig { params(criteria: T.untyped, base: T.untyped).returns(T.untyped) }
          def with_polymorphic_criterion(criteria, base); end

                    sig { params(object: T.untyped).returns(T::Boolean) }
          def query?(object); end
        end
      end

      # The has_many association.
      # 
      # @since 7.0
      class HasMany
        include Mongoid::Association::Relatable
        include Mongoid::Association::Referenced::HasMany::Buildable
        ASSOCIATION_OPTIONS = T.let([
    :after_add,
    :after_remove,
    :as,
    :autosave,
    :before_add,
    :before_remove,
    :dependent,
    :foreign_key,
    :order,
    :primary_key
].freeze, T.untyped)
        VALID_OPTIONS = T.let((ASSOCIATION_OPTIONS + SHARED_OPTIONS).freeze, T.untyped)
        FOREIGN_KEY_SUFFIX = T.let('_id'.freeze, T.untyped)
        SHARED_OPTIONS = T.let([
  :class_name,
  :inverse_of,
  :validate,
  :extend
].freeze, T.untyped)
        PRIMARY_KEY_DEFAULT = T.let('_id'.freeze, T.untyped)

        # The list of association complements.
        # 
        # _@return_ — The association complements.
        sig { returns(T::Array[Association]) }
        def relation_complements; end

        # Setup the instance methods, fields, etc. on the association owning class.
        sig { returns(T.self_type) }
        def setup!; end

        # Setup the instance methods on the class having this association type.
        sig { returns(T.self_type) }
        def setup_instance_methods!; end

        # Get the foreign key field on the inverse for saving the association reference.
        # 
        # _@return_ — The foreign key field on the inverse for saving the
        # association reference.
        sig { returns(String) }
        def foreign_key; end

        # Is this association type embedded?
        # 
        # _@return_ — Always false.
        sig { returns(T::Boolean) }
        def embedded?; end

        # The default for validation the association object.
        # 
        # _@return_ — Always true.
        sig { returns(T::Boolean) }
        def validation_default; end

        # Does this association type store the foreign key?
        # 
        # _@return_ — Always true.
        sig { returns(T::Boolean) }
        def stores_foreign_key?; end

        # sord warn - Association::HasMany::Proxy wasn't able to be resolved to a constant in this project
        # Get the association proxy class for this association type.
        # 
        # _@return_ — The proxy class.
        sig { returns(Mongoid::Association::Referenced::HasMany::Proxy) }
        def relation; end

                # The criteria used for querying this association.
        # 
        # _@return_ — The criteria used for querying this association.
        sig { params(base: T.untyped).returns(Mongoid::Criteria) }
        def criteria(base); end

        # The type of this association if it's polymorphic.
        # 
        # _@return_ — The type field.
        # 
        # _@note_ — Only relevant for polymorphic associations.
        sig { returns(T.nilable(String)) }
        def type; end

        # Add polymorphic query criteria to a Criteria object, if this association is
        #  polymorphic.
        # 
        # _@param_ `criteria` — The criteria object to add to.
        # 
        # _@param_ `object_class` — The object class.
        # 
        # _@return_ — The criteria object.
        sig { params(criteria: Mongoid::Criteria, object_class: Class).returns(Mongoid::Criteria) }
        def add_polymorphic_criterion(criteria, object_class); end

        # Is this association polymorphic?
        # 
        # _@return_ — Whether this association is polymorphic.
        sig { returns(T::Boolean) }
        def polymorphic?; end

        # Whether trying to bind an object using this association should raise
        # an error.
        # 
        # _@param_ `doc` — The document to be bound.
        # 
        # _@return_ — Whether the document can be bound.
        sig { params(doc: Document).returns(T::Boolean) }
        def bindable?(doc); end

        # The nested builder object.
        # 
        # _@param_ `attributes` — The attributes to use to build the association object.
        # 
        # _@param_ `options` — The options for the association.
        # 
        # _@return_ — The Nested Builder object.
        sig { params(attributes: T::Hash[T.untyped, T.untyped], options: T::Hash[T.untyped, T.untyped]).returns(Association::Nested::Many) }
        def nested_builder(attributes, options); end

        # sord infer - Root was resolved to Mongoid::Atomic::Paths::Root
        # Get the path calculator for the supplied document.
        # 
        # _@param_ `document` — The document to calculate on.
        # 
        # _@return_ — The root atomic path calculator.
        # 
        # Get the path calculator.
        # ```ruby
        # Proxy.path(document)
        # ```
        sig { params(document: Document).returns(Mongoid::Atomic::Paths::Root) }
        def path(document); end

                sig { returns(T.untyped) }
        def default_foreign_key_field; end

                        sig { params(other: T.untyped).returns(T.untyped) }
        def polymorphic_inverses(other); end

                        sig { params(other: T.untyped).returns(T.untyped) }
        def determine_inverses(other); end

                sig { returns(T.untyped) }
        def default_primary_key; end

                                sig { params(object: T.untyped, base: T.untyped).returns(T.untyped) }
        def query_criteria(object, base); end

                                sig { params(criteria: T.untyped, base: T.untyped).returns(T.untyped) }
        def with_polymorphic_criterion(criteria, base); end

                        sig { params(criteria: T.untyped).returns(T.untyped) }
        def with_ordering(criteria); end

                        sig { params(criteria: T.untyped).returns(T.untyped) }
        def with_inverse_field_criterion(criteria); end

        # This method either takes an _id or an object and queries for the
        # inverse side using the id or sets the object.
        # 
        # _@param_ `base` — The base object.
        # 
        # _@param_ `object` — The object to use to build the association.
        # 
        # _@param_ `type` — The type of document to query for.
        # 
        # _@param_ `selected_fields` — Must be nil.
        # 
        # _@return_ — A single document.
        # 
        # Build the document.
        # ```ruby
        # relation.build(meta, attrs)
        # ```
        sig do
          params(
            base: Object,
            object: Object,
            type: T.nilable(String),
            selected_fields: T.nilable(T.any())
          ).returns(Document)
        end
        def build(base, object, type = nil, selected_fields = nil); end

                sig { params(object: T.untyped).returns(T::Boolean) }
        def query?(object); end

        # Initialize the Association.
        # 
        # _@param_ `_class` — The class of the model who owns this association.
        # 
        # _@param_ `name` — The name of the association.
        # 
        # _@param_ `opts` — The association options.
        # 
        # _@param_ `block` — The optional block.
        sig do
          params(
            _class: Class,
            name: Symbol,
            opts: T::Hash[T.untyped, T.untyped],
            block: T.untyped
          ).void
        end
        def initialize(_class, name, opts = {}, &block); end

                # Compare this association to another.
        # 
        # _@return_ — The object to compare to this association.
        sig { params(other: T.untyped).returns(Object) }
        def ==(other); end

        # Get the callbacks for a given type.
        # 
        # _@param_ `callback_type` — The type of callback type.
        # 
        # _@return_ — A list of the callbacks, either method
        # names or Procs.
        sig { params(callback_type: Symbol).returns(T::Array[T.any(Proc, Symbol)]) }
        def get_callbacks(callback_type); end

        # Get the type setter.
        # 
        # _@return_ — The type setter method.
        # 
        # _@note_ — Only relevant for polymorphic associations that take the :as option.
        sig { returns(String) }
        def type_setter; end

        # Get the inverse names.
        # 
        # _@param_ `other` — The other model class or model object to use when determining inverses.
        # 
        # _@return_ — The list of inverse names.
        sig { params(other: T.nilable(Object)).returns(T::Array[Symbol]) }
        def inverses(other = nil); end

        # Get the inverse's association metadata.
        # 
        # _@param_ `other` — The other model class or model object to use when determining inverses.
        # 
        # _@return_ — The inverse's association metadata.
        sig { params(other: T.nilable(Object)).returns(Association) }
        def inverse_association(other = nil); end

        # Get the inverse type.
        # 
        # _@return_ — Default is nil for an association.
        sig { returns(T.nilable(T.any())) }
        def inverse_type; end

        # The class name, possibly unqualified or :: prefixed, of the association
        # object(s).
        # 
        # This method returns the class name as it is used in the association
        # definition. If :class_name option is given in the association, the
        # exact value of that option is returned here. If :class_name option is
        # not given, the name of the class is calculated from association name
        # but is not resolved to the actual class.
        # 
        # The class name returned by this method may not correspond to a defined
        # class, either because the corresponding class has not been loaded yet,
        # or because the association references a non-existent class altogether.
        # To obtain the association class, use +relation_class+ method.
        # 
        # _@return_ — The association objects' class name.
        # 
        # _@note_ — The return value of this method should not be used to determine
        # whether two associations have the same target class, because the
        # return value is not always a fully qualified class name. To compare
        # classes, retrieve the class instance of the association target using
        # the +relation_class+ method.
        sig { returns(String) }
        def relation_class_name; end

        # The class of the association object(s).
        # 
        # This method returns the class instance corresponding to
        # +relation_class_name+, resolved relative to the host document class.
        # 
        # If the class does not exist, this method raises NameError. This can
        # happen because the target class has not yet been defined. Note that
        # polymorphic associations generally do not have a well defined target
        # class because the target class can change from one object to another,
        # and calling this method on a polymorphic association will generally
        # fail with a NameError or produce misleading results (if a class does
        # happen to be defined with the same name as the association name).
        # 
        # _@return_ — The association objects' class.
        sig { returns(String) }
        def relation_class; end

        # The class name of the object owning this association.
        # 
        # _@return_ — The owning objects' class name.
        sig { returns(String) }
        def inverse_class_name; end

        # The class of the object owning this association.
        # 
        # _@return_ — The owning objects' class.
        sig { returns(String) }
        def inverse_class; end

        # The foreign key field if this association stores a foreign key.
        # Otherwise, the primary key.
        # 
        # _@return_ — The primary key.
        sig { returns(T.any(Symbol, String)) }
        def key; end

        # The name of the setter on this object for assigning an associated object.
        # 
        # _@return_ — The setter name.
        sig { returns(String) }
        def setter; end

                # The name of the inverse setter method.
        # 
        # _@return_ — The name of the inverse setter.
        sig { params(other: T.untyped).returns(String) }
        def inverse_setter(other = nil); end

        # The name of the foreign key setter method.
        # 
        # _@return_ — The name of the foreign key setter.
        sig { returns(String) }
        def foreign_key_setter; end

        # Gets the setter for the field that sets the type of document on a
        # polymorphic association.
        # 
        # _@return_ — The name of the setter.
        # 
        # Get the inverse type setter.
        # ```ruby
        # association.inverse_type_setter
        # ```
        sig { returns(String) }
        def inverse_type_setter; end

        # Get the name of the method to check if the foreign key has changed.
        # 
        # _@return_ — The foreign key check.
        # 
        # Get the foreign key check method.
        # ```ruby
        # association.foreign_key_check
        # ```
        sig { returns(String) }
        def foreign_key_check; end

        # Create an association proxy object using the owner and target.
        # 
        # _@param_ `owner` — The document this association hangs off of.
        # 
        # _@param_ `target` — The target (parent) of the association.
        sig { params(owner: Document, target: T.any(Document, T::Array[Document])).returns(Proxy) }
        def create_relation(owner, target); end

        # Whether the dependent method is destructive.
        # 
        # _@return_ — If the dependent method is destructive.
        sig { returns(T::Boolean) }
        def destructive?; end

        # Get the counter cache column name.
        # 
        # _@return_ — The counter cache column name.
        sig { returns(String) }
        def counter_cache_column_name; end

        # Get the extension.
        # 
        # _@return_ — The extension module, if one has been defined.
        sig { returns(Module) }
        def extension; end

                # Get the inverse name.
        # 
        # _@return_ — The inverse name.
        sig { params(other: T.untyped).returns(Symbol) }
        def inverse(other = nil); end

        # Whether the associated object(s) should be validated.
        # 
        # _@return_ — If the associated object(s)
        # should be validated.
        sig { returns(T::Boolean) }
        def validate?; end

                # Gets the model classes with inverse associations of this model. This is used to determine
        # the classes on the other end of polymorphic associations with models.
        sig { returns(T.untyped) }
        def inverse_association_classes; end

                sig { returns(T.untyped) }
        def setup_index!; end

                sig { returns(T.untyped) }
        def define_touchable!; end

                sig { returns(T.untyped) }
        def define_autosaver!; end

                sig { returns(T.untyped) }
        def define_builder!; end

                sig { returns(T.untyped) }
        def define_creator!; end

                sig { returns(T.untyped) }
        def define_getter!; end

                sig { returns(T.untyped) }
        def define_setter!; end

                sig { returns(T.untyped) }
        def define_existence_check!; end

                sig { returns(T.untyped) }
        def define_ids_getter!; end

                sig { returns(T.untyped) }
        def define_ids_setter!; end

                sig { returns(T.untyped) }
        def define_counter_cache_callbacks!; end

                sig { returns(T.untyped) }
        def define_dependency!; end

                sig { returns(T.untyped) }
        def validate!; end

                sig { returns(T.untyped) }
        def polymorph!; end

                sig { params(block: T.untyped).returns(T.untyped) }
        def create_extension!(&block); end

                sig { returns(T.untyped) }
        def default_inverse; end

                        # Returns an array of classes/modules forming the namespace hierarchy
        # where symbols referenced in the provided class/module would be looked
        # up by Ruby. For example, if mod is Foo::Bar, this method would return
        # [Foo::Bar, Foo, Object].
        sig { params(mod: T.untyped).returns(T.untyped) }
        def namespace_hierarchy(mod); end

                                # Resolves the given class/module name in the context of the specified
        # module, as Ruby would when a constant is referenced in the source.
        # 
        # _@note_ — This method can swallow exceptions produced during class loading,
        # because it rescues NameError internally. Since this method attempts
        # to load classes, failure during the loading process may also lead to
        # there being incomplete class definitions.
        sig { params(mod: T.untyped, name: T.untyped).returns(T.untyped) }
        def resolve_name(mod, name); end

        # Returns the name of the parent to a polymorphic child.
        # 
        # _@return_ — The name.
        sig { returns(T.any(String, Symbol)) }
        def as; end

        # Specify what happens to the associated object when the owner is destroyed.
        # 
        # _@return_ — The dependent option.
        sig { returns(String) }
        def dependent; end

        # The custom sorting options on the association.
        # 
        # _@return_ — The custom sorting options.
        sig { returns(Criteria::Queryable::Key) }
        def order; end

        # Whether to index the primary or foreign key field.
        sig { returns(T::Boolean) }
        def indexed?; end

        # Whether the association is autobuilding.
        sig { returns(T::Boolean) }
        def autobuilding?; end

        # Is the association cyclic.
        # 
        # _@return_ — Whether the association is cyclic.
        sig { returns(T::Boolean) }
        def cyclic?; end

        # The name the owning object uses to refer to this association.
        # 
        # _@return_ — The inverse_of option.
        sig { returns(String) }
        def inverse_of; end

        # Mongoid assumes that the field used to hold the primary key of the association is id.
        # You can override this and explicitly specify the primary key with the :primary_key option.
        # 
        # _@return_ — The primary key.
        sig { returns(T.any(Symbol, String)) }
        def primary_key; end

        # Options to save any loaded members and destroy members that are marked for destruction
        # when the parent object is saved.
        # 
        # _@return_ — The autosave option.
        sig { returns(T::Boolean) }
        def autosave; end

        # Whether the association is counter-cached.
        sig { returns(T::Boolean) }
        def counter_cached?; end

        # Whether the association has callbacks cascaded down from the parent.
        # 
        # _@return_ — Whether callbacks are cascaded.
        sig { returns(T::Boolean) }
        def cascading_callbacks?; end

        # The store_as option.
        # 
        # _@return_ — Default is nil.
        sig { returns(T.nilable(T.any())) }
        def store_as; end

        # Whether the association has forced nil inverse (So no foreign keys are saved).
        # 
        # _@return_ — Default is false.
        sig { returns(T::Boolean) }
        def forced_nil_inverse?; end

        # The field for saving the associated object's type.
        # 
        # _@return_ — Default is nil.
        sig { returns(T.nilable(T.any())) }
        def touch_field; end

        sig { returns(T::Boolean) }
        def touchable?; end

        # Convert the supplied object to the appropriate type to set as the
        # foreign key for an association.
        # 
        # _@param_ `object` — The object to convert.
        # 
        # _@return_ — The object cast to the correct type.
        # 
        # Convert the object.
        # ```ruby
        # constraint.convert("12345")
        # ```
        sig { params(object: Object).returns(Object) }
        def convert_to_foreign_key(object); end

                        sig { params(object: T.untyped).returns(T.untyped) }
        def convert_polymorphic(object); end

        # Eager class for has_many associations.
        class Eager < Mongoid::Association::Referenced::Eager::Base
                    sig { returns(T.untyped) }
          def preload; end

                                        sig { params(doc: T.untyped, element: T.untyped).returns(T.untyped) }
          def set_relation(doc, element); end

                    sig { returns(T.untyped) }
          def group_by_key; end

                    sig { returns(T.untyped) }
          def key; end
        end

        # This class defines the behavior for all associations that are a
        # one-to-many between documents in different collections.
        class Proxy < Mongoid::Association::Many
          extend Forwardable

          # Appends a document or array of documents to the association. Will set
          # the parent and update the index in the process.
          # 
          # _@param_ `args` — Any number of documents.
          # 
          # _@return_ — The loaded docs.
          # 
          # Append a document.
          # ```ruby
          # person.posts << post
          # ```
          # 
          # Push a document.
          # ```ruby
          # person.posts.push(post)
          # ```
          # 
          # Concat with other documents.
          # ```ruby
          # person.posts.concat([ post_one, post_two ])
          # ```
          sig { params(args: T.any(Document, T::Array[Document])).returns(T::Array[Document]) }
          def <<(*args); end

          # Appends an array of documents to the association. Performs a batch
          # insert of the documents instead of persisting one at a time.
          # 
          # _@param_ `documents` — The docs to add.
          # 
          # _@return_ — The documents.
          # 
          # Concat with other documents.
          # ```ruby
          # person.posts.concat([ post_one, post_two ])
          # ```
          sig { params(documents: T::Array[Document]).returns(T::Array[Document]) }
          def concat(documents); end

          # Build a new document from the attributes and append it to this
          # association without saving.
          # 
          # _@param_ `attributes` — The attributes of the new document.
          # 
          # _@param_ `type` — The optional subclass to build.
          # 
          # _@return_ — The new document.
          # 
          # Build a new document on the association.
          # ```ruby
          # person.posts.build(:title => "A new post")
          # ```
          sig { params(attributes: T::Hash[T.untyped, T.untyped], type: T.nilable(Class)).returns(Document) }
          def build(attributes = {}, type = nil); end

          # Delete the document from the association. This will set the foreign key
          # on the document to nil. If the dependent options on the association are
          # :delete_all or :destroy the appropriate removal will occur.
          # 
          # _@param_ `document` — The document to remove.
          # 
          # _@return_ — The matching document.
          # 
          # Delete the document.
          # ```ruby
          # person.posts.delete(post)
          # ```
          sig { params(document: Document).returns(Document) }
          def delete(document); end

          # Deletes all related documents from the database given the supplied
          # conditions.
          # 
          # _@param_ `conditions` — Optional conditions to delete with.
          # 
          # _@return_ — The number of documents deleted.
          # 
          # Delete all documents in the association.
          # ```ruby
          # person.posts.delete_all
          # ```
          # 
          # Conditonally delete all documents in the association.
          # ```ruby
          # person.posts.delete_all({ :title => "Testing" })
          # ```
          sig { params(conditions: T.nilable(T::Hash[T.untyped, T.untyped])).returns(Integer) }
          def delete_all(conditions = nil); end

          # Destroys all related documents from the database given the supplied
          # conditions.
          # 
          # _@param_ `conditions` — Optional conditions to destroy with.
          # 
          # _@return_ — The number of documents destroyd.
          # 
          # Destroy all documents in the association.
          # ```ruby
          # person.posts.destroy_all
          # ```
          # 
          # Conditonally destroy all documents in the association.
          # ```ruby
          # person.posts.destroy_all({ :title => "Testing" })
          # ```
          sig { params(conditions: T.nilable(T::Hash[T.untyped, T.untyped])).returns(Integer) }
          def destroy_all(conditions = nil); end

          # Iterate over each document in the association and yield to the provided
          # block.
          # 
          # _@return_ — The loaded docs.
          # 
          # Iterate over the documents.
          # ```ruby
          # person.posts.each do |post|
          #   post.save
          # end
          # ```
          # 
          # _@note_ — This will load the entire association into memory.
          sig { returns(T::Array[Document]) }
          def each; end

          # Determine if any documents in this association exist in the database.
          # 
          # If the association contains documents but all of the documents
          # exist only in the application, i.e. have not been persisted to the
          # database, this method returns false.
          # 
          # This method queries the database on each invocation even if the
          # association is already loaded into memory.
          # 
          # _@return_ — True is persisted documents exist, false if not.
          # 
          # Are there persisted documents?
          # ```ruby
          # person.posts.exists?
          # ```
          sig { returns(T::Boolean) }
          def exists?; end

          # Find the matchind document on the association, either based on id or
          # conditions.
          # 
          # _@param_ `args` — The ids.
          # 
          # _@return_ — The matching document(s).
          # 
          # Find by an id.
          # ```ruby
          # person.posts.find(BSON::ObjectId.new)
          # ```
          # 
          # Find by multiple ids.
          # ```ruby
          # person.posts.find([ BSON::ObjectId.new, BSON::ObjectId.new ])
          # ```
          # 
          # _@note_ — This will keep matching documents in memory for iteration
          # later.
          sig { params(args: T.any(BSON::ObjectId, T::Array[BSON::ObjectId])).returns(T.any(Document, Criteria)) }
          def find(*args); end

          # Instantiate a new references_many association. Will set the foreign key
          # and the base on the inverse object.
          # 
          # _@param_ `base` — The document this association hangs off of.
          # 
          # _@param_ `target` — The target of the association.
          # 
          # _@param_ `association` — The association metadata.
          # 
          # Create the new association.
          # ```ruby
          # Referenced::Many.new(base, target, association)
          # ```
          sig { params(base: Document, target: T::Array[Document], association: Association).void }
          def initialize(base, target, association); end

                    # Removes all associations between the base document and the target
          # documents by deleting the foreign keys and the references, orphaning
          # the target documents in the process.
          # 
          # Nullify the association.
          # ```ruby
          # person.posts.nullify
          # ```
          sig { returns(T.untyped) }
          def nullify; end

          # Clear the association. Will delete the documents from the db if they are
          # already persisted.
          # 
          # _@return_ — The association emptied.
          # 
          # Clear the association.
          # ```ruby
          # person.posts.clear
          # ```
          sig { returns(Many) }
          def purge; end

          # Substitutes the supplied target documents for the existing documents
          # in the association. If the new target is nil, perform the necessary
          # deletion.
          # 
          # _@param_ `replacement` — The replacement target.
          # 
          # _@return_ — The association.
          # 
          # Replace the association.
          # ```ruby
          # person.posts.substitute([ new_post ])
          # ```
          sig { params(replacement: T::Array[Document]).returns(Many) }
          def substitute(replacement); end

          # Get a criteria for the documents without the default scoping
          # applied.
          # 
          # _@return_ — The unscoped criteria.
          # 
          # Get the unscoped criteria.
          # ```ruby
          # person.posts.unscoped
          # ```
          sig { returns(Criteria) }
          def unscoped; end

                    # Appends the document to the target array, updating the index on the
          # document at the same time.
          # 
          # _@param_ `document` — The document to append to the target.
          # 
          # Append the document to the association.
          # ```ruby
          # relation.append(document)
          # ```
          sig { params(document: Document).returns(T.untyped) }
          def append(document); end

                    # Execute before/after add callbacks around the block unless the objects
          # already have a persisted association.
          # 
          # _@param_ `document` — The document to append to the target.
          # 
          # _@param_ `already_related` — Whether the document is already related to the target.
          # 
          # Execute before/after add callbacks around the block.
          # ```ruby
          # relation.with_add_callbacks(document, false)
          # ```
          sig { params(document: Document, already_related: T::Boolean).returns(T.untyped) }
          def with_add_callbacks(document, already_related); end

          # Whether the document and the base already have a persisted association.
          # 
          # _@param_ `document` — The document to possibly append to the target.
          # 
          # _@return_ — Whether the document is already related to the base and the
          # association is persisted.
          # 
          # Is the document already related to the base.
          # ```ruby
          # relation.already_related?(document)
          # ```
          sig { params(document: Document).returns(T::Boolean) }
          def already_related?(document); end

          # sord warn - Binding wasn't able to be resolved to a constant in this project
          # Instantiate the binding associated with this association.
          # 
          # _@return_ — The binding.
          # 
          # Get the binding.
          # ```ruby
          # relation.binding([ address ])
          # ```
          sig { returns(Binding) }
          def binding; end

          # sord warn - Collection wasn't able to be resolved to a constant in this project
          # Get the collection of the association in question.
          # 
          # _@return_ — The collection of the association.
          # 
          # Get the collection of the association.
          # ```ruby
          # relation.collection
          # ```
          sig { returns(Mongo::Collection) }
          def collection; end

          # Returns the criteria object for the target class with its documents set
          # to target.
          # 
          # _@return_ — A new criteria.
          # 
          # Get a criteria for the association.
          # ```ruby
          # relation.criteria
          # ```
          sig { returns(Criteria) }
          def criteria; end

          # Perform the necessary cascade operations for documents that just got
          # deleted or nullified.
          # 
          # _@param_ `document` — The document to cascade on.
          # 
          # _@return_ — If the association is destructive.
          # 
          # Cascade the change.
          # ```ruby
          # relation.cascade!(document)
          # ```
          sig { params(document: Document).returns(T::Boolean) }
          def cascade!(document); end

          # If the target array does not respond to the supplied method then try to
          # find a named scope or criteria on the class and send the call there.
          # 
          # If the method exists on the array, use the default proxy behavior.
          # 
          # _@param_ `name` — The name of the method.
          # 
          # _@param_ `args` — The method args
          # 
          # _@param_ `block` — Optional block to pass.
          # 
          # _@return_ — A Criteria or return value from the target.
          sig { params(name: T.any(Symbol, String), args: T::Array[T.untyped], block: T.untyped).returns(T.any(Criteria, Object)) }
          def method_missing(name, *args, &block); end

                    # Persist all the delayed batch inserts.
          # 
          # _@param_ `docs` — The delayed inserts.
          # 
          # _@param_ `inserts` — The raw insert document.
          # 
          # Persist the delayed batch inserts.
          # ```ruby
          # relation.persist_delayed([ doc ])
          # ```
          sig { params(docs: T::Array[Document], inserts: T::Array[T::Hash[T.untyped, T.untyped]]).returns(T.untyped) }
          def persist_delayed(docs, inserts); end

          # Are we able to persist this association?
          # 
          # _@return_ — If the association is persistable.
          # 
          # Can we persist the association?
          # ```ruby
          # relation.persistable?
          # ```
          sig { returns(T::Boolean) }
          def persistable?; end

          # Deletes all related documents from the database given the supplied
          # conditions.
          # 
          # _@param_ `conditions` — Optional conditions to delete with.
          # 
          # _@param_ `method` — The deletion method to call.
          # 
          # _@return_ — The number of documents deleted.
          # 
          # Delete all documents in the association.
          # ```ruby
          # person.posts.delete_all
          # ```
          # 
          # Conditonally delete all documents in the association.
          # ```ruby
          # person.posts.delete_all({ :title => "Testing" })
          # ```
          sig { params(conditions: T.nilable(T::Hash[T.untyped, T.untyped]), method: Symbol).returns(Integer) }
          def remove_all(conditions = nil, method = :delete_all); end

                    # Remove all the documents in the proxy that do not have the provided
          # ids.
          # 
          # _@param_ `ids` — The ids.
          # 
          # Remove all documents without the ids.
          # ```ruby
          # proxy.remove_not_in([ id ])
          # ```
          sig { params(ids: T::Array[Object]).returns(T.untyped) }
          def remove_not_in(ids); end

                              # Save a persisted document immediately or delay a new document for
          # batch insert.
          # 
          # _@param_ `doc` — The document.
          # 
          # _@param_ `inserts` — The inserts.
          # 
          # Save or delay the document.
          # ```ruby
          # relation.save_or_delay(doc, [])
          # ```
          sig { params(doc: Document, docs: T.untyped, inserts: T::Array[Document]).returns(T.untyped) }
          def save_or_delay(doc, docs, inserts); end

                                        sig { params(association: T.untyped, docs: T.untyped).returns(T.untyped) }
          def self.eager_loader(association, docs); end

          # Returns true if the association is an embedded one. In this case
          # always false.
          # 
          # _@return_ — Always false.
          # 
          # Is this association embedded?
          # ```ruby
          # Referenced::Many.embedded?
          # ```
          sig { returns(T::Boolean) }
          def self.embedded?; end
        end

        # Binding class for has_many associations.
        class Binding
          include Mongoid::Association::Bindable

                              # Binds a single document with the inverse association. Used
          # specifically when appending to the proxy.
          # 
          # Bind one document.
          # ```ruby
          # person.posts.bind_one(post)
          # ```
          sig { params(doc: T.untyped).returns(T.untyped) }
          def bind_one(doc); end

                              # Unbind a single document.
          # 
          # Unbind the document.
          # ```ruby
          # person.posts.unbind_one(document)
          # ```
          sig { params(doc: T.untyped).returns(T.untyped) }
          def unbind_one(doc); end

          # Create the new binding.
          # 
          # _@param_ `base` — The base of the binding.
          # 
          # _@param_ `target` — The target of the binding.
          # 
          # _@param_ `association` — The association metadata.
          # 
          # Initialize a binding.
          # ```ruby
          # Binding.new(base, target, association)
          # ```
          sig { params(base: Document, target: T.any(Document, T::Array[Document]), association: Association).void }
          def initialize(base, target, association); end

          # Execute the provided block inside a binding.
          # 
          # _@return_ — The result of the yield.
          # 
          # Execute the binding block.
          # ```ruby
          # binding.binding do
          #   base.foreign_key = 1
          # end
          # ```
          sig { returns(Object) }
          def binding; end

                    # Check if the inverse is properly defined.
          # 
          # _@param_ `doc` — The document getting bound.
          # 
          # Check the inverse definition.
          # ```ruby
          # binding.check_inverse!(doc)
          # ```
          sig { params(doc: Document).returns(T.untyped) }
          def check_inverse!(doc); end

                    # Set the id of the related document in the foreign key field on the
          # keyed document.
          # 
          # _@param_ `keyed` — The document that stores the foreign key.
          # 
          # _@param_ `id` — The id of the bound document.
          # 
          # Bind the foreign key.
          # ```ruby
          # binding.bind_foreign_key(post, person._id)
          # ```
          sig { params(keyed: Document, id: Object).returns(T.untyped) }
          def bind_foreign_key(keyed, id); end

                    # Set the type of the related document on the foreign type field, used
          # when associations are polymorphic.
          # 
          # _@param_ `typed` — The document that stores the type field.
          # 
          # _@param_ `name` — The name of the model.
          # 
          # Bind the polymorphic type.
          # ```ruby
          # binding.bind_polymorphic_type(post, "Person")
          # ```
          sig { params(typed: Document, name: String).returns(T.untyped) }
          def bind_polymorphic_type(typed, name); end

                    # Set the type of the related document on the foreign type field, used
          # when associations are polymorphic.
          # 
          # _@param_ `typed` — The document that stores the type field.
          # 
          # _@param_ `name` — The name of the model.
          # 
          # Bind the polymorphic type.
          # ```ruby
          # binding.bind_polymorphic_inverse_type(post, "Person")
          # ```
          sig { params(typed: Document, name: String).returns(T.untyped) }
          def bind_polymorphic_inverse_type(typed, name); end

                    # Bind the inverse document to the child document so that the in memory
          # instances are the same.
          # 
          # _@param_ `doc` — The base document.
          # 
          # _@param_ `inverse` — The inverse document.
          # 
          # Bind the inverse.
          # ```ruby
          # binding.bind_inverse(post, person)
          # ```
          sig { params(doc: Document, inverse: Document).returns(T.untyped) }
          def bind_inverse(doc, inverse); end

                    # Bind the provided document with the base from the parent association.
          # 
          # _@param_ `doc` — The document to bind.
          # 
          # Bind the document with the base.
          # ```ruby
          # binding.bind_from_relational_parent(doc)
          # ```
          sig { params(doc: Document).returns(T.untyped) }
          def bind_from_relational_parent(doc); end

                              sig { params(_base: T.untyped).returns(T.untyped) }
          def record_id(_base); end

          # Ensure that the association on the base is correct, for the cases
          # where we have multiple belongs to definitions and were are setting
          # different parents in memory in order.
          # 
          # _@return_ — If the association changed.
          # 
          # Set the base association.
          # ```ruby
          # binding.set_base_association
          # ```
          sig { returns(T::Boolean) }
          def set_base_association; end

                    # Bind the provided document with the base from the parent association.
          # 
          # _@param_ `doc` — The document to unbind.
          # 
          # Bind the document with the base.
          # ```ruby
          # unbinding.unbind_from_relational_parent(doc)
          # ```
          sig { params(doc: Document).returns(T.untyped) }
          def unbind_from_relational_parent(doc); end

          # Begin the assignment of attributes. While in this block embedded
          # documents will not autosave themselves in order to allow the document to
          # be in a valid state.
          # 
          # _@return_ — The yielded value.
          # 
          # Execute the assignment.
          # ```ruby
          # _assigning do
          #   person.attributes = { :addresses => [ address ] }
          # end
          # ```
          sig { returns(Object) }
          def _assigning; end

          # Is the current thread in assigning mode?
          # 
          # _@return_ — If the thread is assigning.
          # 
          # Is the current thread in assigning mode?
          # ```ruby
          # proxy._assigning?
          # ```
          sig { returns(T::Boolean) }
          def _assigning?; end

          # Execute a block in binding mode.
          # 
          # _@return_ — The return value of the block.
          # 
          # Execute in binding mode.
          # ```ruby
          # binding do
          #   relation.push(doc)
          # end
          # ```
          sig { returns(Object) }
          def _binding; end

          # Is the current thread in binding mode?
          # 
          # _@return_ — If the thread is binding.
          # 
          # Is the current thread in binding mode?
          # ```ruby
          # proxy.binding?
          # ```
          sig { returns(T::Boolean) }
          def _binding?; end

          # Execute a block in building mode.
          # 
          # _@return_ — The return value of the block.
          # 
          # Execute in building mode.
          # ```ruby
          # _building do
          #   relation.push(doc)
          # end
          # ```
          sig { returns(Object) }
          def _building; end

          # Is the current thread in building mode?
          # 
          # _@return_ — If the thread is building.
          # 
          # Is the current thread in building mode?
          # ```ruby
          # proxy._building?
          # ```
          sig { returns(T::Boolean) }
          def _building?; end

          # Is the current thread in creating mode?
          # 
          # _@return_ — If the thread is creating.
          # 
          # Is the current thread in creating mode?
          # ```ruby
          # proxy.creating?
          # ```
          sig { returns(T::Boolean) }
          def _creating?; end

          # Execute a block in loading mode.
          # 
          # _@return_ — The return value of the block.
          # 
          # Execute in loading mode.
          # ```ruby
          # _loading do
          #   relation.push(doc)
          # end
          # ```
          sig { returns(Object) }
          def _loading; end

          # Is the current thread in loading mode?
          # 
          # _@return_ — If the thread is loading.
          # 
          # Is the current thread in loading mode?
          # ```ruby
          # proxy._loading?
          # ```
          sig { returns(T::Boolean) }
          def _loading?; end
        end

        # The Builder behavior for has_many associations.
        # 
        # @since 7.0
        module Buildable
          # This method either takes an _id or an object and queries for the
          # inverse side using the id or sets the object.
          # 
          # _@param_ `base` — The base object.
          # 
          # _@param_ `object` — The object to use to build the association.
          # 
          # _@param_ `type` — The type of document to query for.
          # 
          # _@param_ `selected_fields` — Must be nil.
          # 
          # _@return_ — A single document.
          # 
          # Build the document.
          # ```ruby
          # relation.build(meta, attrs)
          # ```
          sig do
            params(
              base: Object,
              object: Object,
              type: T.nilable(String),
              selected_fields: T.nilable(T.any())
            ).returns(Document)
          end
          def build(base, object, type = nil, selected_fields = nil); end

                    sig { params(object: T.untyped).returns(T::Boolean) }
          def query?(object); end
        end

        # This class is the wrapper for all referenced associations that have a
        # target that can be a criteria or array of _loaded documents. This
        # handles both cases or a combination of the two.
        class Enumerable
          include ::Enumerable
          extend Forwardable

          # Check if the enumerable is equal to the other object.
          # 
          # _@param_ `other` — The other enumerable.
          # 
          # _@return_ — If the objects are equal.
          # 
          # Check equality.
          # ```ruby
          # enumerable == []
          # ```
          sig { params(other: T::Enumerable[T.untyped]).returns(T::Boolean) }
          def ==(other); end

          # Check equality of the enumerable against the provided object for case
          # statements.
          # 
          # _@param_ `other` — The object to check.
          # 
          # _@return_ — If the objects are equal in a case.
          # 
          # Check case equality.
          # ```ruby
          # enumerable === Array
          # ```
          sig { params(other: Object).returns(T::Boolean) }
          def ===(other); end

          # Append a document to the enumerable.
          # 
          # _@param_ `document` — The document to append.
          # 
          # _@return_ — The document.
          # 
          # Append the document.
          # ```ruby
          # enumerable << document
          # ```
          sig { params(document: Document).returns(Document) }
          def <<(document); end

          # Clears out all the documents in this enumerable. If passed a block it
          # will yield to each document that is in memory.
          # 
          # _@return_ — The cleared out _added docs.
          # 
          # Clear out the enumerable.
          # ```ruby
          # enumerable.clear
          # ```
          # 
          # Clear out the enumerable with a block.
          # ```ruby
          # enumerable.clear do |doc|
          #   doc.unbind
          # end
          # ```
          sig { returns(T::Array[Document]) }
          def clear; end

          # Clones each document in the enumerable.
          # 
          # _@return_ — An array clone of the enumerable.
          # 
          # Clone the enumerable.
          # ```ruby
          # enumerable.clone
          # ```
          # 
          # _@note_ — This loads all documents into memory.
          sig { returns(T::Array[Document]) }
          def clone; end

          # Delete the supplied document from the enumerable.
          # 
          # _@param_ `document` — The document to delete.
          # 
          # _@return_ — The deleted document.
          # 
          # Delete the document.
          # ```ruby
          # enumerable.delete(document)
          # ```
          sig { params(document: Document).returns(Document) }
          def delete(document); end

          # Deletes every document in the enumerable for where the block returns
          # true.
          # 
          # _@return_ — The remaining docs.
          # 
          # Delete all matching documents.
          # ```ruby
          # enumerable.delete_if do |doc|
          #   dod._id == _id
          # end
          # ```
          # 
          # _@note_ — This operation loads all documents from the database.
          sig { params(block: T.untyped).returns(T::Array[Document]) }
          def delete_if(&block); end

          # Iterating over this enumerable has to handle a few different
          # scenarios.
          # 
          # If the enumerable has its criteria _loaded into memory then it yields
          # to all the _loaded docs and all the _added docs.
          # 
          # If the enumerable has not _loaded the criteria then it iterates over
          # the cursor while loading the documents and then iterates over the
          # _added docs.
          # 
          # If no block is passed then it returns an enumerator containing all
          # docs.
          # 
          # _@return_ — That the enumerable is now _loaded.
          # 
          # Iterate over the enumerable.
          # ```ruby
          # enumerable.each do |doc|
          #   puts doc
          # end
          # ```
          # 
          # return an enumerator containing all the docs
          # ```ruby
          # 
          # a = enumerable.each
          # ```
          sig { returns(T::Boolean) }
          def each; end

          # Is the enumerable empty? Will determine if the count is zero based on
          # whether or not it is _loaded.
          # 
          # _@return_ — If the enumerable is empty.
          # 
          # Is the enumerable empty?
          # ```ruby
          # enumerable.empty?
          # ```
          sig { returns(T::Boolean) }
          def empty?; end

          # sord infer - argument name in single @param inferred as "*args"
          # Returns whether the association has any documents, optionally
          # subject to the provided filters.
          # 
          # This method returns true if the association has any persisted
          # documents and if it has any not yet persisted documents.
          # 
          # If the association is already loaded, this method inspects the
          # loaded documents and does not query the database. If the
          # association is not loaded, the argument-less and block-less
          # version does not load the association; the other versions
          # (that delegate to Enumerable) may or may not load the association
          # completely depending on whether it is iterated to completion.
          # 
          # This method can take a parameter and a block. The behavior with
          # either the paramater or the block is delegated to the standard
          # library Enumerable module.
          # 
          # Note that when Enumerable's any? method is invoked with both
          # a block and a pattern, it only uses the pattern.
          # 
          # _@param_ `condition` — The condition that documents must satisfy. See Enumerable documentation for details.
          # 
          # _@return_ — If the association has any documents.
          sig { params(args: Object).returns(T::Boolean) }
          def any?(*args); end

          # Get the first document in the enumerable. Will check the persisted
          # documents first. Does not load the entire enumerable.
          # 
          # _@param_ `opts` — The options for the query returning the first document.
          # 
          # _@return_ — The first document found.
          # 
          # Get the first document.
          # ```ruby
          # enumerable.first
          # ```
          # 
          # _@note_ — Automatically adding a sort on _id when no other sort is
          # defined on the criteria has the potential to cause bad performance issues.
          # If you experience unexpected poor performance when using #first or #last,
          # use the option { id_sort: :none }.
          # Be aware that #first/#last won't guarantee order in this case.
          sig { params(opts: T::Hash[T.untyped, T.untyped]).returns(Document) }
          def first(opts = {}); end

                              # Initialize the new enumerable either with a criteria or an array.
          # 
          # _@param_ `target` — The wrapped object.
          # 
          # Initialize the enumerable with a criteria.
          # ```ruby
          # Enumberable.new(Post.where(:person_id => id))
          # ```
          # 
          # Initialize the enumerable with an array.
          # ```ruby
          # Enumerable.new([ post ])
          # ```
          sig { params(target: T.any(Criteria, T::Array[Document]), base: T.untyped, association: T.untyped).void }
          def initialize(target, base = nil, association = nil); end

          # Does the target include the provided document?
          # 
          # _@param_ `doc` — The document to check.
          # 
          # _@return_ — If the document is in the target.
          # 
          # Does the target include the document?
          # ```ruby
          # enumerable.include?(document)
          # ```
          sig { params(doc: Document).returns(T::Boolean) }
          def include?(doc); end

          # Inspection will just inspect the entries for nice array-style
          # printing.
          # 
          # _@return_ — The inspected enum.
          # 
          # Inspect the enumerable.
          # ```ruby
          # enumerable.inspect
          # ```
          sig { returns(String) }
          def inspect; end

          # Return all the documents in the enumerable that have been _loaded or
          # _added.
          # 
          # _@return_ — The in memory docs.
          # 
          # Get the in memory docs.
          # ```ruby
          # enumerable.in_memory
          # ```
          # 
          # _@note_ — When passed a block it yields to each document.
          sig { returns(T::Array[Document]) }
          def in_memory; end

          # Get the last document in the enumerable. Will check the new
          # documents first. Does not load the entire enumerable.
          # 
          # _@param_ `opts` — The options for the query returning the first document.
          # 
          # _@return_ — The last document found.
          # 
          # Get the last document.
          # ```ruby
          # enumerable.last
          # ```
          # 
          # _@note_ — Automatically adding a sort on _id when no other sort is
          # defined on the criteria has the potential to cause bad performance issues.
          # If you experience unexpected poor performance when using #first or #last,
          # use the option { id_sort: :none }.
          # Be aware that #first/#last won't guarantee order in this case.
          sig { params(opts: T::Hash[T.untyped, T.untyped]).returns(Document) }
          def last(opts = {}); end

          # Has the enumerable been _loaded? This will be true if the criteria has
          # been executed or we manually load the entire thing.
          # 
          # _@return_ — If the enumerable has been _loaded.
          # 
          # Is the enumerable _loaded?
          # ```ruby
          # enumerable._loaded?
          # ```
          sig { returns(T::Boolean) }
          def _loaded?; end

          # Provides the data needed to Marshal.dump an enumerable proxy.
          # 
          # _@return_ — The dumped data.
          # 
          # Dump the proxy.
          # ```ruby
          # Marshal.dump(proxy)
          # ```
          sig { returns(T::Array[Object]) }
          def marshal_dump; end

                    # Loads the data needed to Marshal.load an enumerable proxy.
          # 
          # _@return_ — The dumped data.
          # 
          # Load the proxy.
          # ```ruby
          # Marshal.load(proxy)
          # ```
          sig { params(data: T.untyped).returns(T::Array[Object]) }
          def marshal_load(data); end

          # Reset the enumerable back to its persisted state.
          # 
          # _@return_ — Always false.
          # 
          # Reset the enumerable.
          # ```ruby
          # enumerable.reset
          # ```
          sig { returns(T::Boolean) }
          def reset; end

                    # Resets the underlying unloaded criteria object with a new one. Used
          # my HABTM associations to keep the underlying array in sync.
          # 
          # _@param_ `criteria` — The criteria to replace with.
          # 
          # Reset the unloaded documents.
          # ```ruby
          # enumerable.reset_unloaded(criteria)
          # ```
          sig { params(criteria: Criteria).returns(T.untyped) }
          def reset_unloaded(criteria); end

          # Does this enumerable respond to the provided method?
          # 
          # _@param_ `name` — The name of the method.
          # 
          # _@param_ `include_private` — Whether to include private methods.
          # 
          # _@return_ — Whether the enumerable responds.
          # 
          # Does the enumerable respond to the method?
          # ```ruby
          # enumerable.respond_to?(:sum)
          # ```
          sig { params(name: T.any(String, Symbol), include_private: T::Boolean).returns(T::Boolean) }
          def respond_to?(name, include_private = false); end

          # Gets the total size of this enumerable. This is a combination of all
          # the persisted and unpersisted documents.
          # 
          # _@return_ — The size of the enumerable.
          # 
          # Get the size.
          # ```ruby
          # enumerable.size
          # ```
          sig { returns(Integer) }
          def size; end

          # Send #to_json to the entries.
          # 
          # _@param_ `options` — Optional parameters.
          # 
          # _@return_ — The entries all _loaded as a string.
          # 
          # Get the enumerable as json.
          # ```ruby
          # enumerable.to_json
          # ```
          sig { params(options: T::Hash[T.untyped, T.untyped]).returns(String) }
          def to_json(options = {}); end

          # Send #as_json to the entries, without encoding.
          # 
          # _@param_ `options` — Optional parameters.
          # 
          # _@return_ — The entries all _loaded as a hash.
          # 
          # Get the enumerable as json.
          # ```ruby
          # enumerable.as_json
          # ```
          sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Hash[T.untyped, T.untyped]) }
          def as_json(options = {}); end

          # Return all the unique documents in the enumerable.
          # 
          # _@return_ — The unique documents.
          # 
          # Get all the unique documents.
          # ```ruby
          # enumerable.uniq
          # ```
          # 
          # _@note_ — This operation loads all documents from the database.
          sig { returns(T::Array[Document]) }
          def uniq; end

                              sig { params(document: T.untyped).returns(T.untyped) }
          def set_base(document); end

                                        sig { params(name: T.untyped, args: T.untyped, block: T.untyped).returns(T.untyped) }
          def method_missing(name, *args, &block); end

                    sig { returns(T.untyped) }
          def unloaded_documents; end

                    # The three main instance variables are collections of documents.
          sig { returns(T.untyped) }
          attr_accessor :_added

                    # The three main instance variables are collections of documents.
          sig { returns(T.untyped) }
          attr_accessor :_added

                    # The three main instance variables are collections of documents.
          sig { returns(T.untyped) }
          attr_accessor :_loaded

                    # The three main instance variables are collections of documents.
          sig { returns(T.untyped) }
          attr_accessor :_unloaded

                    # The three main instance variables are collections of documents.
          sig { returns(T.untyped) }
          attr_accessor :_loaded

                    # The three main instance variables are collections of documents.
          sig { returns(T.untyped) }
          attr_accessor :_unloaded
        end
      end

      # This module handles the behavior for synchronizing foreign keys between
      # both sides of a many to many associations.
      module Syncable
        # Is the document able to be synced on the inverse side? This is only if
        # the key has changed and the association bindings have not been run.
        # 
        # _@param_ `association` — The association metadata.
        # 
        # _@return_ — If we can sync.
        # 
        # Are the foreign keys syncable?
        # ```ruby
        # document._syncable?(association)
        # ```
        sig { params(association: Association).returns(T::Boolean) }
        def _syncable?(association); end

        # Get the synced foreign keys.
        # 
        # _@return_ — The synced foreign keys.
        # 
        # Get the synced foreign keys.
        # ```ruby
        # document._synced
        # ```
        sig { returns(T::Hash[T.untyped, T.untyped]) }
        def _synced; end

        # Has the document been synced for the foreign key?
        # 
        # _@param_ `foreign_key` — The foreign key.
        # 
        # _@return_ — If we can sync.
        # 
        # Has the document been synced?
        # ```ruby
        # document._synced?
        # ```
        sig { params(foreign_key: String).returns(T::Boolean) }
        def _synced?(foreign_key); end

        # Update the inverse keys on destroy.
        # 
        # _@param_ `association` — The association.
        # 
        # _@return_ — The updated values.
        # 
        # Update the inverse keys.
        # ```ruby
        # document.remove_inverse_keys(association)
        # ```
        sig { params(association: Association).returns(Object) }
        def remove_inverse_keys(association); end

        # Update the inverse keys for the association.
        # 
        # _@param_ `association` — The document association.
        # 
        # _@return_ — The updated values.
        # 
        # Update the inverse keys
        # ```ruby
        # document.update_inverse_keys(association)
        # ```
        sig { params(association: Association).returns(Object) }
        def update_inverse_keys(association); end

        module ClassMethods
                    # Set up the syncing of many to many foreign keys.
          # 
          # _@param_ `association` — The association metadata.
          # 
          # Set up the syncing.
          # ```ruby
          # Person._synced(association)
          # ```
          sig { params(association: Association).returns(T.untyped) }
          def _synced(association); end

          # Set up the sync of inverse keys that needs to happen on a save.
          # 
          # If the foreign key field has changed and the document is not
          # synced, $addToSet the new ids, $pull the ones no longer in the
          # array from the inverse side.
          # 
          # _@param_ `association` — The association metadata.
          # 
          # _@return_ — The class getting set up.
          # 
          # Set up the save syncing.
          # ```ruby
          # Person.synced_save(association)
          # ```
          sig { params(association: Association).returns(Class) }
          def synced_save(association); end

          # Set up the sync of inverse keys that needs to happen on a destroy.
          # 
          # _@param_ `association` — The association metadata.
          # 
          # _@return_ — The class getting set up.
          # 
          # Set up the destroy syncing.
          # ```ruby
          # Person.synced_destroy(association)
          # ```
          sig { params(association: Association).returns(Class) }
          def synced_destroy(association); end
        end
      end

      module AutoSave
        extend ActiveSupport::Concern

        # Used to prevent infinite loops in associated autosaves.
        # 
        # _@return_ — Has the document already been autosaved?
        # 
        # Is the document autosaved?
        # ```ruby
        # document.autosaved?
        # ```
        sig { returns(T::Boolean) }
        def autosaved?; end

                # Begin the associated autosave.
        # 
        # Begin autosave.
        # ```ruby
        # document.__autosaving__
        # ```
        sig { returns(T.untyped) }
        def __autosaving__; end

                # Check if there is changes for auto-saving
        # 
        #   document.changed_for_autosave?
        # 
        # Return true if there is changes on self or in
        # ```ruby
        # autosaved associations.
        # ```
        sig { params(doc: T.untyped).returns(T::Boolean) }
        def changed_for_autosave?(doc); end

        # Define the autosave method on an association's owning class for
        # an associated object.
        # 
        # _@param_ `association` — The association for which autosaving is enabled.
        # 
        # _@return_ — The association's owner class.
        # 
        # Define the autosave method:
        # ```ruby
        # Association::Referenced::Autosave.define_autosave!(association)
        # ```
        sig { params(association: Association).returns(Class) }
        def self.define_autosave!(association); end
      end

      # The BelongsTo type association.
      # 
      # @since 7.0
      class BelongsTo
        include Mongoid::Association::Relatable
        include Mongoid::Association::Referenced::BelongsTo::Buildable
        ASSOCIATION_OPTIONS = T.let([
    :autobuild,
    :autosave,
    :counter_cache,
    :dependent,
    :foreign_key,
    :index,
    :polymorphic,
    :primary_key,
    :touch,
    :optional,
    :required
].freeze, T.untyped)
        VALID_OPTIONS = T.let((ASSOCIATION_OPTIONS + SHARED_OPTIONS).freeze, T.untyped)
        FOREIGN_KEY_FIELD_TYPE = T.let(Object, T.untyped)
        FOREIGN_KEY_SUFFIX = T.let('_id'.freeze, T.untyped)
        SHARED_OPTIONS = T.let([
  :class_name,
  :inverse_of,
  :validate,
  :extend
].freeze, T.untyped)
        PRIMARY_KEY_DEFAULT = T.let('_id'.freeze, T.untyped)

        # The list of association complements.
        # 
        # _@return_ — The association complements.
        sig { returns(T::Array[Association]) }
        def relation_complements; end

        # Setup the instance methods, fields, etc. on the association owning class.
        sig { returns(T.self_type) }
        def setup!; end

        # Does this association type store the foreign key?
        # 
        # _@return_ — Always true.
        sig { returns(T::Boolean) }
        def stores_foreign_key?; end

        # Is this association type embedded?
        # 
        # _@return_ — Always false.
        sig { returns(T::Boolean) }
        def embedded?; end

        # The default for validation the association object.
        # 
        # _@return_ — Always false.
        sig { returns(T::Boolean) }
        def validation_default; end

        # Get the foreign key field for saving the association reference.
        # 
        # _@return_ — The foreign key field for saving the association reference.
        sig { returns(String) }
        def foreign_key; end

        # sord warn - Association::BelongsTo::Proxy wasn't able to be resolved to a constant in this project
        # Get the association proxy class for this association type.
        # 
        # _@return_ — The proxy class.
        sig { returns(Mongoid::Association::Referenced::BelongsTo::Proxy) }
        def relation; end

        # Is this association polymorphic?
        # 
        # _@return_ — Whether this association is polymorphic.
        sig { returns(T::Boolean) }
        def polymorphic?; end

        # The name of the field used to store the type of polymorphic association.
        # 
        # _@return_ — The field used to store the type of polymorphic association.
        sig { returns(String) }
        def inverse_type; end

        # The nested builder object.
        # 
        # _@param_ `attributes` — The attributes to use to build the association object.
        # 
        # _@param_ `options` — The options for the association.
        # 
        # _@return_ — The Nested Builder object.
        sig { params(attributes: T::Hash[T.untyped, T.untyped], options: T::Hash[T.untyped, T.untyped]).returns(Association::Nested::One) }
        def nested_builder(attributes, options); end

        # sord infer - Root was resolved to Mongoid::Atomic::Paths::Root
        # Get the path calculator for the supplied document.
        # 
        # _@param_ `document` — The document to calculate on.
        # 
        # _@return_ — The root atomic path calculator.
        # 
        # Get the path calculator.
        # ```ruby
        # association.path(document)
        # ```
        sig { params(document: Document).returns(Mongoid::Atomic::Paths::Root) }
        def path(document); end

                sig { returns(T.untyped) }
        def setup_instance_methods!; end

                sig { returns(T.untyped) }
        def index_spec; end

                sig { returns(T.untyped) }
        def default_primary_key; end

                sig { returns(T.untyped) }
        def default_foreign_key_field; end

                sig { returns(T.untyped) }
        def polymorph!; end

                        sig { params(other: T.untyped).returns(T.untyped) }
        def polymorphic_inverses(other = nil); end

                        sig { params(other: T.untyped).returns(T.untyped) }
        def determine_inverses(other); end

        # If set to true, then the associated object will be validated when this object is saved
        sig { returns(T::Boolean) }
        def require_association?; end

                sig { returns(T.untyped) }
        def create_foreign_key_field!; end

        # This method either takes an _id or an object and queries for the
        # inverse side using the id or sets the object.
        # 
        # _@param_ `base` — The base object.
        # 
        # _@param_ `object` — The object to use to build the association.
        # 
        # _@param_ `type` — The type of the association.
        # 
        # _@param_ `selected_fields` — Must be nil.
        # 
        # _@return_ — A single document.
        # 
        # Build the document.
        # ```ruby
        # relation.build(meta, attrs)
        # ```
        sig do
          params(
            base: Object,
            object: Object,
            type: T.nilable(String),
            selected_fields: T.nilable(T.any())
          ).returns(Document)
        end
        def build(base, object, type = nil, selected_fields = nil); end

                                sig { params(object: T.untyped, type: T.untyped).returns(T.untyped) }
        def execute_query(object, type); end

                                sig { params(object: T.untyped, type: T.untyped).returns(T.untyped) }
        def query_criteria(object, type); end

                sig { params(object: T.untyped).returns(T::Boolean) }
        def query?(object); end

        # Initialize the Association.
        # 
        # _@param_ `_class` — The class of the model who owns this association.
        # 
        # _@param_ `name` — The name of the association.
        # 
        # _@param_ `opts` — The association options.
        # 
        # _@param_ `block` — The optional block.
        sig do
          params(
            _class: Class,
            name: Symbol,
            opts: T::Hash[T.untyped, T.untyped],
            block: T.untyped
          ).void
        end
        def initialize(_class, name, opts = {}, &block); end

                # Compare this association to another.
        # 
        # _@return_ — The object to compare to this association.
        sig { params(other: T.untyped).returns(Object) }
        def ==(other); end

        # Get the callbacks for a given type.
        # 
        # _@param_ `callback_type` — The type of callback type.
        # 
        # _@return_ — A list of the callbacks, either method
        # names or Procs.
        sig { params(callback_type: Symbol).returns(T::Array[T.any(Proc, Symbol)]) }
        def get_callbacks(callback_type); end

        # Get the type setter.
        # 
        # _@return_ — The type setter method.
        # 
        # _@note_ — Only relevant for polymorphic associations that take the :as option.
        sig { returns(String) }
        def type_setter; end

        # Whether trying to bind an object using this association should raise
        # an error.
        # 
        # _@param_ `doc` — The document to be bound.
        # 
        # _@return_ — Whether the document can be bound.
        sig { params(doc: Document).returns(T::Boolean) }
        def bindable?(doc); end

        # Get the inverse names.
        # 
        # _@param_ `other` — The other model class or model object to use when determining inverses.
        # 
        # _@return_ — The list of inverse names.
        sig { params(other: T.nilable(Object)).returns(T::Array[Symbol]) }
        def inverses(other = nil); end

        # Get the inverse's association metadata.
        # 
        # _@param_ `other` — The other model class or model object to use when determining inverses.
        # 
        # _@return_ — The inverse's association metadata.
        sig { params(other: T.nilable(Object)).returns(Association) }
        def inverse_association(other = nil); end

        # The class name, possibly unqualified or :: prefixed, of the association
        # object(s).
        # 
        # This method returns the class name as it is used in the association
        # definition. If :class_name option is given in the association, the
        # exact value of that option is returned here. If :class_name option is
        # not given, the name of the class is calculated from association name
        # but is not resolved to the actual class.
        # 
        # The class name returned by this method may not correspond to a defined
        # class, either because the corresponding class has not been loaded yet,
        # or because the association references a non-existent class altogether.
        # To obtain the association class, use +relation_class+ method.
        # 
        # _@return_ — The association objects' class name.
        # 
        # _@note_ — The return value of this method should not be used to determine
        # whether two associations have the same target class, because the
        # return value is not always a fully qualified class name. To compare
        # classes, retrieve the class instance of the association target using
        # the +relation_class+ method.
        sig { returns(String) }
        def relation_class_name; end

        # The class of the association object(s).
        # 
        # This method returns the class instance corresponding to
        # +relation_class_name+, resolved relative to the host document class.
        # 
        # If the class does not exist, this method raises NameError. This can
        # happen because the target class has not yet been defined. Note that
        # polymorphic associations generally do not have a well defined target
        # class because the target class can change from one object to another,
        # and calling this method on a polymorphic association will generally
        # fail with a NameError or produce misleading results (if a class does
        # happen to be defined with the same name as the association name).
        # 
        # _@return_ — The association objects' class.
        sig { returns(String) }
        def relation_class; end

        # The class name of the object owning this association.
        # 
        # _@return_ — The owning objects' class name.
        sig { returns(String) }
        def inverse_class_name; end

        # The class of the object owning this association.
        # 
        # _@return_ — The owning objects' class.
        sig { returns(String) }
        def inverse_class; end

        # The foreign key field if this association stores a foreign key.
        # Otherwise, the primary key.
        # 
        # _@return_ — The primary key.
        sig { returns(T.any(Symbol, String)) }
        def key; end

        # The name of the setter on this object for assigning an associated object.
        # 
        # _@return_ — The setter name.
        sig { returns(String) }
        def setter; end

                # The name of the inverse setter method.
        # 
        # _@return_ — The name of the inverse setter.
        sig { params(other: T.untyped).returns(String) }
        def inverse_setter(other = nil); end

        # The name of the foreign key setter method.
        # 
        # _@return_ — The name of the foreign key setter.
        sig { returns(String) }
        def foreign_key_setter; end

        # Gets the setter for the field that sets the type of document on a
        # polymorphic association.
        # 
        # _@return_ — The name of the setter.
        # 
        # Get the inverse type setter.
        # ```ruby
        # association.inverse_type_setter
        # ```
        sig { returns(String) }
        def inverse_type_setter; end

        # Get the name of the method to check if the foreign key has changed.
        # 
        # _@return_ — The foreign key check.
        # 
        # Get the foreign key check method.
        # ```ruby
        # association.foreign_key_check
        # ```
        sig { returns(String) }
        def foreign_key_check; end

        # Create an association proxy object using the owner and target.
        # 
        # _@param_ `owner` — The document this association hangs off of.
        # 
        # _@param_ `target` — The target (parent) of the association.
        sig { params(owner: Document, target: T.any(Document, T::Array[Document])).returns(Proxy) }
        def create_relation(owner, target); end

        # Whether the dependent method is destructive.
        # 
        # _@return_ — If the dependent method is destructive.
        sig { returns(T::Boolean) }
        def destructive?; end

        # Get the counter cache column name.
        # 
        # _@return_ — The counter cache column name.
        sig { returns(String) }
        def counter_cache_column_name; end

        # Get the extension.
        # 
        # _@return_ — The extension module, if one has been defined.
        sig { returns(Module) }
        def extension; end

                # Get the inverse name.
        # 
        # _@return_ — The inverse name.
        sig { params(other: T.untyped).returns(Symbol) }
        def inverse(other = nil); end

        # Whether the associated object(s) should be validated.
        # 
        # _@return_ — If the associated object(s)
        # should be validated.
        sig { returns(T::Boolean) }
        def validate?; end

                # Gets the model classes with inverse associations of this model. This is used to determine
        # the classes on the other end of polymorphic associations with models.
        sig { returns(T.untyped) }
        def inverse_association_classes; end

                sig { returns(T.untyped) }
        def setup_index!; end

                sig { returns(T.untyped) }
        def define_touchable!; end

                sig { returns(T.untyped) }
        def define_autosaver!; end

                sig { returns(T.untyped) }
        def define_builder!; end

                sig { returns(T.untyped) }
        def define_creator!; end

                sig { returns(T.untyped) }
        def define_getter!; end

                sig { returns(T.untyped) }
        def define_setter!; end

                sig { returns(T.untyped) }
        def define_existence_check!; end

                sig { returns(T.untyped) }
        def define_ids_getter!; end

                sig { returns(T.untyped) }
        def define_ids_setter!; end

                sig { returns(T.untyped) }
        def define_counter_cache_callbacks!; end

                sig { returns(T.untyped) }
        def define_dependency!; end

                sig { returns(T.untyped) }
        def validate!; end

                sig { params(block: T.untyped).returns(T.untyped) }
        def create_extension!(&block); end

                sig { returns(T.untyped) }
        def default_inverse; end

                        # Returns an array of classes/modules forming the namespace hierarchy
        # where symbols referenced in the provided class/module would be looked
        # up by Ruby. For example, if mod is Foo::Bar, this method would return
        # [Foo::Bar, Foo, Object].
        sig { params(mod: T.untyped).returns(T.untyped) }
        def namespace_hierarchy(mod); end

                                # Resolves the given class/module name in the context of the specified
        # module, as Ruby would when a constant is referenced in the source.
        # 
        # _@note_ — This method can swallow exceptions produced during class loading,
        # because it rescues NameError internally. Since this method attempts
        # to load classes, failure during the loading process may also lead to
        # there being incomplete class definitions.
        sig { params(mod: T.untyped, name: T.untyped).returns(T.untyped) }
        def resolve_name(mod, name); end

        # Returns the name of the parent to a polymorphic child.
        # 
        # _@return_ — The name.
        sig { returns(T.any(String, Symbol)) }
        def as; end

        # Specify what happens to the associated object when the owner is destroyed.
        # 
        # _@return_ — The dependent option.
        sig { returns(String) }
        def dependent; end

        # The custom sorting options on the association.
        # 
        # _@return_ — The custom sorting options.
        sig { returns(Criteria::Queryable::Key) }
        def order; end

        # Whether to index the primary or foreign key field.
        sig { returns(T::Boolean) }
        def indexed?; end

        # Whether the association is autobuilding.
        sig { returns(T::Boolean) }
        def autobuilding?; end

        # Is the association cyclic.
        # 
        # _@return_ — Whether the association is cyclic.
        sig { returns(T::Boolean) }
        def cyclic?; end

        # The name the owning object uses to refer to this association.
        # 
        # _@return_ — The inverse_of option.
        sig { returns(String) }
        def inverse_of; end

        # Mongoid assumes that the field used to hold the primary key of the association is id.
        # You can override this and explicitly specify the primary key with the :primary_key option.
        # 
        # _@return_ — The primary key.
        sig { returns(T.any(Symbol, String)) }
        def primary_key; end

        # Options to save any loaded members and destroy members that are marked for destruction
        # when the parent object is saved.
        # 
        # _@return_ — The autosave option.
        sig { returns(T::Boolean) }
        def autosave; end

        # Whether the association is counter-cached.
        sig { returns(T::Boolean) }
        def counter_cached?; end

        # Whether the association has callbacks cascaded down from the parent.
        # 
        # _@return_ — Whether callbacks are cascaded.
        sig { returns(T::Boolean) }
        def cascading_callbacks?; end

        # The store_as option.
        # 
        # _@return_ — Default is nil.
        sig { returns(T.nilable(T.any())) }
        def store_as; end

        # Whether the association has forced nil inverse (So no foreign keys are saved).
        # 
        # _@return_ — Default is false.
        sig { returns(T::Boolean) }
        def forced_nil_inverse?; end

        # The field for saving the associated object's type.
        # 
        # _@return_ — Default is nil.
        sig { returns(T.nilable(T.any())) }
        def type; end

        # The field for saving the associated object's type.
        # 
        # _@return_ — Default is nil.
        sig { returns(T.nilable(T.any())) }
        def touch_field; end

        sig { returns(T::Boolean) }
        def touchable?; end

        # Convert the supplied object to the appropriate type to set as the
        # foreign key for an association.
        # 
        # _@param_ `object` — The object to convert.
        # 
        # _@return_ — The object cast to the correct type.
        # 
        # Convert the object.
        # ```ruby
        # constraint.convert("12345")
        # ```
        sig { params(object: Object).returns(Object) }
        def convert_to_foreign_key(object); end

                        sig { params(object: T.untyped).returns(T.untyped) }
        def convert_polymorphic(object); end

        # Eager class for belongs_to associations.
        class Eager < Mongoid::Association::Referenced::Eager::Base
                    sig { returns(T.untyped) }
          def preload; end

                    # Retrieves the documents referenced by the association, and
          # yields each one sequentially to the provided block. If the
          # association is not polymorphic, all documents are retrieved in
          # a single query. If the association is polymorphic, one query is
          # issued per association target class.
          sig { params(block: T.untyped).returns(T.untyped) }
          def each_loaded_document(&block); end

                    # Returns a map from association target class name to foreign key
          # values for the documents of that association target class,
          # as referenced by this association.
          sig { returns(T.untyped) }
          def keys_by_type_from_docs; end

                    sig { returns(T.untyped) }
          def group_by_key; end

                    sig { returns(T.untyped) }
          def key; end
        end

        # This class handles all behavior for associations that are either
        # one-to-many or one-to-one, where the foreign key is stored on this side
        # of the association and the reference is to document(s) in another
        # collection.
        class Proxy < Mongoid::Association::One
          include Mongoid::Evolvable

          # Instantiate a new belongs_to association proxy.
          # 
          # _@param_ `base` — The document this association hangs off of.
          # 
          # _@param_ `target` — The target (parent) of the association.
          # 
          # _@param_ `association` — The association object.
          # 
          # Create the new proxy.
          # ```ruby
          # Association::BelongsTo::Proxy.new(game, person, association)
          # ```
          sig { params(base: Document, target: T.any(Document, T::Array[Document]), association: Association).void }
          def initialize(base, target, association); end

                    # Removes the association between the base document and the target
          # document by deleting the foreign key and the reference, orphaning
          # the target document in the process.
          # 
          # Nullify the association.
          # ```ruby
          # person.game.nullify
          # ```
          sig { returns(T.untyped) }
          def nullify; end

          # Substitutes the supplied target documents for the existing document
          # in the association.
          # 
          # _@param_ `replacement` — The replacement.
          # 
          # _@return_ — The association or nil.
          # 
          # Substitute the association.
          # ```ruby
          # name.substitute(new_name)
          # ```
          sig { params(replacement: T.any(Document, T::Array[Document])).returns(T.nilable(T.self_type)) }
          def substitute(replacement); end

          # sord warn - Binding wasn't able to be resolved to a constant in this project
          # Instantiate the binding associated with this association.
          # 
          # _@return_ — The binding object.
          # 
          # Get the binding object.
          # ```ruby
          # binding([ address ])
          # ```
          sig { returns(Binding) }
          def binding; end

          # Normalize the value provided as a replacement for substitution.
          # 
          # _@param_ `replacement` — The replacement object.
          # 
          # _@return_ — The document.
          # 
          # Normalize the substitute.
          # ```ruby
          # proxy.normalize(id)
          # ```
          sig { params(replacement: T.any(Document, Object)).returns(Document) }
          def normalize(replacement); end

          # Are we able to persist this association?
          # 
          # _@return_ — If the association is persistable.
          # 
          # Can we persist the association?
          # ```ruby
          # relation.persistable?
          # ```
          sig { returns(T::Boolean) }
          def persistable?; end

                    # Get the Eager object for this type of association.
          # 
          # _@param_ `association` — The association object.
          # 
          # _@param_ `docs` — The array of documents.
          # 
          # Get the eager loader object
          # ```ruby
          # ```
          sig { params(association: Association, docs: T::Array[Document]).returns(T.untyped) }
          def self.eager_loader(association, docs); end

          # Returns true if the association is an embedded one. In this case
          # always false.
          # 
          # _@return_ — Always false.
          # 
          # Is this association embedded?
          # ```ruby
          # Association::BelongsTo::Proxy.embedded?
          # ```
          sig { returns(T::Boolean) }
          def self.embedded?; end

          # Evolve the document into an object id.
          # 
          # _@return_ — The document's id.
          # 
          # Evolve the document.
          # ```ruby
          # document.__evolve_object_id__
          # ```
          sig { returns(Object) }
          def __evolve_object_id__; end
        end

        # Binding class for belongs_to associations.
        class Binding
          include Mongoid::Association::Bindable

                    # Binds the base object to the inverse of the association. This is so we
          # are referenced to the actual objects themselves on both sides.
          # 
          # This case sets the association on the inverse object as well as the
          # document itself.
          # 
          # Bind the documents.
          # ```ruby
          # game.person.bind(:continue => true)
          # game.person = Person.new
          # ```
          sig { returns(T.untyped) }
          def bind_one; end

                    # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          # 
          # Unbind the document.
          # ```ruby
          # game.person.unbind(:continue => true)
          # game.person = nil
          # ```
          sig { returns(T.untyped) }
          def unbind_one; end

                    # Check for problems with multiple inverse definitions.
          # 
          # _@param_ `doc` — The document to check.
          # 
          # Check for inverses errors.
          # ```ruby
          # binding.check_inverses!(doc)
          # ```
          sig { params(doc: Document).returns(T.untyped) }
          def check_polymorphic_inverses!(doc); end

          # Create the new binding.
          # 
          # _@param_ `base` — The base of the binding.
          # 
          # _@param_ `target` — The target of the binding.
          # 
          # _@param_ `association` — The association metadata.
          # 
          # Initialize a binding.
          # ```ruby
          # Binding.new(base, target, association)
          # ```
          sig { params(base: Document, target: T.any(Document, T::Array[Document]), association: Association).void }
          def initialize(base, target, association); end

          # Execute the provided block inside a binding.
          # 
          # _@return_ — The result of the yield.
          # 
          # Execute the binding block.
          # ```ruby
          # binding.binding do
          #   base.foreign_key = 1
          # end
          # ```
          sig { returns(Object) }
          def binding; end

                    # Check if the inverse is properly defined.
          # 
          # _@param_ `doc` — The document getting bound.
          # 
          # Check the inverse definition.
          # ```ruby
          # binding.check_inverse!(doc)
          # ```
          sig { params(doc: Document).returns(T.untyped) }
          def check_inverse!(doc); end

                    # Set the id of the related document in the foreign key field on the
          # keyed document.
          # 
          # _@param_ `keyed` — The document that stores the foreign key.
          # 
          # _@param_ `id` — The id of the bound document.
          # 
          # Bind the foreign key.
          # ```ruby
          # binding.bind_foreign_key(post, person._id)
          # ```
          sig { params(keyed: Document, id: Object).returns(T.untyped) }
          def bind_foreign_key(keyed, id); end

                    # Set the type of the related document on the foreign type field, used
          # when associations are polymorphic.
          # 
          # _@param_ `typed` — The document that stores the type field.
          # 
          # _@param_ `name` — The name of the model.
          # 
          # Bind the polymorphic type.
          # ```ruby
          # binding.bind_polymorphic_type(post, "Person")
          # ```
          sig { params(typed: Document, name: String).returns(T.untyped) }
          def bind_polymorphic_type(typed, name); end

                    # Set the type of the related document on the foreign type field, used
          # when associations are polymorphic.
          # 
          # _@param_ `typed` — The document that stores the type field.
          # 
          # _@param_ `name` — The name of the model.
          # 
          # Bind the polymorphic type.
          # ```ruby
          # binding.bind_polymorphic_inverse_type(post, "Person")
          # ```
          sig { params(typed: Document, name: String).returns(T.untyped) }
          def bind_polymorphic_inverse_type(typed, name); end

                    # Bind the inverse document to the child document so that the in memory
          # instances are the same.
          # 
          # _@param_ `doc` — The base document.
          # 
          # _@param_ `inverse` — The inverse document.
          # 
          # Bind the inverse.
          # ```ruby
          # binding.bind_inverse(post, person)
          # ```
          sig { params(doc: Document, inverse: Document).returns(T.untyped) }
          def bind_inverse(doc, inverse); end

                    # Bind the provided document with the base from the parent association.
          # 
          # _@param_ `doc` — The document to bind.
          # 
          # Bind the document with the base.
          # ```ruby
          # binding.bind_from_relational_parent(doc)
          # ```
          sig { params(doc: Document).returns(T.untyped) }
          def bind_from_relational_parent(doc); end

                              sig { params(_base: T.untyped).returns(T.untyped) }
          def record_id(_base); end

          # Ensure that the association on the base is correct, for the cases
          # where we have multiple belongs to definitions and were are setting
          # different parents in memory in order.
          # 
          # _@return_ — If the association changed.
          # 
          # Set the base association.
          # ```ruby
          # binding.set_base_association
          # ```
          sig { returns(T::Boolean) }
          def set_base_association; end

                    # Bind the provided document with the base from the parent association.
          # 
          # _@param_ `doc` — The document to unbind.
          # 
          # Bind the document with the base.
          # ```ruby
          # unbinding.unbind_from_relational_parent(doc)
          # ```
          sig { params(doc: Document).returns(T.untyped) }
          def unbind_from_relational_parent(doc); end

          # Begin the assignment of attributes. While in this block embedded
          # documents will not autosave themselves in order to allow the document to
          # be in a valid state.
          # 
          # _@return_ — The yielded value.
          # 
          # Execute the assignment.
          # ```ruby
          # _assigning do
          #   person.attributes = { :addresses => [ address ] }
          # end
          # ```
          sig { returns(Object) }
          def _assigning; end

          # Is the current thread in assigning mode?
          # 
          # _@return_ — If the thread is assigning.
          # 
          # Is the current thread in assigning mode?
          # ```ruby
          # proxy._assigning?
          # ```
          sig { returns(T::Boolean) }
          def _assigning?; end

          # Execute a block in binding mode.
          # 
          # _@return_ — The return value of the block.
          # 
          # Execute in binding mode.
          # ```ruby
          # binding do
          #   relation.push(doc)
          # end
          # ```
          sig { returns(Object) }
          def _binding; end

          # Is the current thread in binding mode?
          # 
          # _@return_ — If the thread is binding.
          # 
          # Is the current thread in binding mode?
          # ```ruby
          # proxy.binding?
          # ```
          sig { returns(T::Boolean) }
          def _binding?; end

          # Execute a block in building mode.
          # 
          # _@return_ — The return value of the block.
          # 
          # Execute in building mode.
          # ```ruby
          # _building do
          #   relation.push(doc)
          # end
          # ```
          sig { returns(Object) }
          def _building; end

          # Is the current thread in building mode?
          # 
          # _@return_ — If the thread is building.
          # 
          # Is the current thread in building mode?
          # ```ruby
          # proxy._building?
          # ```
          sig { returns(T::Boolean) }
          def _building?; end

          # Is the current thread in creating mode?
          # 
          # _@return_ — If the thread is creating.
          # 
          # Is the current thread in creating mode?
          # ```ruby
          # proxy.creating?
          # ```
          sig { returns(T::Boolean) }
          def _creating?; end

          # Execute a block in loading mode.
          # 
          # _@return_ — The return value of the block.
          # 
          # Execute in loading mode.
          # ```ruby
          # _loading do
          #   relation.push(doc)
          # end
          # ```
          sig { returns(Object) }
          def _loading; end

          # Is the current thread in loading mode?
          # 
          # _@return_ — If the thread is loading.
          # 
          # Is the current thread in loading mode?
          # ```ruby
          # proxy._loading?
          # ```
          sig { returns(T::Boolean) }
          def _loading?; end
        end

        # The Builder behavior for belongs_to associations.
        # 
        # @since 7.0
        module Buildable
          # This method either takes an _id or an object and queries for the
          # inverse side using the id or sets the object.
          # 
          # _@param_ `base` — The base object.
          # 
          # _@param_ `object` — The object to use to build the association.
          # 
          # _@param_ `type` — The type of the association.
          # 
          # _@param_ `selected_fields` — Must be nil.
          # 
          # _@return_ — A single document.
          # 
          # Build the document.
          # ```ruby
          # relation.build(meta, attrs)
          # ```
          sig do
            params(
              base: Object,
              object: Object,
              type: T.nilable(String),
              selected_fields: T.nilable(T.any())
            ).returns(Document)
          end
          def build(base, object, type = nil, selected_fields = nil); end

                                        sig { params(object: T.untyped, type: T.untyped).returns(T.untyped) }
          def execute_query(object, type); end

                                        sig { params(object: T.untyped, type: T.untyped).returns(T.untyped) }
          def query_criteria(object, type); end

                    sig { params(object: T.untyped).returns(T::Boolean) }
          def query?(object); end
        end
      end

      module CounterCache
        extend ActiveSupport::Concern

                # Reset the given counter using the .count() query from the
        # db. This method is usuful in case that a counter got
        # corrupted, or a new counter was added to the collection.
        # 
        # _@param_ `counters` — One or more counter caches to reset
        # 
        # Reset the given counter cache
        # ```ruby
        # post.reset_counters(:comments)
        # ```
        sig { params(counters: T.any(Symbol, T::Array[T.untyped])).returns(T.untyped) }
        def reset_counters(*counters); end

        # Add the callbacks responsible for update the counter cache field.
        # 
        # _@param_ `association` — The association.
        # 
        # _@return_ — The association's owning class.
        # 
        # Add the touchable.
        # ```ruby
        # Mongoid::Association::Referenced::CounterCache.define_callbacks!(association)
        # ```
        sig { params(association: Association).returns(Class) }
        def self.define_callbacks!(association); end

        module ClassMethods
                    # Reset the given counter using the .count() query from the
          # db. This method is usuful in case that a counter got
          # corrupted, or a new counter was added to the collection.
          # 
          # _@param_ `id` — The id of the object that will be reset.
          # 
          # _@param_ `counters` — One or more counter caches to reset
          # 
          # Reset the given counter cache
          # ```ruby
          # Post.reset_counters('50e0edd97c71c17ea9000001', :comments)
          # ```
          sig { params(id: String, counters: T.any(Symbol, T::Array[T.untyped])).returns(T.untyped) }
          def reset_counters(id, *counters); end

                    # Update the given counters by the value factor. It uses the
          # atomic $inc command.
          # 
          # _@param_ `id` — The id of the object to update.
          # 
          # _@param_ `counters`
          # 
          # Add 5 to comments counter and remove 2 from likes
          # ```ruby
          # counter.
          # Post.update_counters('50e0edd97c71c17ea9000001',
          #            :comments_count => 5, :likes_count => -2)
          # ```
          sig { params(id: String, counters: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
          def update_counters(id, counters); end

                    # Increment the counter name from the entries that match the
          # id by one. This method is used on associations callbacks
          # when counter_cache is enabled
          # 
          # _@param_ `counter_name` — Counter cache name
          # 
          # _@param_ `id` — The id of the object that will have its counter incremented.
          # 
          # Increment comments counter
          # ```ruby
          # Post.increment_counter(:comments_count, '50e0edd97c71c17ea9000001')
          # ```
          sig { params(counter_name: Symbol, id: String).returns(T.untyped) }
          def increment_counter(counter_name, id); end

                    # Decrement the counter name from the entries that match the
          # id by one. This method is used on associations callbacks
          # when counter_cache is enabled
          # 
          # _@param_ `counter_name` — Counter cache name
          # 
          # _@param_ `id` — The id of the object that will have its counter decremented.
          # 
          # Decrement comments counter
          # ```ruby
          # Post.decrement_counter(:comments_count, '50e0edd97c71c17ea9000001')
          # ```
          sig { params(counter_name: Symbol, id: String).returns(T.untyped) }
          def decrement_counter(counter_name, id); end
        end
      end

      module NestedAttributes
        class One
          # Builds the association depending on the attributes and the options
          # passed to the macro.
          # 
          # _@param_ `parent` — The parent document.
          # 
          # _@return_ — The built document.
          # 
          # Build a 1-1 nested document.
          # ```ruby
          # one.build(person, as: :admin)
          # ```
          # 
          # _@note_ — This attempts to perform 3 operations, either one of an update of
          # the existing association, a replacement of the association with a new
          # document, or a removal of the association.
          sig { params(parent: Document).returns(Document) }
          def build(parent); end

          # Create the new builder for nested attributes on one-to-one
          # associations.
          # 
          # _@param_ `association` — The association metadata.
          # 
          # _@param_ `attributes` — The attributes hash to attempt to set.
          # 
          # _@param_ `options` — The options defined.
          # 
          # Instantiate the builder.
          # ```ruby
          # One.new(association, attributes)
          # ```
          sig { params(association: Association, attributes: T::Hash[T.untyped, T.untyped], options: T::Hash[T.untyped, T.untyped]).void }
          def initialize(association, attributes, options); end

          # Is the id in the attribtues acceptable for allowing an update to
          # the existing association?
          # 
          # _@return_ — If the id part of the logic will allow an update.
          # 
          # Is the id acceptable?
          # ```ruby
          # one.acceptable_id?
          # ```
          sig { returns(T::Boolean) }
          def acceptable_id?; end

          # Can the existing association be deleted?
          # 
          # _@return_ — If the association should be deleted.
          # 
          # Can the existing object be deleted?
          # ```ruby
          # one.delete?
          # ```
          sig { returns(T::Boolean) }
          def delete?; end

          # Can the existing association potentially be destroyed?
          # 
          # _@return_ — If the association can potentially be
          # destroyed.
          # 
          # Is the object destroyable?
          # ```ruby
          # one.destroyable?({ :_destroy => "1" })
          # ```
          sig { returns(T::Boolean) }
          def destroyable?; end

          # Is the document to be replaced?
          # 
          # _@return_ — If the document should be replaced.
          # 
          # Is the document to be replaced?
          # ```ruby
          # one.replace?
          # ```
          sig { returns(T::Boolean) }
          def replace?; end

          # Should the document be updated?
          # 
          # _@return_ — If the object should have its attributes updated.
          # 
          # Should the document be updated?
          # ```ruby
          # one.update?
          # ```
          sig { returns(T::Boolean) }
          def update?; end

          # Returns the value of attribute destroy.
          sig { returns(T.untyped) }
          attr_accessor :destroy
        end
      end

      # The HasAndBelongsToMany type association.
      # 
      # @since 7.0
      class HasAndBelongsToMany
        include Mongoid::Association::Relatable
        include Mongoid::Association::Referenced::HasAndBelongsToMany::Buildable
        ASSOCIATION_OPTIONS = T.let([
    :after_add,
    :after_remove,
    :autosave,
    :before_add,
    :before_remove,
    :counter_cache,
    :dependent,
    :foreign_key,
    :index,
    :order,
    :primary_key,
    :inverse_primary_key,
    :inverse_foreign_key,
].freeze, T.untyped)
        VALID_OPTIONS = T.let((ASSOCIATION_OPTIONS + SHARED_OPTIONS).freeze, T.untyped)
        FOREIGN_KEY_FIELD_TYPE = T.let(Array, T.untyped)
        FOREIGN_KEY_SUFFIX = T.let('_ids'.freeze, T.untyped)
        SHARED_OPTIONS = T.let([
  :class_name,
  :inverse_of,
  :validate,
  :extend
].freeze, T.untyped)
        PRIMARY_KEY_DEFAULT = T.let('_id'.freeze, T.untyped)

        # The list of association complements.
        # 
        # _@return_ — The association complements.
        sig { returns(T::Array[Association]) }
        def relation_complements; end

        # Setup the instance methods, fields, etc. on the association owning class.
        sig { returns(T.self_type) }
        def setup!; end

        # Is this association type embedded?
        # 
        # _@return_ — Always false.
        sig { returns(T::Boolean) }
        def embedded?; end

        # The default for validation the association object.
        # 
        # _@return_ — Always false.
        sig { returns(T::Boolean) }
        def validation_default; end

        # Are ids only saved on this side of the association?
        # 
        # _@return_ — Whether this association has a forced nil inverse.
        sig { returns(T::Boolean) }
        def forced_nil_inverse?; end

        # Does this association type store the foreign key?
        # 
        # _@return_ — Always true.
        sig { returns(T::Boolean) }
        def stores_foreign_key?; end

        # sord warn - Association::HasAndBelongsToMany::Proxy wasn't able to be resolved to a constant in this project
        # Get the association proxy class for this association type.
        # 
        # _@return_ — The proxy class.
        sig { returns(Mongoid::Association::Referenced::HasAndBelongsToMany::Proxy) }
        def relation; end

        # Get the foreign key field for saving the association reference.
        # 
        # _@return_ — The foreign key field for saving the association reference.
        sig { returns(String) }
        def foreign_key; end

                        # The criteria used for querying this association.
        # 
        # _@return_ — The criteria used for querying this association.
        sig { params(base: T.untyped, id_list: T.untyped).returns(Mongoid::Criteria) }
        def criteria(base, id_list = nil); end

        # Get the foreign key field on the inverse.
        # 
        # _@return_ — The foreign key field for saving the association reference
        # on the inverse side.
        sig { returns(String) }
        def inverse_foreign_key; end

        # Whether trying to bind an object using this association should raise
        # an error.
        # 
        # _@param_ `doc` — The document to be bound.
        # 
        # _@return_ — Whether the document can be bound.
        sig { params(doc: Document).returns(T::Boolean) }
        def bindable?(doc); end

        # Get the foreign key setter on the inverse.
        # 
        # _@return_ — The foreign key setter for saving the association reference
        # on the inverse side.
        sig { returns(String) }
        def inverse_foreign_key_setter; end

        # The nested builder object.
        # 
        # _@param_ `attributes` — The attributes to use to build the association object.
        # 
        # _@param_ `options` — The options for the association.
        # 
        # _@return_ — The Nested Builder object.
        sig { params(attributes: T::Hash[T.untyped, T.untyped], options: T::Hash[T.untyped, T.untyped]).returns(Association::Nested::One) }
        def nested_builder(attributes, options); end

        # sord infer - Root was resolved to Mongoid::Atomic::Paths::Root
        # Get the path calculator for the supplied document.
        # 
        # _@param_ `document` — The document to calculate on.
        # 
        # _@return_ — The root atomic path calculator.
        # 
        # Get the path calculator.
        # ```ruby
        # association.path(document)
        # ```
        sig { params(document: Document).returns(Mongoid::Atomic::Paths::Root) }
        def path(document); end

                sig { returns(T.untyped) }
        def setup_instance_methods!; end

                sig { returns(T.untyped) }
        def index_spec; end

                sig { returns(T.untyped) }
        def default_primary_key; end

                sig { returns(T.untyped) }
        def default_foreign_key_field; end

                sig { returns(T.untyped) }
        def setup_syncing!; end

                sig { returns(T.untyped) }
        def synced_destroy; end

                sig { returns(T.untyped) }
        def synced_save; end

                sig { returns(T.untyped) }
        def create_foreign_key_field!; end

                        sig { params(other: T.untyped).returns(T.untyped) }
        def determine_inverses(other); end

                        sig { params(criteria: T.untyped).returns(T.untyped) }
        def with_ordering(criteria); end

                        sig { params(id_list: T.untyped).returns(T.untyped) }
        def query_criteria(id_list); end

        # This builder either takes a hash and queries for the
        # object or an array of documents, where it will just return them.
        # 
        # _@param_ `base` — The base object.
        # 
        # _@param_ `object` — The object to use to build the association.
        # 
        # _@param_ `type` — Not used in this context.
        # 
        # _@param_ `selected_fields` — Must be nil.
        # 
        # _@return_ — The documents.
        # 
        # Build the documents.
        # ```ruby
        # relation.build(association, attrs)
        # ```
        sig do
          params(
            base: Object,
            object: Object,
            type: T.nilable(String),
            selected_fields: T.nilable(T.any())
          ).returns(T::Array[Document])
        end
        def build(base, object, type = nil, selected_fields = nil); end

                sig { params(object: T.untyped).returns(T::Boolean) }
        def query?(object); end

        # Initialize the Association.
        # 
        # _@param_ `_class` — The class of the model who owns this association.
        # 
        # _@param_ `name` — The name of the association.
        # 
        # _@param_ `opts` — The association options.
        # 
        # _@param_ `block` — The optional block.
        sig do
          params(
            _class: Class,
            name: Symbol,
            opts: T::Hash[T.untyped, T.untyped],
            block: T.untyped
          ).void
        end
        def initialize(_class, name, opts = {}, &block); end

                # Compare this association to another.
        # 
        # _@return_ — The object to compare to this association.
        sig { params(other: T.untyped).returns(Object) }
        def ==(other); end

        # Get the callbacks for a given type.
        # 
        # _@param_ `callback_type` — The type of callback type.
        # 
        # _@return_ — A list of the callbacks, either method
        # names or Procs.
        sig { params(callback_type: Symbol).returns(T::Array[T.any(Proc, Symbol)]) }
        def get_callbacks(callback_type); end

        # Get the type setter.
        # 
        # _@return_ — The type setter method.
        # 
        # _@note_ — Only relevant for polymorphic associations that take the :as option.
        sig { returns(String) }
        def type_setter; end

        # Get the inverse names.
        # 
        # _@param_ `other` — The other model class or model object to use when determining inverses.
        # 
        # _@return_ — The list of inverse names.
        sig { params(other: T.nilable(Object)).returns(T::Array[Symbol]) }
        def inverses(other = nil); end

        # Get the inverse's association metadata.
        # 
        # _@param_ `other` — The other model class or model object to use when determining inverses.
        # 
        # _@return_ — The inverse's association metadata.
        sig { params(other: T.nilable(Object)).returns(Association) }
        def inverse_association(other = nil); end

        # Get the inverse type.
        # 
        # _@return_ — Default is nil for an association.
        sig { returns(T.nilable(T.any())) }
        def inverse_type; end

        # The class name, possibly unqualified or :: prefixed, of the association
        # object(s).
        # 
        # This method returns the class name as it is used in the association
        # definition. If :class_name option is given in the association, the
        # exact value of that option is returned here. If :class_name option is
        # not given, the name of the class is calculated from association name
        # but is not resolved to the actual class.
        # 
        # The class name returned by this method may not correspond to a defined
        # class, either because the corresponding class has not been loaded yet,
        # or because the association references a non-existent class altogether.
        # To obtain the association class, use +relation_class+ method.
        # 
        # _@return_ — The association objects' class name.
        # 
        # _@note_ — The return value of this method should not be used to determine
        # whether two associations have the same target class, because the
        # return value is not always a fully qualified class name. To compare
        # classes, retrieve the class instance of the association target using
        # the +relation_class+ method.
        sig { returns(String) }
        def relation_class_name; end

        # The class of the association object(s).
        # 
        # This method returns the class instance corresponding to
        # +relation_class_name+, resolved relative to the host document class.
        # 
        # If the class does not exist, this method raises NameError. This can
        # happen because the target class has not yet been defined. Note that
        # polymorphic associations generally do not have a well defined target
        # class because the target class can change from one object to another,
        # and calling this method on a polymorphic association will generally
        # fail with a NameError or produce misleading results (if a class does
        # happen to be defined with the same name as the association name).
        # 
        # _@return_ — The association objects' class.
        sig { returns(String) }
        def relation_class; end

        # The class name of the object owning this association.
        # 
        # _@return_ — The owning objects' class name.
        sig { returns(String) }
        def inverse_class_name; end

        # The class of the object owning this association.
        # 
        # _@return_ — The owning objects' class.
        sig { returns(String) }
        def inverse_class; end

        # The foreign key field if this association stores a foreign key.
        # Otherwise, the primary key.
        # 
        # _@return_ — The primary key.
        sig { returns(T.any(Symbol, String)) }
        def key; end

        # The name of the setter on this object for assigning an associated object.
        # 
        # _@return_ — The setter name.
        sig { returns(String) }
        def setter; end

                # The name of the inverse setter method.
        # 
        # _@return_ — The name of the inverse setter.
        sig { params(other: T.untyped).returns(String) }
        def inverse_setter(other = nil); end

        # The name of the foreign key setter method.
        # 
        # _@return_ — The name of the foreign key setter.
        sig { returns(String) }
        def foreign_key_setter; end

        # Gets the setter for the field that sets the type of document on a
        # polymorphic association.
        # 
        # _@return_ — The name of the setter.
        # 
        # Get the inverse type setter.
        # ```ruby
        # association.inverse_type_setter
        # ```
        sig { returns(String) }
        def inverse_type_setter; end

        # Get the name of the method to check if the foreign key has changed.
        # 
        # _@return_ — The foreign key check.
        # 
        # Get the foreign key check method.
        # ```ruby
        # association.foreign_key_check
        # ```
        sig { returns(String) }
        def foreign_key_check; end

        # Create an association proxy object using the owner and target.
        # 
        # _@param_ `owner` — The document this association hangs off of.
        # 
        # _@param_ `target` — The target (parent) of the association.
        sig { params(owner: Document, target: T.any(Document, T::Array[Document])).returns(Proxy) }
        def create_relation(owner, target); end

        # Whether the dependent method is destructive.
        # 
        # _@return_ — If the dependent method is destructive.
        sig { returns(T::Boolean) }
        def destructive?; end

        # Get the counter cache column name.
        # 
        # _@return_ — The counter cache column name.
        sig { returns(String) }
        def counter_cache_column_name; end

        # Get the extension.
        # 
        # _@return_ — The extension module, if one has been defined.
        sig { returns(Module) }
        def extension; end

                # Get the inverse name.
        # 
        # _@return_ — The inverse name.
        sig { params(other: T.untyped).returns(Symbol) }
        def inverse(other = nil); end

        # Whether the associated object(s) should be validated.
        # 
        # _@return_ — If the associated object(s)
        # should be validated.
        sig { returns(T::Boolean) }
        def validate?; end

                # Gets the model classes with inverse associations of this model. This is used to determine
        # the classes on the other end of polymorphic associations with models.
        sig { returns(T.untyped) }
        def inverse_association_classes; end

                sig { returns(T.untyped) }
        def setup_index!; end

                sig { returns(T.untyped) }
        def define_touchable!; end

                sig { returns(T.untyped) }
        def define_autosaver!; end

                sig { returns(T.untyped) }
        def define_builder!; end

                sig { returns(T.untyped) }
        def define_creator!; end

                sig { returns(T.untyped) }
        def define_getter!; end

                sig { returns(T.untyped) }
        def define_setter!; end

                sig { returns(T.untyped) }
        def define_existence_check!; end

                sig { returns(T.untyped) }
        def define_ids_getter!; end

                sig { returns(T.untyped) }
        def define_ids_setter!; end

                sig { returns(T.untyped) }
        def define_counter_cache_callbacks!; end

                sig { returns(T.untyped) }
        def define_dependency!; end

                sig { returns(T.untyped) }
        def validate!; end

                sig { returns(T.untyped) }
        def polymorph!; end

                sig { params(block: T.untyped).returns(T.untyped) }
        def create_extension!(&block); end

                sig { returns(T.untyped) }
        def default_inverse; end

                        # Returns an array of classes/modules forming the namespace hierarchy
        # where symbols referenced in the provided class/module would be looked
        # up by Ruby. For example, if mod is Foo::Bar, this method would return
        # [Foo::Bar, Foo, Object].
        sig { params(mod: T.untyped).returns(T.untyped) }
        def namespace_hierarchy(mod); end

                                # Resolves the given class/module name in the context of the specified
        # module, as Ruby would when a constant is referenced in the source.
        # 
        # _@note_ — This method can swallow exceptions produced during class loading,
        # because it rescues NameError internally. Since this method attempts
        # to load classes, failure during the loading process may also lead to
        # there being incomplete class definitions.
        sig { params(mod: T.untyped, name: T.untyped).returns(T.untyped) }
        def resolve_name(mod, name); end

        # Returns the name of the parent to a polymorphic child.
        # 
        # _@return_ — The name.
        sig { returns(T.any(String, Symbol)) }
        def as; end

        # Specify what happens to the associated object when the owner is destroyed.
        # 
        # _@return_ — The dependent option.
        sig { returns(String) }
        def dependent; end

        # The custom sorting options on the association.
        # 
        # _@return_ — The custom sorting options.
        sig { returns(Criteria::Queryable::Key) }
        def order; end

        # Whether to index the primary or foreign key field.
        sig { returns(T::Boolean) }
        def indexed?; end

        # Whether the association is autobuilding.
        sig { returns(T::Boolean) }
        def autobuilding?; end

        # Is the association cyclic.
        # 
        # _@return_ — Whether the association is cyclic.
        sig { returns(T::Boolean) }
        def cyclic?; end

        # The name the owning object uses to refer to this association.
        # 
        # _@return_ — The inverse_of option.
        sig { returns(String) }
        def inverse_of; end

        # Mongoid assumes that the field used to hold the primary key of the association is id.
        # You can override this and explicitly specify the primary key with the :primary_key option.
        # 
        # _@return_ — The primary key.
        sig { returns(T.any(Symbol, String)) }
        def primary_key; end

        # Options to save any loaded members and destroy members that are marked for destruction
        # when the parent object is saved.
        # 
        # _@return_ — The autosave option.
        sig { returns(T::Boolean) }
        def autosave; end

        # Whether the association is counter-cached.
        sig { returns(T::Boolean) }
        def counter_cached?; end

        # Whether this association is polymorphic.
        # 
        # _@return_ — Whether the association is polymorphic.
        sig { returns(T::Boolean) }
        def polymorphic?; end

        # Whether the association has callbacks cascaded down from the parent.
        # 
        # _@return_ — Whether callbacks are cascaded.
        sig { returns(T::Boolean) }
        def cascading_callbacks?; end

        # The store_as option.
        # 
        # _@return_ — Default is nil.
        sig { returns(T.nilable(T.any())) }
        def store_as; end

        # The field for saving the associated object's type.
        # 
        # _@return_ — Default is nil.
        sig { returns(T.nilable(T.any())) }
        def type; end

        # The field for saving the associated object's type.
        # 
        # _@return_ — Default is nil.
        sig { returns(T.nilable(T.any())) }
        def touch_field; end

        sig { returns(T::Boolean) }
        def touchable?; end

        # Convert the supplied object to the appropriate type to set as the
        # foreign key for an association.
        # 
        # _@param_ `object` — The object to convert.
        # 
        # _@return_ — The object cast to the correct type.
        # 
        # Convert the object.
        # ```ruby
        # constraint.convert("12345")
        # ```
        sig { params(object: Object).returns(Object) }
        def convert_to_foreign_key(object); end

                        sig { params(object: T.untyped).returns(T.untyped) }
        def convert_polymorphic(object); end

        # Eager class for has_and_belongs_to_many associations.
        class Eager < Mongoid::Association::Referenced::Eager::Base
                    sig { returns(T.untyped) }
          def preload; end

                    sig { returns(T.untyped) }
          def keys_from_docs; end

                                        sig { params(doc: T.untyped, element: T.untyped).returns(T.untyped) }
          def set_relation(doc, element); end

                    sig { returns(T.untyped) }
          def group_by_key; end

                    sig { returns(T.untyped) }
          def key; end
        end

        # This class defines the behavior for all associations that are a
        # many-to-many between documents in different collections.
        class Proxy < Mongoid::Association::Referenced::HasMany::Proxy
          # Appends a document or array of documents to the association. Will set
          # the parent and update the index in the process.
          # 
          # _@param_ `args` — Any number of documents.
          # 
          # _@return_ — The loaded docs.
          # 
          # Append a document.
          # ```ruby
          # person.posts << post
          # ```
          # 
          # Push a document.
          # ```ruby
          # person.posts.push(post)
          # ```
          # 
          # Concat with other documents.
          # ```ruby
          # person.posts.concat([ post_one, post_two ])
          # ```
          sig { params(args: T.any(Document, T::Array[Document])).returns(T::Array[Document]) }
          def <<(*args); end

          # Appends an array of documents to the association. Performs a batch
          # insert of the documents instead of persisting one at a time.
          # 
          # _@param_ `documents` — The docs to add.
          # 
          # _@return_ — The documents.
          # 
          # Concat with other documents.
          # ```ruby
          # person.posts.concat([ post_one, post_two ])
          # ```
          sig { params(documents: T::Array[Document]).returns(T::Array[Document]) }
          def concat(documents); end

          # Build a new document from the attributes and append it to this
          # association without saving.
          # 
          # _@param_ `attributes` — The attributes of the new document.
          # 
          # _@param_ `type` — The optional subclass to build.
          # 
          # _@return_ — The new document.
          # 
          # Build a new document on the association.
          # ```ruby
          # person.posts.build(:title => "A new post")
          # ```
          sig { params(attributes: T::Hash[T.untyped, T.untyped], type: T.nilable(Class)).returns(Document) }
          def build(attributes = {}, type = nil); end

          # Delete the document from the association. This will set the foreign key
          # on the document to nil. If the dependent options on the association are
          # :delete_all or :destroy the appropriate removal will occur.
          # 
          # _@param_ `document` — The document to remove.
          # 
          # _@return_ — The matching document.
          # 
          # Delete the document.
          # ```ruby
          # person.posts.delete(post)
          # ```
          sig { params(document: Document).returns(Document) }
          def delete(document); end

                    # Removes all associations between the base document and the target
          # documents by deleting the foreign keys and the references, orphaning
          # the target documents in the process.
          # 
          # _@param_ `replacement` — The replacement documents.
          # 
          # Nullify the association.
          # ```ruby
          # person.preferences.nullify
          # ```
          sig { params(replacement: T::Array[Document]).returns(T.untyped) }
          def nullify(replacement = []); end

          # Substitutes the supplied target documents for the existing documents
          # in the association. If the new target is nil, perform the necessary
          # deletion.
          # 
          # person.preferences.substitute([ new_post ])
          # 
          # _@param_ `replacement` — The replacement target.
          # 
          # _@return_ — The association.
          # 
          # Replace the association.
          # ```ruby
          # ```
          sig { params(replacement: T::Array[Document]).returns(Many) }
          def substitute(replacement); end

          # Get a criteria for the documents without the default scoping
          # applied.
          # 
          # _@return_ — The unscoped criteria.
          # 
          # Get the unscoped criteria.
          # ```ruby
          # person.preferences.unscoped
          # ```
          sig { returns(Criteria) }
          def unscoped; end

                    # Appends the document to the target array, updating the index on the
          # document at the same time.
          # 
          # _@param_ `document` — The document to append to the target.
          # 
          # Append the document to the association.
          # ```ruby
          # relation.append(document)
          # ```
          sig { params(document: Document).returns(T.untyped) }
          def append(document); end

          # sord warn - Binding wasn't able to be resolved to a constant in this project
          # Instantiate the binding associated with this association.
          # 
          # _@return_ — The binding.
          # 
          # Get the binding.
          # ```ruby
          # relation.binding([ address ])
          # ```
          sig { returns(Binding) }
          def binding; end

          # Determine if the child document should be persisted.
          # 
          # _@param_ `doc` — The document.
          # 
          # _@return_ — If the document can be persisted.
          # 
          # Is the child persistable?
          # ```ruby
          # relation.child_persistable?(doc)
          # ```
          sig { params(doc: Document).returns(T::Boolean) }
          def child_persistable?(doc); end

                    # Returns the criteria object for the target class with its documents set
          # to target.
          # 
          # _@return_ — A new criteria.
          # 
          # Get a criteria for the association.
          # ```ruby
          # relation.criteria
          # ```
          sig { params(id_list: T.untyped).returns(Criteria) }
          def criteria(id_list = nil); end

          # Flag the base as unsynced with respect to the foreign key.
          # 
          # _@param_ `doc` — The document to flag.
          # 
          # _@param_ `key` — The key to flag on the document.
          # 
          # _@return_ — true.
          # 
          # Flag as unsynced.
          # ```ruby
          # relation.unsynced(doc, :preference_ids)
          # ```
          sig { params(doc: Document, key: Symbol).returns(T::Boolean) }
          def unsynced(doc, key); end

                    # Get the Eager object for this type of association.
          # 
          # _@param_ `association` — The association object.
          # 
          # _@param_ `docs` — The array of documents.
          # 
          # Get the eager loader object
          # ```ruby
          # ```
          sig { params(association: Association, docs: T::Array[Document]).returns(T.untyped) }
          def self.eager_loader(association, docs); end

          # Returns true if the association is an embedded one. In this case
          # always false.
          # 
          # _@return_ — Always false.
          # 
          # Is this association embedded?
          # ```ruby
          # Referenced::ManyToMany.embedded?
          # ```
          sig { returns(T::Boolean) }
          def self.embedded?; end
        end

        # Binding class for all has_and_belongs_to_many associations.
        class Binding
          include Mongoid::Association::Bindable

                    # Binds a single document with the inverse association. Used
          # specifically when appending to the proxy.
          # 
          # _@param_ `doc` — The single document to bind.
          # 
          # Bind one document.
          # ```ruby
          # person.preferences.bind_one(preference)
          # ```
          sig { params(doc: Document).returns(T.untyped) }
          def bind_one(doc); end

                              # Unbind a single document.
          # 
          # Unbind the document.
          # ```ruby
          # person.preferences.unbind_one(document)
          # ```
          sig { params(doc: T.untyped).returns(T.untyped) }
          def unbind_one(doc); end

                              # Find the inverse id referenced by inverse_keys
          sig { params(doc: T.untyped).returns(T.untyped) }
          def inverse_record_id(doc); end

                              sig { params(doc: T.untyped).returns(T.untyped) }
          def determine_inverse_association(doc); end

          # Create the new binding.
          # 
          # _@param_ `base` — The base of the binding.
          # 
          # _@param_ `target` — The target of the binding.
          # 
          # _@param_ `association` — The association metadata.
          # 
          # Initialize a binding.
          # ```ruby
          # Binding.new(base, target, association)
          # ```
          sig { params(base: Document, target: T.any(Document, T::Array[Document]), association: Association).void }
          def initialize(base, target, association); end

          # Execute the provided block inside a binding.
          # 
          # _@return_ — The result of the yield.
          # 
          # Execute the binding block.
          # ```ruby
          # binding.binding do
          #   base.foreign_key = 1
          # end
          # ```
          sig { returns(Object) }
          def binding; end

                    # Check if the inverse is properly defined.
          # 
          # _@param_ `doc` — The document getting bound.
          # 
          # Check the inverse definition.
          # ```ruby
          # binding.check_inverse!(doc)
          # ```
          sig { params(doc: Document).returns(T.untyped) }
          def check_inverse!(doc); end

                    # Set the id of the related document in the foreign key field on the
          # keyed document.
          # 
          # _@param_ `keyed` — The document that stores the foreign key.
          # 
          # _@param_ `id` — The id of the bound document.
          # 
          # Bind the foreign key.
          # ```ruby
          # binding.bind_foreign_key(post, person._id)
          # ```
          sig { params(keyed: Document, id: Object).returns(T.untyped) }
          def bind_foreign_key(keyed, id); end

                    # Set the type of the related document on the foreign type field, used
          # when associations are polymorphic.
          # 
          # _@param_ `typed` — The document that stores the type field.
          # 
          # _@param_ `name` — The name of the model.
          # 
          # Bind the polymorphic type.
          # ```ruby
          # binding.bind_polymorphic_type(post, "Person")
          # ```
          sig { params(typed: Document, name: String).returns(T.untyped) }
          def bind_polymorphic_type(typed, name); end

                    # Set the type of the related document on the foreign type field, used
          # when associations are polymorphic.
          # 
          # _@param_ `typed` — The document that stores the type field.
          # 
          # _@param_ `name` — The name of the model.
          # 
          # Bind the polymorphic type.
          # ```ruby
          # binding.bind_polymorphic_inverse_type(post, "Person")
          # ```
          sig { params(typed: Document, name: String).returns(T.untyped) }
          def bind_polymorphic_inverse_type(typed, name); end

                    # Bind the inverse document to the child document so that the in memory
          # instances are the same.
          # 
          # _@param_ `doc` — The base document.
          # 
          # _@param_ `inverse` — The inverse document.
          # 
          # Bind the inverse.
          # ```ruby
          # binding.bind_inverse(post, person)
          # ```
          sig { params(doc: Document, inverse: Document).returns(T.untyped) }
          def bind_inverse(doc, inverse); end

                    # Bind the provided document with the base from the parent association.
          # 
          # _@param_ `doc` — The document to bind.
          # 
          # Bind the document with the base.
          # ```ruby
          # binding.bind_from_relational_parent(doc)
          # ```
          sig { params(doc: Document).returns(T.untyped) }
          def bind_from_relational_parent(doc); end

                              sig { params(_base: T.untyped).returns(T.untyped) }
          def record_id(_base); end

          # Ensure that the association on the base is correct, for the cases
          # where we have multiple belongs to definitions and were are setting
          # different parents in memory in order.
          # 
          # _@return_ — If the association changed.
          # 
          # Set the base association.
          # ```ruby
          # binding.set_base_association
          # ```
          sig { returns(T::Boolean) }
          def set_base_association; end

                    # Bind the provided document with the base from the parent association.
          # 
          # _@param_ `doc` — The document to unbind.
          # 
          # Bind the document with the base.
          # ```ruby
          # unbinding.unbind_from_relational_parent(doc)
          # ```
          sig { params(doc: Document).returns(T.untyped) }
          def unbind_from_relational_parent(doc); end

          # Begin the assignment of attributes. While in this block embedded
          # documents will not autosave themselves in order to allow the document to
          # be in a valid state.
          # 
          # _@return_ — The yielded value.
          # 
          # Execute the assignment.
          # ```ruby
          # _assigning do
          #   person.attributes = { :addresses => [ address ] }
          # end
          # ```
          sig { returns(Object) }
          def _assigning; end

          # Is the current thread in assigning mode?
          # 
          # _@return_ — If the thread is assigning.
          # 
          # Is the current thread in assigning mode?
          # ```ruby
          # proxy._assigning?
          # ```
          sig { returns(T::Boolean) }
          def _assigning?; end

          # Execute a block in binding mode.
          # 
          # _@return_ — The return value of the block.
          # 
          # Execute in binding mode.
          # ```ruby
          # binding do
          #   relation.push(doc)
          # end
          # ```
          sig { returns(Object) }
          def _binding; end

          # Is the current thread in binding mode?
          # 
          # _@return_ — If the thread is binding.
          # 
          # Is the current thread in binding mode?
          # ```ruby
          # proxy.binding?
          # ```
          sig { returns(T::Boolean) }
          def _binding?; end

          # Execute a block in building mode.
          # 
          # _@return_ — The return value of the block.
          # 
          # Execute in building mode.
          # ```ruby
          # _building do
          #   relation.push(doc)
          # end
          # ```
          sig { returns(Object) }
          def _building; end

          # Is the current thread in building mode?
          # 
          # _@return_ — If the thread is building.
          # 
          # Is the current thread in building mode?
          # ```ruby
          # proxy._building?
          # ```
          sig { returns(T::Boolean) }
          def _building?; end

          # Is the current thread in creating mode?
          # 
          # _@return_ — If the thread is creating.
          # 
          # Is the current thread in creating mode?
          # ```ruby
          # proxy.creating?
          # ```
          sig { returns(T::Boolean) }
          def _creating?; end

          # Execute a block in loading mode.
          # 
          # _@return_ — The return value of the block.
          # 
          # Execute in loading mode.
          # ```ruby
          # _loading do
          #   relation.push(doc)
          # end
          # ```
          sig { returns(Object) }
          def _loading; end

          # Is the current thread in loading mode?
          # 
          # _@return_ — If the thread is loading.
          # 
          # Is the current thread in loading mode?
          # ```ruby
          # proxy._loading?
          # ```
          sig { returns(T::Boolean) }
          def _loading?; end
        end

        # The Builder behavior for has_and_belongs_to_many associations.
        # 
        # @since 7.0
        module Buildable
          # This builder either takes a hash and queries for the
          # object or an array of documents, where it will just return them.
          # 
          # _@param_ `base` — The base object.
          # 
          # _@param_ `object` — The object to use to build the association.
          # 
          # _@param_ `type` — Not used in this context.
          # 
          # _@param_ `selected_fields` — Must be nil.
          # 
          # _@return_ — The documents.
          # 
          # Build the documents.
          # ```ruby
          # relation.build(association, attrs)
          # ```
          sig do
            params(
              base: Object,
              object: Object,
              type: T.nilable(String),
              selected_fields: T.nilable(T.any())
            ).returns(T::Array[Document])
          end
          def build(base, object, type = nil, selected_fields = nil); end

                    sig { params(object: T.untyped).returns(T::Boolean) }
          def query?(object); end
        end
      end
    end
  end

  # Contains general behavior for persistence operations.
  # 
  # @since 2.0.0
  module Persistable
    include Mongoid::Persistable::Creatable
    include Mongoid::Persistable::Deletable
    include Mongoid::Persistable::Destroyable
    include Mongoid::Persistable::Incrementable
    include Mongoid::Persistable::Logical
    include Mongoid::Persistable::Poppable
    include Mongoid::Positional
    include Mongoid::Persistable::Pullable
    include Mongoid::Persistable::Pushable
    include Mongoid::Persistable::Renamable
    include Mongoid::Persistable::Savable
    include Mongoid::Persistable::Settable
    include Mongoid::Persistable::Updatable
    include Mongoid::Persistable::Upsertable
    include Mongoid::Persistable::Unsettable
    extend ActiveSupport::Concern
    LIST_OPERATIONS = T.let([ "$addToSet", "$push", "$pull", "$pullAll" ].freeze, T.untyped)

    # Execute operations atomically (in a single database call) for everything
    # that would happen inside the block. This method supports nesting further
    # calls to atomically, which will behave according to the options described
    # below.
    # 
    # An option join_context can be given which, when true, will merge the
    # operations declared by the given block with the atomically block wrapping
    # the current invocation for the same document, if one exists. If this
    # block or any other block sharing the same context raises before
    # persisting, then all the operations of that context will not be
    # persisted, and will also be reset in memory.
    # 
    # When join_context is false, the given block of operations will be
    # persisted independently of other contexts. Failures in other contexts will
    # not affect this one, so long as this block was able to run and persist
    # changes.
    # 
    # The default value of join_context is set by the global configuration
    # option join_contexts, whose own default is false.
    # 
    # _@param_ `join_context` — Join the context (i.e. merge declared atomic operations) of the atomically block wrapping this one for the same document, if one exists.
    # 
    # _@return_ — If the operation succeeded.
    # 
    # Execute the operations atomically.
    # ```ruby
    # document.atomically do
    #   document.set(name: "Tool").inc(likes: 10)
    # end
    # ```
    # 
    # Execute some inner operations atomically, but independently from the outer operations.
    # ```ruby
    # 
    # document.atomically do
    #   document.inc likes: 10
    #   document.atomically join_context: false do
    #     # The following is persisted to the database independently.
    #     document.unset :origin
    #   end
    #   document.atomically join_context: true do
    #     # The following is persisted along with the other outer operations.
    #     document.inc member_count: 3
    #   end
    #   document.set name: "Tool"
    # end
    # ```
    sig { params(join_context: T.nilable(T::Boolean)).returns(T::Boolean) }
    def atomically(join_context: nil); end

        # Raise an error if validation failed.
    # 
    # Raise the validation error.
    # ```ruby
    # Person.fail_due_to_validation!(person)
    # ```
    sig { returns(T.untyped) }
    def fail_due_to_validation!; end

        # Raise an error if a callback failed.
    # 
    # _@param_ `method` — The method being called.
    # 
    # Raise the callback error.
    # ```ruby
    # Person.fail_due_to_callback!(person, :create!)
    # ```
    sig { params(method: Symbol).returns(T.untyped) }
    def fail_due_to_callback!(method); end

    # Are we executing an atomically block on the current document?
    # 
    # _@return_ — If we are current executing atomically.
    # 
    # Are we executing atomically?
    # ```ruby
    # document.executing_atomically?
    # ```
    sig { returns(T::Boolean) }
    def executing_atomically?; end

    # Post process the persistence operation.
    # 
    # _@param_ `result` — The result of the operation.
    # 
    # _@param_ `options` — The options.
    # 
    # _@return_ — true.
    # 
    # Post process the persistence operation.
    # ```ruby
    # document.post_process_persist(true)
    # ```
    sig { params(result: Object, options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
    def post_process_persist(result, options = {}); end

    # Prepare an atomic persistence operation. Yields an empty hash to be sent
    # to the update.
    # 
    # _@return_ — The result of the operation.
    # 
    # Prepare the atomic operation.
    # ```ruby
    # document.prepare_atomic_operation do |coll, selector, opts|
    #   ...
    # end
    # ```
    sig { returns(Object) }
    def prepare_atomic_operation; end

    # Process the atomic operations - this handles the common behavior of
    # iterating through each op, getting the aliased field name, and removing
    # appropriate dirty changes.
    # 
    # _@param_ `operations` — The atomic operations.
    # 
    # _@return_ — The operations.
    # 
    # Process the atomic operations.
    # ```ruby
    # document.process_atomic_operations(pulls) do |field, value|
    #   ...
    # end
    # ```
    sig { params(operations: T::Hash[T.untyped, T.untyped]).returns(T::Hash[T.untyped, T.untyped]) }
    def process_atomic_operations(operations); end

        # Remove the dirty changes for all fields changed in the current atomic
    # context.
    # 
    # Remove the current atomic context's dirty changes.
    # ```ruby
    # document._mongoid_remove_atomic_context_changes
    # ```
    sig { returns(T.untyped) }
    def _mongoid_remove_atomic_context_changes; end

        # Reset the attributes for all fields changed in the current atomic
    # context.
    # 
    # Reset the current atomic context's changed attributes.
    # ```ruby
    # document._mongoid_reset_atomic_context_changes!
    # ```
    sig { returns(T.untyped) }
    def _mongoid_reset_atomic_context_changes!; end

        # Push a new atomic context onto the stack.
    # 
    # Push a new atomic context onto the stack.
    # ```ruby
    # document._mongoid_push_atomic_context
    # ```
    sig { returns(T.untyped) }
    def _mongoid_push_atomic_context; end

        # Pop an atomic context off the stack.
    # 
    # Pop an atomic context off the stack.
    # ```ruby
    # document._mongoid_pop_atomic_context
    # ```
    sig { returns(T.untyped) }
    def _mongoid_pop_atomic_context; end

    # Return the current atomic context's changed fields.
    # 
    # _@return_ — The changed fields.
    # 
    # Return the current atomic context's changed fields.
    # ```ruby
    # document._mongoid_atomic_context_changed_fields
    # ```
    sig { returns(T::Array[T.untyped]) }
    def _mongoid_atomic_context_changed_fields; end

        # If we are in an atomically block, add the operations to the delayed group,
    # otherwise persist immediately.
    # 
    # _@param_ `operation` — The operation.
    # 
    # Persist immediately or delay the operations.
    # ```ruby
    # document.persist_or_delay_atomic_operation(ops)
    # ```
    sig { params(operation: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
    def persist_or_delay_atomic_operation(operation); end

        # Persist the atomic operations.
    # 
    # _@param_ `operations` — The atomic operations.
    # 
    # Persist the atomic operations.
    # ```ruby
    # persist_atomic_operations(ops)
    # ```
    sig { params(operations: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
    def persist_atomic_operations(operations); end

    # Perform an $unset operation on the provided fields and in the
    # values in the document in memory.
    # 
    # _@param_ `fields` — The names of the fields to unset.
    # 
    # _@return_ — The document.
    # 
    # Unset the values.
    # ```ruby
    # document.unset(:first_name, :last_name, :middle)
    # ```
    sig { params(fields: T::Array[T.any(String, Symbol)]).returns(Document) }
    def unset(*fields); end

    # Perform an upsert of the document. If the document does not exist in the
    # database, then Mongo will insert a new one, otherwise the fields will get
    # overwritten with new values on the existing document.
    # 
    # _@param_ `options` — The validation options.
    # 
    # _@return_ — True.
    # 
    # Upsert the document.
    # ```ruby
    # document.upsert
    # ```
    sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
    def upsert(options = {}); end

    # Prepare the upsert for execution.
    # 
    # _@param_ `options` — The options hash.
    # 
    # _@return_ — If the operation succeeded.
    # 
    # Prepare the upsert
    # ```ruby
    # document.prepare_upsert do
    #   collection.find(selector).update(as_document)
    # end
    # ```
    sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
    def prepare_upsert(options = {}); end

    # Update a single attribute and persist the entire document.
    # This skips validation but fires the callbacks.
    # 
    # _@param_ `name` — The name of the attribute.
    # 
    # _@param_ `value` — The new value of the attribute.a
    # 
    # _@return_ — True if save was successfull, false if not.
    # 
    # Update the attribute.
    # ```ruby
    # person.update_attribute(:title, "Sir")
    # ```
    sig { params(name: T.any(Symbol, String), value: Object).returns(T::Boolean) }
    def update_attribute(name, value); end

    # Update the document attributes in the database.
    # 
    # _@param_ `attributes` — The attributes to update.
    # 
    # _@return_ — True if validation passed, false if not.
    # 
    # Update the document's attributes
    # ```ruby
    # document.update(:title => "Sir")
    # ```
    sig { params(attributes: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
    def update(attributes = {}); end

    # Update the document attributes in the database and raise an error if
    # validation failed.
    # 
    # _@param_ `attributes` — The attributes to update.
    # 
    # _@return_ — True if validation passed.
    # 
    # Update the document's attributes.
    # ```ruby
    # document.update!(:title => "Sir")
    # ```
    sig { params(attributes: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
    def update!(attributes = {}); end

    # Initialize the atomic updates.
    # 
    # _@return_ — The updates and conflicts.
    # 
    # Initialize the atomic updates.
    # ```ruby
    # document.init_atomic_updates
    # ```
    sig { returns(T::Array[T::Hash[T.untyped, T.untyped]]) }
    def init_atomic_updates; end

    # Prepare the update for execution. Validates and runs callbacks, etc.
    # 
    # _@param_ `options` — The options.
    # 
    # _@return_ — The result of the update.
    # 
    # Prepare for update.
    # ```ruby
    # document.prepare_update do
    #   collection.update(atomic_selector)
    # end
    # ```
    sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
    def prepare_update(options = {}); end

    # Update the document in the database.
    # 
    # _@param_ `options` — Options to pass to update.
    # 
    # _@return_ — True if succeeded, false if not.
    # 
    # Update an existing document.
    # ```ruby
    # document.update
    # ```
    sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
    def update_document(options = {}); end

    # Perform a $set operation on the provided field/value pairs and set the
    # values in the document in memory.
    # 
    # The key can be a dotted sequence of keys, in which case the
    # top level field is treated as a nested hash and any missing keys
    # are created automatically:
    # 
    # Performing a nested set like this merges values of intermediate keys:
    # 
    # If the top level field was not a hash, its original value is discarded
    # and the field is replaced with a hash.
    # 
    # Note that unlike MongoDB's $set, Mongoid's set writes out the entire
    # field even when setting a subset of the field via the nested hash
    # semantics. This means performing a $set with nested hash semantics
    # can overwrite other hash keys within the top level field in the database.
    # 
    # _@param_ `setters` — The field/value pairs to set.
    # 
    # _@return_ — The document.
    # 
    # Set the values.
    # ```ruby
    # document.set(title: "sir", dob: Date.new(1970, 1, 1))
    # ```
    # 
    # Set the values using nested hash semantics.
    # ```ruby
    # document.set('author.title' => 'Sir')
    # # => document.author == {'title' => 'Sir'}
    # ```
    # 
    # Nested hash value merging.
    # ```ruby
    # document.set('author.title' => 'Sir')
    # document.set('author.name' => 'Linus Torvalds')
    # # => document.author == {'title' => 'Sir', 'name' => 'Linus Torvalds'}
    # ```
    # 
    # Nested hash overwriting a non-hash value.
    # ```ruby
    # document.set('author' => 'John Doe')
    # document.set('author.title' => 'Sir')
    # # => document.author == {'title' => 'Sir'}
    # ```
    sig { params(setters: T::Hash[T.untyped, T.untyped]).returns(Document) }
    def set(setters); end

    # Save the document - will perform an insert if the document is new, and
    # update if not.
    # 
    # _@param_ `options` — Options to pass to the save.
    # 
    # _@return_ — True is success, false if not.
    # 
    # Save the document.
    # ```ruby
    # document.save
    # ```
    sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
    def save(options = {}); end

    # Save the document - will perform an insert if the document is new, and
    # update if not. If a validation error occurs an error will get raised.
    # 
    # _@param_ `options` — Options to pass to the save.
    # 
    # _@return_ — True if validation passed.
    # 
    # Save the document.
    # ```ruby
    # document.save!
    # ```
    sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
    def save!(options = {}); end

    # Rename fields from one value to another via $rename.
    # 
    # _@param_ `renames` — The rename pairs of old name/new name.
    # 
    # _@return_ — The document.
    # 
    # Rename the fields.
    # ```ruby
    # document.rename(title: "salutation", name: "nombre")
    # ```
    # 
    # _@note_ — This does not work for fields in embeds many associations.
    sig { params(renames: T::Hash[T.untyped, T.untyped]).returns(Document) }
    def rename(renames); end

    # Add the single values to the arrays only if the value does not already
    # exist in the array.
    # 
    # _@param_ `adds` — The field/value pairs to add.
    # 
    # _@return_ — The document.
    # 
    # Add the values to the sets.
    # ```ruby
    # document.add_to_set(names: "James", aliases: "Bond")
    # ```
    sig { params(adds: T::Hash[T.untyped, T.untyped]).returns(Document) }
    def add_to_set(adds); end

    # Push a single value or multiple values onto arrays.
    # 
    # _@param_ `pushes` — The $push operations.
    # 
    # _@return_ — The document.
    # 
    # Push a single value onto arrays.
    # ```ruby
    # document.push(names: "James", aliases: "007")
    # ```
    # 
    # Push multiple values onto arrays.
    # ```ruby
    # document.push(names: [ "James", "Bond" ])
    # ```
    sig { params(pushes: T::Hash[T.untyped, T.untyped]).returns(Document) }
    def push(pushes); end

    # Pull single values from the provided arrays.
    # 
    # _@param_ `pulls` — The field/value pull pairs.
    # 
    # _@return_ — The document.
    # 
    # Pull a value from the array.
    # ```ruby
    # document.pull(names: "Jeff", levels: 5)
    # ```
    # 
    # _@note_ — If duplicate values are found they will all be pulled.
    sig { params(pulls: T::Hash[T.untyped, T.untyped]).returns(Document) }
    def pull(pulls); end

    # Pull multiple values from the provided array fields.
    # 
    # _@param_ `pulls` — The pull all operations.
    # 
    # _@return_ — The document.
    # 
    # Pull values from the arrays.
    # ```ruby
    # document.pull_all(names: [ "Jeff", "Bob" ], levels: [ 5, 6 ])
    # ```
    sig { params(pulls: T::Hash[T.untyped, T.untyped]).returns(Document) }
    def pull_all(pulls); end

    # Takes the provided selector and atomic operations and replaces the
    # indexes of the embedded documents with the positional operator when
    # needed.
    # 
    # _@param_ `selector` — The selector.
    # 
    # _@param_ `operations` — The update operations.
    # 
    # _@param_ `processed` — The processed update operations.
    # 
    # _@return_ — The new operations.
    # 
    # Process the operations.
    # ```ruby
    # positionally(
    #   { "_id" => 1, "addresses._id" => 2 },
    #   { "$set" => { "addresses.0.street" => "hobrecht" }}
    # )
    # ```
    # 
    # _@note_ — The only time we can accurately know when to use the positional
    # operator is at the exact time we are going to persist something. So
    # we can tell by the selector that we are sending if it is actually
    # possible to use the positional operator at all. For example, if the
    # selector is: { "_id" => 1 }, then we could not use the positional
    # operator for updating embedded documents since there would never be a
    # match - we base whether we can based on the number of levels deep the
    # selector goes, and if the id values are not nil.
    sig { params(selector: T::Hash[T.untyped, T.untyped], operations: T::Hash[T.untyped, T.untyped], processed: T::Hash[T.untyped, T.untyped]).returns(T::Hash[T.untyped, T.untyped]) }
    def positionally(selector, operations, processed = {}); end

                    sig { params(keys: T.untyped, operations: T.untyped, processed: T.untyped).returns(T.untyped) }
    def process_operations(keys, operations, processed); end

                    sig { params(keys: T.untyped, update: T.untyped, updates: T.untyped).returns(T.untyped) }
    def process_updates(keys, update, updates = {}); end

                sig { params(keys: T.untyped, position: T.untyped).returns(T.untyped) }
    def replace_index(keys, position); end

    # Pop or shift items from arrays using the $pop operator.
    # 
    # _@param_ `pops` — The field/value pop operations.
    # 
    # _@return_ — The document.
    # 
    # Pop items from an array.
    # ```ruby
    # document.pop(aliases: 1)
    # ```
    # 
    # Shift items in the array.
    # ```ruby
    # document.pop(aliases: -1)
    # ```
    # 
    # Multiple pops in one call.
    # ```ruby
    # document.pop(names: 1, aliases: 1)
    # ```
    sig { params(pops: T::Hash[T.untyped, T.untyped]).returns(Document) }
    def pop(pops); end

    # Performs an atomic $bit operation on the field with the provided hash
    # of bitwise ops to execute in order.
    # 
    # _@param_ `operations` — The bitwise operations.
    # 
    # _@return_ — The document.
    # 
    # Execute the bitwise operations.
    # ```ruby
    # person.bit(age: { :and => 12 }, val: { and: 10, or: 12 })
    # ```
    sig { params(operations: T::Hash[T.untyped, T.untyped]).returns(Document) }
    def bit(operations); end

    # Increment the provided fields by the corresponding values. Values can
    # be positive or negative, and if no value exists for the field it will
    # be set with the provided value.
    # 
    # _@param_ `increments` — The field/inc increment pairs.
    # 
    # _@return_ — The document.
    # 
    # Increment the fields.
    # ```ruby
    # document.inc(score: 10, place: 1, lives: -10)
    # ```
    sig { params(increments: T::Hash[T.untyped, T.untyped]).returns(Document) }
    def inc(increments); end

    # Remove the document from the database with callbacks.
    # 
    # _@param_ `options` — Options to pass to destroy.
    # 
    # _@return_ — True if successful, false if not.
    # 
    # Destroy a document.
    # ```ruby
    # document.destroy
    # ```
    sig { params(options: T.nilable(T::Hash[T.untyped, T.untyped])).returns(T::Boolean) }
    def destroy(options = nil); end

            sig { params(options: T.untyped).returns(T.untyped) }
    def destroy!(options = {}); end

    # Remove the document from the database.
    # 
    # _@param_ `options` — Options to pass to remove.
    # 
    # _@return_ — True.
    # 
    # Remove the document.
    # ```ruby
    # document.remove
    # ```
    sig { params(options: T::Hash[T.untyped, T.untyped]).returns(TrueClass) }
    def delete(options = {}); end

    # Get the atomic deletes for the operation.
    # 
    # _@return_ — The atomic deletes.
    # 
    # Get the atomic deletes.
    # ```ruby
    # document.atomic_deletes
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def atomic_deletes; end

    # Delete the embedded document.
    # 
    # _@param_ `options` — The deletion options.
    # 
    # _@return_ — If the operation succeeded.
    # 
    # Delete the embedded document.
    # ```ruby
    # document.delete_as_embedded
    # ```
    sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
    def delete_as_embedded(options = {}); end

    # Delete the root document.
    # 
    # _@return_ — If the document was removed.
    # 
    # Delete the root document.
    # ```ruby
    # document.delete_as_root
    # ```
    sig { returns(T::Boolean) }
    def delete_as_root; end

    # Are we needing to notify the parent document of the deletion.
    # 
    # _@param_ `options` — The delete options.
    # 
    # _@return_ — If the parent should be notified.
    # 
    # Are we notifying the parent.
    # ```ruby
    # document.notifying_parent?(suppress: true)
    # ```
    sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
    def notifying_parent?(options = {}); end

    # Prepare the delete operation.
    # 
    # _@return_ — The result of the block.
    # 
    # Prepare the delete operation.
    # ```ruby
    # document.prepare_delete do
    #   collection.find(atomic_selector).remove
    # end
    # ```
    sig { returns(Object) }
    def prepare_delete; end

    # Insert a new document into the database. Will return the document
    # itself whether or not the save was successful.
    # 
    # _@param_ `options` — Options to pass to insert.
    # 
    # _@return_ — The persisted document.
    # 
    # Insert a document.
    # ```ruby
    # document.insert
    # ```
    sig { params(options: T::Hash[T.untyped, T.untyped]).returns(Document) }
    def insert(options = {}); end

    # Get the atomic insert for embedded documents, either a push or set.
    # 
    # _@return_ — The insert ops.
    # 
    # Get the inserts.
    # ```ruby
    # document.inserts
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def atomic_inserts; end

    # Insert the embedded document.
    # 
    # _@return_ — The document.
    # 
    # Insert the document as embedded.
    # ```ruby
    # document.insert_as_embedded
    # ```
    sig { returns(Document) }
    def insert_as_embedded; end

    # Insert the root document.
    # 
    # _@return_ — The document.
    # 
    # Insert the document as root.
    # ```ruby
    # document.insert_as_root
    # ```
    sig { returns(Document) }
    def insert_as_root; end

    # Post process an insert, which sets the new record attribute to false
    # and flags all the children as persisted.
    # 
    # _@return_ — true.
    # 
    # Post process the insert.
    # ```ruby
    # document.post_process_insert
    # ```
    sig { returns(T::Boolean) }
    def post_process_insert; end

    # Prepare the insert for execution. Validates and runs callbacks, etc.
    # 
    # _@param_ `options` — The options.
    # 
    # _@return_ — The document.
    # 
    # Prepare for insertion.
    # ```ruby
    # document.prepare_insert do
    #   collection.insert(as_document)
    # end
    # ```
    sig { params(options: T::Hash[T.untyped, T.untyped]).returns(Document) }
    def prepare_insert(options = {}); end

    # Defines behavior for logical bitwise operations.
    # 
    # @since 4.0.0
    module Logical
      extend ActiveSupport::Concern

      # Performs an atomic $bit operation on the field with the provided hash
      # of bitwise ops to execute in order.
      # 
      # _@param_ `operations` — The bitwise operations.
      # 
      # _@return_ — The document.
      # 
      # Execute the bitwise operations.
      # ```ruby
      # person.bit(age: { :and => 12 }, val: { and: 10, or: 12 })
      # ```
      sig { params(operations: T::Hash[T.untyped, T.untyped]).returns(Document) }
      def bit(operations); end
    end

    # Defines behavior for persistence operations that save documents.
    # 
    # @since 4.0.0
    module Savable
      # Save the document - will perform an insert if the document is new, and
      # update if not.
      # 
      # _@param_ `options` — Options to pass to the save.
      # 
      # _@return_ — True is success, false if not.
      # 
      # Save the document.
      # ```ruby
      # document.save
      # ```
      sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
      def save(options = {}); end

      # Save the document - will perform an insert if the document is new, and
      # update if not. If a validation error occurs an error will get raised.
      # 
      # _@param_ `options` — Options to pass to the save.
      # 
      # _@return_ — True if validation passed.
      # 
      # Save the document.
      # ```ruby
      # document.save!
      # ```
      sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
      def save!(options = {}); end
    end

    # Defines behavior for $pop operations.
    # 
    # @since 4.0.0
    module Poppable
      extend ActiveSupport::Concern

      # Pop or shift items from arrays using the $pop operator.
      # 
      # _@param_ `pops` — The field/value pop operations.
      # 
      # _@return_ — The document.
      # 
      # Pop items from an array.
      # ```ruby
      # document.pop(aliases: 1)
      # ```
      # 
      # Shift items in the array.
      # ```ruby
      # document.pop(aliases: -1)
      # ```
      # 
      # Multiple pops in one call.
      # ```ruby
      # document.pop(names: 1, aliases: 1)
      # ```
      sig { params(pops: T::Hash[T.untyped, T.untyped]).returns(Document) }
      def pop(pops); end
    end

    # Defines behavior for $pull and $pullAll operations.
    # 
    # @since 4.0.0
    module Pullable
      extend ActiveSupport::Concern

      # Pull single values from the provided arrays.
      # 
      # _@param_ `pulls` — The field/value pull pairs.
      # 
      # _@return_ — The document.
      # 
      # Pull a value from the array.
      # ```ruby
      # document.pull(names: "Jeff", levels: 5)
      # ```
      # 
      # _@note_ — If duplicate values are found they will all be pulled.
      sig { params(pulls: T::Hash[T.untyped, T.untyped]).returns(Document) }
      def pull(pulls); end

      # Pull multiple values from the provided array fields.
      # 
      # _@param_ `pulls` — The pull all operations.
      # 
      # _@return_ — The document.
      # 
      # Pull values from the arrays.
      # ```ruby
      # document.pull_all(names: [ "Jeff", "Bob" ], levels: [ 5, 6 ])
      # ```
      sig { params(pulls: T::Hash[T.untyped, T.untyped]).returns(Document) }
      def pull_all(pulls); end
    end

    # Defines behavior for $push and $addToSet operations.
    # 
    # @since 4.0.0
    module Pushable
      extend ActiveSupport::Concern

      # Add the single values to the arrays only if the value does not already
      # exist in the array.
      # 
      # _@param_ `adds` — The field/value pairs to add.
      # 
      # _@return_ — The document.
      # 
      # Add the values to the sets.
      # ```ruby
      # document.add_to_set(names: "James", aliases: "Bond")
      # ```
      sig { params(adds: T::Hash[T.untyped, T.untyped]).returns(Document) }
      def add_to_set(adds); end

      # Push a single value or multiple values onto arrays.
      # 
      # _@param_ `pushes` — The $push operations.
      # 
      # _@return_ — The document.
      # 
      # Push a single value onto arrays.
      # ```ruby
      # document.push(names: "James", aliases: "007")
      # ```
      # 
      # Push multiple values onto arrays.
      # ```ruby
      # document.push(names: [ "James", "Bond" ])
      # ```
      sig { params(pushes: T::Hash[T.untyped, T.untyped]).returns(Document) }
      def push(pushes); end
    end

    # Defines behavior for $set operations.
    # 
    # @since 4.0.0
    module Settable
      extend ActiveSupport::Concern

      # Perform a $set operation on the provided field/value pairs and set the
      # values in the document in memory.
      # 
      # The key can be a dotted sequence of keys, in which case the
      # top level field is treated as a nested hash and any missing keys
      # are created automatically:
      # 
      # Performing a nested set like this merges values of intermediate keys:
      # 
      # If the top level field was not a hash, its original value is discarded
      # and the field is replaced with a hash.
      # 
      # Note that unlike MongoDB's $set, Mongoid's set writes out the entire
      # field even when setting a subset of the field via the nested hash
      # semantics. This means performing a $set with nested hash semantics
      # can overwrite other hash keys within the top level field in the database.
      # 
      # _@param_ `setters` — The field/value pairs to set.
      # 
      # _@return_ — The document.
      # 
      # Set the values.
      # ```ruby
      # document.set(title: "sir", dob: Date.new(1970, 1, 1))
      # ```
      # 
      # Set the values using nested hash semantics.
      # ```ruby
      # document.set('author.title' => 'Sir')
      # # => document.author == {'title' => 'Sir'}
      # ```
      # 
      # Nested hash value merging.
      # ```ruby
      # document.set('author.title' => 'Sir')
      # document.set('author.name' => 'Linus Torvalds')
      # # => document.author == {'title' => 'Sir', 'name' => 'Linus Torvalds'}
      # ```
      # 
      # Nested hash overwriting a non-hash value.
      # ```ruby
      # document.set('author' => 'John Doe')
      # document.set('author.title' => 'Sir')
      # # => document.author == {'title' => 'Sir'}
      # ```
      sig { params(setters: T::Hash[T.untyped, T.untyped]).returns(Document) }
      def set(setters); end
    end

    # Defines behavior for persistence operations that create new documents.
    # 
    # @since 4.0.0
    module Creatable
      extend ActiveSupport::Concern

      # Insert a new document into the database. Will return the document
      # itself whether or not the save was successful.
      # 
      # _@param_ `options` — Options to pass to insert.
      # 
      # _@return_ — The persisted document.
      # 
      # Insert a document.
      # ```ruby
      # document.insert
      # ```
      sig { params(options: T::Hash[T.untyped, T.untyped]).returns(Document) }
      def insert(options = {}); end

      # Get the atomic insert for embedded documents, either a push or set.
      # 
      # _@return_ — The insert ops.
      # 
      # Get the inserts.
      # ```ruby
      # document.inserts
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def atomic_inserts; end

      # Insert the embedded document.
      # 
      # _@return_ — The document.
      # 
      # Insert the document as embedded.
      # ```ruby
      # document.insert_as_embedded
      # ```
      sig { returns(Document) }
      def insert_as_embedded; end

      # Insert the root document.
      # 
      # _@return_ — The document.
      # 
      # Insert the document as root.
      # ```ruby
      # document.insert_as_root
      # ```
      sig { returns(Document) }
      def insert_as_root; end

      # Post process an insert, which sets the new record attribute to false
      # and flags all the children as persisted.
      # 
      # _@return_ — true.
      # 
      # Post process the insert.
      # ```ruby
      # document.post_process_insert
      # ```
      sig { returns(T::Boolean) }
      def post_process_insert; end

      # Prepare the insert for execution. Validates and runs callbacks, etc.
      # 
      # _@param_ `options` — The options.
      # 
      # _@return_ — The document.
      # 
      # Prepare for insertion.
      # ```ruby
      # document.prepare_insert do
      #   collection.insert(as_document)
      # end
      # ```
      sig { params(options: T::Hash[T.untyped, T.untyped]).returns(Document) }
      def prepare_insert(options = {}); end

      module ClassMethods
        # Create a new document. This will instantiate a new document and
        # insert it in a single call. Will always return the document
        # whether save passed or not.
        # 
        # _@param_ `attributes` — The attributes to create with, or an Array of multiple attributes for multiple documents.
        # 
        # _@return_ — The newly created document(s).
        # 
        # Create a new document.
        # ```ruby
        # Person.create(:title => "Mr")
        # ```
        # 
        # Create multiple new documents.
        # ```ruby
        # Person.create({ title: "Mr" }, { title: "Mrs" })
        # ```
        sig { params(attributes: T.nilable(T.any(T::Hash[T.untyped, T.untyped], T::Array[T.untyped])), block: T.untyped).returns(T.any(Document, T::Array[Document])) }
        def create(attributes = nil, &block); end

        # Create a new document. This will instantiate a new document and
        # insert it in a single call. Will always return the document
        # whether save passed or not, and if validation fails an error will be
        # raise.
        # 
        # _@param_ `attributes` — The attributes to create with, or an Array of multiple attributes for multiple documents.
        # 
        # _@return_ — The newly created document(s).
        # 
        # Create a new document.
        # ```ruby
        # Person.create!(:title => "Mr")
        # ```
        # 
        # Create multiple new documents.
        # ```ruby
        # Person.create!({ title: "Mr" }, { title: "Mrs" })
        # ```
        sig { params(attributes: T.nilable(T.any(T::Hash[T.untyped, T.untyped], T::Array[T.untyped])), block: T.untyped).returns(T.any(Document, T::Array[Document])) }
        def create!(attributes = nil, &block); end
      end
    end

    # Defines behavior for persistence operations that delete documents.
    # 
    # @since 4.0.0
    module Deletable
      extend ActiveSupport::Concern

      # Remove the document from the database.
      # 
      # _@param_ `options` — Options to pass to remove.
      # 
      # _@return_ — True.
      # 
      # Remove the document.
      # ```ruby
      # document.remove
      # ```
      sig { params(options: T::Hash[T.untyped, T.untyped]).returns(TrueClass) }
      def delete(options = {}); end

      # Get the atomic deletes for the operation.
      # 
      # _@return_ — The atomic deletes.
      # 
      # Get the atomic deletes.
      # ```ruby
      # document.atomic_deletes
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def atomic_deletes; end

      # Delete the embedded document.
      # 
      # _@param_ `options` — The deletion options.
      # 
      # _@return_ — If the operation succeeded.
      # 
      # Delete the embedded document.
      # ```ruby
      # document.delete_as_embedded
      # ```
      sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
      def delete_as_embedded(options = {}); end

      # Delete the root document.
      # 
      # _@return_ — If the document was removed.
      # 
      # Delete the root document.
      # ```ruby
      # document.delete_as_root
      # ```
      sig { returns(T::Boolean) }
      def delete_as_root; end

      # Are we needing to notify the parent document of the deletion.
      # 
      # _@param_ `options` — The delete options.
      # 
      # _@return_ — If the parent should be notified.
      # 
      # Are we notifying the parent.
      # ```ruby
      # document.notifying_parent?(suppress: true)
      # ```
      sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
      def notifying_parent?(options = {}); end

      # Prepare the delete operation.
      # 
      # _@return_ — The result of the block.
      # 
      # Prepare the delete operation.
      # ```ruby
      # document.prepare_delete do
      #   collection.find(atomic_selector).remove
      # end
      # ```
      sig { returns(Object) }
      def prepare_delete; end

      module ClassMethods
        # Delete all documents given the supplied conditions. If no conditions
        # are passed, the entire collection will be dropped for performance
        # benefits. Does not fire any callbacks.
        # 
        # _@param_ `conditions` — Optional conditions to delete by.
        # 
        # _@return_ — The number of documents deleted.
        # 
        # Delete matching documents from the collection.
        # ```ruby
        # Person.delete_all({ :title => "Sir" })
        # ```
        # 
        # Delete all documents from the collection.
        # ```ruby
        # Person.delete_all
        # ```
        sig { params(conditions: T::Hash[T.untyped, T.untyped]).returns(Integer) }
        def delete_all(conditions = {}); end
      end
    end

    # Defines behavior for $rename operations.
    # 
    # @since 4.0.0
    module Renamable
      extend ActiveSupport::Concern

      # Rename fields from one value to another via $rename.
      # 
      # _@param_ `renames` — The rename pairs of old name/new name.
      # 
      # _@return_ — The document.
      # 
      # Rename the fields.
      # ```ruby
      # document.rename(title: "salutation", name: "nombre")
      # ```
      # 
      # _@note_ — This does not work for fields in embeds many associations.
      sig { params(renames: T::Hash[T.untyped, T.untyped]).returns(Document) }
      def rename(renames); end
    end

    # Defines behavior for persistence operations that update existing
    # documents.
    # 
    # @since 4.0.0
    module Updatable
      # Update a single attribute and persist the entire document.
      # This skips validation but fires the callbacks.
      # 
      # _@param_ `name` — The name of the attribute.
      # 
      # _@param_ `value` — The new value of the attribute.a
      # 
      # _@return_ — True if save was successfull, false if not.
      # 
      # Update the attribute.
      # ```ruby
      # person.update_attribute(:title, "Sir")
      # ```
      sig { params(name: T.any(Symbol, String), value: Object).returns(T::Boolean) }
      def update_attribute(name, value); end

      # Update the document attributes in the database.
      # 
      # _@param_ `attributes` — The attributes to update.
      # 
      # _@return_ — True if validation passed, false if not.
      # 
      # Update the document's attributes
      # ```ruby
      # document.update(:title => "Sir")
      # ```
      sig { params(attributes: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
      def update(attributes = {}); end

      # Update the document attributes in the database and raise an error if
      # validation failed.
      # 
      # _@param_ `attributes` — The attributes to update.
      # 
      # _@return_ — True if validation passed.
      # 
      # Update the document's attributes.
      # ```ruby
      # document.update!(:title => "Sir")
      # ```
      sig { params(attributes: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
      def update!(attributes = {}); end

      # Initialize the atomic updates.
      # 
      # _@return_ — The updates and conflicts.
      # 
      # Initialize the atomic updates.
      # ```ruby
      # document.init_atomic_updates
      # ```
      sig { returns(T::Array[T::Hash[T.untyped, T.untyped]]) }
      def init_atomic_updates; end

      # Prepare the update for execution. Validates and runs callbacks, etc.
      # 
      # _@param_ `options` — The options.
      # 
      # _@return_ — The result of the update.
      # 
      # Prepare for update.
      # ```ruby
      # document.prepare_update do
      #   collection.update(atomic_selector)
      # end
      # ```
      sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
      def prepare_update(options = {}); end

      # Update the document in the database.
      # 
      # _@param_ `options` — Options to pass to update.
      # 
      # _@return_ — True if succeeded, false if not.
      # 
      # Update an existing document.
      # ```ruby
      # document.update
      # ```
      sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
      def update_document(options = {}); end
    end

    # Defines behavior for $unset operations.
    # 
    # @since 4.0.0
    module Unsettable
      extend ActiveSupport::Concern

      # Perform an $unset operation on the provided fields and in the
      # values in the document in memory.
      # 
      # _@param_ `fields` — The names of the fields to unset.
      # 
      # _@return_ — The document.
      # 
      # Unset the values.
      # ```ruby
      # document.unset(:first_name, :last_name, :middle)
      # ```
      sig { params(fields: T::Array[T.any(String, Symbol)]).returns(Document) }
      def unset(*fields); end
    end

    # Defines behavior for persistence operations that upsert documents.
    # 
    # @since 4.0.0
    module Upsertable
      # Perform an upsert of the document. If the document does not exist in the
      # database, then Mongo will insert a new one, otherwise the fields will get
      # overwritten with new values on the existing document.
      # 
      # _@param_ `options` — The validation options.
      # 
      # _@return_ — True.
      # 
      # Upsert the document.
      # ```ruby
      # document.upsert
      # ```
      sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
      def upsert(options = {}); end

      # Prepare the upsert for execution.
      # 
      # _@param_ `options` — The options hash.
      # 
      # _@return_ — If the operation succeeded.
      # 
      # Prepare the upsert
      # ```ruby
      # document.prepare_upsert do
      #   collection.find(selector).update(as_document)
      # end
      # ```
      sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
      def prepare_upsert(options = {}); end
    end

    # Defines behavior for persistence operations that destroy documents.
    # 
    # @since 4.0.0
    module Destroyable
      extend ActiveSupport::Concern

      # Remove the document from the database with callbacks.
      # 
      # _@param_ `options` — Options to pass to destroy.
      # 
      # _@return_ — True if successful, false if not.
      # 
      # Destroy a document.
      # ```ruby
      # document.destroy
      # ```
      sig { params(options: T.nilable(T::Hash[T.untyped, T.untyped])).returns(T::Boolean) }
      def destroy(options = nil); end

                  sig { params(options: T.untyped).returns(T.untyped) }
      def destroy!(options = {}); end

      module ClassMethods
        # Delete all documents given the supplied conditions. If no conditions
        # are passed, the entire collection will be dropped for performance
        # benefits. Fires the destroy callbacks if conditions were passed.
        # 
        # _@param_ `conditions` — Optional conditions to destroy by.
        # 
        # _@return_ — The number of documents destroyed.
        # 
        # Destroy matching documents from the collection.
        # ```ruby
        # Person.destroy_all({ :title => "Sir" })
        # ```
        # 
        # Destroy all documents from the collection.
        # ```ruby
        # Person.destroy_all
        # ```
        sig { params(conditions: T.nilable(T::Hash[T.untyped, T.untyped])).returns(Integer) }
        def destroy_all(conditions = nil); end
      end
    end

    # Defines behavior for $inc operations.
    # 
    # @since 4.0.0
    module Incrementable
      extend ActiveSupport::Concern

      # Increment the provided fields by the corresponding values. Values can
      # be positive or negative, and if no value exists for the field it will
      # be set with the provided value.
      # 
      # _@param_ `increments` — The field/inc increment pairs.
      # 
      # _@return_ — The document.
      # 
      # Increment the fields.
      # ```ruby
      # document.inc(score: 10, place: 1, lives: -10)
      # ```
      sig { params(increments: T::Hash[T.untyped, T.untyped]).returns(Document) }
      def inc(increments); end
    end
  end

  # A cache of database queries on a per-request basis.
  # 
  # @since 4.0.0
  module QueryCache
    # Get the cached queries.
    # 
    # _@return_ — The hash of cached queries.
    # 
    # Get the cached queries from the current thread.
    # ```ruby
    # QueryCache.cache_table
    # ```
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    def self.cache_table; end

    # Clear the query cache.
    # 
    # _@return_ — Always nil.
    # 
    # Clear the cache.
    # ```ruby
    # QueryCache.clear_cache
    # ```
    sig { returns(T.nilable(T.any())) }
    def self.clear_cache; end

        # Set whether the cache is enabled.
    # 
    # _@param_ `value` — The enabled value.
    # 
    # Set if the cache is enabled.
    # ```ruby
    # QueryCache.enabled = true
    # ```
    sig { params(value: T::Boolean).returns(T.untyped) }
    def self.enabled=(value); end

    # Is the query cache enabled on the current thread?
    # 
    # _@return_ — If the cache is enabled.
    # 
    # Is the query cache enabled?
    # ```ruby
    # QueryCache.enabled?
    # ```
    sig { returns(T::Boolean) }
    def self.enabled?; end

    # Execute the block while using the query cache.
    # 
    # _@return_ — The result of the block.
    # 
    # Execute with the cache.
    # ```ruby
    # QueryCache.cache { collection.find }
    # ```
    sig { params(block: T.untyped).returns(Object) }
    def self.cache(&block); end

    # Execute the block with the query cache disabled.
    # 
    # _@return_ — The result of the block.
    # 
    # Execute without the cache.
    # ```ruby
    # QueryCache.uncached { collection.find }
    # ```
    sig { params(block: T.untyped).returns(Object) }
    def self.uncached(&block); end

    # The middleware to be added to a rack application in order to activate the
    # query cache.
    # 
    # @since 4.0.0
    class Middleware
      # Instantiate the middleware.
      # 
      # _@param_ `app` — The rack applciation stack.
      # 
      # Create the new middleware.
      # ```ruby
      # Middleware.new(app)
      # ```
      sig { params(app: Object).void }
      def initialize(app); end

      # Execute the request, wrapping in a query cache.
      # 
      # _@param_ `env` — The environment.
      # 
      # _@return_ — The result of the call.
      # 
      # Execute the request.
      # ```ruby
      # middleware.call(env)
      # ```
      sig { params(env: Object).returns(Object) }
      def call(env); end
    end

    # A Cursor that attempts to load documents from memory first before hitting
    # the database if the same query has already been executed.
    # 
    # @since 5.0.0
    # @deprecated This class is only used with driver versions 2.13 and lower.
    class CachedCursor < Mongo::Cursor
            # We iterate over the cached documents if they exist already in the
      # cursor otherwise proceed as normal.
      # 
      # Iterate over the documents.
      # ```ruby
      # cursor.each do |doc|
      #   # ...
      # end
      # ```
      sig { returns(T.untyped) }
      def each; end

      # Get a human-readable string representation of +Cursor+.
      # 
      # _@return_ — A string representation of a +Cursor+ instance.
      # 
      # Inspect the cursor.
      # ```ruby
      # cursor.inspect
      # ```
      sig { returns(String) }
      def inspect; end

                  sig { params(result: T.untyped).returns(T.untyped) }
      def process(result); end
    end

    # Included to add behavior for clearing out the query cache on certain
    # operations.
    # 
    # @since 4.0.0
    # @deprecated This module is only used with driver versions 2.13 and lower.
    module Base
                  sig { params(method_names: T.untyped).returns(T.untyped) }
      def alias_query_cache_clear(*method_names); end
    end

    # Contains enhancements to the Mongo::Collection::View in order to get a
    # cached cursor or a regular cursor on iteration.
    # 
    # @since 5.0.0
    # @deprecated This module is only used with driver versions 2.13 and lower.
    module View
      extend ActiveSupport::Concern

            # Override the default enumeration to handle if the cursor can be cached
      # or not.
      # 
      # Iterate over the view.
      # ```ruby
      # view.each do |doc|
      #   # ...
      # end
      # ```
      sig { returns(T.untyped) }
      def each; end

            sig { returns(T.untyped) }
      def cached_cursor; end

            sig { returns(T.untyped) }
      def cache_key; end

      sig { returns(T::Boolean) }
      def system_collection?; end
    end

    # Adds behavior to the query cache for collections.
    # 
    # @since 5.0.0
    # @deprecated This module is only used with driver versions 2.13 and lower.
    module Collection
      extend ActiveSupport::Concern
    end

    # Bypass the query cache when reloading a document.
    module Document
            sig { returns(T.untyped) }
      def reload; end
    end
  end

  # Provides behavior around traversing the document graph.
  # 
  # @since 4.0.0
  module Traversable
    extend ActiveSupport::Concern

        sig { returns(T.untyped) }
    def _parent; end

            sig { params(p: T.untyped).returns(T.untyped) }
    def _parent=(p); end

    # Get all child +Documents+ to this +Document+, going n levels deep if
    # necessary. This is used when calling update persistence operations from
    # the root document, where changes in the entire tree need to be
    # determined. Note that persistence from the embedded documents will
    # always be preferred, since they are optimized calls... This operation
    # can get expensive in domains with large hierarchies.
    # 
    # _@return_ — All child documents in the hierarchy.
    # 
    # Get all the document's children.
    # ```ruby
    # person._children
    # ```
    sig { returns(T::Array[Document]) }
    def _children; end

    # Collect all the children of this document.
    # 
    # _@return_ — The children.
    # 
    # Collect all the children.
    # ```ruby
    # document.collect_children
    # ```
    sig { returns(T::Array[Document]) }
    def collect_children; end

    # Marks all children as being persisted.
    # 
    # _@return_ — The flagged children.
    # 
    # Flag all the children.
    # ```ruby
    # document.flag_children_persisted
    # ```
    sig { returns(T::Array[Document]) }
    def flag_children_persisted; end

    # Determines if the document is a subclass of another document.
    # 
    # _@return_ — True if hereditary, false if not.
    # 
    # Check if the document is a subclass
    # ```ruby
    # Square.new.hereditary?
    # ```
    sig { returns(T::Boolean) }
    def hereditary?; end

    # Sets up a child/parent association. This is used for newly created
    # objects so they can be properly added to the graph.
    # 
    # _@param_ `document` — The parent document.
    # 
    # _@return_ — The parent document.
    # 
    # Set the parent document.
    # ```ruby
    # document.parentize(parent)
    # ```
    sig { params(document: Document).returns(Document) }
    def parentize(document); end

        # Remove a child document from this parent. If an embeds one then set to
    # nil, otherwise remove from the embeds many.
    # 
    # This is called from the +RemoveEmbedded+ persistence command.
    # 
    # _@param_ `child` — The child (embedded) document to remove.
    # 
    # Remove the child.
    # ```ruby
    # document.remove_child(child)
    # ```
    sig { params(child: Document).returns(T.untyped) }
    def remove_child(child); end

    # After children are persisted we can call this to move all their changes
    # and flag them as persisted in one call.
    # 
    # _@return_ — The children.
    # 
    # Reset the children.
    # ```ruby
    # document.reset_persisted_children
    # ```
    sig { returns(T::Array[Document]) }
    def reset_persisted_children; end

    # Resets the memoized children on the object. Called internally when an
    # embedded array changes size.
    # 
    # _@return_ — nil.
    # 
    # Reset the memoized children.
    # ```ruby
    # document._reset_memoized_children!
    # ```
    sig { returns(T.nilable(T.any())) }
    def _reset_memoized_children!; end

    # Return the root document in the object graph. If the current document
    # is the root object in the graph it will return self.
    # 
    # _@return_ — The root document in the hierarchy.
    # 
    # Get the root document in the hierarchy.
    # ```ruby
    # document._root
    # ```
    sig { returns(Document) }
    def _root; end

    # Is this document the root document of the hierarchy?
    # 
    # _@return_ — If the document is the root.
    # 
    # Is the document the root?
    # ```ruby
    # document._root?
    # ```
    sig { returns(T::Boolean) }
    def _root?; end

    # Module used for prepending to the various discriminator_*= methods
    # 
    # @api private
    module DiscriminatorAssignment
                  sig { params(value: T.untyped).returns(T.untyped) }
      def discriminator_key=(value); end

                  sig { params(value: T.untyped).returns(T.untyped) }
      def discriminator_value=(value); end
    end

    # Module used for prepending the discriminator_value method.
    # 
    # A separate module was needed because the subclasses of this class
    # need to be manually prepended with the discriminator_value and can't
    # rely on being a class_attribute because the .discriminator_value
    # method is overriden by every subclass in the inherited method.
    # 
    # @api private
    module DiscriminatorRetrieval
            # Get the name on the reading side if the discriminator_value is nil
      sig { returns(T.untyped) }
      def discriminator_value; end
    end

    module ClassMethods
      # Determines if the document is a subclass of another document.
      # 
      # _@return_ — True if hereditary, false if not.
      # 
      # Check if the document is a subclass.
      # ```ruby
      # Square.hereditary?
      # ```
      sig { returns(T::Boolean) }
      def hereditary?; end

            # When inheriting, we want to copy the fields from the parent class and
      # set the on the child to start, mimicking the behavior of the old
      # class_inheritable_accessor that was deprecated in Rails edge.
      # 
      # _@param_ `subclass` — The inheriting class.
      # 
      # Inherit from this class.
      # ```ruby
      # Person.inherited(Doctor)
      # ```
      sig { params(subclass: Class).returns(T.untyped) }
      def inherited(subclass); end
    end
  end

  # This module provides additional validations that ActiveModel does not
  # provide: validates_associated and validates_uniqueness_of.
  module Validatable
    extend ActiveSupport::Concern

        # Begin the associated validation.
    # 
    # Begin validation.
    # ```ruby
    # document.begin_validate
    # ```
    sig { returns(T.untyped) }
    def begin_validate; end

        # Exit the associated validation.
    # 
    # Exit validation.
    # ```ruby
    # document.exit_validate
    # ```
    sig { returns(T.untyped) }
    def exit_validate; end

    # Given the provided options, are we performing validations?
    # 
    # _@param_ `options` — The options to check.
    # 
    # _@return_ — If we are validating.
    # 
    # Are we performing validations?
    # ```ruby
    # document.performing_validations?(validate: true)
    # ```
    sig { params(options: T::Hash[T.untyped, T.untyped]).returns(T::Boolean) }
    def performing_validations?(options = {}); end

    # Overrides the default ActiveModel behavior since we need to handle
    # validations of associations slightly different than just calling the
    # getter.
    # 
    # _@param_ `attr` — The name of the field or association.
    # 
    # _@return_ — The value of the field or the association.
    # 
    # Read the value.
    # ```ruby
    # person.read_attribute_for_validation(:addresses)
    # ```
    sig { params(attr: Symbol).returns(Object) }
    def read_attribute_for_validation(attr); end

    # Determine if the document is valid.
    # 
    # _@param_ `context` — The optional validation context.
    # 
    # _@return_ — True if valid, false if not.
    # 
    # Is the document valid?
    # ```ruby
    # person.valid?
    # ```
    # 
    # Is the document valid in a context?
    # ```ruby
    # person.valid?(:create)
    # ```
    sig { params(context: T.nilable(Symbol)).returns(T::Boolean) }
    def valid?(context = nil); end

    # Used to prevent infinite loops in associated validations.
    # 
    # _@return_ — Has the document already been validated?
    # 
    # Is the document validated?
    # ```ruby
    # document.validated?
    # ```
    sig { returns(T::Boolean) }
    def validated?; end

    # Are we currently performing a validation that has a query?
    # 
    # _@return_ — If we are validating with a query.
    # 
    # Are we validating with a query?
    # ```ruby
    # document.validating_with_query?
    # ```
    sig { returns(T::Boolean) }
    def validating_with_query?; end

    module ClassMethods
            # Adds an associated validator for the association if the validate option
      # was not provided or set to true.
      # 
      # _@param_ `association` — The association metadata.
      # 
      # Set up validation.
      # ```ruby
      # Person.validates_relation(association)
      # ```
      sig { params(association: Association).returns(T.untyped) }
      def validates_relation(association); end

            # Add validation with the supplied validators forthe provided fields
      # with options.
      # 
      # _@param_ `args` — The validator classes and options.
      # 
      # Validate with a specific validator.
      # ```ruby
      # validates_with MyValidator, on: :create
      # ```
      # 
      # _@note_ — See ActiveModel::Validations::With for full options. This is
      # overridden to add autosave functionality when presence validation is
      # added.
      sig { params(args: T.any(T::Array[T.untyped], T::Hash[T.untyped, T.untyped]), block: T.untyped).returns(T.untyped) }
      def validates_with(*args, &block); end

      # Are we currently performing a validation that has a query?
      # 
      # _@return_ — If we are validating with a query.
      # 
      # Are we validating with a query?
      # ```ruby
      # Model.validating_with_query?
      # ```
      sig { returns(T::Boolean) }
      def validating_with_query?; end
    end

    # Validates that the specified attributes do or do not match a certain
    # regular expression.
    # 
    # @example Set up the format validator.
    # 
    #   class Person
    #     include Mongoid::Document
    #     field :website
    # 
    #     validates_format_of :website, :with => URI.regexp
    #   end
    class FormatValidator < ActiveModel::Validations::FormatValidator
      include Mongoid::Validatable::Localizable

            # Validates each for localized fields.
      # 
      # _@param_ `document` — The document.
      # 
      # _@param_ `attribute` — The attribute to validate.
      # 
      # _@param_ `value` — The attribute value.
      # 
      # Validate localized fields.
      # ```ruby
      # validator.validate_each(model, :name, "value")
      # ```
      sig { params(document: Document, attribute: T.any(Symbol, String), value: Object).returns(T.untyped) }
      def validate_each(document, attribute, value); end
    end

    # Validates that the specified attributes do or do not match a certain
    # length.
    # 
    # @example Set up the length validator.
    # 
    #   class Person
    #     include Mongoid::Document
    #     field :website
    # 
    #     validates_length_of :website, in: 1..10
    #   end
    class LengthValidator < ActiveModel::Validations::LengthValidator
      include Mongoid::Validatable::Localizable

            # Validates each for localized fields.
      # 
      # _@param_ `document` — The document.
      # 
      # _@param_ `attribute` — The attribute to validate.
      # 
      # _@param_ `value` — The attribute value.
      # 
      # Validate localized fields.
      # ```ruby
      # validator.validate_each(model, :name, "value")
      # ```
      sig { params(document: Document, attribute: T.any(Symbol, String), value: Object).returns(T.untyped) }
      def validate_each(document, attribute, value); end
    end

    module Macros
      extend ActiveSupport::Concern

            # Validates whether or not an association is valid or not. Will correctly
      # handle has one and has many associations.
      # 
      # _@param_ `args` — The arguments to pass to the validator.
      # 
      # ```ruby
      # 
      # class Person
      #   include Mongoid::Document
      #   embeds_one :name
      #   embeds_many :addresses
      # 
      #   validates_associated :name, :addresses
      # end
      # ```
      sig { params(args: T::Array[T.untyped]).returns(T.untyped) }
      def validates_associated(*args); end

            # Validates whether or not a field is unique against the documents in the
      # database.
      # 
      # _@param_ `args` — The arguments to pass to the validator.
      # 
      # ```ruby
      # 
      # class Person
      #   include Mongoid::Document
      #   field :title
      # 
      #   validates_uniqueness_of :title
      # end
      # ```
      sig { params(args: T::Array[T.untyped]).returns(T.untyped) }
      def validates_uniqueness_of(*args); end

            # Validates the format of a field.
      # 
      # _@param_ `args` — The names of the fields to validate.
      # 
      # ```ruby
      # class Person
      #   include Mongoid::Document
      #   field :title
      # 
      #   validates_format_of :title, with: /\A[a-z0-9 \-_]*\z/i
      # end
      # ```
      sig { params(args: T::Array[T.untyped]).returns(T.untyped) }
      def validates_format_of(*args); end

            # Validates the length of a field.
      # 
      # _@param_ `args` — The names of the fields to validate.
      # 
      # ```ruby
      # class Person
      #   include Mongoid::Document
      #   field :title
      # 
      #   validates_length_of :title, minimum: 100
      # end
      # ```
      sig { params(args: T::Array[T.untyped]).returns(T.untyped) }
      def validates_length_of(*args); end

            # Validates whether or not a field is present - meaning nil or empty.
      # 
      # _@param_ `args` — The names of the fields to validate.
      # 
      # ```ruby
      # class Person
      #   include Mongoid::Document
      #   field :title
      # 
      #   validates_presence_of :title
      # end
      # ```
      sig { params(args: T::Array[T.untyped]).returns(T.untyped) }
      def validates_presence_of(*args); end
    end

    # Validates that the specified attributes are not blank (as defined by
    # Object#blank?).
    # 
    # @example Define the presence validator.
    # 
    #   class Person
    #     include Mongoid::Document
    #     field :title
    # 
    #     validates_presence_of :title
    #   end
    class PresenceValidator < ActiveModel::EachValidator
            # Validate the document for the attribute and value.
      # 
      # _@param_ `document` — The document to validate.
      # 
      # _@param_ `attribute` — The attribute name.
      # 
      # _@param_ `value` — The current value of the field.
      # 
      # Validate the document.
      # ```ruby
      # validator.validate_each(doc, :title, "")
      # ```
      sig { params(document: Document, attribute: Symbol, value: Object).returns(T.untyped) }
      def validate_each(document, attribute, value); end

      # Returns true if the association is blank or the foreign key is blank.
      # 
      # _@param_ `doc` — The document.
      # 
      # _@param_ `attr` — The attribute.
      # 
      # _@param_ `value` — The value.
      # 
      # _@return_ — If the doc is missing.
      # 
      # Check is the association or fk is blank.
      # ```ruby
      # validator.relation_or_fk_mising(doc, :name, "")
      # ```
      sig { params(doc: Document, attr: Symbol, value: Object).returns(T::Boolean) }
      def relation_or_fk_missing?(doc, attr, value); end

      # For guarding against false values.
      # 
      # _@param_ `value` — The value.
      # 
      # _@return_ — If the value is not present.
      # 
      # Is the value not present?
      # ```ruby
      # validator.not_present?(value)
      # ```
      sig { params(value: Object).returns(T::Boolean) }
      def not_present?(value); end
    end

    module Queryable
      # Wrap the validation inside the an execution block that alert's the
      # client not to clear its persistence options.
      # 
      # _@param_ `document` — The document being validated.
      # 
      # _@return_ — The result of the yield.
      # 
      # Execute the validation with a query.
      # ```ruby
      # with_query(document) do
      #   #...
      # end
      # ```
      sig { params(document: Document).returns(Object) }
      def with_query(document); end
    end

    # Validates whether or not an association is valid or not. Will correctly
    # handle has one and has many associations.
    # 
    # @example Set up the association validations.
    # 
    #   class Person
    #     include Mongoid::Document
    #     embeds_one :name
    #     embeds_many :addresses
    # 
    #     validates_associated :name, :addresses
    #   end
    class AssociatedValidator < ActiveModel::EachValidator
            # Validates that the associations provided are either all nil or all
      # valid. If neither is true then the appropriate errors will be added to
      # the parent document.
      # 
      # _@param_ `document` — The document to validate.
      # 
      # _@param_ `attribute` — The association to validate.
      # 
      # _@param_ `value` — The value of the association.
      # 
      # Validate the association.
      # ```ruby
      # validator.validate_each(document, :name, name)
      # ```
      sig { params(document: Document, attribute: Symbol, value: Object).returns(T.untyped) }
      def validate_each(document, attribute, value); end
    end

    # Validates whether or not a field is unique against the documents in the
    # database.
    # 
    # @example Define the uniqueness validator.
    # 
    #   class Person
    #     include Mongoid::Document
    #     field :title
    # 
    #     validates_uniqueness_of :title
    #   end
    # 
    # It is also possible to limit the uniqueness constraint to a set of
    # records matching certain conditions:
    #   class Person
    #     include Mongoid::Document
    #     field :title
    #     field :active, type: Boolean
    # 
    #     validates_uniqueness_of :title, conditions: -> {where(active: true)}
    #   end
    class UniquenessValidator < ActiveModel::EachValidator
      include Mongoid::Validatable::Queryable

      # Validate the document for uniqueness violations.
      # 
      # _@param_ `document` — The document to validate.
      # 
      # _@param_ `attribute` — The field to validate on.
      # 
      # _@param_ `value` — The value of the field.
      # 
      # _@return_ — The errors.
      # 
      # Validate the document.
      # ```ruby
      # validate_each(person, :title, "Sir")
      # ```
      sig { params(document: Document, attribute: Symbol, value: Object).returns(Errors) }
      def validate_each(document, attribute, value); end

            # Add the error to the document.
      # 
      # _@param_ `document` — The document to validate.
      # 
      # _@param_ `attribute` — The name of the attribute.
      # 
      # _@param_ `value` — The value of the object.
      # 
      # Add the error.
      # ```ruby
      # validator.add_error(doc, :name, "test")
      # ```
      sig { params(document: Document, attribute: Symbol, value: Object).returns(T.untyped) }
      def add_error(document, attribute, value); end

      # Should the uniqueness validation be case sensitive?
      # 
      # _@return_ — If the validation is case sensitive.
      # 
      # Is the validation case sensitive?
      # ```ruby
      # validator.case_sensitive?
      # ```
      sig { returns(T::Boolean) }
      def case_sensitive?; end

      # sord warn - Proxy wasn't able to be resolved to a constant in this project
      # Create the validation criteria.
      # 
      # _@param_ `base` — The base to execute the criteria from.
      # 
      # _@param_ `document` — The document to validate.
      # 
      # _@param_ `attribute` — The name of the attribute.
      # 
      # _@param_ `value` — The value of the object.
      # 
      # _@return_ — The criteria.
      # 
      # Create the criteria.
      # ```ruby
      # validator.create_criteria(User, user, :name, "syd")
      # ```
      sig do
        params(
          base: T.untyped, # Proxy | Class
          document: Document,
          attribute: Symbol,
          value: Object
        ).returns(Criteria)
      end
      def create_criteria(base, document, attribute, value); end

      # Get the default criteria for checking uniqueness.
      # 
      # _@param_ `document` — The document to validate.
      # 
      # _@param_ `attribute` — The name of the attribute.
      # 
      # _@param_ `value` — The value of the object.
      # 
      # _@return_ — The uniqueness criteria.
      # 
      # Get the criteria.
      # ```ruby
      # validator.criterion(person, :title, "Sir")
      # ```
      sig { params(document: Document, attribute: Symbol, value: Object).returns(Criteria) }
      def criterion(document, attribute, value); end

      # Filter the value based on whether the check is case sensitive or not.
      # 
      # _@param_ `value` — The value to filter.
      # 
      # _@return_ — The value, filtered or not.
      # 
      # Filter the value.
      # ```ruby
      # validator.filter("testing")
      # ```
      sig { params(value: Object).returns(T.any(Object, Regexp)) }
      def filter(value); end

            # Scope the criteria to the scope options provided.
      # 
      # _@param_ `criteria` — The criteria to scope.
      # 
      # _@param_ `document` — The document being validated.
      # 
      # _@return_ — The scoped criteria.
      # 
      # Scope the criteria.
      # ```ruby
      # validator.scope(criteria, document)
      # ```
      sig { params(criteria: Criteria, document: Document, _attribute: T.untyped).returns(Criteria) }
      def scope(criteria, document, _attribute); end

      # Should validation be skipped?
      # 
      # _@param_ `document` — The embedded document.
      # 
      # _@return_ — If the validation should be skipped.
      # 
      # Should the validation be skipped?
      # ```ruby
      # validator.skip_validation?(doc)
      # ```
      sig { params(document: Document).returns(T::Boolean) }
      def skip_validation?(document); end

      # Scope reference has changed?
      # 
      # _@param_ `document` — The embedded document.
      # 
      # _@return_ — If the scope reference has changed.
      # 
      # Has scope reference changed?
      # ```ruby
      # validator.scope_value_changed?(doc)
      # ```
      sig { params(document: Document).returns(T::Boolean) }
      def scope_value_changed?(document); end

      # Get the name of the field and the value to validate. This is for the
      # case when we validate an association via the association name and not the key,
      # we need to send the key name and value to the db, not the association
      # object.
      # 
      # _@param_ `document` — The doc getting validated.
      # 
      # _@param_ `attribute` — The attribute getting validated.
      # 
      # _@param_ `value` — The value of the attribute.
      # 
      # _@return_ — The field and value.
      # 
      # Get the name and key to validate.
      # ```ruby
      # validator.to_validate(doc, :parent, Parent.new)
      # ```
      sig { params(document: Document, attribute: Symbol, value: Object).returns(T::Array[T.any(Object, Object)]) }
      def to_validate(document, attribute, value); end

            # Validate an embedded document.
      # 
      # _@param_ `document` — The document.
      # 
      # _@param_ `attribute` — The attribute name.
      # 
      # _@param_ `value` — The value.
      # 
      # Validate the embedded document.
      # ```ruby
      # validator.validate_embedded(doc, :name, "test")
      # ```
      sig { params(document: Document, attribute: Symbol, value: Object).returns(T.untyped) }
      def validate_embedded(document, attribute, value); end

            # Validate a root document.
      # 
      # _@param_ `document` — The document.
      # 
      # _@param_ `attribute` — The attribute name.
      # 
      # _@param_ `value` — The value.
      # 
      # Validate the root document.
      # ```ruby
      # validator.validate_root(doc, :name, "test")
      # ```
      sig { params(document: Document, attribute: Symbol, value: Object).returns(T.untyped) }
      def validate_root(document, attribute, value); end

      # Are we required to validate the document?
      # 
      # _@param_ `document` — The document getting validated.
      # 
      # _@param_ `attribute` — The attribute to validate.
      # 
      # _@return_ — If we need to validate.
      # 
      # Is validation needed?
      # ```ruby
      # validator.validation_required?(doc, :field)
      # ```
      sig { params(document: Document, attribute: Symbol).returns(T::Boolean) }
      def validation_required?(document, attribute); end

      # Is the attribute localized?
      # 
      # _@param_ `document` — The document getting validated.
      # 
      # _@param_ `attribute` — The attribute to validate.
      # 
      # _@return_ — If the attribute is localized.
      # 
      # Is the attribute localized?
      # ```ruby
      # validator.localized?(doc, :field)
      # ```
      sig { params(document: Document, attribute: Symbol).returns(T::Boolean) }
      def localized?(document, attribute); end

      # Wrap the validation inside the an execution block that alert's the
      # client not to clear its persistence options.
      # 
      # _@param_ `document` — The document being validated.
      # 
      # _@return_ — The result of the yield.
      # 
      # Execute the validation with a query.
      # ```ruby
      # with_query(document) do
      #   #...
      # end
      # ```
      sig { params(document: Document).returns(Object) }
      def with_query(document); end
    end

    # Adds localization support to validations.
    module Localizable
            # Validates each for localized fields.
      # 
      # _@param_ `document` — The document.
      # 
      # _@param_ `attribute` — The attribute to validate.
      # 
      # _@param_ `value` — The attribute value.
      # 
      # Validate localized fields.
      # ```ruby
      # validator.validate_each(model, :name, "value")
      # ```
      sig { params(document: Document, attribute: T.any(Symbol, String), value: Object).returns(T.untyped) }
      def validate_each(document, attribute, value); end
    end
  end

  # This module provides the extra behavior for including associations in JSON
  # and XML serialization.
  # 
  # @since 4.0.0
  module Serializable
    extend ActiveSupport::Concern

    # Gets the document as a serializable hash, used by ActiveModel's JSON
    # serializer.
    # 
    # _@param_ `options` — The options to pass.
    # 
    # _@return_ — The document, ready to be serialized.
    # 
    # Get the serializable hash.
    # ```ruby
    # document.serializable_hash
    # ```
    # 
    # Get the serializable hash with options.
    # ```ruby
    # document.serializable_hash(:include => :addresses)
    # ```
    sig { params(options: T.nilable(T::Hash[T.untyped, T.untyped])).returns(T::Hash[T.untyped, T.untyped]) }
    def serializable_hash(options = nil); end

        # Get the names of all fields that will be serialized.
    # 
    # _@return_ — The names of the fields.
    # 
    # Get all the field names.
    # ```ruby
    # document.send(:field_names)
    # ```
    sig { params(options: T.untyped).returns(T::Array[String]) }
    def field_names(options); end

    # Serialize a single attribute. Handles associations, fields, and dynamic
    # attributes.
    # 
    # _@param_ `attrs` — The attributes.
    # 
    # _@param_ `name` — The attribute name.
    # 
    # _@param_ `names` — The names of all attributes.
    # 
    # _@param_ `options` — The options.
    # 
    # _@return_ — The attribute.
    # 
    # Serialize the attribute.
    # ```ruby
    # document.serialize_attribute({}, "id" , [ "id" ])
    # ```
    sig do
      params(
        attrs: T::Hash[T.untyped, T.untyped],
        name: String,
        names: T::Array[String],
        options: T::Hash[T.untyped, T.untyped]
      ).returns(Object)
    end
    def serialize_attribute(attrs, name, names, options); end

        # For each of the provided include options, get the association needed and
    # provide it in the hash.
    # 
    # _@param_ `attributes` — The attributes to serialize.
    # 
    # _@param_ `options` — The serialization options.
    # 
    # Serialize the included associations.
    # ```ruby
    # document.serialize_relations({}, :include => :addresses)
    # ```
    sig { params(attributes: T::Hash[T.untyped, T.untyped], options: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
    def serialize_relations(attributes = {}, options = {}); end

    # Since the inclusions can be a hash, symbol, or array of symbols, this is
    # provided as a convenience to parse out the names.
    # 
    # _@param_ `inclusions` — The inclusions.
    # 
    # _@return_ — The names of the included associations.
    # 
    # Get the association names.
    # ```ruby
    # document.relation_names(:include => [ :addresses ])
    # ```
    sig { params(inclusions: T.any(T::Hash[T.untyped, T.untyped], Symbol, T::Array[Symbol])).returns(T::Array[Symbol]) }
    def relation_names(inclusions); end

    # Since the inclusions can be a hash, symbol, or array of symbols, this is
    # provided as a convenience to parse out the options.
    # 
    # _@param_ `inclusions` — The inclusions.
    # 
    # _@param_ `options` — The options.
    # 
    # _@param_ `name` — The name of the association.
    # 
    # _@return_ — The options for the association.
    # 
    # Get the association options.
    # ```ruby
    # document.relation_names(:include => [ :addresses ])
    # ```
    sig { params(inclusions: T.any(T::Hash[T.untyped, T.untyped], Symbol, T::Array[Symbol]), options: T::Hash[T.untyped, T.untyped], name: Symbol).returns(T::Hash[T.untyped, T.untyped]) }
    def relation_options(inclusions, options, name); end
  end

  # This module contains all the callback hooks for Mongoid.
  # 
  # @since 4.0.0
  module Interceptable
    extend ActiveSupport::Concern
    CALLBACKS = T.let([
  :after_build,
  :after_create,
  :after_destroy,
  :after_find,
  :after_initialize,
  :after_save,
  :after_touch,
  :after_update,
  :after_upsert,
  :after_validation,
  :around_create,
  :around_destroy,
  :around_save,
  :around_update,
  :around_upsert,
  :before_create,
  :before_destroy,
  :before_save,
  :before_update,
  :before_upsert,
  :before_validation
].freeze, T.untyped)

    # Is the provided type of callback executable by this document?
    # 
    # _@param_ `kind` — The type of callback.
    # 
    # _@return_ — If the callback can be executed.
    # 
    # Is the callback executable?
    # ```ruby
    # document.callback_executable?(:save)
    # ```
    sig { params(kind: Symbol).returns(T::Boolean) }
    def callback_executable?(kind); end

    # Is the document currently in a state that could potentially require
    # callbacks to be executed?
    # 
    # _@param_ `kind` — The callback kind.
    # 
    # _@return_ — If the document is in a callback state.
    # 
    # Is the document in a callback state?
    # ```ruby
    # document.in_callback_state?(:update)
    # ```
    sig { params(kind: Symbol).returns(T::Boolean) }
    def in_callback_state?(kind); end

    # Run only the after callbacks for the specific event.
    # 
    # _@param_ `kinds` — The events that are occurring.
    # 
    # _@return_ — The result of the chain executing.
    # 
    # Run only the after save callbacks.
    # ```ruby
    # model.run_after_callbacks(:save)
    # ```
    # 
    # _@note_ — ActiveSupport does not allow this type of behavior by default, so
    # Mongoid has to get around it and implement itself.
    sig { params(kinds: T::Array[Symbol]).returns(Object) }
    def run_after_callbacks(*kinds); end

    # Run only the before callbacks for the specific event.
    # 
    # _@param_ `kinds` — The events that are occurring.
    # 
    # _@return_ — The result of the chain executing.
    # 
    # Run only the before save callbacks.
    # ```ruby
    # model.run_before_callbacks(:save, :create)
    # ```
    # 
    # _@note_ — ActiveSupport does not allow this type of behavior by default, so
    # Mongoid has to get around it and implement itself.
    sig { params(kinds: T::Array[Symbol]).returns(Object) }
    def run_before_callbacks(*kinds); end

    # Run the callbacks for the document. This overrides active support's
    # functionality to cascade callbacks to embedded documents that have been
    # flagged as such.
    # 
    # _@param_ `kind` — The type of callback to execute.
    # 
    # _@param_ `args` — Any options.
    # 
    # _@return_ — The document
    # 
    # Run the callbacks.
    # ```ruby
    # run_callbacks :save do
    #   save!
    # end
    # ```
    sig { params(kind: Symbol, args: T::Array[T.untyped], block: T.untyped).returns(Document) }
    def run_callbacks(kind, *args, &block); end

    # We need to hook into this for autosave, since we don't want it firing if
    # the before callbacks were halted.
    # 
    # _@return_ — If a before callback was halted.
    # 
    # Was a before callback halted?
    # ```ruby
    # document.before_callback_halted?
    # ```
    sig { returns(T::Boolean) }
    def before_callback_halted?; end

        # Get all the child embedded documents that are flagged as cascadable.
    # 
    # _@param_ `kind` — The type of callback.
    # 
    # _@return_ — The children.
    # 
    # Get all the cascading children.
    # ```ruby
    # document.cascadable_children(:update)
    # ```
    sig { params(kind: Symbol, children: T.untyped).returns(T::Array[Document]) }
    def cascadable_children(kind, children = Set.new); end

        # Determine if the child should fire the callback.
    # 
    # _@param_ `kind` — The type of callback.
    # 
    # _@param_ `child` — The child document.
    # 
    # _@return_ — If the child should fire the callback.
    # 
    # Should the child fire the callback?
    # ```ruby
    # document.cascadable_child?(:update, doc)
    # ```
    sig { params(kind: Symbol, child: Document, association: T.untyped).returns(T::Boolean) }
    def cascadable_child?(kind, child, association); end

    # Get the name of the callback that the child should fire. This changes
    # depending on whether or not the child is new. A persisted parent with a
    # new child would fire :update from the parent, but needs to fire :create
    # on the child.
    # 
    # _@param_ `kind` — The type of callback.
    # 
    # _@param_ `child` — The child document
    # 
    # _@return_ — The name of the callback.
    # 
    # Get the callback type.
    # ```ruby
    # document.child_callback_type(:update, doc)
    # ```
    sig { params(kind: Symbol, child: Document).returns(Symbol) }
    def child_callback_type(kind, child); end

        # We need to hook into this for autosave, since we don't want it firing if
    # the before callbacks were halted.
    # 
    # _@param_ `filter` — The callback that halted.
    # 
    # _@param_ `name` — The name of the callback that was halted (requires Rails 6.1+)
    # 
    # Hook into the halt.
    # ```ruby
    # document.halted_callback_hook(filter)
    # ```
    sig { params(filter: Symbol, name: T.nilable(Symbol)).returns(T.untyped) }
    def halted_callback_hook(filter, name = nil); end

    # Run only the callbacks for the target location (before, after, around)
    # and kind (save, update, create).
    # 
    # _@param_ `place` — The time to run, :before, :after, :around.
    # 
    # _@param_ `kind` — The type of callback, :save, :create, :update.
    # 
    # _@return_ — The result of the chain execution.
    # 
    # Run the targeted callbacks.
    # ```ruby
    # model.run_targeted_callbacks(:before, :save)
    # ```
    sig { params(place: Symbol, kind: Symbol).returns(Object) }
    def run_targeted_callbacks(place, kind); end
  end

  module Extensions
    module Set
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      # 
      # _@return_ — The object mongoized.
      # 
      # Mongoize the object.
      # ```ruby
      # set.mongoize
      # ```
      sig { returns(T::Array[T.untyped]) }
      def mongoize; end

      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        # 
        # _@param_ `object` — The object to demongoize.
        # 
        # _@return_ — The set.
        # 
        # Demongoize the object.
        # ```ruby
        # Set.demongoize([1, 2, 3])
        # ```
        sig { params(object: T::Array[T.untyped]).returns(T::Set[T.untyped]) }
        def demongoize(object); end

        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        # 
        # _@param_ `object` — The object to mongoize.
        # 
        # _@return_ — The object mongoized.
        # 
        # Mongoize the object.
        # ```ruby
        # Set.mongoize(Set.new([1,2,3]))
        # ```
        sig { params(object: T::Set[T.untyped]).returns(T::Array[T.untyped]) }
        def mongoize(object); end
      end
    end

    module Date
      EPOCH = T.let(::Date.new(1970, 1, 1), T.untyped)

      # sord warn - ActiveSupport::TimeWithZone wasn't able to be resolved to a constant in this project
      # Convert the date into a time.
      # 
      # _@return_ — Local time in the
      # configured default time zone corresponding to local midnight of
      # this date.
      # 
      # Convert the date to a time.
      # ```ruby
      # Date.new(2018, 11, 1).__mongoize_time__
      # # => Thu, 01 Nov 2018 00:00:00 EDT -04:00
      # ```
      sig { returns(T.any(Time, ActiveSupport::TimeWithZone)) }
      def __mongoize_time__; end

      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      # 
      # _@return_ — The object mongoized.
      # 
      # Mongoize the object.
      # ```ruby
      # date.mongoize
      # ```
      sig { returns(Time) }
      def mongoize; end

      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        # 
        # _@param_ `object` — The time from Mongo.
        # 
        # _@return_ — The object as a date.
        # 
        # Demongoize the object.
        # ```ruby
        # Date.demongoize(object)
        # ```
        sig { params(object: Time).returns(Date) }
        def demongoize(object); end

        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        # 
        # _@param_ `object` — The object to mongoize.
        # 
        # _@return_ — The object mongoized.
        # 
        # Mongoize the object.
        # ```ruby
        # Date.mongoize("2012-1-1")
        # ```
        sig { params(object: Object).returns(Time) }
        def mongoize(object); end
      end
    end

    module Hash
      # Evolves each value in the hash to an object id if it is convertable.
      # 
      # _@return_ — The converted hash.
      # 
      # Convert the hash values.
      # ```ruby
      # { field: id }.__evolve_object_id__
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def __evolve_object_id__; end

      # Mongoizes each value in the hash to an object id if it is convertable.
      # 
      # _@return_ — The converted hash.
      # 
      # Convert the hash values.
      # ```ruby
      # { field: id }.__mongoize_object_id__
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def __mongoize_object_id__; end

            # Consolidate the key/values in the hash under an atomic $set.
      # 
      # _@return_ — A new consolidated hash.
      # 
      # Consolidate the hash.
      # ```ruby
      # { name: "Placebo" }.__consolidate__
      # ```
      sig { params(klass: T.untyped).returns(T::Hash[T.untyped, T.untyped]) }
      def __consolidate__(klass); end

      # Checks whether conditions given in this hash are known to be
      # unsatisfiable, i.e., querying with this hash will always return no
      # documents.
      # 
      # This method only handles condition shapes that Mongoid itself uses when
      # it builds association queries. It does not guarantee that a false
      # return value means the condition can produce a non-empty document set -
      # only that if the return value is true, the condition always produces
      # an empty document set.
      # 
      # _@return_ — Whether hash contains known unsatisfiable
      # conditions.
      # 
      # Unsatisfiable conditions
      # ```ruby
      # {'_id' => {'$in' => []}}._mongoid_unsatisfiable_criteria?
      # # => true
      # ```
      # 
      # Conditions which could be satisfiable
      # ```ruby
      # {'_id' => '123'}._mongoid_unsatisfiable_criteria?
      # # => false
      # ```
      # 
      # Conditions which are unsatisfiable that this method does not handle
      # ```ruby
      # {'foo' => {'$in' => []}}._mongoid_unsatisfiable_criteria?
      # # => false
      # ```
      sig { returns(T::Boolean) }
      def _mongoid_unsatisfiable_criteria?; end

      # Deletes an id value from the hash.
      # 
      # _@return_ — The deleted value, or nil.
      # 
      # Delete an id value.
      # ```ruby
      # {}.delete_id
      # ```
      sig { returns(Object) }
      def delete_id; end

      # Get the id attribute from this hash, whether it's prefixed with an
      # underscore or is a symbol.
      # 
      # _@return_ — The value of the id.
      # 
      # Extract the id.
      # ```ruby
      # { :_id => 1 }.extract_id
      # ```
      sig { returns(Object) }
      def extract_id; end

      # Fetch a nested value via dot syntax.
      # 
      # _@param_ `string` — the dot syntax string.
      # 
      # _@return_ — The matching value.
      # 
      # Fetch a nested value via dot syntax.
      # ```ruby
      # { "name" => { "en" => "test" }}.__nested__("name.en")
      # ```
      sig { params(string: String).returns(Object) }
      def __nested__(string); end

      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      # 
      # _@return_ — The object.
      # 
      # Mongoize the object.
      # ```ruby
      # object.mongoize
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def mongoize; end

      # Can the size of this object change?
      # 
      # _@return_ — true.
      # 
      # Is the hash resizable?
      # ```ruby
      # {}.resizable?
      # ```
      sig { returns(T::Boolean) }
      def resizable?; end

      # Convert this hash to a criteria. Will iterate over each keys in the
      # hash which must correspond to method on a criteria object. The hash
      # must also include a "klass" key.
      # 
      # _@return_ — The criteria.
      # 
      # Convert the hash to a criteria.
      # ```ruby
      # { klass: Band, where: { name: "Depeche Mode" }.to_criteria
      # ```
      sig { returns(Criteria) }
      def to_criteria; end

      # Mongoize for the klass, key and value.
      # 
      # _@param_ `operator` — The operator.
      # 
      # _@param_ `klass` — The model class.
      # 
      # _@param_ `key` — The field key.
      # 
      # _@param_ `value` — The value to mongoize.
      # 
      # _@return_ — The mongoized value.
      # 
      # Mongoize for the klass, field and value.
      # ```ruby
      # {}.mongoize_for("$push", Band, "name", "test")
      # ```
      sig do
        params(
          operator: String,
          klass: Class,
          key: T.any(String, Symbol),
          value: Object
        ).returns(Object)
      end
      def mongoize_for(operator, klass, key, value); end

      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        # 
        # _@param_ `object` — The object to mongoize.
        # 
        # _@return_ — The object mongoized.
        # 
        # Mongoize the object.
        # ```ruby
        # Hash.mongoize([ 1, 2, 3 ])
        # ```
        sig { params(object: Object).returns(T::Hash[T.untyped, T.untyped]) }
        def mongoize(object); end

        # Can the size of this object change?
        # 
        # _@return_ — true.
        # 
        # Is the hash resizable?
        # ```ruby
        # {}.resizable?
        # ```
        sig { returns(T::Boolean) }
        def resizable?; end
      end
    end

    module Time
      EPOCH = T.let(::Time.utc(1970, 1, 1, 0, 0, 0), T.untyped)

      # Mongoizes a Time into a time.
      # 
      # Time always mongoize into Time instances
      # (which are themselves).
      # 
      # _@return_ — self.
      sig { returns(Time) }
      def __mongoize_time__; end

      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      # 
      # _@return_ — The object mongoized.
      # 
      # Mongoize the object.
      # ```ruby
      # time.mongoize
      # ```
      sig { returns(Time) }
      def mongoize; end

      module ClassMethods
        # Get the configured time to use when converting - either the time zone
        # or the time.
        # 
        # _@return_ — The configured time.
        # 
        # Get the configured time.
        # ```ruby
        # ::Time.configured
        # ```
        sig { returns(Time) }
        def configured; end

        # Convert the object from its mongo friendly ruby type to this type.
        # 
        # _@param_ `object` — The time from Mongo.
        # 
        # _@return_ — The object as a date.
        # 
        # Demongoize the object.
        # ```ruby
        # Time.demongoize(object)
        # ```
        sig { params(object: Time).returns(Time) }
        def demongoize(object); end

        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        # 
        # _@param_ `object` — The object to mongoize.
        # 
        # _@return_ — The object mongoized.
        # 
        # Mongoize the object.
        # ```ruby
        # Time.mongoize("2012-1-1")
        # ```
        sig { params(object: Object).returns(Time) }
        def mongoize(object); end
      end
    end

    module Array
      # Evolve the array into an array of object ids.
      # 
      # _@return_ — The converted array.
      # 
      # Evolve the array to object ids.
      # ```ruby
      # [ id ].__evolve_object_id__
      # ```
      sig { returns(T::Array[BSON::ObjectId]) }
      def __evolve_object_id__; end

      # Get the array of args as arguments for a find query.
      # 
      # _@return_ — The array of args.
      # 
      # Get the array as find args.
      # ```ruby
      # [ 1, 2, 3 ].__find_args__
      # ```
      sig { returns(T::Array[T.untyped]) }
      def __find_args__; end

      # Mongoize the array into an array of object ids.
      # 
      # _@return_ — The converted array.
      # 
      # Evolve the array to object ids.
      # ```ruby
      # [ id ].__mongoize_object_id__
      # ```
      sig { returns(T::Array[BSON::ObjectId]) }
      def __mongoize_object_id__; end

      # sord warn - ActiveSupport::TimeWithZone wasn't able to be resolved to a constant in this project
      # Converts the array for storing as a time.
      # 
      # _@return_ — Local time in the
      # configured default time zone corresponding to date/time components
      # in this array.
      # 
      # Convert the array to a time.
      # ```ruby
      # [ 2010, 1, 1 ].__mongoize_time__
      # # => 2010-01-01 00:00:00 -0500
      # ```
      # 
      # _@note_ — Returns a local time in the default time zone.
      sig { returns(T.any(Time, ActiveSupport::TimeWithZone)) }
      def __mongoize_time__; end

      # Checks whether conditions given in this array are known to be
      # unsatisfiable, i.e., querying with this array will always return no
      # documents.
      # 
      # This method used to assume that the array is the list of criteria
      # to be used with an $and operator. This assumption is no longer made;
      # therefore, since the interpretation of conditions in the array differs
      # between $and, $or and $nor operators, this method now always returns
      # false.
      # 
      # This method is deprecated. Mongoid now uses
      # +_mongoid_unsatisfiable_criteria?+ internally; this method is retained
      # for backwards compatibility only. It always returns false.
      # 
      # _@return_ — Always false.
      # 
      # _@deprecated_ — 
      sig { returns(T::Boolean) }
      def blank_criteria?; end

      # Is the array a set of multiple arguments in a method?
      # 
      # _@return_ — If the array is multi args.
      # 
      # Is this multi args?
      # ```ruby
      # [ 1, 2, 3 ].multi_arged?
      # ```
      sig { returns(T::Boolean) }
      def multi_arged?; end

      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      # 
      # _@return_ — The object.
      # 
      # Mongoize the object.
      # ```ruby
      # object.mongoize
      # ```
      sig { returns(T::Array[T.untyped]) }
      def mongoize; end

      # Delete the first object in the array that is equal to the supplied
      # object and return it. This is much faster than performing a standard
      # delete for large arrays ince it attempt to delete multiple in the
      # other.
      # 
      # _@param_ `object` — The object to delete.
      # 
      # _@return_ — The deleted object.
      # 
      # Delete the first object.
      # ```ruby
      # [ "1", "2", "1" ].delete_one("1")
      # ```
      sig { params(object: Object).returns(Object) }
      def delete_one(object); end

      # Is the object's size changable?
      # 
      # _@return_ — true.
      # 
      # Is the object resizable?
      # ```ruby
      # object.resizable?
      # ```
      sig { returns(T::Boolean) }
      def resizable?; end

      module ClassMethods
        # Convert the provided object to a proper array of foreign keys.
        # 
        # _@param_ `association` — The association metadata.
        # 
        # _@param_ `object` — The object to convert.
        # 
        # _@return_ — The array of ids.
        # 
        # Mongoize the object.
        # ```ruby
        # Array.__mongoize_fk__(constraint, object)
        # ```
        sig { params(association: Association, object: Object).returns(T::Array[T.untyped]) }
        def __mongoize_fk__(association, object); end

        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        # 
        # _@param_ `object` — The object to mongoize.
        # 
        # _@return_ — The object mongoized.
        # 
        # Mongoize the object.
        # ```ruby
        # Array.mongoize([ 1, 2, 3 ])
        # ```
        sig { params(object: Object).returns(T::Array[T.untyped]) }
        def mongoize(object); end

        # Is the object's size changable?
        # 
        # _@return_ — true.
        # 
        # Is the object resizable?
        # ```ruby
        # Array.resizable?
        # ```
        sig { returns(T::Boolean) }
        def resizable?; end
      end
    end

    module Float
      # sord warn - ActiveSupport::TimeWithZone wasn't able to be resolved to a constant in this project
      # Converts the float into a time as the number of seconds since the epoch.
      # 
      # _@return_ — The time.
      # 
      # Convert the float into a time.
      # ```ruby
      # 1335532685.117847.__mongoize_time__
      # ```
      sig { returns(T.any(Time, ActiveSupport::TimeWithZone)) }
      def __mongoize_time__; end

      # Is the float a number?
      # 
      # _@return_ — Always true.
      # 
      # Is the object a number?.
      # ```ruby
      # object.numeric?
      # ```
      sig { returns(T::Boolean) }
      def numeric?; end

      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        # 
        # _@param_ `object` — The object to mongoize.
        # 
        # _@return_ — The object mongoized.
        # 
        # Mongoize the object.
        # ```ruby
        # Float.mongoize("123.11")
        # ```
        sig { params(object: Object).returns(String) }
        def mongoize(object); end
      end
    end

    module Range
      # Get the range as arguments for a find.
      # 
      # _@return_ — The range as an array.
      # 
      # Get the range as find args.
      # ```ruby
      # range.__find_args__
      # ```
      sig { returns(T::Array[T.untyped]) }
      def __find_args__; end

      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      # 
      # _@return_ — The object mongoized.
      # 
      # Mongoize the object.
      # ```ruby
      # range.mongoize
      # ```
      sig { returns(T::Hash[T.untyped, T.untyped]) }
      def mongoize; end

      # Is this a resizable object.
      # 
      # _@return_ — True.
      # 
      # Is this resizable?
      # ```ruby
      # range.resizable?
      # ```
      sig { returns(T::Boolean) }
      def resizable?; end

      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        # 
        # _@param_ `object` — The object to demongoize.
        # 
        # _@return_ — The range.
        # 
        # Demongoize the object.
        # ```ruby
        # Range.demongoize({ "min" => 1, "max" => 5 })
        # ```
        sig { params(object: T::Hash[T.untyped, T.untyped]).returns(T::Range[T.untyped]) }
        def demongoize(object); end

        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        # 
        # _@param_ `object` — The object to mongoize.
        # 
        # _@return_ — The object mongoized.
        # 
        # Mongoize the object.
        # ```ruby
        # Range.mongoize(1..3)
        # ```
        sig { params(object: T::Range[T.untyped]).returns(T::Hash[T.untyped, T.untyped]) }
        def mongoize(object); end
      end
    end

    module Module
      # Redefine the method. Will undef the method if it exists or simply
      # just define it.
      # 
      # _@param_ `name` — The name of the method.
      # 
      # _@param_ `block` — The method body.
      # 
      # _@return_ — The new method.
      # 
      # Redefine the method.
      # ```ruby
      # Object.re_define_method("exists?") do
      #   self
      # end
      # ```
      sig { params(name: T.any(String, Symbol), block: T.untyped).returns(Method) }
      def re_define_method(name, &block); end
    end

    module Object
      # Evolve a plain object into an object id.
      # 
      # _@return_ — self.
      # 
      # Evolve the object.
      # ```ruby
      # object.__evolve_object_id__
      # ```
      sig { returns(Object) }
      def __evolve_object_id__; end

      # Convert the object to args for a find query.
      # 
      # _@return_ — self.
      # 
      # Convert the object to args.
      # ```ruby
      # object.__find_args__
      # ```
      sig { returns(Object) }
      def __find_args__; end

      # Mongoize a plain object into a time.
      # 
      # _@return_ — self.
      # 
      # Mongoize the object.
      # ```ruby
      # object.__mongoize_time__
      # ```
      # 
      # _@note_ — This method should not be used, because it does not
      # return correct results for non-Time objects. Override
      # __mongoize_time__ in classes that are time-like to return an
      # instance of Time or ActiveSupport::TimeWithZone.
      # 
      # _@deprecated_ — 
      sig { returns(Object) }
      def __mongoize_time__; end

      # Try to form a setter from this object.
      # 
      # _@return_ — The object as a string plus =.
      # 
      # Try to form a setter.
      # ```ruby
      # object.__setter__
      # ```
      sig { returns(String) }
      def __setter__; end

      # Get the value of the object as a mongo friendy sort value.
      # 
      # _@return_ — self.
      # 
      # Get the object as sort criteria.
      # ```ruby
      # object.__sortable__
      # ```
      sig { returns(Object) }
      def __sortable__; end

      # Conversion of an object to an $inc-able value.
      # 
      # _@return_ — The object.
      # 
      # Convert the object.
      # ```ruby
      # 1.__to_inc__
      # ```
      sig { returns(Object) }
      def __to_inc__; end

      # Checks whether conditions given in this object are known to be
      # unsatisfiable, i.e., querying with this object will always return no
      # documents.
      # 
      # This method is deprecated. Mongoid now uses
      # +_mongoid_unsatisfiable_criteria?+ internally; this method is retained
      # for backwards compatibility only. It always returns false.
      # 
      # _@return_ — Always false.
      # 
      # _@deprecated_ — 
      sig { returns(T::Boolean) }
      def blank_criteria?; end

      # Do or do not, there is no try. -- Yoda.
      # 
      # _@param_ `name` — The method name.
      # 
      # _@param_ `args` — The arguments.
      # 
      # _@return_ — The result of the method call or nil if the
      # method does not exist.
      # 
      # Do or do not.
      # ```ruby
      # object.do_or_do_not(:use, "The Force")
      # ```
      sig { params(name: T.any(String, Symbol), args: T::Array[T.untyped]).returns(T.nilable(Object)) }
      def do_or_do_not(name, *args); end

      # Get the value for an instance variable or false if it doesn't exist.
      # 
      # _@param_ `name` — The name of the variable.
      # 
      # _@return_ — The value or false.
      # 
      # Get the value for an instance var.
      # ```ruby
      # document.ivar("person")
      # ```
      sig { params(name: String).returns(T.any(Object, T::Boolean)) }
      def ivar(name); end

      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      # 
      # _@return_ — The object.
      # 
      # Mongoize the object.
      # ```ruby
      # object.mongoize
      # ```
      sig { returns(Object) }
      def mongoize; end

      # Is the object multi args.
      # 
      # _@return_ — false.
      # 
      # Is the object multi args?
      # ```ruby
      # object.multi_arged?
      # ```
      sig { returns(T::Boolean) }
      def multi_arged?; end

      # Is the object a number?
      # 
      # _@return_ — Always false.
      # 
      # Is the object a number?.
      # ```ruby
      # object.numeric?
      # ```
      sig { returns(T::Boolean) }
      def numeric?; end

      # Remove the instance variable for the provided name.
      # 
      # _@param_ `name` — The name of the variable.
      # 
      # _@return_ — If the variable was defined.
      # 
      # Remove the instance variable
      # ```ruby
      # document.remove_ivar("person")
      # ```
      sig { params(name: String).returns(T::Boolean) }
      def remove_ivar(name); end

      # Is the object's size changable? Only returns true for arrays and hashes
      # currently.
      # 
      # _@return_ — false.
      # 
      # Is the object resizable?
      # ```ruby
      # object.resizable?
      # ```
      sig { returns(T::Boolean) }
      def resizable?; end

      # Get the substitutable version of an object.
      # 
      # _@return_ — self.
      # 
      # Get the substitutable.
      # ```ruby
      # object.substitutable
      # ```
      sig { returns(Object) }
      def substitutable; end

      # You must unlearn what you have learned. -- Yoda
      # 
      # _@param_ `name` — The method name.
      # 
      # _@param_ `args` — The arguments.
      # 
      # _@return_ — The result of the method call or nil if the
      # method does not exist. Nil if the object is frozen.
      # 
      # You must perform this execution.
      # ```ruby
      # object.you_must(:use, "The Force")
      # ```
      sig { params(name: T.any(String, Symbol), args: T::Array[T.untyped]).returns(T.nilable(Object)) }
      def you_must(name, *args); end

      module ClassMethods
        # Convert the provided object to a foreign key, given the metadata key
        # contstraint.
        # 
        # _@param_ `association` — The association metadata.
        # 
        # _@param_ `object` — The object to convert.
        # 
        # _@return_ — The converted object.
        # 
        # Convert the object to a fk.
        # ```ruby
        # Object.__mongoize_fk__(association, object)
        # ```
        sig { params(association: Association, object: Object).returns(Object) }
        def __mongoize_fk__(association, object); end

        # Convert the object from its mongo friendly ruby type to this type.
        # 
        # _@param_ `object` — The object to demongoize.
        # 
        # _@return_ — The object.
        # 
        # Demongoize the object.
        # ```ruby
        # Object.demongoize(object)
        # ```
        sig { params(object: Object).returns(Object) }
        def demongoize(object); end

        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        # 
        # _@param_ `object` — The object to mongoize.
        # 
        # _@return_ — The object mongoized.
        # 
        # Mongoize the object.
        # ```ruby
        # Object.mongoize("123.11")
        # ```
        sig { params(object: Object).returns(Object) }
        def mongoize(object); end
      end
    end

    module Regexp
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        # 
        # _@param_ `object` — The object to mongoize.
        # 
        # _@return_ — The object mongoized.
        # 
        # Mongoize the object.
        # ```ruby
        # Regexp.mongoize(/\A[abc]/)
        # ```
        sig { params(object: T.any(Regexp, String)).returns(Regexp) }
        def mongoize(object); end
      end
    end

    module String
      # Evolve the string into an object id if possible.
      # 
      # _@return_ — The evolved string.
      # 
      # Evolve the string.
      # ```ruby
      # "test".__evolve_object_id__
      # ```
      sig { returns(T.any(String, BSON::ObjectId)) }
      def __evolve_object_id__; end

      # Mongoize the string into an object id if possible.
      # 
      # _@return_ — The mongoized string.
      # 
      # Evolve the string.
      # ```ruby
      # "test".__mongoize_object_id__
      # ```
      sig { returns(T.nilable(T.any(String, BSON::ObjectId))) }
      def __mongoize_object_id__; end

      # sord warn - ActiveSupport::TimeWithZone wasn't able to be resolved to a constant in this project
      # Mongoize the string for storage.
      # 
      # _@return_ — Local time in the
      # configured default time zone corresponding to this string.
      # 
      # Mongoize the string.
      # ```ruby
      # "2012-01-01".__mongoize_time__
      # # => 2012-01-01 00:00:00 -0500
      # ```
      # 
      # _@note_ — Returns a local time in the default time zone.
      sig { returns(T.any(Time, ActiveSupport::TimeWithZone)) }
      def __mongoize_time__; end

      # Convert the string to a collection friendly name.
      # 
      # _@return_ — The string in collection friendly form.
      # 
      # Collectionize the string.
      # ```ruby
      # "namespace/model".collectionize
      # ```
      sig { returns(String) }
      def collectionize; end

      # Is the string a valid value for a Mongoid id?
      # 
      # _@return_ — If the string is id or _id.
      # 
      # Is the string an id value?
      # ```ruby
      # "_id".mongoid_id?
      # ```
      sig { returns(T::Boolean) }
      def mongoid_id?; end

      # Is the string a number? The literals "NaN", "Infinity", and "-Infinity"
      # are counted as numbers.
      # 
      # _@return_ — If the string is a number.
      # 
      # Is the string a number.
      # ```ruby
      # "1234.23".numeric?
      # ```
      sig { returns(T::Boolean) }
      def numeric?; end

      # Get the string as a getter string.
      # 
      # _@return_ — The string stripped of "=".
      # 
      # Get the reader/getter
      # ```ruby
      # "model=".reader
      # ```
      sig { returns(String) }
      def reader; end

      # Is this string a writer?
      # 
      # _@return_ — If the string contains "=".
      # 
      # Is the string a setter method?
      # ```ruby
      # "model=".writer?
      # ```
      sig { returns(T::Boolean) }
      def writer?; end

      # Is this string a valid_method_name?
      # 
      # _@return_ — If the string contains a valid Ruby identifier.
      # 
      # Is the string a valid Ruby idenfier for use as a method name
      # ```ruby
      # "model=".valid_method_name?
      # ```
      sig { returns(T::Boolean) }
      def valid_method_name?; end

      # Does the string end with _before_type_cast?
      # 
      # _@return_ — If the string ends with "_before_type_cast"
      # 
      # Is the string a setter method?
      # ```ruby
      # "price_before_type_cast".before_type_cast?
      # ```
      sig { returns(T::Boolean) }
      def before_type_cast?; end

      # Is the object not to be converted to bson on criteria creation?
      # 
      # _@return_ — If the object is unconvertable.
      # 
      # Is the object unconvertable?
      # ```ruby
      # object.unconvertable_to_bson?
      # ```
      sig { returns(T::Boolean) }
      def unconvertable_to_bson?; end

      # If the string is a legal object id, convert it.
      # 
      # _@return_ — The string or the id.
      # 
      # Convert to the object id.
      # ```ruby
      # string.convert_to_object_id
      # ```
      sig { returns(T.any(String, BSON::ObjectId)) }
      def convert_to_object_id; end

      # Returns the value of attribute unconvertable_to_bson.
      sig { returns(T.untyped) }
      attr_accessor :unconvertable_to_bson

            sig { returns(T.untyped) }
      attr_accessor :unconvertable_to_bson

      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        # 
        # _@param_ `object` — The object to demongoize.
        # 
        # _@return_ — The object.
        # 
        # Demongoize the object.
        # ```ruby
        # String.demongoize(object)
        # ```
        sig { params(object: Object).returns(String) }
        def demongoize(object); end

        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        # 
        # _@param_ `object` — The object to mongoize.
        # 
        # _@return_ — The object mongoized.
        # 
        # Mongoize the object.
        # ```ruby
        # String.mongoize("123.11")
        # ```
        sig { params(object: Object).returns(String) }
        def mongoize(object); end
      end
    end

    module Symbol
      # Is the symbol a valid value for a Mongoid id?
      # 
      # _@return_ — If the symbol is :id or :_id.
      # 
      # Is the string an id value?
      # ```ruby
      # :_id.mongoid_id?
      # ```
      sig { returns(T::Boolean) }
      def mongoid_id?; end

      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        # 
        # _@param_ `object` — The object to demongoize.
        # 
        # _@return_ — The object.
        # 
        # Demongoize the object.
        # ```ruby
        # Symbol.demongoize(object)
        # ```
        sig { params(object: Object).returns(Symbol) }
        def demongoize(object); end

        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        # 
        # _@param_ `object` — The object to mongoize.
        # 
        # _@return_ — The object mongoized.
        # 
        # Mongoize the object.
        # ```ruby
        # Symbol.mongoize("123.11")
        # ```
        sig { params(object: Object).returns(Symbol) }
        def mongoize(object); end
      end
    end

    module Integer
      # sord warn - ActiveSupport::TimeWithZone wasn't able to be resolved to a constant in this project
      # Converts the integer into a time as the number of seconds since the epoch.
      # 
      # _@return_ — The time.
      # 
      # Convert the integer to a time.
      # ```ruby
      # 1335532685.__mongoize_time__
      # ```
      sig { returns(T.any(Time, ActiveSupport::TimeWithZone)) }
      def __mongoize_time__; end

      # Is the integer a number?
      # 
      # _@return_ — Always true.
      # 
      # Is the object a number?.
      # ```ruby
      # object.numeric?
      # ```
      sig { returns(T::Boolean) }
      def numeric?; end

      # Is the object not to be converted to bson on criteria creation?
      # 
      # _@return_ — If the object is unconvertable.
      # 
      # Is the object unconvertable?
      # ```ruby
      # object.unconvertable_to_bson?
      # ```
      sig { returns(T::Boolean) }
      def unconvertable_to_bson?; end

      module ClassMethods
                # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        # 
        # _@return_ — The object mongoized.
        # 
        # Mongoize the object.
        # ```ruby
        # BigDecimal.mongoize("123.11")
        # ```
        sig { params(object: T.untyped).returns(String) }
        def mongoize(object); end
      end
    end

    module DateTime
      # sord warn - ActiveSupport::TimeWithZone wasn't able to be resolved to a constant in this project
      # Mongoize the date time into a time.
      # 
      # _@return_ — The mongoized time.
      # 
      # Mongoize the date time.
      # ```ruby
      # date_time.__mongoize_time__
      # ```
      sig { returns(T.any(Time, ActiveSupport::TimeWithZone)) }
      def __mongoize_time__; end

      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      # 
      # _@return_ — The object mongoized.
      # 
      # Mongoize the object.
      # ```ruby
      # date_time.mongoize
      # ```
      sig { returns(Time) }
      def mongoize; end

      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        # 
        # _@param_ `object` — The time from Mongo.
        # 
        # _@return_ — The object as a date.
        # 
        # Demongoize the object.
        # ```ruby
        # DateTime.demongoize(object)
        # ```
        sig { params(object: Time).returns(DateTime) }
        def demongoize(object); end

        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        # 
        # _@param_ `object` — The object to convert.
        # 
        # _@return_ — The object mongoized.
        # 
        # Mongoize the object.
        # ```ruby
        # DateTime.mongoize("2012-1-1")
        # ```
        sig { params(object: Object).returns(Time) }
        def mongoize(object); end
      end
    end

    module NilClass
      # Try to form a setter from this object.
      # 
      # _@return_ — Always nil.
      # 
      # Try to form a setter.
      # ```ruby
      # object.__setter__
      # ```
      sig { returns(T.nilable(T.any())) }
      def __setter__; end

      # Get the name of a nil collection.
      # 
      # _@return_ — A blank string.
      # 
      # Get the nil name.
      # ```ruby
      # nil.collectionize
      # ```
      sig { returns(String) }
      def collectionize; end
    end

    module ObjectId
      # Evolve the object id.
      # 
      # _@return_ — self.
      # 
      # Evolve the object id.
      # ```ruby
      # object_id.__evolve_object_id__
      # ```
      sig { returns(BSON::ObjectId) }
      def __evolve_object_id__; end

      module ClassMethods
        # Evolve the object into a mongo-friendly value to query with.
        # 
        # _@param_ `object` — The object to evolve.
        # 
        # _@return_ — The object id.
        # 
        # Evolve the object.
        # ```ruby
        # ObjectId.evolve(id)
        # ```
        sig { params(object: Object).returns(BSON::ObjectId) }
        def evolve(object); end

        # Convert the object into a mongo-friendly value to store.
        # 
        # _@param_ `object` — The object to convert.
        # 
        # _@return_ — The object id.
        # 
        # Convert the object.
        # ```ruby
        # ObjectId.mongoize(id)
        # ```
        sig { params(object: Object).returns(BSON::ObjectId) }
        def mongoize(object); end
      end
    end

    module Decimal128
      # sord warn - BSON::Decimal128 wasn't able to be resolved to a constant in this project
      # Evolve the decimal128.
      # 
      # _@return_ — self.
      # 
      # Evolve the decimal128.
      # ```ruby
      # decimal128.__evolve_decimal128__
      # ```
      sig { returns(BSON::Decimal128) }
      def __evolve_decimal128__; end

      module ClassMethods
        # sord warn - BSON::Decimal128 wasn't able to be resolved to a constant in this project
        # Evolve the object into a mongo-friendly value to query with.
        # 
        # _@param_ `object` — The object to evolve.
        # 
        # _@return_ — The decimal128.
        # 
        # Evolve the object.
        # ```ruby
        # Decimal128.evolve(dec)
        # ```
        sig { params(object: Object).returns(BSON::Decimal128) }
        def evolve(object); end
      end
    end

    module TrueClass
      # Get the value of the object as a mongo friendy sort value.
      # 
      # _@return_ — 1.
      # 
      # Get the object as sort criteria.
      # ```ruby
      # object.__sortable__
      # ```
      sig { returns(Integer) }
      def __sortable__; end

      # Is the passed value a boolean?
      # 
      # _@param_ `other` — The class to check.
      # 
      # _@return_ — If the other is a boolean.
      # 
      # Is the value a boolean type?
      # ```ruby
      # true.is_a?(Boolean)
      # ```
      sig { params(other: Class).returns(T::Boolean) }
      def is_a?(other); end
    end

    module BigDecimal
      # Convert the big decimal to an $inc-able value.
      # 
      # _@return_ — The big decimal as a float.
      # 
      # Convert the big decimal.
      # ```ruby
      # bd.__to_inc__
      # ```
      sig { returns(Float) }
      def __to_inc__; end

      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      # 
      # _@return_ — The object.
      # 
      # Mongoize the object.
      # ```ruby
      # object.mongoize
      # ```
      sig { returns(Object) }
      def mongoize; end

      # Is the BigDecimal a number?
      # 
      # _@return_ — Always true.
      # 
      # Is the object a number?.
      # ```ruby
      # object.numeric?
      # ```
      sig { returns(T::Boolean) }
      def numeric?; end

      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        # 
        # _@param_ `object` — The object to demongoize.
        # 
        # _@return_ — A BigDecimal derived from the object or nil.
        # 
        # Demongoize the object.
        # ```ruby
        # Object.demongoize(object)
        # ```
        sig { params(object: Object).returns(T.nilable(BigDecimal)) }
        def demongoize(object); end

        # Mongoize an object of any type to how it's stored in the db as a String.
        # 
        # _@param_ `object` — The object to Mongoize
        # 
        # _@return_ — A String representing the object or nil.
        # 
        # Mongoize the object.
        # ```ruby
        # BigDecimal.mongoize(123)
        # ```
        sig { params(object: Object).returns(T.nilable(String)) }
        def mongoize(object); end
      end
    end

    module FalseClass
      # Get the value of the object as a mongo friendy sort value.
      # 
      # _@return_ — 0.
      # 
      # Get the object as sort criteria.
      # ```ruby
      # object.__sortable__
      # ```
      sig { returns(Integer) }
      def __sortable__; end

      # Is the passed value a boolean?
      # 
      # _@param_ `other` — The class to check.
      # 
      # _@return_ — If the other is a boolean.
      # 
      # Is the value a boolean type?
      # ```ruby
      # false.is_a?(Boolean)
      # ```
      sig { params(other: Class).returns(T::Boolean) }
      def is_a?(other); end
    end

    module TimeWithZone
      # sord warn - ActiveSupport::TimeWithZone wasn't able to be resolved to a constant in this project
      # Mongoizes an ActiveSupport::TimeWithZone into a time.
      # 
      # TimeWithZone always mongoize into TimeWithZone instances
      # (which are themselves).
      # 
      # _@return_ — self.
      sig { returns(ActiveSupport::TimeWithZone) }
      def __mongoize_time__; end

      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      # 
      # _@return_ — The object mongoized.
      # 
      # Mongoize the object.
      # ```ruby
      # date_time.mongoize
      # ```
      sig { returns(Time) }
      def mongoize; end

      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        # 
        # _@param_ `object` — The time from Mongo.
        # 
        # _@return_ — The object as a date.
        # 
        # Demongoize the object.
        # ```ruby
        # TimeWithZone.demongoize(object)
        # ```
        sig { params(object: Time).returns(TimeWithZone) }
        def demongoize(object); end

        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        # 
        # _@param_ `object` — The object to convert.
        # 
        # _@return_ — The object mongoized.
        # 
        # Mongoize the object.
        # ```ruby
        # TimeWithZone.mongoize("2012-1-1")
        # ```
        sig { params(object: Object).returns(Time) }
        def mongoize(object); end
      end
    end
  end

  module Tasks
    module Database
      extend Mongoid::Tasks::Database

            # Create indexes for each model given the provided globs and the class is
      # not embedded.
      # 
      # _@return_ — The indexed models.
      # 
      # Create all the indexes.
      # ```ruby
      # Mongoid::Tasks::Database.create_indexes
      # ```
      sig { params(models: T.untyped).returns(T::Array[Class]) }
      def create_indexes(models = ::Mongoid.models); end

            # Return the list of indexes by model that exist in the database but aren't
      # specified on the models.
      # 
      # _@return_ — The list of undefined indexes by model.
      # 
      # Return the list of unused indexes.
      # ```ruby
      # Mongoid::Tasks::Database.undefined_indexes
      # ```
      sig { params(models: T.untyped).returns(T::Array[T::Hash[T.untyped, T.untyped]]) }
      def undefined_indexes(models = ::Mongoid.models); end

            # Remove indexes that exist in the database but aren't specified on the
      # models.
      # 
      # _@return_ — The list of indexes that were removed by model.
      # 
      # Remove undefined indexes.
      # ```ruby
      # Mongoid::Tasks::Database.remove_undefined_indexes
      # ```
      sig { params(models: T.untyped).returns(T::Hash[Class, [T::Hash[T.untyped, T.untyped]]]) }
      def remove_undefined_indexes(models = ::Mongoid.models); end

            # Remove indexes for each model given the provided globs and the class is
      # not embedded.
      # 
      # _@return_ — The un-indexed models.
      # 
      # Remove all the indexes.
      # ```ruby
      # Mongoid::Tasks::Database.remove_indexes
      # ```
      sig { params(models: T.untyped).returns(T::Array[Class]) }
      def remove_indexes(models = ::Mongoid.models); end

            # Shard collections for models that declare shard keys.
      # 
      # Returns the model classes that have had their collections sharded,
      # including model classes whose collections had already been sharded
      # prior to the invocation of this method.
      # 
      # _@return_ — The sharded models
      # 
      # Shard all collections
      # ```ruby
      # Mongoid::Tasks::Database.shard_collections
      # ```
      sig { params(models: T.untyped).returns(T::Array[Class]) }
      def shard_collections(models = ::Mongoid.models); end

            sig { returns(T.untyped) }
      def logger; end

            # Create indexes for each model given the provided globs and the class is
      # not embedded.
      # 
      # _@return_ — The indexed models.
      # 
      # Create all the indexes.
      # ```ruby
      # Mongoid::Tasks::Database.create_indexes
      # ```
      sig { params(models: T.untyped).returns(T::Array[Class]) }
      def self.create_indexes(models = ::Mongoid.models); end

            # Return the list of indexes by model that exist in the database but aren't
      # specified on the models.
      # 
      # _@return_ — The list of undefined indexes by model.
      # 
      # Return the list of unused indexes.
      # ```ruby
      # Mongoid::Tasks::Database.undefined_indexes
      # ```
      sig { params(models: T.untyped).returns(T::Array[T::Hash[T.untyped, T.untyped]]) }
      def self.undefined_indexes(models = ::Mongoid.models); end

            # Remove indexes that exist in the database but aren't specified on the
      # models.
      # 
      # _@return_ — The list of indexes that were removed by model.
      # 
      # Remove undefined indexes.
      # ```ruby
      # Mongoid::Tasks::Database.remove_undefined_indexes
      # ```
      sig { params(models: T.untyped).returns(T::Hash[Class, [T::Hash[T.untyped, T.untyped]]]) }
      def self.remove_undefined_indexes(models = ::Mongoid.models); end

            # Remove indexes for each model given the provided globs and the class is
      # not embedded.
      # 
      # _@return_ — The un-indexed models.
      # 
      # Remove all the indexes.
      # ```ruby
      # Mongoid::Tasks::Database.remove_indexes
      # ```
      sig { params(models: T.untyped).returns(T::Array[Class]) }
      def self.remove_indexes(models = ::Mongoid.models); end

            # Shard collections for models that declare shard keys.
      # 
      # Returns the model classes that have had their collections sharded,
      # including model classes whose collections had already been sharded
      # prior to the invocation of this method.
      # 
      # _@return_ — The sharded models
      # 
      # Shard all collections
      # ```ruby
      # Mongoid::Tasks::Database.shard_collections
      # ```
      sig { params(models: T.untyped).returns(T::Array[Class]) }
      def self.shard_collections(models = ::Mongoid.models); end

            sig { returns(T.untyped) }
      def self.logger; end
    end
  end

  module Errors
    # This error is raised when calling #save! or .create! on a model when one
    # of the callbacks returns false.
    class Callback < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Create the new callbacks error.
      # 
      # _@param_ `klass` — The class of the document.
      # 
      # _@param_ `method` — The name of the method.
      # 
      # Create the new callbacks error.
      # ```ruby
      # Callbacks.new(Post, :create!)
      # ```
      sig { params(klass: Class, method: Symbol).void }
      def initialize(klass, method); end
    end

    # This error is raised when trying to persist an embedded document
    # when there is no parent set.
    class NoParent < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Create the new error.
      # 
      # _@param_ `klass` — The class of the embedded document.
      # 
      # Create the new error.
      # ```ruby
      # NoParent.new(klass)
      # ```
      sig { params(klass: Class).void }
      def initialize(klass); end
    end

    # This error is raised when attempting to eager load a many to many
    # association.
    # 
    # @deprecated No longer used by Mongoid per MONGOID-4841.
    class EagerLoad < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Create the new eager load error.
      # 
      # _@param_ `name` — The name of the association.
      # 
      # Create the new eager load error.
      # ```ruby
      # EagerLoad.new(:preferences)
      # ```
      sig { params(name: Symbol).void }
      def initialize(name); end
    end

    # Used when trying to persist data when metadata has not been set.
    class NoMetadata < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Create the new error.
      # 
      # _@param_ `klass` — The document class.
      # 
      # Create the error.
      # ```ruby
      # NoMetadata.new(Address)
      # ```
      sig { params(klass: Class).void }
      def initialize(klass); end
    end

    # Raised when a persistence method ending in ! fails validation. The message
    # will contain the full error messages from the +Document+ in question.
    # 
    # @example Create the error.
    #   Validations.new(person.errors)
    class Validations < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

            sig { params(document: T.untyped).void }
      def initialize(document); end

            # Returns the value of attribute document.
      sig { returns(T.untyped) }
      attr_reader :document
    end

    # Raised when invalid arguments are passed to #find.
    class InvalidFind < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Create the new invalid find error.
      # 
      # Create the error.
      # ```ruby
      # InvalidFind.new
      # ```
      sig { void }
      def initialize; end
    end

    # Used when attempting to get embedded paths with incorrect root path set.
    class InvalidPath < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Create the new error.
      # 
      # _@param_ `klass` — The document class.
      # 
      # Create the error.
      # ```ruby
      # InvalidPath.new(Address)
      # ```
      sig { params(klass: Class).void }
      def initialize(klass); end
    end

    # This exception is raised when a bad value is attempted to be converted to
    # a date or time.
    class InvalidTime < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Create the new invalid date error.
      # 
      # _@param_ `value` — The value that was attempted.
      # 
      # Create the new invalid date error.
      # ```ruby
      # InvalidTime.new("this is not a time")
      # ```
      sig { params(value: Object).void }
      def initialize(value); end
    end

    # This error is raised when trying to create a field that conflicts with
    # an already defined method.
    class InvalidField < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Create the new error.
      # 
      # _@param_ `klass` — The document class.
      # 
      # _@param_ `name` — The method name.
      # 
      # Create the error.
      # ```ruby
      # InvalidField.new(person, :crazy_method_name)
      # ```
      sig { params(klass: Class, name: Symbol).void }
      def initialize(klass, name); end

      # Get the queryable of the method.
      # 
      # _@param_ `klass` — The document class.
      # 
      # _@param_ `name` — The method name.
      # 
      # _@return_ — The originating class or module.
      # 
      # Get the originating class or module.
      # ```ruby
      # error.queryable(Person, :crazy_method_name)
      # ```
      sig { params(klass: Class, name: Symbol).returns(T.any(Class, Module)) }
      def origin(klass, name); end

      # Get the location of the method.
      # 
      # _@param_ `klass` — The document class.
      # 
      # _@param_ `name` — The method name.
      # 
      # _@return_ — The location of the method.
      # 
      # Get the location of the method on the filesystem.
      # ```ruby
      # error.location(Person, :crazy_method_name)
      # ```
      sig { params(klass: Class, name: Symbol).returns(T::Array[T.any(String, Integer)]) }
      def location(klass, name); end
    end

    # Raised when an invalid index is defined.
    class InvalidIndex < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Create the new error.
      # 
      # _@param_ `klass` — The model class.
      # 
      # _@param_ `spec` — The invalid specification.
      # 
      # _@param_ `options` — The invalid options.
      # 
      # Create the error.
      # ```ruby
      # InvalidIndex.new(Band, name: 1)
      # ```
      sig { params(klass: Class, spec: T::Hash[T.untyped, T.untyped], options: T::Hash[T.untyped, T.untyped]).void }
      def initialize(klass, spec, options); end
    end

    # Raised when invalid query is passed to an embedded matcher, or an
    # invalid query fragment is passed to the query builder (Criteria object).
    class InvalidQuery < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

            # Create the new invalid query error.
      sig { params(msg: T.untyped).void }
      def initialize(msg); end

            # Stringifies the argument using #inspect and truncates the result to
      # about 100 characters.
      # 
      # _@param_ `expr` — An expression to stringify and truncate.
      sig { params(expr: Object).returns(T.untyped) }
      def self.truncate_expr(expr); end
    end

    # This error is raised when defining a scope of an invalid type.
    class InvalidScope < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Create the error.
      # 
      # _@param_ `klass` — The model class.
      # 
      # _@param_ `value` — The attempted scope value.
      # 
      # Create the error.
      # ```ruby
      # InvalidScope.new(Band, {})
      # ```
      sig { params(klass: Class, value: Object).void }
      def initialize(klass, value); end
    end

    # This error is raised when trying to set an attribute with an invalid value.
    # For example when try to set an Array value to a Hash attribute.
    class InvalidValue < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

                  sig { params(field_class: T.untyped, value_class: T.untyped).void }
      def initialize(field_class, value_class); end
    end

    # Default parent Mongoid error for all custom errors. This handles the base
    # key for the translations and provides the convenience method for
    # translating the messages.
    class MongoidError < StandardError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

                  # Compose the message.
      # 
      # _@return_ — The composed message.
      # 
      # Create the message
      # ```ruby
      # error.compose_message
      # ```
      sig { params(key: T.untyped, attributes: T.untyped).returns(String) }
      def compose_message(key, attributes = {}); end

      # Given the key of the specific error and the options hash, translate the
      # message.
      # 
      # _@param_ `key` — The key of the error in the locales.
      # 
      # _@param_ `options` — The objects to pass to create the message.
      # 
      # _@return_ — A localized error message string.
      # 
      # Translate the message.
      # ```ruby
      # error.translate("errors", :key => value)
      # ```
      sig { params(key: String, options: T::Hash[T.untyped, T.untyped]).returns(String) }
      def translate(key, options); end

      # Create the problem.
      # 
      # _@param_ `key` — The error key.
      # 
      # _@param_ `attributes` — The attributes to interpolate.
      # 
      # _@return_ — The problem.
      # 
      # Create the problem.
      # ```ruby
      # error.problem("error", {})
      # ```
      sig { params(key: T.any(String, Symbol), attributes: T::Hash[T.untyped, T.untyped]).returns(String) }
      def translate_problem(key, attributes); end

      # Create the summary.
      # 
      # _@param_ `key` — The error key.
      # 
      # _@param_ `attributes` — The attributes to interpolate.
      # 
      # _@return_ — The summary.
      # 
      # Create the summary.
      # ```ruby
      # error.summary("error", {})
      # ```
      sig { params(key: T.any(String, Symbol), attributes: T::Hash[T.untyped, T.untyped]).returns(String) }
      def translate_summary(key, attributes); end

      # Create the resolution.
      # 
      # _@param_ `key` — The error key.
      # 
      # _@param_ `attributes` — The attributes to interpolate.
      # 
      # _@return_ — The resolution.
      # 
      # Create the resolution.
      # ```ruby
      # error.resolution("error", {})
      # ```
      sig { params(key: T.any(String, Symbol), attributes: T::Hash[T.untyped, T.untyped]).returns(String) }
      def translate_resolution(key, attributes); end

            # Returns the value of attribute problem.
      sig { returns(T.untyped) }
      attr_reader :problem

            # Returns the value of attribute summary.
      sig { returns(T.untyped) }
      attr_reader :summary

            # Returns the value of attribute resolution.
      sig { returns(T.untyped) }
      attr_reader :resolution
    end

    # This error is raised when trying to instantiate a model object from the value in
    # the '_type' field of a document and the class doesn't exist.
    class UnknownModel < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Create the new error.
      # 
      # _@param_ `klass` — The model class.
      # 
      # _@param_ `value` — The value used to determine the (invalid) class.
      # 
      # Instantiate the error.
      # ```ruby
      # UnknownModel.new('InvalidClass', "invalid_class")
      # ```
      sig { params(klass: String, value: String).void }
      def initialize(klass, value); end
    end

    # Raised when trying to load configuration with no RACK_ENV set
    class NoEnvironment < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Create the new no environment error.
      # 
      # Create the new no environment error.
      # ```ruby
      # NoEnvironment.new
      # ```
      sig { void }
      def initialize; end
    end

    # Raised when invalid options are passed to an association macro.
    class InvalidOptions < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Instantiate the options error.
      # 
      # _@param_ `name` — The name of the association.
      # 
      # _@param_ `invalid` — The invalid option.
      # 
      # _@param_ `valid` — The allowed options.
      # 
      # Create the error.
      # ```ruby
      # InvalidOptions.new(:name, :polymorphic, [ :as ])
      # ```
      sig { params(name: Symbol, invalid: Symbol, valid: T::Array[Symbol]).void }
      def initialize(name, invalid, valid); end
    end

    # This error is raised when trying to reference an embedded document from
    # a document in another collection that is not its parent.
    # 
    # @example An illegal reference to an embedded document.
    #   class Post
    #     include Mongoid::Document
    #     references_many :addresses
    #   end
    # 
    #   class Address
    #     include Mongoid::Document
    #     embedded_in :person
    #     referenced_in :post
    #   end
    # 
    # @since 2.0.0
    class MixedRelations < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

                  sig { params(root_klass: T.untyped, embedded_klass: T.untyped).void }
      def initialize(root_klass, embedded_klass); end
    end

    # This error is raised when a client is configured without hosts.
    class NoClientHosts < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Create the new error.
      # 
      # _@param_ `name` — The db config key.
      # 
      # _@param_ `config` — The hash configuration options.
      # 
      # Create the new error.
      # ```ruby
      # NoClientHosts.new(:default, {}})
      # ```
      sig { params(name: T.any(Symbol, String), config: T::Hash[T.untyped, T.untyped]).void }
      def initialize(name, config); end
    end

    # This error is raised when trying to create a scope with an name already
    # taken by another scope or method
    # 
    # @example Create the error.
    #   ScopeOverwrite.new(Person,'teenies')
    class ScopeOverwrite < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

                  sig { params(model_name: T.untyped, scope_name: T.untyped).void }
      def initialize(model_name, scope_name); end
    end

    # This error is raised when an invalid value is passed to an eager
    # loading query.
    class InvalidIncludes < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Initialize the error.
      # 
      # _@param_ `klass` — The model class.
      # 
      # _@param_ `args` — The arguments passed to the includes.
      # 
      # Initialize the error.
      # ```ruby
      # InvalidIncludes.new(Band, [ :members ])
      # ```
      sig { params(klass: Class, args: T::Array[Object]).void }
      def initialize(klass, args); end
    end

    # This error is raised when trying to create an association that conflicts with
    # an already defined method.
    # 
    # @since 6.0.0
    class InvalidRelation < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Create the new error.
      # 
      # _@param_ `klass` — The document class.
      # 
      # _@param_ `name` — The method name.
      # 
      # Create the error.
      # ```ruby
      # InvalidRelation.new(person, :crazy_relation_name)
      # ```
      sig { params(klass: Class, name: Symbol).void }
      def initialize(klass, name); end

      # Get the queryable of the method.
      # 
      # _@param_ `klass` — The document class.
      # 
      # _@param_ `name` — The method name.
      # 
      # _@return_ — The originating class or module.
      # 
      # Get the originating class or module.
      # ```ruby
      # error.queryable(Person, :crazy_method_name)
      # ```
      sig { params(klass: Class, name: Symbol).returns(T.any(Class, Module)) }
      def origin(klass, name); end

      # Get the location of the association definition.
      # 
      # _@param_ `klass` — The document class.
      # 
      # _@param_ `name` — The method name.
      # 
      # _@return_ — The location of the method.
      # 
      # Get the location of the method on the filesystem.
      # ```ruby
      # error.location(Person, :crazy_method_name)
      # ```
      sig { params(klass: Class, name: Symbol).returns(T::Array[T.any(String, Integer)]) }
      def location(klass, name); end
    end

    # This error is raised when attempting to create a new client that does
    # not have a named configuration.
    class NoClientConfig < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Create the new error.
      # 
      # _@param_ `name` — The name of the client.
      # 
      # Create the error.
      # ```ruby
      # NoClientConfig.new(:analytics)
      # ```
      sig { params(name: T.any(String, Symbol)).void }
      def initialize(name); end
    end

    # Raised when attempting to call create or create! through a
    # references_many when the parent document has not been saved. This
    # prevents the child from getting presisted and immediately being orphaned.
    class UnsavedDocument < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

                  sig { params(base: T.untyped, document: T.untyped).void }
      def initialize(base, document); end
    end

    # Raised when no inverse_of definition can be found when needed.
    class InverseNotFound < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Create then new error.
      # 
      # _@param_ `base` — The base class.
      # 
      # _@param_ `name` — The name of the association.
      # 
      # _@param_ `klass` — The child class.
      # 
      # _@param_ `inverse` — The attempted inverse key.
      # 
      # Create the new error.
      # ```ruby
      # InverseNotFound.new(Town, :citizens, Person, :town_id)
      # ```
      sig do
        params(
          base: Class,
          name: Symbol,
          klass: Class,
          inverse: Symbol
        ).void
      end
      def initialize(base, name, klass, inverse); end
    end

    # This error is raised when no clients exists in the database
    # configuration.
    class NoClientsConfig < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Create the new error.
      # 
      # Create the error.
      # ```ruby
      # NoClientsConfig.new
      # ```
      sig { void }
      def initialize; end
    end

    # This error is raised when a default client is not defined.
    class NoDefaultClient < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Create the new error with the defined client names.
      # 
      # _@param_ `keys` — The defined clients.
      # 
      # Create the new error.
      # ```ruby
      # NoDefaultClient.new([ :analytics ])
      # ```
      sig { params(keys: T::Array[Symbol]).void }
      def initialize(keys); end
    end

    # Raised when attempting to persist a document that was loaded from the
    # database with partial fields.
    # 
    # @since 4.0.0
    class ReadonlyDocument < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Instnatiate the exception.
      # 
      # _@param_ `klass` — The document class.
      # 
      # Create the error.
      # ```ruby
      # ReadonlyDocument.new(Band)
      # ```
      sig { params(klass: Class).void }
      def initialize(klass); end
    end

    # This error is raised when trying to set a value in Mongoid that is not
    # already set with dynamic attributes or the field is not defined.
    class UnknownAttribute < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Create the new error.
      # 
      # _@param_ `klass` — The model class.
      # 
      # _@param_ `name` — The name of the attribute.
      # 
      # Instantiate the error.
      # ```ruby
      # UnknownAttribute.new(Person, "gender")
      # ```
      sig { params(klass: Class, name: T.any(String, Symbol)).void }
      def initialize(klass, name); end
    end

    # This error is raised when calling #save! or .create! on a model when one
    # of the callbacks returns false.
    class DeleteRestriction < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

            # Create the new callbacks error.
      # 
      # _@param_ `document`
      # 
      # _@param_ `association`
      # 
      # Create the new callbacks error.
      # ```ruby
      # Callbacks.new(Post, :create!)
      # ```
      sig { params(document: Class, relation: T.untyped).void }
      def initialize(document, relation); end
    end

    # Raised when querying the database for a document by a specific id or by
    # set of attributes which does not exist. If multiple ids were passed then
    # it will display all of those.
    class DocumentNotFound < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Create the new error.
      # 
      # _@param_ `klass` — The model class.
      # 
      # _@param_ `params` — The attributes or ids.
      # 
      # _@param_ `unmatched` — The unmatched ids, if appropriate
      # 
      # Create the error.
      # ```ruby
      # DocumentNotFound.new(Person, ["1", "2"])
      # ```
      # 
      # Create the error with attributes instead of ids
      # ```ruby
      # DocumentNotFound.new(Person, :ssn => "1234", :name => "Helen")
      # ```
      sig { params(klass: Class, params: T.any(T::Hash[T.untyped, T.untyped], T::Array[T.untyped], Object), unmatched: T.nilable(T::Array[T.untyped])).void }
      def initialize(klass, params, unmatched = nil); end

      # Get the string to display the document params that were unmatched.
      # 
      # _@param_ `unmatched` — The ids that did not match.
      # 
      # _@return_ — The missing string.
      # 
      # Get the missing string.
      # ```ruby
      # error.missing(1)
      # ```
      sig { params(unmatched: T.any(Object, T::Array[T.untyped])).returns(String) }
      def missing(unmatched); end

      # Get the string to display the document params that were searched for.
      # 
      # _@param_ `params` — The ids that were searched for.
      # 
      # _@return_ — The searched string.
      # 
      # Get the searched string.
      # ```ruby
      # error.searched(1)
      # ```
      sig { params(params: T.any(Object, T::Array[T.untyped])).returns(String) }
      def searched(params); end

      # Get the total number of expected documents.
      # 
      # _@param_ `params` — What was searched for.
      # 
      # _@return_ — The total number.
      # 
      # Get the total.
      # ```ruby
      # error.total([ 1, 2, 3 ])
      # ```
      sig { params(params: T.any(Object, T::Array[T.untyped])).returns(Integer) }
      def total(params); end

            # Create the problem.
      # 
      # _@return_ — The problem.
      # 
      # Create the problem.
      # ```ruby
      # error.problem
      # ```
      sig { params(params: T.untyped).returns(String) }
      def message_key(params); end

            # Returns the value of attribute klass.
      sig { returns(T.untyped) }
      attr_reader :klass

            # Returns the value of attribute params.
      sig { returns(T.untyped) }
      attr_reader :params
    end

    # This error is raised when trying to access a Mongo::Collection from an
    # embedded document.
    # 
    # @example Create the error.
    #   InvalidCollection.new(Address)
    class InvalidCollection < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

            sig { params(klass: T.untyped).void }
      def initialize(klass); end
    end

    # This error is raised when a client is configured without a database.
    class NoClientDatabase < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Create the new error.
      # 
      # _@param_ `name` — The db config key.
      # 
      # _@param_ `config` — The hash configuration options.
      # 
      # Create the new error.
      # ```ruby
      # NoClientDatabase.new(:default, {}})
      # ```
      sig { params(name: T.any(Symbol, String), config: T::Hash[T.untyped, T.untyped]).void }
      def initialize(name, config); end
    end

    # This error is raised when attempting the change the value of a readonly
    # attribute after the document has been persisted.
    class ReadonlyAttribute < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Create the new error.
      # 
      # _@param_ `name` — The name of the attribute.
      # 
      # _@param_ `value` — The attempted set value.
      # 
      # Create the new error.
      # ```ruby
      # ReadonlyAttribute.new(:title, "mr")
      # ```
      sig { params(name: T.any(Symbol, String), value: Object).void }
      def initialize(name, value); end
    end

    # This error is raised when a session is attempted to be used with a model whose client cannot use it, if
    #   sessions are nested, or if the mongodb deployment doesn't support sessions.
    # 
    # @since 6.4.0
    class InvalidSessionUse < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Create the error.
      # 
      # _@param_ `error_type` — The type of session misuse.
      # 
      # Create the error.
      # ```ruby
      # InvalidSessionUse.new(:invalid_session_use)
      # ```
      sig { params(error_type: Symbol).void }
      def initialize(error_type); end
    end

    # This error is raised when trying to create a field that has an invalid
    # option.
    class InvalidFieldOption < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Create the new error.
      # 
      # _@param_ `klass` — The document class.
      # 
      # _@param_ `name` — The method name.
      # 
      # _@param_ `option` — The option name.
      # 
      # _@param_ `valid` — All the valid options.
      # 
      # Create the error.
      # ```ruby
      # InvalidFieldOption.new(Model, :name, :localized, [ :localize ])
      # ```
      sig do
        params(
          klass: Class,
          name: Symbol,
          option: Symbol,
          valid: T::Array[Symbol]
        ).void
      end
      def initialize(klass, name, option, valid); end
    end

    # Raised when executing a map/reduce without specifying the output
    # location.
    class NoMapReduceOutput < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Create the new error.
      # 
      # _@param_ `command` — The map/reduce command.
      # 
      # Create the new error.
      # ```ruby
      # NoMapReduceOutput.new({ map: "" })
      # ```
      sig { params(command: T::Hash[T.untyped, T.untyped]).void }
      def initialize(command); end
    end

    # This error is raised when a bad configuration option is attempted to be
    # set.
    class InvalidConfigOption < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Create the new error.
      # 
      # _@param_ `name` — The attempted config option name.
      # 
      # Create the new error.
      # ```ruby
      # InvalidConfigOption.new(:name, [ :option ])
      # ```
      sig { params(name: T.any(Symbol, String)).void }
      def initialize(name); end
    end

    # This error is raised in case of an ambigous association.
    # 
    # @example An ambigous association.
    #   class Person
    #     include Mongoid::Document
    # 
    #     has_many :invitations, inverse_of: :person
    #     has_many :referred_invitations, class_name: "Invitation", inverse_of: :referred_by
    #   end
    # 
    #   class Invitation
    #     include Mongoid::Document
    # 
    #     belongs_to :person
    #     belongs_to :referred_by, class_name: "Person"
    #   end
    class AmbiguousRelationship < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Create the new error.
      # 
      # _@param_ `klass` — The base class.
      # 
      # _@param_ `inverse` — The inverse class.
      # 
      # _@param_ `name` — The relation name.
      # 
      # _@param_ `candidates` — The potential inverses.
      # 
      # Create the error.
      # ```ruby
      # AmbiguousRelationship.new(
      #   Person, Drug, :person, [ :drugs, :evil_drugs ]
      # )
      # ```
      sig do
        params(
          klass: Class,
          inverse: Class,
          name: Symbol,
          candidates: T::Array[Symbol]
        ).void
      end
      def initialize(klass, inverse, name, candidates); end
    end

    # Raised when attempting to destroy a document that had destory callbacks
    # return false.
    # 
    # @since 4.0.0
    class DocumentNotDestroyed < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Instnatiate the exception.
      # 
      # _@param_ `id` — The document id.
      # 
      # _@param_ `klass` — The document class.
      # 
      # Create the error.
      # ```ruby
      # DocumentNotDestroyed.new(Band)
      # ```
      sig { params(id: Object, klass: Class).void }
      def initialize(id, klass); end
    end

    # Raised when invalid field-level operator is passed to an
    # embedded matcher.
    class InvalidFieldOperator < Mongoid::Errors::InvalidQuery
      VALID_OPERATORS = T.let(%w(
  all elemMatch eq exists gt gte in lt lte ne nin not regex size
).freeze, T.untyped)
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Creates the exception.
      # 
      # _@param_ `operator` — The operator that was used.
      sig { params(operator: String).void }
      def initialize(operator); end

      # _@return_ — The operator that was used.
      sig { returns(String) }
      attr_reader :operator
    end

    # Raised when calling store_in in a sub-class of Mongoid::Document
    class InvalidStorageParent < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Create the new error.
      # 
      # _@param_ `klass` — The model class.
      # 
      # Create the new error.
      # ```ruby
      # InvalidStorageParent.new(Person)
      # ```
      sig { params(klass: Class).void }
      def initialize(klass); end
    end

    # Raised when Javascript criteria selector is passed for embedded document.
    class UnsupportedJavascript < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Create the new error caused by using Javascript in embedded document criteria selector.
      # 
      # _@param_ `klass` — The embedded document class.
      # 
      # _@param_ `javascript` — The javascript expression.
      # 
      # Create the error.
      # ```ruby
      # UnsupportedJavascriptSelector.new(Album, "this.name == '101'")
      # ```
      sig { params(klass: Class, javascript: String).void }
      def initialize(klass, javascript); end
    end

    # Raised when an option provided for an association is invalid.
    class InvalidRelationOption < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Create the new error.
      # 
      # _@param_ `klass` — The model class.
      # 
      # _@param_ `name` — The association name.
      # 
      # _@param_ `option` — The invalid option.
      # 
      # _@param_ `valid_options` — The valid option.
      # 
      # Create the new error.
      # ```ruby
      # InvalidRelationOption.new(Person, invalid_option: 'make_me_a_sandwich')
      # ```
      sig do
        params(
          klass: Class,
          name: T.any(String, Symbol),
          option: Symbol,
          valid_options: T::Array[Symbol]
        ).void
      end
      def initialize(klass, name, option, valid_options); end
    end

    # Raised when options provided to :store_in are invalid.
    class InvalidStorageOptions < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Create the new error.
      # 
      # _@param_ `klass` — The model class.
      # 
      # _@param_ `options` — The provided options.
      # 
      # Create the new error.
      # ```ruby
      # InvalidStorageOptions.new(Person, invalid_option: 'name')
      # ```
      sig { params(klass: Class, options: T.any(T::Hash[T.untyped, T.untyped], String, Symbol)).void }
      def initialize(klass, options); end
    end

    # This error is raised when a method on Criteria is given a nil argument.
    class CriteriaArgumentRequired < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

            # Creates the new exception instance.
      sig { params(query_method: T.untyped).void }
      def initialize(query_method); end
    end

    # This error is raised when an invalid strategy is defined for an association dependency.
    class InvalidDependentStrategy < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Create the new error.
      # 
      # _@param_ `association` — The association for which this dependency is defined.
      # 
      # _@param_ `invalid_strategy` — The attempted invalid strategy.
      # 
      # _@param_ `valid_strategies` — The valid strategies.
      # 
      # Create the new error.
      # ```ruby
      # InvalidDependentStrategy.new(association, invalid_strategy, valid_strategies)
      # ```
      sig { params(association: Mongoid::Association, invalid_strategy: T.any(Symbol, String), valid_strategies: T::Array[Symbol]).void }
      def initialize(association, invalid_strategy, valid_strategies); end
    end

    # Raised when invalid options are used to create a persistence context.
    # 
    # @since 6.0.0
    class InvalidPersistenceOption < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Instantiate the persistence context option error.
      # 
      # _@param_ `invalid` — The invalid option.
      # 
      # _@param_ `valid` — The allowed options.
      # 
      # Create the error.
      # ```ruby
      # InvalidPersistenceOption.new(:invalid_option, [ :connect_timeout, :database ])
      # ```
      sig { params(invalid: Symbol, valid: T::Array[Symbol]).void }
      def initialize(invalid, valid); end
    end

    # This error is raised when a client configuration contains both a uri and
    # other standard options.
    class MixedClientConfiguration < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Initialize the error.
      # 
      # _@param_ `name` — The name of the client config.
      # 
      # _@param_ `config` — The configuration options.
      # 
      # Initialize the error.
      # ```ruby
      # MixedClientConfiguration.new(:name, {})
      # ```
      sig { params(name: Symbol, config: T::Hash[T.untyped, T.untyped]).void }
      def initialize(name, config); end
    end

    # Raised when invalid field-level operator is passed to the $elemMatch
    # embedded matcher.
    class InvalidElemMatchOperator < Mongoid::Errors::InvalidQuery
      VALID_OPERATORS = T.let(%w(
  and all eq exists gt gte in lt lte ne nin nor not or regex size
).freeze, T.untyped)
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Creates the exception.
      # 
      # _@param_ `operator` — The operator that was used.
      sig { params(operator: String).void }
      def initialize(operator); end

      # _@return_ — The operator that was used.
      sig { returns(String) }
      attr_reader :operator
    end

    # Raised when invalid expression-level operator is passed to an
    # embedded matcher.
    class InvalidExpressionOperator < Mongoid::Errors::InvalidQuery
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Creates the exception.
      # 
      # _@param_ `operator` — The operator that was used.
      sig { params(operator: String).void }
      def initialize(operator); end

      # _@return_ — The operator that was used.
      sig { returns(String) }
      attr_reader :operator
    end

    # Creates the exception raised when trying to set or get the 
    # discriminator key on a child class.
    # 
    # @param [ String ] class_name The class name.
    # @param [ String ] operator The class' superclass.
    # 
    # @api private
    class InvalidDiscriminatorKeyTarget < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

                  sig { params(class_name: T.untyped, superclass: T.untyped).void }
      def initialize(class_name, superclass); end
    end

    class InvalidEstimatedCountCriteria < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Creates the exception raised when trying to call estimated_count
      # on a filtered criteria.
      # 
      # _@param_ `class_name` — The klass of the criteria used to call estimated count.
      sig { params(class_name: String).void }
      def initialize(class_name); end
    end

    # Raised when trying to set a polymorphic "references in" association to a
    # model with multiple "references many/one" associations pointing to that
    # first model.
    # 
    # @example Invalid setting of a polymorphic association.
    #   class Face
    #     include Mongoid::Document
    # 
    #     has_one :left_eye, class_name: "Eye", as: :eyeable
    #     has_one :right_eye, class_name: "Eye", as: :eyeable
    #   end
    # 
    #   class Eye
    #     include Mongoid::Document
    # 
    #     belongs_to :eyeable, polymorphic: true
    #   end
    # 
    #   eye = Eye.new
    #   face = Face.new
    #   eye.eyeable = face # Raises error
    class InvalidSetPolymorphicRelation < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

                        # Create the new invalid set polymorphic association error.
      # 
      # Create the error.
      # ```ruby
      # InvalidSetPolymorphicRelation.new
      # ```
      sig { params(name: T.untyped, klass: T.untyped, other_klass: T.untyped).void }
      def initialize(name, klass, other_klass); end
    end

    # This error is raised when attempting to do a query with a
    # collation on documents in memory.
    class InMemoryCollationNotSupported < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Create the new error.
      # 
      # Create the new unsupported collation error.
      # ```ruby
      # InMemoryCollationNotSupported.new
      # ```
      sig { void }
      def initialize; end
    end

    # This error is raised when trying to create set nested records above the
    # specified :limit
    # 
    # @example Create the error.
    #   TooManyNestedAttributeRecords.new('association', limit)
    class TooManyNestedAttributeRecords < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

                  sig { params(association: T.untyped, limit: T.untyped).void }
      def initialize(association, limit); end
    end

    # This error is raised when metadata could not be found when defining
    # nested attributes, or the name was incorrect.
    class NestedAttributesMetadataNotFound < Mongoid::Errors::MongoidError
      BASE_KEY = T.let("mongoid.errors.messages", T.untyped)

      # Create the new metadata error.
      # 
      # _@param_ `klass` — The class of the document.
      # 
      # _@param_ `name` — The name of the association
      # 
      # Create the new metadata error.
      # ```ruby
      # NestedAttributesMetadataNotFound.new(klass, name)
      # ```
      sig { params(klass: Class, name: T.any(Symbol, String)).void }
      def initialize(klass, name); end
    end
  end

  class Boolean
        # Turn the object from the ruby type we deal with to a Mongo friendly
    # type.
    # 
    # _@return_ — The object mongoized.
    # 
    # Mongoize the object.
    # ```ruby
    # Boolean.mongoize("123.11")
    # ```
    sig { params(object: T.untyped).returns(String) }
    def self.mongoize(object); end
  end

  class StringifiedSymbol
    # Convert the object from its mongo friendly ruby type to this type.
    # 
    # _@param_ `object` — The object to demongoize.
    # 
    # _@return_ — The object.
    # 
    # Demongoize the object.
    # ```ruby
    # Symbol.demongoize(object)
    # ```
    sig { params(object: Object).returns(Symbol) }
    def self.demongoize(object); end

    # Turn the object from the ruby type we deal with to a Mongo friendly
    # type.
    # 
    # _@param_ `object` — The object to mongoize.
    # 
    # _@return_ — The object mongoized.
    # 
    # Mongoize the object.
    # ```ruby
    # Symbol.mongoize("123.11")
    # ```
    sig { params(object: Object).returns(Symbol) }
    def self.mongoize(object); end

            sig { params(object: T.untyped).returns(T.untyped) }
    def self.evolve(object); end
  end

  # Object encapsulating logic for setting/getting a collection and database name
  # and a client with particular options to use when persisting models.
  # 
  # @since 6.0.0
  class PersistenceContext
    extend Forwardable
    EXTRA_OPTIONS = T.let([ :client,
  :collection
].freeze, T.untyped)
    VALID_OPTIONS = T.let(( Mongo::Client::VALID_OPTIONS + EXTRA_OPTIONS ).freeze, T.untyped)

    # Initialize the persistence context object.
    # 
    # _@param_ `object` — The class or model instance for which a persistence context should be created.
    # 
    # _@param_ `opts` — The persistence context options.
    # 
    # Create a new persistence context.
    # ```ruby
    # PersistenceContext.new(model, collection: 'other')
    # ```
    sig { params(object: Object, opts: T::Hash[T.untyped, T.untyped]).void }
    def initialize(object, opts = {}); end

    # sord warn - Mongo::Collection wasn't able to be resolved to a constant in this project
    # Get the collection for this persistence context.
    # 
    # _@param_ `parent` — The parent object whose collection name is used instead of this persistence context's collection name.
    # 
    # _@return_ — The collection for this persistence
    # context.
    # 
    # Get the collection for this persistence context.
    # ```ruby
    # context.collection
    # ```
    sig { params(parent: T.nilable(Object)).returns(Mongo::Collection) }
    def collection(parent = nil); end

    # Get the collection name for this persistence context.
    # 
    # _@return_ — The collection name for this persistence
    # context.
    # 
    # Get the collection name for this persistence context.
    # ```ruby
    # context.collection_name
    # ```
    sig { returns(String) }
    def collection_name; end

    # Get the database name for this persistence context.
    # 
    # _@return_ — The database name for this persistence
    # context.
    # 
    # Get the database name for this persistence context.
    # ```ruby
    # context.database_name
    # ```
    sig { returns(String) }
    def database_name; end

    # sord warn - Mongo::Client wasn't able to be resolved to a constant in this project
    # Get the client for this persistence context.
    # 
    # _@return_ — The client for this persistence
    # context.
    # 
    # Get the client for this persistence context.
    # ```ruby
    # context.client
    # ```
    sig { returns(::Mongo::Client) }
    def client; end

        sig { returns(T.untyped) }
    def client_name; end

    # Determine if this persistence context is equal to another.
    # 
    # _@param_ `other` — The object to be compared with this one.
    # 
    # _@return_ — Whether the two persistence contexts are equal.
    # 
    # Compare two persistence contexts.
    # ```ruby
    # context == other_context
    # ```
    sig { params(other: Object).returns(T::Boolean) }
    def ==(other); end

            sig { params(opts: T.untyped).returns(T.untyped) }
    def set_options!(opts); end

            sig { params(name: T.untyped).returns(T.untyped) }
    def __evaluate__(name); end

        sig { returns(T.untyped) }
    def client_options; end

        sig { returns(T.untyped) }
    def database_name_option; end

    # Set the persistence context for a particular class or model instance.
    # 
    # If there already is a persistence context set, options in the existing
    # context are combined with options given to the set call.
    # 
    # _@param_ `object` — The class or model instance.
    # 
    # _@param_ `options_or_context` — The persistence options or a persistence context object.
    # 
    # _@return_ — The persistence context for the object.
    # 
    # Set the persistence context for a class or model instance.
    # ```ruby
    # PersistenceContext.set(model)
    # ```
    sig { params(object: Object, options_or_context: T.any(T::Hash[T.untyped, T.untyped], Mongoid::PersistenceContext)).returns(Mongoid::PersistenceContext) }
    def self.set(object, options_or_context); end

    # Get the persistence context for a particular class or model instance.
    # 
    # _@param_ `object` — The class or model instance.
    # 
    # _@return_ — The persistence context for the object.
    # 
    # Get the persistence context for a class or model instance.
    # ```ruby
    # PersistenceContext.get(model)
    # ```
    sig { params(object: Object).returns(Mongoid::PersistenceContext) }
    def self.get(object); end

    # sord warn - Mongo::Cluster wasn't able to be resolved to a constant in this project
        # Clear the persistence context for a particular class or model instance.
    # 
    # _@param_ `object` — The class or model instance.
    # 
    # _@param_ `cluster` — The original cluster before this context was used.
    # 
    # _@param_ `original_context` — The original persistence context that was set before this context was used.
    # 
    # Clear the persistence context for a class or model instance.
    # ```ruby
    # PersistenceContext.clear(model)
    # ```
    sig { params(object: T.any(Class, Object), cluster: T.nilable(Mongo::Cluster), original_context: T.nilable(Mongoid::PersistenceContext)).returns(T.untyped) }
    def self.clear(object, cluster = nil, original_context = nil); end

    # The options defining this persistence context.
    # 
    # _@return_ — The persistence context options.
    sig { returns(T::Hash[T.untyped, T.untyped]) }
    attr_reader :options
  end

  module Generators
    class Base
            sig { returns(T.untyped) }
      def self.source_root; end
    end

    class ModelGenerator < Mongoid::Generators::Base
            sig { returns(T.untyped) }
      def create_model_file; end
    end

    class ConfigGenerator
            sig { returns(T.untyped) }
      def self.source_root; end

            sig { returns(T.untyped) }
      def app_name; end

            sig { returns(T.untyped) }
      def create_config_file; end
    end
  end

  module Railties
    module ControllerRuntime
      # This extension mimics the Rails' internal method to
      # measure ActiveRecord runtime during request processing.
      # It appends MongoDB runtime value (`mongoid_runtime`) into payload
      # of instrumentation event `process_action.action_controller`.
      module ControllerExtension
        extend ActiveSupport::Concern

                                # Reset the runtime before each action.
        sig { params(action: T.untyped, args: T.untyped).returns(T.untyped) }
        def process_action(action, *args); end

                # Override to collect the measurements.
        sig { returns(T.untyped) }
        def cleanup_view_runtime; end

                        # Add the measurement to the instrumentation event payload.
        sig { params(payload: T.untyped).returns(T.untyped) }
        def append_info_to_payload(payload); end

        module ClassMethods
                              # Append MongoDB runtime information to ActionController runtime
          # log message.
          sig { params(payload: T.untyped).returns(T.untyped) }
          def log_process_action(payload); end
        end
      end

      # The Collector of MongoDB runtime metric, that subscribes to Mongo
      # driver command monitoring. Stores the value within a thread-local
      # variable to provide correct accounting when an application issues
      # MongoDB operations from background threads.
      class Collector
        VARIABLE_NAME = T.let("Mongoid.controller_runtime".freeze, T.untyped)

                        sig { params(_: T.untyped).returns(T.untyped) }
        def started(_); end

                        sig { params(e: T.untyped).returns(T.untyped) }
        def _completed(e); end

                sig { returns(T.untyped) }
        def self.runtime; end

                        sig { params(value: T.untyped).returns(T.untyped) }
        def self.runtime=(value); end

                sig { returns(T.untyped) }
        def self.reset_runtime; end
      end
    end
  end
end

module Rails
  module Mongoid
    extend Rails::Mongoid

    # sord warn - Application wasn't able to be resolved to a constant in this project
        # Use the application configuration to get every model and require it, so
    # that indexing and inheritance work in both development and production
    # with the same results.
    # 
    # _@param_ `app` — The rails application.
    # 
    # Load all the application models.
    # ```ruby
    # Rails::Mongoid.load_models(app)
    # ```
    sig { params(app: Application).returns(T.untyped) }
    def load_models(app); end

    # sord warn - Application wasn't able to be resolved to a constant in this project
        # Conditionally calls `Rails::Mongoid.load_models(app)` if the
    # `::Mongoid.preload_models` is `true`.
    # 
    # _@param_ `app` — The rails application.
    sig { params(app: Application).returns(T.untyped) }
    def preload_models(app); end

        # I don't want to mock out kernel for unit testing purposes, so added this
    # method as a convenience.
    # 
    # _@param_ `file` — The base filename.
    # 
    # Load the model.
    # ```ruby
    # Mongoid.load_model("/mongoid/behavior")
    # ```
    sig { params(file: String).returns(T.untyped) }
    def load_model(file); end

    # sord warn - Application wasn't able to be resolved to a constant in this project
        # Use the application configuration to get every model and require it, so
    # that indexing and inheritance work in both development and production
    # with the same results.
    # 
    # _@param_ `app` — The rails application.
    # 
    # Load all the application models.
    # ```ruby
    # Rails::Mongoid.load_models(app)
    # ```
    sig { params(app: Application).returns(T.untyped) }
    def self.load_models(app); end

    # sord warn - Application wasn't able to be resolved to a constant in this project
        # Conditionally calls `Rails::Mongoid.load_models(app)` if the
    # `::Mongoid.preload_models` is `true`.
    # 
    # _@param_ `app` — The rails application.
    sig { params(app: Application).returns(T.untyped) }
    def self.preload_models(app); end

        # I don't want to mock out kernel for unit testing purposes, so added this
    # method as a convenience.
    # 
    # _@param_ `file` — The base filename.
    # 
    # Load the model.
    # ```ruby
    # Mongoid.load_model("/mongoid/behavior")
    # ```
    sig { params(file: String).returns(T.untyped) }
    def self.load_model(file); end

    # Hooks Mongoid into Rails 3 and higher.
    # 
    # @since 2.0.0
    class Railtie
            # Mapping of rescued exceptions to HTTP responses
      # 
      # @ return [Hash] rescued responses
      # 
      # ```ruby
      # railtie.rescue_responses
      # ```
      sig { returns(T.untyped) }
      def self.rescue_responses; end

                  # Rails runs all initializers first before getting into any generator
      # code, so we have no way in the intitializer to know if we are
      # generating a mongoid.yml. So instead of failing, we catch all the
      # errors and print them out.
      sig { params(e: T.untyped).returns(T.untyped) }
      def handle_configuration_error(e); end
    end
  end

  module Generators
    class GeneratedAttribute
            sig { returns(T.untyped) }
      def type_class; end
    end
  end
end
