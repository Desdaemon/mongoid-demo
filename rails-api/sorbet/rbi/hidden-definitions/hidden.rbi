# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

class ActionCable::Server::Worker
  include ::ActionCable::Server::Worker::ActiveRecordConnectionManagement
  def async_exec(receiver, *args, connection:, &block); end

  def async_invoke(receiver, method, *args, connection: T.unsafe(nil), &block); end

  def executor(); end

  def halt(); end

  def initialize(max_size: T.unsafe(nil)); end

  def invoke(receiver, method, *args, connection:, &block); end

  def stopping?(); end

  def work(connection); end
end

module ActionCable::Server::Worker::ActiveRecordConnectionManagement
  def with_database_connections(); end
end

module ActionCable::Server::Worker::ActiveRecordConnectionManagement
  extend ::ActiveSupport::Concern
end

class ActionController::API
  include ::ActionDispatch::Routing::RouteSet::MountedHelpers
  include ::Mongoid::Railties::ControllerRuntime::ControllerExtension
end

class ActionController::API
  extend ::ActionController::Railties::Helpers
end

class ActionController::Base
  include ::ActionDispatch::Routing::RouteSet::MountedHelpers
  include ::Mongoid::Railties::ControllerRuntime::ControllerExtension
end

class ActionController::Base
  extend ::ActionController::Railties::Helpers
end

class ActionController::Metal
  include ::ActionController::Testing::Functional
end

class ActionDispatch::IntegrationTest
  include ::ActionMailer::TestHelper
  include ::ActiveJob::TestHelper
  include ::ActionMailer::TestCase::ClearTestDeliveries
end

class ActionDispatch::Journey::Parser
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing::RouteSet::MountedHelpers
  def _main_app(); end

  def main_app(); end
end

module ActionMailbox
  def incinerate(); end

  def incinerate=(obj); end

  def incinerate_after(); end

  def incinerate_after=(obj); end

  def ingress(); end

  def ingress=(obj); end

  def logger(); end

  def logger=(obj); end

  def queues(); end

  def queues=(obj); end
end

class ActionMailbox::Base
  include ::ActiveSupport::Rescuable
  include ::ActionMailbox::Routing
  include ::ActiveSupport::Callbacks
  include ::ActionMailbox::Callbacks
  def __callbacks(); end

  def __callbacks?(); end

  def _process_callbacks(); end

  def _run_process_callbacks(&block); end

  def bounce_with(message); end

  def bounced!(*args, &block); end

  def delivered!(*args, &block); end

  def finished_processing?(); end

  def inbound_email(); end

  def initialize(inbound_email); end

  def logger(*args, &block); end

  def mail(*args, &block); end

  def perform_processing(); end

  def process(); end

  def rescue_handlers(); end

  def rescue_handlers=(val); end

  def rescue_handlers?(); end

  def router(); end

  def router=(obj); end
end

class ActionMailbox::Base
  extend ::ActionMailbox::Routing::ClassMethods
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActionMailbox::Callbacks::ClassMethods
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._process_callbacks(); end

  def self._process_callbacks=(value); end

  def self.receive(inbound_email); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(val); end

  def self.rescue_handlers?(); end

  def self.router(); end

  def self.router=(obj); end
end

module ActionMailbox::Callbacks
  TERMINATOR = ::T.let(nil, ::T.untyped)
end

module ActionMailbox::Callbacks::ClassMethods
  def after_processing(*methods, &block); end

  def around_processing(*methods, &block); end

  def before_processing(*methods, &block); end
end

module ActionMailbox::Callbacks::ClassMethods
end

module ActionMailbox::Callbacks
  extend ::ActiveSupport::Concern
end

class ActionMailbox::Engine
end

class ActionMailbox::Engine
end

class ActionMailbox::Router
  def add_route(address, to:); end

  def add_routes(routes); end

  def route(inbound_email); end
end

class ActionMailbox::Router::Route
  def address(); end

  def initialize(address, to:); end

  def mailbox_class(); end

  def mailbox_name(); end

  def match?(inbound_email); end
end

class ActionMailbox::Router::Route
end

class ActionMailbox::Router::RoutingError
end

class ActionMailbox::Router::RoutingError
end

class ActionMailbox::Router
end

module ActionMailbox::Routing
end

module ActionMailbox::Routing::ClassMethods
  def route(inbound_email); end

  def routing(routes); end
end

module ActionMailbox::Routing::ClassMethods
end

module ActionMailbox::Routing
  extend ::ActiveSupport::Concern
end

class ActionMailbox::TestCase
  include ::ActionMailbox::TestHelper
end

class ActionMailbox::TestCase
end

module ActionMailbox::TestHelper
  def create_inbound_email_from_fixture(fixture_name, status: T.unsafe(nil)); end

  def create_inbound_email_from_mail(status: T.unsafe(nil), **mail_options); end

  def create_inbound_email_from_source(source, status: T.unsafe(nil)); end

  def receive_inbound_email_from_fixture(*args); end

  def receive_inbound_email_from_mail(**kwargs); end

  def receive_inbound_email_from_source(*args); end
end

module ActionMailbox::TestHelper
end

module ActionMailbox
  extend ::ActiveSupport::Autoload
  def self.incinerate(); end

  def self.incinerate=(obj); end

  def self.incinerate_after(); end

  def self.incinerate_after=(obj); end

  def self.ingress(); end

  def self.ingress=(obj); end

  def self.logger(); end

  def self.logger=(obj); end

  def self.queues(); end

  def self.queues=(obj); end

  def self.railtie_helpers_paths(); end

  def self.railtie_namespace(); end

  def self.railtie_routes_url_helpers(include_path_helpers=T.unsafe(nil)); end

  def self.table_name_prefix(); end

  def self.use_relative_model_naming?(); end
end

class ActionMailer::Base
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::AbstractController::UrlFor
  include ::ActionDispatch::Routing::RouteSet::MountedHelpers
  def default_url_options(); end

  def default_url_options=(val); end

  def default_url_options?(); end
end

class ActionMailer::Base
  extend ::AbstractController::UrlFor::ClassMethods
  def self.default_url_options(); end

  def self.default_url_options=(val); end

  def self.default_url_options?(); end
end

module ActionText
end

module ActionText::Attachable
  def as_json(*_); end

  def attachable_content_type(); end

  def attachable_filename(); end

  def attachable_filesize(); end

  def attachable_metadata(); end

  def attachable_sgid(); end

  def previewable_attachable?(); end

  def to_rich_text_attributes(attributes=T.unsafe(nil)); end

  def to_trix_content_attachment_partial_path(); end
  LOCATOR_NAME = ::T.let(nil, ::T.untyped)
end

module ActionText::Attachable::ClassMethods
  def from_attachable_sgid(sgid); end
end

module ActionText::Attachable::ClassMethods
end

module ActionText::Attachable
  extend ::ActiveSupport::Concern
  def self.from_attachable_sgid(sgid, options=T.unsafe(nil)); end

  def self.from_node(node); end
end

module ActionText::Attachables
end

class ActionText::Attachables::ContentAttachment
  include ::ActiveModel::Validations
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  include ::ActiveModel::Conversion
  include ::ActiveModel::Model
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::ForbiddenAttributesProtection
  def __callbacks(); end

  def __callbacks?(); end

  def _run_validate_callbacks(&block); end

  def _validate_callbacks(); end

  def _validators(); end

  def _validators?(); end

  def attachable_plain_text_representation(caption); end

  def model_name(*args, &block); end

  def name(); end

  def name=(name); end

  def to_trix_content_attachment_partial_path(); end

  def validation_context(); end
end

class ActionText::Attachables::ContentAttachment
  extend ::ActiveModel::Callbacks
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveModel::Translation
  extend ::ActiveModel::Naming
  extend ::ActiveModel::Validations::HelperMethods
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._validate_callbacks(); end

  def self._validate_callbacks=(value); end

  def self._validators(); end

  def self._validators=(val); end

  def self._validators?(); end

  def self.from_node(node); end
end

module ActionText::Attachables::MissingAttachable
  def model_name(*args, &block); end
end

module ActionText::Attachables::MissingAttachable
  extend ::ActiveModel::Naming
  def self.to_partial_path(); end
end

class ActionText::Attachables::RemoteImage
  def attachable_plain_text_representation(caption); end

  def content_type(); end

  def height(); end

  def initialize(attributes=T.unsafe(nil)); end

  def model_name(*args, &block); end

  def to_partial_path(); end

  def url(); end

  def width(); end
end

class ActionText::Attachables::RemoteImage
  extend ::ActiveModel::Naming
  def self.from_node(node); end
end

module ActionText::Attachables
  extend ::ActiveSupport::Autoload
end

class ActionText::Attachment
  include ::ActionText::Attachments::Caching
  include ::ActionText::Attachments::Minification
  include ::ActionText::Attachments::TrixConversion
  def attachable(); end

  def caption(); end

  def full_attributes(); end

  def initialize(node, attachable); end

  def method_missing(method, *args, &block); end

  def node(); end

  def to_html(); end

  def to_param(*args, &block); end

  def to_plain_text(); end

  def with_full_attributes(); end
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
  SELECTOR = ::T.let(nil, ::T.untyped)
  TAG_NAME = ::T.let(nil, ::T.untyped)
end

class ActionText::Attachment
  def self.fragment_by_canonicalizing_attachments(content); end

  def self.from_attachable(attachable, attributes=T.unsafe(nil)); end

  def self.from_attachables(attachables); end

  def self.from_attributes(attributes, attachable=T.unsafe(nil)); end

  def self.from_node(node, attachable=T.unsafe(nil)); end
end

class ActionText::AttachmentGallery
  include ::ActiveModel::Validations
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  include ::ActiveModel::Conversion
  include ::ActiveModel::Model
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::ForbiddenAttributesProtection
  def __callbacks(); end

  def __callbacks?(); end

  def _run_validate_callbacks(&block); end

  def _validate_callbacks(); end

  def _validators(); end

  def _validators?(); end

  def attachments(); end

  def initialize(node); end

  def model_name(*args, &block); end

  def node(); end

  def size(); end

  def validation_context(); end
end

class ActionText::AttachmentGallery
  extend ::ActiveModel::Callbacks
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveModel::Translation
  extend ::ActiveModel::Naming
  extend ::ActiveModel::Validations::HelperMethods
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._validate_callbacks(); end

  def self._validate_callbacks=(value); end

  def self._validators(); end

  def self._validators=(val); end

  def self._validators?(); end

  def self.find_attachment_gallery_nodes(content); end

  def self.fragment_by_canonicalizing_attachment_galleries(content); end

  def self.fragment_by_replacing_attachment_gallery_nodes(content); end

  def self.from_node(node); end
end

module ActionText::Attachments
end

module ActionText::Attachments::Caching
  def cache_key(*args); end
end

module ActionText::Attachments::Caching
end

module ActionText::Attachments::Minification
end

module ActionText::Attachments::Minification
  extend ::ActiveSupport::Concern
end

module ActionText::Attachments::TrixConversion
  def to_trix_attachment(content=T.unsafe(nil)); end
end

module ActionText::Attachments::TrixConversion
  extend ::ActiveSupport::Concern
end

module ActionText::Attachments
  extend ::ActiveSupport::Autoload
end

module ActionText::Attribute
end

module ActionText::Attribute::ClassMethods
  def has_rich_text(name); end
end

module ActionText::Attribute::ClassMethods
end

module ActionText::Attribute
  extend ::ActiveSupport::Concern
end

class ActionText::Content
  include ::ActionText::Serialization
  def ==(other); end

  def append_attachables(attachables); end

  def as_json(*_); end

  def attachables(); end

  def attachment_galleries(); end

  def attachments(); end

  def blank?(*args, &block); end

  def empty?(*args, &block); end

  def fragment(); end

  def gallery_attachments(); end

  def html_safe(*args, &block); end

  def initialize(content=T.unsafe(nil), options=T.unsafe(nil)); end

  def links(); end

  def present?(*args, &block); end

  def render_attachment_galleries(&block); end

  def render_attachments(**options, &block); end

  def renderer(); end

  def renderer=(obj); end

  def to_html(); end

  def to_plain_text(); end

  def to_rendered_html_with_layout(); end

  def to_trix_html(); end
end

class ActionText::Content
  extend ::ActionText::Serialization::ClassMethods
  def self.fragment_by_canonicalizing_content(content); end

  def self.renderer(); end

  def self.renderer=(obj); end
end

class ActionText::Engine
end

class ActionText::Engine
end

class ActionText::Fragment
  def find_all(selector); end

  def initialize(source); end

  def replace(selector); end

  def source(); end

  def to_html(); end

  def to_plain_text(); end

  def update(); end
end

class ActionText::Fragment
  def self.from_html(html); end

  def self.wrap(fragment_or_html); end
end

module ActionText::HtmlConversion
  def create_element(tag_name, attributes=T.unsafe(nil)); end

  def fragment_for_html(html); end

  def node_to_html(node); end
end

module ActionText::HtmlConversion
  extend ::ActionText::HtmlConversion
end

module ActionText::PlainTextConversion
  def node_to_plain_text(node); end
end

module ActionText::PlainTextConversion
  extend ::ActionText::PlainTextConversion
end

module ActionText::Serialization
  def _dump(*_); end
end

module ActionText::Serialization::ClassMethods
  def _load(content); end

  def dump(content); end

  def load(content); end
end

module ActionText::Serialization::ClassMethods
end

module ActionText::Serialization
  extend ::ActiveSupport::Concern
end

class ActionText::TrixAttachment
  def attributes(); end

  def initialize(node); end

  def node(); end

  def to_html(); end
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_TYPES = ::T.let(nil, ::T.untyped)
  COMPOSED_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  SELECTOR = ::T.let(nil, ::T.untyped)
  TAG_NAME = ::T.let(nil, ::T.untyped)
end

class ActionText::TrixAttachment
  def self.from_attributes(attributes); end
end

module ActionText
  extend ::ActiveSupport::Autoload
  def self.railtie_helpers_paths(); end

  def self.railtie_namespace(); end

  def self.railtie_routes_url_helpers(include_path_helpers=T.unsafe(nil)); end

  def self.table_name_prefix(); end

  def self.use_relative_model_naming?(); end
end

class ActionView::Base
  include ::ActionCable::Helpers::ActionCableHelper
end

module ActionView::RoutingUrlFor
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def default_url_options=(obj); end
end

module ActionView::RoutingUrlFor
  def self.default_url_options=(obj); end
end

class ActionView::TestCase
  include ::ActionDispatch::Routing::UrlFor
end

module ActionView::TestCase::Behavior
  include ::ActionDispatch::Routing::UrlFor
end

class ActiveModel::Attribute::FromUser
  def type_cast(value); end
end

class ActiveModel::Attribute::FromUser
end

class ActiveRecord::AdvisoryLockBase
  include ::ActiveRecord::AdvisoryLockBase::GeneratedAttributeMethods
  include ::ActiveRecord::AdvisoryLockBase::GeneratedAssociationMethods
end

module ActiveRecord::AdvisoryLockBase::GeneratedAssociationMethods
end

module ActiveRecord::AdvisoryLockBase::GeneratedAssociationMethods
end

module ActiveRecord::AdvisoryLockBase::GeneratedAttributeMethods
end

module ActiveRecord::AdvisoryLockBase::GeneratedAttributeMethods
  extend ::Mutex_m
end

class ActiveRecord::AdvisoryLockBase
end

module ActiveRecord::Aggregations
  def reload(*_); end
end

module ActiveRecord::Aggregations::ClassMethods
  def composed_of(part_id, options=T.unsafe(nil)); end
end

module ActiveRecord::Aggregations::ClassMethods
end

class ActiveRecord::AssociationRelation
  def initialize(klass, association, **_); end

  def proxy_association(); end
end

class ActiveRecord::AssociationRelation
end

class ActiveRecord::Associations::AliasTracker
  def aliased_table_for(table_name, aliased_name, type_caster); end

  def aliases(); end

  def initialize(connection, aliases); end
end

class ActiveRecord::Associations::AliasTracker
  def self.create(connection, initial_table, joins); end

  def self.initial_count_for(connection, name, table_joins); end
end

class ActiveRecord::Associations::Association
  def create(attributes=T.unsafe(nil), &block); end

  def create!(attributes=T.unsafe(nil), &block); end

  def extensions(); end

  def initialize(owner, reflection); end

  def initialize_attributes(record, except_from_scope_attributes=T.unsafe(nil)); end

  def inversed_from(record); end

  def inversed_from_queries(record); end

  def klass(); end

  def load_target(); end

  def loaded!(); end

  def loaded?(); end

  def marshal_dump(); end

  def marshal_load(data); end

  def options(*args, &block); end

  def owner(); end

  def reflection(); end

  def reload(force=T.unsafe(nil)); end

  def remove_inverse_instance(record); end

  def reset(); end

  def reset_scope(); end

  def scope(); end

  def set_inverse_instance(record); end

  def set_inverse_instance_from_queries(record); end

  def stale_target?(); end

  def target(); end

  def target=(target); end
end

class ActiveRecord::Associations::Association
end

class ActiveRecord::Associations::AssociationScope
  def initialize(value_transformation); end

  def scope(association); end
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Associations::AssociationScope::ReflectionProxy
  def aliased_table(); end

  def all_includes(); end

  def initialize(reflection, aliased_table); end
end

class ActiveRecord::Associations::AssociationScope::ReflectionProxy
end

class ActiveRecord::Associations::AssociationScope
  def self.create(&block); end

  def self.get_bind_values(owner, chain); end

  def self.scope(association); end
end

class ActiveRecord::Associations::BelongsToAssociation
  def decrement_counters(); end

  def decrement_counters_before_last_save(); end

  def default(&block); end

  def handle_dependency(); end

  def increment_counters(); end

  def target_changed?(); end

  def updated?(); end
end

class ActiveRecord::Associations::BelongsToAssociation
end

class ActiveRecord::Associations::BelongsToPolymorphicAssociation
end

class ActiveRecord::Associations::BelongsToPolymorphicAssociation
end

module ActiveRecord::Associations::Builder
end

class ActiveRecord::Associations::Builder::Association
  VALID_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Associations::Builder::Association
  def self.build(model, name, scope, options, &block); end

  def self.create_reflection(model, name, scope, options, &block); end

  def self.extensions(); end

  def self.extensions=(extensions); end
end

class ActiveRecord::Associations::Builder::BelongsTo
end

class ActiveRecord::Associations::Builder::BelongsTo
  def self.touch_record(o, changes, foreign_key, name, touch, touch_method); end
end

class ActiveRecord::Associations::Builder::CollectionAssociation
  CALLBACKS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Associations::Builder::CollectionAssociation
end

class ActiveRecord::Associations::Builder::HasAndBelongsToMany
  def association_name(); end

  def initialize(association_name, lhs_model, options); end

  def lhs_model(); end

  def middle_reflection(join_model); end

  def options(); end

  def through_model(); end
end

class ActiveRecord::Associations::Builder::HasAndBelongsToMany
end

class ActiveRecord::Associations::Builder::HasMany
end

class ActiveRecord::Associations::Builder::HasMany
end

class ActiveRecord::Associations::Builder::HasOne
end

class ActiveRecord::Associations::Builder::HasOne
  def self.touch_record(o, name, touch); end
end

class ActiveRecord::Associations::Builder::SingularAssociation
end

class ActiveRecord::Associations::Builder::SingularAssociation
end

module ActiveRecord::Associations::Builder
end

class ActiveRecord::Associations::CollectionAssociation
  def add_to_target(record, skip_callbacks=T.unsafe(nil), &block); end

  def build(attributes=T.unsafe(nil), &block); end

  def concat(*records); end

  def delete(*records); end

  def delete_all(dependent=T.unsafe(nil)); end

  def destroy(*records); end

  def destroy_all(); end

  def empty?(); end

  def find(*args); end

  def find_from_target?(); end

  def ids_reader(); end

  def ids_writer(ids); end

  def include?(record); end

  def null_scope?(); end

  def reader(); end

  def replace(other_array); end

  def size(); end

  def transaction(*args); end

  def writer(records); end
end

class ActiveRecord::Associations::CollectionAssociation
end

class ActiveRecord::Associations::CollectionProxy
  def <<(*records); end

  def _select!(*args, &block); end

  def annotate(*args, &block); end

  def annotate!(*args, &block); end

  def annotate_values(*args, &block); end

  def annotate_values=(arg); end

  def append(*records); end

  def arel(*args, &block); end

  def clear(); end

  def concat(*records); end

  def construct_join_dependency(*args, &block); end

  def create_with(*args, &block); end

  def create_with!(*args, &block); end

  def create_with_value(*args, &block); end

  def create_with_value=(arg); end

  def delete(*records); end

  def delete_all(dependent=T.unsafe(nil)); end

  def destroy(*records); end

  def distinct(*args, &block); end

  def distinct!(*args, &block); end

  def distinct_value(*args, &block); end

  def distinct_value=(arg); end

  def eager_load(*args, &block); end

  def eager_load!(*args, &block); end

  def eager_load_values(*args, &block); end

  def eager_load_values=(arg); end

  def except(*args, &block); end

  def extending(*args, &block); end

  def extending!(*args, &block); end

  def extending_values(*args, &block); end

  def extending_values=(arg); end

  def extensions(*args, &block); end

  def extract_associated(*args, &block); end

  def from(*args, &block); end

  def from!(*args, &block); end

  def from_clause(*args, &block); end

  def from_clause=(arg); end

  def group(*args, &block); end

  def group!(*args, &block); end

  def group_values(*args, &block); end

  def group_values=(arg); end

  def having(*args, &block); end

  def having!(*args, &block); end

  def having_clause(*args, &block); end

  def having_clause=(arg); end

  def include?(record); end

  def includes(*args, &block); end

  def includes!(*args, &block); end

  def includes_values(*args, &block); end

  def includes_values=(arg); end

  def initialize(klass, association, **_); end

  def joins(*args, &block); end

  def joins!(*args, &block); end

  def joins_values(*args, &block); end

  def joins_values=(arg); end

  def left_joins(*args, &block); end

  def left_outer_joins(*args, &block); end

  def left_outer_joins!(*args, &block); end

  def left_outer_joins_values(*args, &block); end

  def left_outer_joins_values=(arg); end

  def limit(*args, &block); end

  def limit!(*args, &block); end

  def limit_value(*args, &block); end

  def limit_value=(arg); end

  def load_target(); end

  def lock(*args, &block); end

  def lock!(*args, &block); end

  def lock_value(*args, &block); end

  def lock_value=(arg); end

  def merge(*args, &block); end

  def merge!(*args, &block); end

  def none(*args, &block); end

  def none!(*args, &block); end

  def offset(*args, &block); end

  def offset!(*args, &block); end

  def offset_value(*args, &block); end

  def offset_value=(arg); end

  def only(*args, &block); end

  def optimizer_hints(*args, &block); end

  def optimizer_hints!(*args, &block); end

  def optimizer_hints_values(*args, &block); end

  def optimizer_hints_values=(arg); end

  def or(*args, &block); end

  def or!(*args, &block); end

  def order(*args, &block); end

  def order!(*args, &block); end

  def order_values(*args, &block); end

  def order_values=(arg); end

  def preload(*args, &block); end

  def preload!(*args, &block); end

  def preload_values(*args, &block); end

  def preload_values=(arg); end

  def prepend(*args); end

  def proxy_association(); end

  def push(*records); end

  def readonly(*args, &block); end

  def readonly!(*args, &block); end

  def readonly_value(*args, &block); end

  def readonly_value=(arg); end

  def references(*args, &block); end

  def references!(*args, &block); end

  def references_values(*args, &block); end

  def references_values=(arg); end

  def reorder(*args, &block); end

  def reorder!(*args, &block); end

  def reordering_value(*args, &block); end

  def reordering_value=(arg); end

  def replace(other_array); end

  def reselect(*args, &block); end

  def reselect!(*args, &block); end

  def reset_scope(); end

  def reverse_order(*args, &block); end

  def reverse_order!(*args, &block); end

  def reverse_order_value(*args, &block); end

  def reverse_order_value=(arg); end

  def rewhere(*args, &block); end

  def scope(); end

  def scoping(*args, &block); end

  def select_values(*args, &block); end

  def select_values=(arg); end

  def skip_preloading!(*args, &block); end

  def skip_query_cache!(*args, &block); end

  def skip_query_cache_value(*args, &block); end

  def skip_query_cache_value=(arg); end

  def spawn(*args, &block); end

  def target(); end

  def unscope(*args, &block); end

  def unscope!(*args, &block); end

  def unscope_values(*args, &block); end

  def unscope_values=(arg); end

  def values(*args, &block); end

  def where(*args, &block); end

  def where!(*args, &block); end

  def where_clause(*args, &block); end

  def where_clause=(arg); end
end

class ActiveRecord::Associations::CollectionProxy
end

module ActiveRecord::Associations::ForeignAssociation
  def foreign_key_present?(); end

  def nullified_owner_attributes(); end
end

module ActiveRecord::Associations::ForeignAssociation
end

class ActiveRecord::Associations::HasManyAssociation
  include ::ActiveRecord::Associations::ForeignAssociation
  def handle_dependency(); end

  def insert_record(record, validate=T.unsafe(nil), raise=T.unsafe(nil)); end
end

class ActiveRecord::Associations::HasManyAssociation
end

class ActiveRecord::Associations::HasManyThroughAssociation
  include ::ActiveRecord::Associations::ThroughAssociation
end

class ActiveRecord::Associations::HasManyThroughAssociation
end

class ActiveRecord::Associations::HasOneAssociation
  include ::ActiveRecord::Associations::ForeignAssociation
  def delete(method=T.unsafe(nil)); end

  def handle_dependency(); end
end

class ActiveRecord::Associations::HasOneAssociation
end

class ActiveRecord::Associations::HasOneThroughAssociation
  include ::ActiveRecord::Associations::ThroughAssociation
end

class ActiveRecord::Associations::HasOneThroughAssociation
end

class ActiveRecord::Associations::JoinDependency
  def apply_column_aliases(relation); end

  def base_klass(); end

  def initialize(base, table, associations, join_type); end

  def instantiate(result_set, &block); end

  def join_constraints(joins_to_add, alias_tracker); end

  def join_root(); end

  def join_type(); end

  def reflections(); end
end

class ActiveRecord::Associations::JoinDependency::Aliases
  def column_alias(node, column); end

  def column_aliases(node); end

  def columns(); end

  def initialize(tables); end
end

class ActiveRecord::Associations::JoinDependency::Aliases::Column
  def alias(); end

  def alias=(_); end

  def name(); end

  def name=(_); end
end

class ActiveRecord::Associations::JoinDependency::Aliases::Column
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::Associations::JoinDependency::Aliases::Table
  def column_aliases(); end

  def columns(); end

  def columns=(_); end

  def node(); end

  def node=(_); end
end

class ActiveRecord::Associations::JoinDependency::Aliases::Table
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::Associations::JoinDependency::Aliases
end

class ActiveRecord::Associations::JoinDependency::JoinAssociation
  def initialize(reflection, children); end

  def join_constraints(foreign_table, foreign_klass, join_type, alias_tracker); end

  def readonly?(); end

  def reflection(); end

  def table=(table); end

  def tables(); end

  def tables=(tables); end
end

class ActiveRecord::Associations::JoinDependency::JoinAssociation
end

class ActiveRecord::Associations::JoinDependency::JoinBase
  def initialize(base_klass, table, children); end
end

class ActiveRecord::Associations::JoinDependency::JoinBase
end

class ActiveRecord::Associations::JoinDependency::JoinPart
  include ::Enumerable
  def base_klass(); end

  def children(); end

  def column_names(*args, &block); end

  def each(&block); end

  def each_children(&block); end

  def extract_record(row, column_names_with_alias); end

  def initialize(base_klass, children); end

  def instantiate(row, aliases, &block); end

  def match?(other); end

  def primary_key(*args, &block); end

  def table(); end

  def table_name(*args, &block); end
end

class ActiveRecord::Associations::JoinDependency::JoinPart
end

class ActiveRecord::Associations::JoinDependency
  def self.make_tree(associations); end

  def self.walk_tree(associations, hash); end
end

class ActiveRecord::Associations::Preloader::AlreadyLoaded
  def initialize(klass, owners, reflection, preload_scope); end

  def preloaded_records(); end

  def records_by_owner(); end

  def run(); end
end

class ActiveRecord::Associations::Preloader::AlreadyLoaded
end

class ActiveRecord::Associations::Preloader::Association
  def initialize(klass, owners, reflection, preload_scope); end

  def preloaded_records(); end

  def records_by_owner(); end

  def run(); end
end

class ActiveRecord::Associations::Preloader::Association
end

class ActiveRecord::Associations::Preloader::ThroughAssociation
  def initialize(*_); end
  PRELOADER = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Associations::Preloader::ThroughAssociation
end

class ActiveRecord::Associations::Preloader
  extend ::ActiveSupport::Autoload
end

class ActiveRecord::Associations::SingularAssociation
  def build(attributes=T.unsafe(nil), &block); end

  def force_reload_reader(); end

  def reader(); end

  def writer(record); end
end

class ActiveRecord::Associations::SingularAssociation
end

module ActiveRecord::Associations::ThroughAssociation
  def source_reflection(*args, &block); end
end

module ActiveRecord::Associations::ThroughAssociation
end

module ActiveRecord::Associations
  extend ::ActiveSupport::Autoload
end

module ActiveRecord::AttributeAssignment
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::ForbiddenAttributesProtection
end

class ActiveRecord::AttributeAssignmentError
  def attribute(); end

  def exception(); end

  def initialize(message=T.unsafe(nil), exception=T.unsafe(nil), attribute=T.unsafe(nil)); end
end

module ActiveRecord::AttributeDecorators
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods
  extend ::ActiveSupport::Autoload
end

module ActiveRecord::Attributes
  extend ::ActiveSupport::Concern
end

class ActiveRecord::Base
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveRecord::Validations
  include ::ActiveRecord::Base::GeneratedAttributeMethods
  include ::ActiveRecord::Base::GeneratedAssociationMethods
  include ::ActiveModel::Serializers::JSON
  include ::ActiveModel::Serialization
  include ::GlobalID::Identification
  def __callbacks(); end

  def __callbacks?(); end

  def _before_commit_callbacks(); end

  def _before_commit_without_transaction_enrollment_callbacks(); end

  def _commit_callbacks(); end

  def _commit_without_transaction_enrollment_callbacks(); end

  def _create_callbacks(); end

  def _destroy_callbacks(); end

  def _find_callbacks(); end

  def _initialize_callbacks(); end

  def _reflections(); end

  def _reflections?(); end

  def _rollback_callbacks(); end

  def _rollback_without_transaction_enrollment_callbacks(); end

  def _run_before_commit_callbacks(&block); end

  def _run_before_commit_without_transaction_enrollment_callbacks(&block); end

  def _run_commit_callbacks(&block); end

  def _run_commit_without_transaction_enrollment_callbacks(&block); end

  def _run_create_callbacks(&block); end

  def _run_destroy_callbacks(&block); end

  def _run_find_callbacks(&block); end

  def _run_initialize_callbacks(&block); end

  def _run_rollback_callbacks(&block); end

  def _run_rollback_without_transaction_enrollment_callbacks(&block); end

  def _run_save_callbacks(&block); end

  def _run_touch_callbacks(&block); end

  def _run_update_callbacks(&block); end

  def _run_validate_callbacks(&block); end

  def _run_validation_callbacks(&block); end

  def _save_callbacks(); end

  def _touch_callbacks(); end

  def _update_callbacks(); end

  def _validate_callbacks(); end

  def _validation_callbacks(); end

  def _validators(); end

  def _validators?(); end

  def aggregate_reflections(); end

  def aggregate_reflections?(); end

  def allow_unsafe_raw_sql(); end

  def attribute_aliases(); end

  def attribute_aliases?(); end

  def attribute_method_matchers(); end

  def attribute_method_matchers?(); end

  def cache_timestamp_format(); end

  def cache_timestamp_format?(); end

  def cache_versioning(); end

  def cache_versioning?(); end

  def collection_cache_versioning(); end

  def collection_cache_versioning?(); end

  def column_for_attribute(*args, &block); end

  def default_connection_handler(); end

  def default_connection_handler?(); end

  def default_scope_override(); end

  def default_scopes(); end

  def default_timezone(); end

  def defined_enums(); end

  def defined_enums?(); end

  def dump_schema_after_migration(); end

  def dump_schemas(); end

  def error_on_ignored_order(); end

  def include_root_in_json(); end

  def include_root_in_json?(); end

  def index_nested_attribute_errors(); end

  def lock_optimistically(); end

  def lock_optimistically?(); end

  def logger(); end

  def model_name(*args, &block); end

  def nested_attributes_options(); end

  def nested_attributes_options?(); end

  def partial_writes(); end

  def partial_writes?(); end

  def pluralize_table_names(); end

  def pluralize_table_names?(); end

  def primary_key_prefix_type(); end

  def record_timestamps(); end

  def record_timestamps=(val); end

  def record_timestamps?(); end

  def schema_format(); end

  def skip_time_zone_conversion_for_attributes(); end

  def skip_time_zone_conversion_for_attributes?(); end

  def store_full_sti_class(); end

  def store_full_sti_class?(); end

  def table_name_prefix(); end

  def table_name_prefix?(); end

  def table_name_suffix(); end

  def table_name_suffix?(); end

  def time_zone_aware_attributes(); end

  def time_zone_aware_types(); end

  def time_zone_aware_types?(); end

  def timestamped_migrations(); end

  def type_for_attribute(*args, &block); end

  def validation_context(); end

  def verbose_query_logs(); end

  def warn_on_records_fetched_greater_than(); end
end

module ActiveRecord::Base::GeneratedAssociationMethods
end

module ActiveRecord::Base::GeneratedAssociationMethods
end

module ActiveRecord::Base::GeneratedAttributeMethods
end

module ActiveRecord::Base::GeneratedAttributeMethods
  extend ::Mutex_m
end

class ActiveRecord::Base
  extend ::ActiveModel::Translation
  extend ::ActiveRecord::Aggregations::ClassMethods
  extend ::ActiveRecord::Scoping::ClassMethods
  extend ::ActiveRecord::Integration::ClassMethods
  extend ::ActiveModel::Validations::HelperMethods
  extend ::ActiveRecord::CounterCache::ClassMethods
  extend ::ActiveModel::AttributeMethods::ClassMethods
  extend ::ActiveRecord::Timestamp::ClassMethods
  extend ::ActiveRecord::NoTouching::ClassMethods
  extend ::ActiveRecord::Reflection::ClassMethods
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._attr_readonly(); end

  def self._attr_readonly=(val); end

  def self._attr_readonly?(); end

  def self._before_commit_callbacks(); end

  def self._before_commit_callbacks=(value); end

  def self._before_commit_without_transaction_enrollment_callbacks(); end

  def self._before_commit_without_transaction_enrollment_callbacks=(value); end

  def self._commit_callbacks(); end

  def self._commit_callbacks=(value); end

  def self._commit_without_transaction_enrollment_callbacks(); end

  def self._commit_without_transaction_enrollment_callbacks=(value); end

  def self._create_callbacks(); end

  def self._create_callbacks=(value); end

  def self._destroy_callbacks(); end

  def self._destroy_callbacks=(value); end

  def self._find_callbacks(); end

  def self._find_callbacks=(value); end

  def self._initialize_callbacks(); end

  def self._initialize_callbacks=(value); end

  def self._reflections(); end

  def self._reflections=(val); end

  def self._reflections?(); end

  def self._rollback_callbacks(); end

  def self._rollback_callbacks=(value); end

  def self._rollback_without_transaction_enrollment_callbacks(); end

  def self._rollback_without_transaction_enrollment_callbacks=(value); end

  def self._save_callbacks(); end

  def self._save_callbacks=(value); end

  def self._touch_callbacks(); end

  def self._touch_callbacks=(value); end

  def self._update_callbacks(); end

  def self._update_callbacks=(value); end

  def self._validate_callbacks(); end

  def self._validate_callbacks=(value); end

  def self._validation_callbacks(); end

  def self._validation_callbacks=(value); end

  def self._validators(); end

  def self._validators=(val); end

  def self._validators?(); end

  def self.after_find(*args, **options, &block); end

  def self.after_initialize(*args, **options, &block); end

  def self.after_touch(*args, **options, &block); end

  def self.aggregate_reflections(); end

  def self.aggregate_reflections=(val); end

  def self.aggregate_reflections?(); end

  def self.allow_unsafe_raw_sql(); end

  def self.allow_unsafe_raw_sql=(obj); end

  def self.attribute_aliases(); end

  def self.attribute_aliases=(val); end

  def self.attribute_aliases?(); end

  def self.attribute_method_matchers(); end

  def self.attribute_method_matchers=(val); end

  def self.attribute_method_matchers?(); end

  def self.attribute_type_decorations(); end

  def self.attribute_type_decorations=(val); end

  def self.attribute_type_decorations?(); end

  def self.attributes_to_define_after_schema_loads(); end

  def self.attributes_to_define_after_schema_loads=(val); end

  def self.attributes_to_define_after_schema_loads?(); end

  def self.belongs_to_required_by_default(); end

  def self.belongs_to_required_by_default=(obj); end

  def self.cache_timestamp_format(); end

  def self.cache_timestamp_format=(val); end

  def self.cache_timestamp_format?(); end

  def self.cache_versioning(); end

  def self.cache_versioning=(val); end

  def self.cache_versioning?(); end

  def self.collection_cache_versioning(); end

  def self.collection_cache_versioning=(val); end

  def self.collection_cache_versioning?(); end

  def self.configurations(); end

  def self.configurations=(config); end

  def self.connection_handler(); end

  def self.connection_handler=(handler); end

  def self.connection_handlers(); end

  def self.connection_handlers=(obj); end

  def self.default_connection_handler(); end

  def self.default_connection_handler=(val); end

  def self.default_connection_handler?(); end

  def self.default_scope_override(); end

  def self.default_scope_override=(val); end

  def self.default_scopes(); end

  def self.default_scopes=(val); end

  def self.default_timezone(); end

  def self.default_timezone=(obj); end

  def self.defined_enums(); end

  def self.defined_enums=(val); end

  def self.defined_enums?(); end

  def self.dump_schema_after_migration(); end

  def self.dump_schema_after_migration=(obj); end

  def self.dump_schemas(); end

  def self.dump_schemas=(obj); end

  def self.error_on_ignored_order(); end

  def self.error_on_ignored_order=(obj); end

  def self.implicit_order_column(); end

  def self.implicit_order_column=(val); end

  def self.implicit_order_column?(); end

  def self.include_root_in_json(); end

  def self.include_root_in_json=(val); end

  def self.include_root_in_json?(); end

  def self.index_nested_attribute_errors(); end

  def self.index_nested_attribute_errors=(obj); end

  def self.internal_metadata_table_name(); end

  def self.internal_metadata_table_name=(val); end

  def self.internal_metadata_table_name?(); end

  def self.local_stored_attributes(); end

  def self.local_stored_attributes=(local_stored_attributes); end

  def self.lock_optimistically(); end

  def self.lock_optimistically=(val); end

  def self.lock_optimistically?(); end

  def self.logger(); end

  def self.logger=(obj); end

  def self.maintain_test_schema(); end

  def self.maintain_test_schema=(obj); end

  def self.nested_attributes_options(); end

  def self.nested_attributes_options=(val); end

  def self.nested_attributes_options?(); end

  def self.partial_writes(); end

  def self.partial_writes=(val); end

  def self.partial_writes?(); end

  def self.pluralize_table_names(); end

  def self.pluralize_table_names=(val); end

  def self.pluralize_table_names?(); end

  def self.primary_key_prefix_type(); end

  def self.primary_key_prefix_type=(obj); end

  def self.reading_role(); end

  def self.reading_role=(obj); end

  def self.record_timestamps(); end

  def self.record_timestamps=(val); end

  def self.record_timestamps?(); end

  def self.schema_format(); end

  def self.schema_format=(obj); end

  def self.schema_migrations_table_name(); end

  def self.schema_migrations_table_name=(val); end

  def self.schema_migrations_table_name?(); end

  def self.skip_time_zone_conversion_for_attributes(); end

  def self.skip_time_zone_conversion_for_attributes=(val); end

  def self.skip_time_zone_conversion_for_attributes?(); end

  def self.store_full_sti_class(); end

  def self.store_full_sti_class=(val); end

  def self.store_full_sti_class?(); end

  def self.table_name_prefix(); end

  def self.table_name_prefix=(val); end

  def self.table_name_prefix?(); end

  def self.table_name_suffix(); end

  def self.table_name_suffix=(val); end

  def self.table_name_suffix?(); end

  def self.time_zone_aware_attributes(); end

  def self.time_zone_aware_attributes=(obj); end

  def self.time_zone_aware_types(); end

  def self.time_zone_aware_types=(val); end

  def self.time_zone_aware_types?(); end

  def self.timestamped_migrations(); end

  def self.timestamped_migrations=(obj); end

  def self.verbose_query_logs(); end

  def self.verbose_query_logs=(obj); end

  def self.warn_on_records_fetched_greater_than(); end

  def self.warn_on_records_fetched_greater_than=(obj); end

  def self.writing_role(); end

  def self.writing_role=(obj); end
end

module ActiveRecord::Batches
  def find_each(start: T.unsafe(nil), finish: T.unsafe(nil), batch_size: T.unsafe(nil), error_on_ignore: T.unsafe(nil)); end

  def find_in_batches(start: T.unsafe(nil), finish: T.unsafe(nil), batch_size: T.unsafe(nil), error_on_ignore: T.unsafe(nil)); end

  def in_batches(of: T.unsafe(nil), start: T.unsafe(nil), finish: T.unsafe(nil), load: T.unsafe(nil), error_on_ignore: T.unsafe(nil)); end
  ORDER_IGNORE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Batches::BatchEnumerator
  include ::Enumerable
  def delete_all(*args, &block); end

  def destroy_all(*args, &block); end

  def each(&blk); end

  def each_record(); end

  def initialize(relation:, of: T.unsafe(nil), start: T.unsafe(nil), finish: T.unsafe(nil)); end

  def update_all(*args, &block); end
end

module ActiveRecord::Calculations
  def average(column_name); end

  def calculate(operation, column_name); end

  def count(column_name=T.unsafe(nil)); end

  def ids(); end

  def maximum(column_name); end

  def minimum(column_name); end

  def pick(*column_names); end

  def pluck(*column_names); end

  def sum(column_name=T.unsafe(nil)); end
end

module ActiveRecord::Calculations
end

module ActiveRecord::Callbacks
  def destroy(); end

  def increment!(attribute, by=T.unsafe(nil), touch: T.unsafe(nil)); end

  def touch(*_, **_1); end
  CALLBACKS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Callbacks
  extend ::ActiveSupport::Concern
end

class ActiveRecord::ConcurrentMigrationError
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
  RELEASE_LOCK_FAILED_MESSAGE = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter
  include ::ActiveSupport::Callbacks
  include ::ActiveRecord::ConnectionAdapters::SchemaStatements
  include ::ActiveRecord::Migration::JoinTable
  include ::ActiveRecord::ConnectionAdapters::DatabaseStatements
  include ::ActiveRecord::ConnectionAdapters::Quoting
  include ::ActiveRecord::ConnectionAdapters::DatabaseLimits
  include ::ActiveRecord::ConnectionAdapters::QueryCache
  include ::ActiveRecord::ConnectionAdapters::Savepoints
  def __callbacks(); end

  def __callbacks?(); end

  def _checkin_callbacks(); end

  def _checkout_callbacks(); end

  def _run_checkin_callbacks(&block); end

  def _run_checkout_callbacks(&block); end

  def active?(); end

  def adapter_name(); end

  def advisory_locks_enabled?(); end

  def build_insert_sql(insert); end

  def case_insensitive_comparison(attribute, value); end

  def case_sensitive_comparison(attribute, value); end

  def check_version(); end

  def clear_cache!(); end

  def close(); end

  def column_name_for_operation(operation, node); end

  def database_version(); end

  def default_index_type?(index); end

  def default_uniqueness_comparison(attribute, value, klass); end

  def delete(*_); end

  def disable_extension(name); end

  def disable_referential_integrity(); end

  def discard!(); end

  def disconnect!(); end

  def enable_extension(name); end

  def exec_insert_all(*_); end

  def expire(); end

  def extensions(); end

  def get_advisory_lock(lock_id); end

  def get_database_version(); end

  def in_use?(); end

  def index_algorithms(); end

  def initialize(connection, logger=T.unsafe(nil), config=T.unsafe(nil)); end

  def insert(*_); end

  def lease(); end

  def lock(); end

  def logger(); end

  def migration_context(); end

  def migrations_paths(); end

  def owner(); end

  def pool(); end

  def pool=(pool); end

  def prefetch_primary_key?(table_name=T.unsafe(nil)); end

  def prepared_statements(); end

  def prepared_statements_disabled_cache(); end

  def preventing_writes?(); end

  def raw_connection(); end

  def reconnect!(); end

  def release_advisory_lock(lock_id); end

  def replica?(); end

  def requires_reloading?(); end

  def reset!(); end

  def rollback_db_transaction(*_); end

  def rollback_to_savepoint(*_); end

  def schema_cache(); end

  def schema_cache=(cache); end

  def schema_migration(); end

  def seconds_idle(); end

  def steal!(); end

  def supports_advisory_locks?(); end

  def supports_bulk_alter?(); end

  def supports_comments?(); end

  def supports_comments_in_create?(); end

  def supports_common_table_expressions?(); end

  def supports_datetime_with_precision?(); end

  def supports_ddl_transactions?(); end

  def supports_explain?(); end

  def supports_expression_index?(); end

  def supports_extensions?(); end

  def supports_foreign_keys?(); end

  def supports_foreign_keys_in_create?(*args, &block); end

  def supports_foreign_tables?(); end

  def supports_index_sort_order?(); end

  def supports_indexes_in_create?(); end

  def supports_insert_conflict_target?(); end

  def supports_insert_on_duplicate_skip?(); end

  def supports_insert_on_duplicate_update?(); end

  def supports_insert_returning?(); end

  def supports_json?(); end

  def supports_lazy_transactions?(); end

  def supports_materialized_views?(); end

  def supports_multi_insert?(*args, &block); end

  def supports_optimizer_hints?(); end

  def supports_partial_index?(); end

  def supports_partitioned_indexes?(); end

  def supports_savepoints?(); end

  def supports_transaction_isolation?(); end

  def supports_validate_constraints?(); end

  def supports_views?(); end

  def supports_virtual_columns?(); end

  def truncate(*_); end

  def truncate_tables(*_); end

  def unprepared_statement(); end

  def update(*_); end

  def valid_type?(type); end

  def verify!(); end

  def visitor(); end
  ADAPTER_NAME = ::T.let(nil, ::T.untyped)
  COMMENT_REGEX = ::T.let(nil, ::T.untyped)
  SIMPLE_INT = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter::SchemaCreation
  def accept(o); end

  def initialize(conn); end
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter::SchemaCreation
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter::Version
  include ::Comparable
  def full_version_string(); end

  def initialize(version_string, full_version_string=T.unsafe(nil)); end
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter::Version
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._checkin_callbacks(); end

  def self._checkin_callbacks=(value); end

  def self._checkout_callbacks(); end

  def self._checkout_callbacks=(value); end

  def self.build_read_query_regexp(*parts); end

  def self.database_exists?(config); end

  def self.quoted_column_names(); end

  def self.quoted_table_names(); end

  def self.type_cast_config_to_boolean(config); end

  def self.type_cast_config_to_integer(config); end
end

module ActiveRecord::ConnectionAdapters::AbstractPool
  def get_schema_cache(connection); end

  def set_schema_cache(cache); end
end

module ActiveRecord::ConnectionAdapters::AbstractPool
end

class ActiveRecord::ConnectionAdapters::AlterTable
  def add_column(name, type, **options); end

  def add_foreign_key(to_table, options); end

  def adds(); end

  def drop_foreign_key(name); end

  def foreign_key_adds(); end

  def foreign_key_drops(); end

  def initialize(td); end

  def name(); end
end

class ActiveRecord::ConnectionAdapters::AlterTable
end

class ActiveRecord::ConnectionAdapters::ChangeColumnDefinition
  def column(); end

  def column=(_); end

  def name(); end

  def name=(_); end
end

class ActiveRecord::ConnectionAdapters::ChangeColumnDefinition
  def self.[](*_); end

  def self.members(); end
end

module ActiveRecord::ConnectionAdapters::ColumnMethods
  extend ::ActiveSupport::Concern
end

class ActiveRecord::ConnectionAdapters::ConnectionPool
  include ::MonitorMixin
  include ::ActiveRecord::ConnectionAdapters::QueryCache::ConnectionPoolConfiguration
  include ::ActiveRecord::ConnectionAdapters::AbstractPool
  def active_connection?(); end

  def automatic_reconnect(); end

  def automatic_reconnect=(automatic_reconnect); end

  def checkin(conn); end

  def checkout(checkout_timeout=T.unsafe(nil)); end

  def checkout_timeout(); end

  def checkout_timeout=(checkout_timeout); end

  def clear_reloadable_connections(raise_on_acquisition_timeout=T.unsafe(nil)); end

  def clear_reloadable_connections!(); end

  def connected?(); end

  def connection(); end

  def connections(); end

  def discard!(); end

  def disconnect(raise_on_acquisition_timeout=T.unsafe(nil)); end

  def disconnect!(); end

  def flush(minimum_idle=T.unsafe(nil)); end

  def flush!(); end

  def initialize(spec); end

  def lock_thread=(lock_thread); end

  def num_waiting_in_queue(); end

  def reap(); end

  def reaper(); end

  def release_connection(owner_thread=T.unsafe(nil)); end

  def remove(conn); end

  def schema_cache(); end

  def schema_cache=(schema_cache); end

  def size(); end

  def spec(); end

  def stat(); end

  def with_connection(); end
end

module ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue
  def with_a_bias_for(thread); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue::BiasedConditionVariable
  def broadcast(); end

  def broadcast_on_biased(); end

  def initialize(lock, other_cond, preferred_thread); end

  def signal(); end

  def wait(timeout); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue::BiasedConditionVariable
end

module ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::ConnectionLeasingQueue
  include ::ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::ConnectionLeasingQueue
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::Queue
  def add(element); end

  def any_waiting?(); end

  def clear(); end

  def delete(element); end

  def initialize(lock=T.unsafe(nil)); end

  def num_waiting(); end

  def poll(timeout=T.unsafe(nil)); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::Queue
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::Reaper
  def frequency(); end

  def initialize(pool, frequency); end

  def pool(); end

  def run(); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::Reaper
  def self.register_pool(pool, frequency); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool
end

class ActiveRecord::ConnectionAdapters::ConnectionSpecification
  def adapter_method(); end

  def config(); end

  def initialize(name, config, adapter_method); end

  def name(); end

  def to_hash(); end
end

class ActiveRecord::ConnectionAdapters::ConnectionSpecification::ConnectionUrlResolver
  def initialize(url); end

  def to_hash(); end
end

class ActiveRecord::ConnectionAdapters::ConnectionSpecification::ConnectionUrlResolver
end

class ActiveRecord::ConnectionAdapters::ConnectionSpecification::Resolver
  def configurations(); end

  def initialize(configurations); end

  def resolve(config_or_env, pool_name=T.unsafe(nil)); end

  def spec(config); end
end

class ActiveRecord::ConnectionAdapters::ConnectionSpecification::Resolver
end

class ActiveRecord::ConnectionAdapters::ConnectionSpecification
end

module ActiveRecord::ConnectionAdapters::DatabaseLimits
  def allowed_index_name_length(); end

  def column_name_length(*args, &block); end

  def columns_per_multicolumn_index(*args, &block); end

  def columns_per_table(*args, &block); end

  def in_clause_length(); end

  def index_name_length(); end

  def indexes_per_table(*args, &block); end

  def joins_per_query(*args, &block); end

  def max_identifier_length(); end

  def sql_query_length(*args, &block); end

  def table_alias_length(); end

  def table_name_length(*args, &block); end
end

module ActiveRecord::ConnectionAdapters::DatabaseLimits
end

module ActiveRecord::ConnectionAdapters::DatabaseStatements
  def add_transaction_record(record); end

  def begin_db_transaction(); end

  def begin_isolated_db_transaction(isolation); end

  def begin_transaction(*args, &block); end

  def cacheable_query(klass, arel); end

  def commit_db_transaction(); end

  def commit_transaction(*args, &block); end

  def create(arel, name=T.unsafe(nil), pk=T.unsafe(nil), id_value=T.unsafe(nil), sequence_name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def current_transaction(*args, &block); end

  def default_sequence_name(table, column); end

  def delete(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def disable_lazy_transactions!(*args, &block); end

  def empty_insert_statement_value(primary_key=T.unsafe(nil)); end

  def enable_lazy_transactions!(*args, &block); end

  def exec_delete(sql, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def exec_insert(sql, name=T.unsafe(nil), binds=T.unsafe(nil), pk=T.unsafe(nil), sequence_name=T.unsafe(nil)); end

  def exec_insert_all(sql, name); end

  def exec_query(sql, name=T.unsafe(nil), binds=T.unsafe(nil), prepare: T.unsafe(nil)); end

  def exec_rollback_db_transaction(); end

  def exec_update(sql, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def execute(sql, name=T.unsafe(nil)); end

  def initialize(); end

  def insert(arel, name=T.unsafe(nil), pk=T.unsafe(nil), id_value=T.unsafe(nil), sequence_name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def insert_fixture(fixture, table_name); end

  def insert_fixtures_set(fixture_set, tables_to_delete=T.unsafe(nil)); end

  def materialize_transactions(*args, &block); end

  def open_transactions(*args, &block); end

  def query(sql, name=T.unsafe(nil)); end

  def query_value(sql, name=T.unsafe(nil)); end

  def query_values(sql, name=T.unsafe(nil)); end

  def reset_sequence!(table, column, sequence=T.unsafe(nil)); end

  def reset_transaction(); end

  def rollback_db_transaction(); end

  def rollback_to_savepoint(name=T.unsafe(nil)); end

  def rollback_transaction(*args, &block); end

  def sanitize_limit(limit); end

  def select_all(arel, name=T.unsafe(nil), binds=T.unsafe(nil), preparable: T.unsafe(nil)); end

  def select_one(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def select_rows(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def select_value(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def select_values(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def to_sql(arel_or_sql_string, binds=T.unsafe(nil)); end

  def transaction(requires_new: T.unsafe(nil), isolation: T.unsafe(nil), joinable: T.unsafe(nil)); end

  def transaction_isolation_levels(); end

  def transaction_manager(); end

  def transaction_open?(); end

  def transaction_state(); end

  def truncate(table_name, name=T.unsafe(nil)); end

  def truncate_tables(*table_names); end

  def update(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def with_yaml_fallback(value); end

  def within_new_transaction(*args, &block); end

  def write_query?(sql); end
end

module ActiveRecord::ConnectionAdapters::DatabaseStatements
end

module ActiveRecord::ConnectionAdapters::DetermineIfPreparableVisitor
  def accept(object, collector); end

  def preparable(); end

  def preparable=(preparable); end

  def visit_Arel_Nodes_In(o, collector); end

  def visit_Arel_Nodes_NotIn(o, collector); end

  def visit_Arel_Nodes_SqlLiteral(o, collector); end
end

module ActiveRecord::ConnectionAdapters::DetermineIfPreparableVisitor
end

class ActiveRecord::ConnectionAdapters::ForeignKeyDefinition
  def column(); end

  def custom_primary_key?(); end

  def defined_for?(to_table: T.unsafe(nil), **options); end

  def export_name_on_schema_dump?(); end

  def from_table(); end

  def from_table=(_); end

  def name(); end

  def on_delete(); end

  def on_update(); end

  def options(); end

  def options=(_); end

  def primary_key(); end

  def to_table(); end

  def to_table=(_); end

  def validate?(); end

  def validated?(); end
end

class ActiveRecord::ConnectionAdapters::ForeignKeyDefinition
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::ConnectionAdapters::IndexDefinition
  def columns(); end

  def comment(); end

  def initialize(table, name, unique=T.unsafe(nil), columns=T.unsafe(nil), lengths: T.unsafe(nil), orders: T.unsafe(nil), opclasses: T.unsafe(nil), where: T.unsafe(nil), type: T.unsafe(nil), using: T.unsafe(nil), comment: T.unsafe(nil)); end

  def lengths(); end

  def name(); end

  def opclasses(); end

  def orders(); end

  def table(); end

  def type(); end

  def unique(); end

  def using(); end

  def where(); end
end

class ActiveRecord::ConnectionAdapters::IndexDefinition
end

class ActiveRecord::ConnectionAdapters::NullPool
  include ::ActiveRecord::ConnectionAdapters::AbstractPool
end

class ActiveRecord::ConnectionAdapters::NullPool
end

class ActiveRecord::ConnectionAdapters::NullTransaction
  def add_record(record); end

  def closed?(); end

  def joinable?(); end

  def open?(); end

  def state(); end
end

class ActiveRecord::ConnectionAdapters::NullTransaction
end

module ActiveRecord::ConnectionAdapters::QueryCache
  def cache(); end

  def clear_query_cache(); end

  def disable_query_cache!(); end

  def enable_query_cache!(); end

  def initialize(*_); end

  def query_cache(); end

  def query_cache_enabled(); end

  def select_all(arel, name=T.unsafe(nil), binds=T.unsafe(nil), preparable: T.unsafe(nil)); end

  def uncached(); end
end

module ActiveRecord::ConnectionAdapters::QueryCache::ConnectionPoolConfiguration
  def disable_query_cache!(); end

  def enable_query_cache!(); end

  def initialize(*_); end

  def query_cache_enabled(); end
end

module ActiveRecord::ConnectionAdapters::QueryCache::ConnectionPoolConfiguration
end

module ActiveRecord::ConnectionAdapters::QueryCache
  def self.dirties_query_cache(base, *method_names); end

  def self.included(base); end
end

module ActiveRecord::ConnectionAdapters::Quoting
  def column_name_matcher(); end

  def column_name_with_order_matcher(); end

  def lookup_cast_type_from_column(column); end

  def quote(value); end

  def quote_column_name(column_name); end

  def quote_default_expression(value, column); end

  def quote_string(s); end

  def quote_table_name(table_name); end

  def quote_table_name_for_assignment(table, attr); end

  def quoted_binary(value); end

  def quoted_date(value); end

  def quoted_false(); end

  def quoted_time(value); end

  def quoted_true(); end

  def sanitize_as_sql_comment(value); end

  def type_cast(value, column=T.unsafe(nil)); end

  def type_cast_from_column(column, value); end

  def unquoted_false(); end

  def unquoted_true(); end
end

module ActiveRecord::ConnectionAdapters::Quoting
end

class ActiveRecord::ConnectionAdapters::RealTransaction
  def commit(); end

  def rollback(); end
end

class ActiveRecord::ConnectionAdapters::RealTransaction
end

class ActiveRecord::ConnectionAdapters::ReferenceDefinition
  def add_to(table); end

  def initialize(name, polymorphic: T.unsafe(nil), index: T.unsafe(nil), foreign_key: T.unsafe(nil), type: T.unsafe(nil), **options); end
end

class ActiveRecord::ConnectionAdapters::ReferenceDefinition
end

class ActiveRecord::ConnectionAdapters::SavepointTransaction
  def commit(); end

  def initialize(connection, savepoint_name, parent_transaction, *args, **options); end

  def rollback(); end
end

class ActiveRecord::ConnectionAdapters::SavepointTransaction
end

module ActiveRecord::ConnectionAdapters::Savepoints
  def create_savepoint(name=T.unsafe(nil)); end

  def current_savepoint_name(); end

  def exec_rollback_to_savepoint(name=T.unsafe(nil)); end

  def release_savepoint(name=T.unsafe(nil)); end
end

module ActiveRecord::ConnectionAdapters::Savepoints
end

class ActiveRecord::ConnectionAdapters::SchemaCache
  def add(table_name); end

  def clear!(); end

  def clear_data_source_cache!(name); end

  def columns(table_name); end

  def columns_hash(table_name); end

  def columns_hash?(table_name); end

  def connection(); end

  def connection=(connection); end

  def data_source_exists?(name); end

  def data_sources(name); end

  def database_version(); end

  def encode_with(coder); end

  def indexes(table_name); end

  def init_with(coder); end

  def initialize(conn); end

  def marshal_dump(); end

  def marshal_load(array); end

  def primary_keys(table_name); end

  def size(); end

  def version(); end
end

class ActiveRecord::ConnectionAdapters::SchemaCache
end

ActiveRecord::ConnectionAdapters::SchemaCreation = ActiveRecord::ConnectionAdapters::AbstractAdapter::SchemaCreation

class ActiveRecord::ConnectionAdapters::SchemaDumper
end

class ActiveRecord::ConnectionAdapters::SchemaDumper
  def self.create(connection, options); end
end

module ActiveRecord::ConnectionAdapters::SchemaStatements
  include ::ActiveRecord::Migration::JoinTable
  def add_belongs_to(table_name, ref_name, **options); end

  def add_column(table_name, column_name, type, **options); end

  def add_foreign_key(from_table, to_table, **options); end

  def add_index(table_name, column_name, options=T.unsafe(nil)); end

  def add_index_options(table_name, column_name, comment: T.unsafe(nil), **options); end

  def add_reference(table_name, ref_name, **options); end

  def add_timestamps(table_name, **options); end

  def assume_migrated_upto_version(version, migrations_paths=T.unsafe(nil)); end

  def change_column(table_name, column_name, type, options=T.unsafe(nil)); end

  def change_column_comment(table_name, column_name, comment_or_changes); end

  def change_column_default(table_name, column_name, default_or_changes); end

  def change_column_null(table_name, column_name, null, default=T.unsafe(nil)); end

  def change_table(table_name, **options); end

  def change_table_comment(table_name, comment_or_changes); end

  def column_exists?(table_name, column_name, type=T.unsafe(nil), **options); end

  def columns(table_name); end

  def columns_for_distinct(columns, orders); end

  def create_join_table(table_1, table_2, column_options: T.unsafe(nil), **options); end

  def create_schema_dumper(options); end

  def create_table(table_name, **options); end

  def data_source_exists?(name); end

  def data_sources(); end

  def drop_join_table(table_1, table_2, **options); end

  def drop_table(table_name, **options); end

  def dump_schema_information(); end

  def foreign_key_column_for(table_name); end

  def foreign_key_exists?(from_table, to_table=T.unsafe(nil), **options); end

  def foreign_key_options(from_table, to_table, options); end

  def foreign_keys(table_name); end

  def index_exists?(table_name, column_name, options=T.unsafe(nil)); end

  def index_name(table_name, options); end

  def index_name_exists?(table_name, index_name); end

  def indexes(table_name); end

  def internal_string_options_for_primary_key(); end

  def native_database_types(); end

  def options_include_default?(options); end

  def primary_key(table_name); end

  def remove_belongs_to(table_name, ref_name, foreign_key: T.unsafe(nil), polymorphic: T.unsafe(nil), **options); end

  def remove_column(table_name, column_name, type=T.unsafe(nil), **options); end

  def remove_columns(table_name, *column_names); end

  def remove_foreign_key(from_table, to_table=T.unsafe(nil), **options); end

  def remove_index(table_name, options=T.unsafe(nil)); end

  def remove_reference(table_name, ref_name, foreign_key: T.unsafe(nil), polymorphic: T.unsafe(nil), **options); end

  def remove_timestamps(table_name, **options); end

  def rename_column(table_name, column_name, new_column_name); end

  def rename_index(table_name, old_name, new_name); end

  def rename_table(table_name, new_name); end

  def table_alias_for(table_name); end

  def table_comment(table_name); end

  def table_exists?(table_name); end

  def table_options(table_name); end

  def tables(); end

  def type_to_sql(type, limit: T.unsafe(nil), precision: T.unsafe(nil), scale: T.unsafe(nil), **_); end

  def update_table_definition(table_name, base); end

  def view_exists?(view_name); end

  def views(); end
end

module ActiveRecord::ConnectionAdapters::SchemaStatements
end

class ActiveRecord::ConnectionAdapters::SqlTypeMetadata
  def ==(other); end

  def eql?(other); end

  def initialize(sql_type: T.unsafe(nil), type: T.unsafe(nil), limit: T.unsafe(nil), precision: T.unsafe(nil), scale: T.unsafe(nil)); end

  def limit(); end

  def precision(); end

  def scale(); end

  def sql_type(); end

  def type(); end
end

class ActiveRecord::ConnectionAdapters::SqlTypeMetadata
end

class ActiveRecord::ConnectionAdapters::Table
  def bigint(*names, **options); end

  def binary(*names, **options); end

  def boolean(*names, **options); end

  def date(*names, **options); end

  def datetime(*names, **options); end

  def decimal(*names, **options); end

  def float(*names, **options); end

  def initialize(table_name, base); end

  def integer(*names, **options); end

  def json(*names, **options); end

  def name(); end

  def numeric(*names, **options); end

  def string(*names, **options); end

  def text(*names, **options); end

  def time(*names, **options); end

  def timestamp(*names, **options); end

  def virtual(*names, **options); end
end

class ActiveRecord::ConnectionAdapters::TableDefinition
  def as(); end

  def bigint(*names, **options); end

  def binary(*names, **options); end

  def boolean(*names, **options); end

  def comment(); end

  def date(*names, **options); end

  def datetime(*names, **options); end

  def decimal(*names, **options); end

  def float(*names, **options); end

  def foreign_key(table_name, **options); end

  def foreign_keys(); end

  def if_not_exists(); end

  def indexes(); end

  def initialize(conn, name, temporary: T.unsafe(nil), if_not_exists: T.unsafe(nil), options: T.unsafe(nil), as: T.unsafe(nil), comment: T.unsafe(nil), **_); end

  def integer(*names, **options); end

  def json(*names, **options); end

  def name(); end

  def new_column_definition(name, type, **options); end

  def numeric(*names, **options); end

  def options(); end

  def primary_keys(name=T.unsafe(nil)); end

  def string(*names, **options); end

  def temporary(); end

  def text(*names, **options); end

  def time(*names, **options); end

  def timestamp(*names, **options); end

  def virtual(*names, **options); end
end

class ActiveRecord::ConnectionAdapters::Transaction
  def add_record(record); end

  def before_commit_records(); end

  def closed?(); end

  def commit_records(); end

  def connection(); end

  def full_rollback?(); end

  def initialize(connection, options, run_commit_callbacks: T.unsafe(nil)); end

  def isolation_level(); end

  def joinable?(); end

  def materialize!(); end

  def materialized?(); end

  def open?(); end

  def records(); end

  def rollback_records(); end

  def savepoint_name(); end

  def state(); end
end

class ActiveRecord::ConnectionAdapters::Transaction
end

class ActiveRecord::ConnectionAdapters::TransactionManager
  def begin_transaction(options=T.unsafe(nil)); end

  def commit_transaction(); end

  def current_transaction(); end

  def disable_lazy_transactions!(); end

  def enable_lazy_transactions!(); end

  def initialize(connection); end

  def lazy_transactions_enabled?(); end

  def materialize_transactions(); end

  def open_transactions(); end

  def rollback_transaction(transaction=T.unsafe(nil)); end

  def within_new_transaction(options=T.unsafe(nil)); end
  NULL_TRANSACTION = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::TransactionManager
end

class ActiveRecord::ConnectionAdapters::TransactionState
  def add_child(state); end

  def commit!(); end

  def committed?(); end

  def completed?(); end

  def finalized?(); end

  def full_commit!(); end

  def full_rollback!(); end

  def fully_committed?(); end

  def fully_completed?(); end

  def fully_rolledback?(); end

  def initialize(state=T.unsafe(nil)); end

  def nullify!(); end

  def rollback!(); end

  def rolledback?(); end
end

class ActiveRecord::ConnectionAdapters::TransactionState
end

module ActiveRecord::ConnectionAdapters
  extend ::ActiveSupport::Autoload
end

module ActiveRecord::ConnectionHandling
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
  RAILS_ENV = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::CounterCache::ClassMethods
  def decrement_counter(counter_name, id, touch: T.unsafe(nil)); end

  def increment_counter(counter_name, id, touch: T.unsafe(nil)); end

  def reset_counters(id, *counters, touch: T.unsafe(nil)); end

  def update_counters(id, counters); end
end

module ActiveRecord::CounterCache::ClassMethods
end

module ActiveRecord::CounterCache
  extend ::ActiveSupport::Concern
end

class ActiveRecord::DuplicateMigrationNameError
  def initialize(name=T.unsafe(nil)); end
end

class ActiveRecord::DuplicateMigrationVersionError
  def initialize(version=T.unsafe(nil)); end
end

class ActiveRecord::DynamicMatchers::FindBy
end

class ActiveRecord::DynamicMatchers::FindBy
end

class ActiveRecord::DynamicMatchers::FindByBang
end

class ActiveRecord::DynamicMatchers::FindByBang
end

class ActiveRecord::DynamicMatchers::Method
  def attribute_names(); end

  def define(); end

  def initialize(model, method_name); end

  def model(); end

  def name(); end

  def valid?(); end
end

class ActiveRecord::DynamicMatchers::Method
  def self.match(model, name); end

  def self.matchers(); end

  def self.pattern(); end

  def self.prefix(); end

  def self.suffix(); end
end

class ActiveRecord::EnvironmentMismatchError
  def initialize(current: T.unsafe(nil), stored: T.unsafe(nil)); end
end

module ActiveRecord::Explain
  def collecting_queries_for_explain(); end

  def exec_explain(queries); end
end

module ActiveRecord::FinderMethods
  def exists?(conditions=T.unsafe(nil)); end

  def fifth(); end

  def fifth!(); end

  def find(*args); end

  def find_by(arg, *args); end

  def find_by!(arg, *args); end

  def first(limit=T.unsafe(nil)); end

  def first!(); end

  def forty_two(); end

  def forty_two!(); end

  def fourth(); end

  def fourth!(); end

  def last(limit=T.unsafe(nil)); end

  def last!(); end

  def raise_record_not_found_exception!(ids=T.unsafe(nil), result_size=T.unsafe(nil), expected_size=T.unsafe(nil), key=T.unsafe(nil), not_found_ids=T.unsafe(nil)); end

  def second(); end

  def second!(); end

  def second_to_last(); end

  def second_to_last!(); end

  def take(limit=T.unsafe(nil)); end

  def take!(); end

  def third(); end

  def third!(); end

  def third_to_last(); end

  def third_to_last!(); end
  ONE_AS_ONE = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::FinderMethods
end

class ActiveRecord::IllegalMigrationNameError
  def initialize(name=T.unsafe(nil)); end
end

module ActiveRecord::Inheritance::ClassMethods
  def abstract_class?(); end

  def base_class(); end

  def base_class?(); end

  def compute_type(type_name); end

  def descends_from_active_record?(); end

  def finder_needs_type_condition?(); end

  def inherited(subclass); end

  def new(attributes=T.unsafe(nil), &block); end

  def polymorphic_name(); end

  def sti_name(); end
end

module ActiveRecord::Inheritance
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Integration
  def cache_key(); end

  def cache_key_with_version(); end

  def cache_version(); end

  def to_param(); end
end

module ActiveRecord::Integration::ClassMethods
  def collection_cache_key(collection=T.unsafe(nil), timestamp_column=T.unsafe(nil)); end

  def to_param(method_name=T.unsafe(nil)); end
end

module ActiveRecord::Integration::ClassMethods
end

module ActiveRecord::Integration
  extend ::ActiveSupport::Concern
end

class ActiveRecord::InternalMetadata
  include ::ActiveRecord::InternalMetadata::GeneratedAttributeMethods
  include ::ActiveRecord::InternalMetadata::GeneratedAssociationMethods
end

module ActiveRecord::InternalMetadata::GeneratedAssociationMethods
end

module ActiveRecord::InternalMetadata::GeneratedAssociationMethods
end

module ActiveRecord::InternalMetadata::GeneratedAttributeMethods
end

module ActiveRecord::InternalMetadata::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActiveRecord::LegacyYamlAdapter
end

module ActiveRecord::LegacyYamlAdapter::Rails41
end

module ActiveRecord::LegacyYamlAdapter::Rails41
  def self.convert(klass, coder); end
end

module ActiveRecord::LegacyYamlAdapter::Rails420
end

module ActiveRecord::LegacyYamlAdapter::Rails420
  def self.convert(klass, coder); end
end

module ActiveRecord::LegacyYamlAdapter
  def self.convert(klass, coder); end
end

class ActiveRecord::Locking::LockingType
  def deserialize(value); end

  def encode_with(coder); end

  def init_with(coder); end

  def serialize(value); end
end

class ActiveRecord::Locking::LockingType
end

module ActiveRecord::Locking::Optimistic
  def locking_enabled?(); end
end

module ActiveRecord::Locking::Optimistic
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Locking::Pessimistic
  def lock!(lock=T.unsafe(nil)); end
end

module ActiveRecord::Locking
  extend ::ActiveSupport::Autoload
end

module ActiveRecord::Middleware
end

class ActiveRecord::Middleware::DatabaseSelector
  def call(env); end

  def context_klass(); end

  def initialize(app, resolver_klass=T.unsafe(nil), context_klass=T.unsafe(nil), options=T.unsafe(nil)); end

  def options(); end

  def resolver_klass(); end
end

class ActiveRecord::Middleware::DatabaseSelector::Resolver
  def context(); end

  def delay(); end

  def initialize(context, options=T.unsafe(nil)); end

  def instrumenter(); end

  def read(&blk); end

  def write(&blk); end
  SEND_TO_REPLICA_DELAY = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Middleware::DatabaseSelector::Resolver::Session
  def initialize(session); end

  def last_write_timestamp(); end

  def session(); end

  def update_last_write_timestamp(); end
end

class ActiveRecord::Middleware::DatabaseSelector::Resolver::Session
  def self.call(request); end

  def self.convert_time_to_timestamp(time); end

  def self.convert_timestamp_to_time(timestamp); end
end

class ActiveRecord::Middleware::DatabaseSelector::Resolver
  def self.call(context, options=T.unsafe(nil)); end
end

class ActiveRecord::Middleware::DatabaseSelector
end

module ActiveRecord::Middleware
  extend ::ActiveSupport::Autoload
end

class ActiveRecord::Migration
  def announce(message); end

  def connection(); end

  def copy(destination, sources, options=T.unsafe(nil)); end

  def disable_ddl_transaction(); end

  def down(); end

  def exec_migration(conn, direction); end

  def initialize(name=T.unsafe(nil), version=T.unsafe(nil)); end

  def method_missing(method, *arguments, &block); end

  def migrate(direction); end

  def name(); end

  def name=(name); end

  def next_migration_number(number); end

  def proper_table_name(name, options=T.unsafe(nil)); end

  def reversible(); end

  def revert(*migration_classes); end

  def reverting?(); end

  def run(*migration_classes); end

  def say(message, subitem=T.unsafe(nil)); end

  def say_with_time(message); end

  def suppress_messages(); end

  def table_name_options(config=T.unsafe(nil)); end

  def up(); end

  def up_only(); end

  def verbose(); end

  def verbose=(obj); end

  def version(); end

  def version=(version); end

  def write(text=T.unsafe(nil)); end
end

class ActiveRecord::Migration::CheckPending
  def call(env); end

  def initialize(app); end
end

class ActiveRecord::Migration::CheckPending
end

class ActiveRecord::Migration::CommandRecorder
  include ::ActiveRecord::Migration::JoinTable
  include ::ActiveRecord::Migration::CommandRecorder::StraightReversions
  def add_belongs_to(*args, &block); end

  def add_column(*args, &block); end

  def add_foreign_key(*args, &block); end

  def add_index(*args, &block); end

  def add_reference(*args, &block); end

  def add_timestamps(*args, &block); end

  def change_column(*args, &block); end

  def change_column_comment(*args, &block); end

  def change_column_default(*args, &block); end

  def change_column_null(*args, &block); end

  def change_table(table_name, **options); end

  def change_table_comment(*args, &block); end

  def commands(); end

  def commands=(commands); end

  def create_join_table(*args, &block); end

  def create_table(*args, &block); end

  def delegate(); end

  def delegate=(delegate); end

  def disable_extension(*args, &block); end

  def drop_join_table(*args, &block); end

  def drop_table(*args, &block); end

  def enable_extension(*args, &block); end

  def execute(*args, &block); end

  def execute_block(*args, &block); end

  def initialize(delegate=T.unsafe(nil)); end

  def inverse_of(command, args, &block); end

  def invert_add_belongs_to(args, &block); end

  def invert_remove_belongs_to(args, &block); end

  def record(*command, &block); end

  def remove_belongs_to(*args, &block); end

  def remove_column(*args, &block); end

  def remove_columns(*args, &block); end

  def remove_foreign_key(*args, &block); end

  def remove_index(*args, &block); end

  def remove_reference(*args, &block); end

  def remove_timestamps(*args, &block); end

  def rename_column(*args, &block); end

  def rename_index(*args, &block); end

  def rename_table(*args, &block); end

  def replay(migration); end

  def revert(); end

  def reverting(); end

  def reverting=(reverting); end

  def transaction(*args, &block); end
  ReversibleAndIrreversibleMethods = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Migration::CommandRecorder::StraightReversions
  def invert_add_column(args, &block); end

  def invert_add_foreign_key(args, &block); end

  def invert_add_reference(args, &block); end

  def invert_add_timestamps(args, &block); end

  def invert_create_join_table(args, &block); end

  def invert_create_table(args, &block); end

  def invert_disable_extension(args, &block); end

  def invert_drop_join_table(args, &block); end

  def invert_drop_table(args, &block); end

  def invert_enable_extension(args, &block); end

  def invert_execute_block(args, &block); end

  def invert_remove_column(args, &block); end

  def invert_remove_foreign_key(args, &block); end

  def invert_remove_reference(args, &block); end

  def invert_remove_timestamps(args, &block); end
end

module ActiveRecord::Migration::CommandRecorder::StraightReversions
end

class ActiveRecord::Migration::CommandRecorder
end

class ActiveRecord::Migration::Compatibility::V4_2
  def index_exists?(table_name, column_name, options=T.unsafe(nil)); end

  def remove_index(table_name, options=T.unsafe(nil)); end
end

module ActiveRecord::Migration::Compatibility::V4_2::TableDefinition
  def belongs_to(*_, **options); end

  def references(*_, **options); end

  def timestamps(**options); end
end

module ActiveRecord::Migration::Compatibility::V4_2::TableDefinition
end

class ActiveRecord::Migration::Compatibility::V4_2
end

class ActiveRecord::Migration::Compatibility::V5_0
  def add_belongs_to(table_name, ref_name, **options); end

  def add_column(table_name, column_name, type, **options); end

  def add_reference(table_name, ref_name, **options); end

  def create_join_table(table_1, table_2, column_options: T.unsafe(nil), **options); end
end

module ActiveRecord::Migration::Compatibility::V5_0::TableDefinition
  def belongs_to(*args, **options); end

  def primary_key(name, type=T.unsafe(nil), **options); end

  def references(*args, **options); end
end

module ActiveRecord::Migration::Compatibility::V5_0::TableDefinition
end

class ActiveRecord::Migration::Compatibility::V5_0
end

class ActiveRecord::Migration::Compatibility::V5_1
  def change_column(table_name, column_name, type, options=T.unsafe(nil)); end
end

class ActiveRecord::Migration::Compatibility::V5_2
  def add_timestamps(table_name, **options); end

  def change_table(table_name, **options); end

  def create_join_table(table_1, table_2, **options); end
end

module ActiveRecord::Migration::Compatibility::V5_2::CommandRecorder
  def invert_change_column_comment(args); end

  def invert_change_table_comment(args); end

  def invert_transaction(args, &block); end
end

module ActiveRecord::Migration::Compatibility::V5_2::CommandRecorder
end

module ActiveRecord::Migration::Compatibility::V5_2::TableDefinition
  def timestamps(**options); end
end

module ActiveRecord::Migration::Compatibility::V5_2::TableDefinition
end

module ActiveRecord::Migration::Compatibility
  def self.find(version); end
end

module ActiveRecord::Migration::JoinTable
end

module ActiveRecord::Migration::JoinTable
end

class ActiveRecord::Migration::ReversibleBlockHelper
  def down(); end

  def reverting(); end

  def reverting=(_); end

  def up(); end
end

class ActiveRecord::Migration::ReversibleBlockHelper
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::Migration
  def self.[](version); end

  def self.check_pending!(connection=T.unsafe(nil)); end

  def self.current_version(); end

  def self.delegate(); end

  def self.delegate=(delegate); end

  def self.disable_ddl_transaction(); end

  def self.disable_ddl_transaction!(); end

  def self.disable_ddl_transaction=(disable_ddl_transaction); end

  def self.inherited(subclass); end

  def self.load_schema_if_pending!(); end

  def self.maintain_test_schema!(); end

  def self.method_missing(name, *args, &block); end

  def self.migrate(direction); end

  def self.nearest_delegate(); end

  def self.verbose(); end

  def self.verbose=(obj); end
end

class ActiveRecord::MigrationContext
  def any_migrations?(); end

  def current_environment(); end

  def current_version(); end

  def down(target_version=T.unsafe(nil)); end

  def forward(steps=T.unsafe(nil)); end

  def get_all_versions(); end

  def initialize(migrations_paths, schema_migration); end

  def last_migration(); end

  def last_stored_environment(); end

  def migrate(target_version=T.unsafe(nil), &block); end

  def migrations(); end

  def migrations_paths(); end

  def migrations_status(); end

  def needs_migration?(); end

  def open(); end

  def protected_environment?(); end

  def rollback(steps=T.unsafe(nil)); end

  def run(direction, target_version); end

  def schema_migration(); end

  def up(target_version=T.unsafe(nil)); end
end

class ActiveRecord::MigrationContext
end

class ActiveRecord::MigrationError
  def initialize(message=T.unsafe(nil)); end
end

class ActiveRecord::MismatchedForeignKey
  def initialize(message: T.unsafe(nil), sql: T.unsafe(nil), binds: T.unsafe(nil), table: T.unsafe(nil), foreign_key: T.unsafe(nil), target_table: T.unsafe(nil), primary_key: T.unsafe(nil), primary_key_column: T.unsafe(nil)); end
end

module ActiveRecord::ModelSchema::ClassMethods
  def _default_attributes(); end

  def attribute_types(); end

  def attributes_builder(); end

  def column_names(); end

  def full_table_name_prefix(); end

  def full_table_name_suffix(); end

  def initialize_load_schema_monitor(); end

  def next_sequence_value(); end

  def reset_column_information(); end

  def reset_sequence_name(); end

  def reset_table_name(); end

  def symbol_column_to_string(name_symbol); end

  def type_for_attribute(attr_name, &block); end

  def yaml_encoder(); end
end

module ActiveRecord::ModelSchema
  extend ::ActiveSupport::Concern
  def self.derive_join_table_name(first_table, second_table); end
end

class ActiveRecord::MultiparameterAssignmentErrors
  def errors(); end

  def initialize(errors=T.unsafe(nil)); end
end

module ActiveRecord::NestedAttributes
  def _destroy(); end
  UNASSIGNABLE_KEYS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::NestedAttributes::ClassMethods
  REJECT_ALL_BLANK_PROC = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::NestedAttributes::TooManyRecords
end

class ActiveRecord::NestedAttributes::TooManyRecords
end

module ActiveRecord::NestedAttributes
  extend ::ActiveSupport::Concern
end

class ActiveRecord::NoEnvironmentInSchemaError
  def initialize(); end
end

module ActiveRecord::NoTouching
  def no_touching?(); end

  def touch(*_, **_1); end

  def touch_later(*_, **_1); end
end

module ActiveRecord::NoTouching::ClassMethods
  def no_touching(&block); end
end

module ActiveRecord::NoTouching::ClassMethods
end

module ActiveRecord::NoTouching
  extend ::ActiveSupport::Concern
  def self.applied_to?(klass); end

  def self.apply_to(klass); end
end

class ActiveRecord::NullMigration
  def initialize(); end
end

class ActiveRecord::NullMigration
end

module ActiveRecord::NullRelation
  def any?(); end

  def calculate(operation, _column_name); end

  def delete(_id_or_array); end

  def delete_all(); end

  def empty?(); end

  def exists?(_conditions=T.unsafe(nil)); end

  def many?(); end

  def none?(); end

  def one?(); end

  def or(other); end

  def pluck(*column_names); end

  def to_sql(); end

  def update_all(_updates); end
end

module ActiveRecord::NullRelation
end

class ActiveRecord::PendingMigrationError
  include ::ActiveSupport::ActionableError
  def _actions(); end

  def _actions=(val); end

  def _actions?(); end
end

class ActiveRecord::PendingMigrationError
  def self._actions(); end

  def self._actions=(val); end

  def self._actions?(); end
end

module ActiveRecord::Persistence::ClassMethods
  def _delete_record(constraints); end

  def _insert_record(values); end

  def _update_record(values, constraints); end
end

module ActiveRecord::Persistence
  extend ::ActiveSupport::Concern
end

class ActiveRecord::PredicateBuilder
  def build(attribute, value); end

  def build_bind_attribute(column_name, value); end

  def build_from_hash(attributes); end

  def expand_from_hash(attributes); end

  def initialize(table); end

  def register_handler(klass, handler); end

  def resolve_column_aliases(*args, &block); end
end

class ActiveRecord::PredicateBuilder::ArrayHandler
  def call(attribute, value); end

  def initialize(predicate_builder); end
end

module ActiveRecord::PredicateBuilder::ArrayHandler::NullPredicate
end

module ActiveRecord::PredicateBuilder::ArrayHandler::NullPredicate
  def self.or(other); end
end

class ActiveRecord::PredicateBuilder::ArrayHandler
end

class ActiveRecord::PredicateBuilder::AssociationQueryValue
  def initialize(associated_table, value); end

  def queries(); end
end

class ActiveRecord::PredicateBuilder::AssociationQueryValue
end

class ActiveRecord::PredicateBuilder::BaseHandler
  def call(attribute, value); end

  def initialize(predicate_builder); end
end

class ActiveRecord::PredicateBuilder::BaseHandler
end

class ActiveRecord::PredicateBuilder::BasicObjectHandler
  def call(attribute, value); end

  def initialize(predicate_builder); end
end

class ActiveRecord::PredicateBuilder::BasicObjectHandler
end

class ActiveRecord::PredicateBuilder::PolymorphicArrayValue
  def initialize(associated_table, values); end

  def queries(); end
end

class ActiveRecord::PredicateBuilder::PolymorphicArrayValue
end

class ActiveRecord::PredicateBuilder::RangeHandler
  def call(attribute, value); end

  def initialize(predicate_builder); end
end

class ActiveRecord::PredicateBuilder::RangeHandler::RangeWithBinds
  def begin(); end

  def begin=(_); end

  def end(); end

  def end=(_); end

  def exclude_end?(); end
end

class ActiveRecord::PredicateBuilder::RangeHandler::RangeWithBinds
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::PredicateBuilder::RangeHandler
end

class ActiveRecord::PredicateBuilder::RelationHandler
  def call(attribute, value); end
end

class ActiveRecord::PredicateBuilder::RelationHandler
end

class ActiveRecord::PredicateBuilder
  def self.references(attributes); end
end

class ActiveRecord::ProtectedEnvironmentError
  def initialize(env=T.unsafe(nil)); end
end

module ActiveRecord::QueryCache::ClassMethods
  def cache(&block); end

  def uncached(&block); end
end

class ActiveRecord::QueryCache
  def self.complete(pools); end

  def self.install_executor_hooks(executor=T.unsafe(nil)); end

  def self.run(); end
end

module ActiveRecord::QueryMethods
  include ::ActiveModel::ForbiddenAttributesProtection
  def _select!(*fields); end

  def annotate(*args); end

  def annotate!(*args); end

  def annotate_values(); end

  def annotate_values=(value); end

  def arel(aliases=T.unsafe(nil)); end

  def build_subquery(subquery_alias, select_value); end

  def construct_join_dependency(associations, join_type); end

  def create_with(value); end

  def create_with!(value); end

  def create_with_value(); end

  def create_with_value=(value); end

  def distinct(value=T.unsafe(nil)); end

  def distinct!(value=T.unsafe(nil)); end

  def distinct_value(); end

  def distinct_value=(value); end

  def eager_load(*args); end

  def eager_load!(*args); end

  def eager_load_values(); end

  def eager_load_values=(value); end

  def extending(*modules, &block); end

  def extending!(*modules, &block); end

  def extending_values(); end

  def extending_values=(value); end

  def extensions(); end

  def extract_associated(association); end

  def from(value, subquery_name=T.unsafe(nil)); end

  def from!(value, subquery_name=T.unsafe(nil)); end

  def from_clause(); end

  def from_clause=(value); end

  def group(*args); end

  def group!(*args); end

  def group_values(); end

  def group_values=(value); end

  def having(opts, *rest); end

  def having!(opts, *rest); end

  def having_clause(); end

  def having_clause=(value); end

  def includes(*args); end

  def includes!(*args); end

  def includes_values(); end

  def includes_values=(value); end

  def joins(*args); end

  def joins!(*args); end

  def joins_values(); end

  def joins_values=(value); end

  def left_joins(*args); end

  def left_outer_joins(*args); end

  def left_outer_joins!(*args); end

  def left_outer_joins_values(); end

  def left_outer_joins_values=(value); end

  def limit(value); end

  def limit!(value); end

  def limit_value(); end

  def limit_value=(value); end

  def lock(locks=T.unsafe(nil)); end

  def lock!(locks=T.unsafe(nil)); end

  def lock_value(); end

  def lock_value=(value); end

  def none(); end

  def none!(); end

  def offset(value); end

  def offset!(value); end

  def offset_value(); end

  def offset_value=(value); end

  def optimizer_hints(*args); end

  def optimizer_hints!(*args); end

  def optimizer_hints_values(); end

  def optimizer_hints_values=(value); end

  def or(other); end

  def or!(other); end

  def order(*args); end

  def order!(*args); end

  def order_values(); end

  def order_values=(value); end

  def preload(*args); end

  def preload!(*args); end

  def preload_values(); end

  def preload_values=(value); end

  def readonly(value=T.unsafe(nil)); end

  def readonly!(value=T.unsafe(nil)); end

  def readonly_value(); end

  def readonly_value=(value); end

  def references(*table_names); end

  def references!(*table_names); end

  def references_values(); end

  def references_values=(value); end

  def reorder(*args); end

  def reorder!(*args); end

  def reordering_value(); end

  def reordering_value=(value); end

  def reselect(*args); end

  def reselect!(*args); end

  def reverse_order(); end

  def reverse_order!(); end

  def reverse_order_value(); end

  def reverse_order_value=(value); end

  def rewhere(conditions); end

  def select(*fields); end

  def select_values(); end

  def select_values=(value); end

  def skip_preloading!(); end

  def skip_query_cache!(value=T.unsafe(nil)); end

  def skip_query_cache_value(); end

  def skip_query_cache_value=(value); end

  def unscope(*args); end

  def unscope!(*args); end

  def unscope_values(); end

  def unscope_values=(value); end

  def where(opts=T.unsafe(nil), *rest); end

  def where!(opts, *rest); end

  def where_clause(); end

  def where_clause=(value); end
  DEFAULT_VALUES = ::T.let(nil, ::T.untyped)
  FROZEN_EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  FROZEN_EMPTY_HASH = ::T.let(nil, ::T.untyped)
  STRUCTURAL_OR_METHODS = ::T.let(nil, ::T.untyped)
  VALID_DIRECTIONS = ::T.let(nil, ::T.untyped)
  VALID_UNSCOPING_VALUES = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::QueryMethods::WhereChain
  include ::ActiveModel::ForbiddenAttributesProtection
  def initialize(scope); end

  def not(opts, *rest); end
end

class ActiveRecord::QueryMethods::WhereChain
end

module ActiveRecord::QueryMethods
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Querying
  def annotate(*args, &block); end

  def any?(*args, &block); end

  def average(*args, &block); end

  def calculate(*args, &block); end

  def count(*args, &block); end

  def count_by_sql(sql); end

  def create_or_find_by(*args, &block); end

  def create_or_find_by!(*args, &block); end

  def create_with(*args, &block); end

  def delete_all(*args, &block); end

  def delete_by(*args, &block); end

  def destroy_all(*args, &block); end

  def destroy_by(*args, &block); end

  def distinct(*args, &block); end

  def eager_load(*args, &block); end

  def except(*args, &block); end

  def exists?(*args, &block); end

  def extending(*args, &block); end

  def extract_associated(*args, &block); end

  def fifth(*args, &block); end

  def fifth!(*args, &block); end

  def find(*args, &block); end

  def find_by(*args, &block); end

  def find_by!(*args, &block); end

  def find_by_sql(sql, binds=T.unsafe(nil), preparable: T.unsafe(nil), &block); end

  def find_each(*args, &block); end

  def find_in_batches(*args, &block); end

  def find_or_create_by(*args, &block); end

  def find_or_create_by!(*args, &block); end

  def find_or_initialize_by(*args, &block); end

  def first(*args, &block); end

  def first!(*args, &block); end

  def first_or_create(*args, &block); end

  def first_or_create!(*args, &block); end

  def first_or_initialize(*args, &block); end

  def forty_two(*args, &block); end

  def forty_two!(*args, &block); end

  def fourth(*args, &block); end

  def fourth!(*args, &block); end

  def from(*args, &block); end

  def group(*args, &block); end

  def having(*args, &block); end

  def ids(*args, &block); end

  def in_batches(*args, &block); end

  def includes(*args, &block); end

  def joins(*args, &block); end

  def last(*args, &block); end

  def last!(*args, &block); end

  def left_joins(*args, &block); end

  def left_outer_joins(*args, &block); end

  def limit(*args, &block); end

  def lock(*args, &block); end

  def many?(*args, &block); end

  def maximum(*args, &block); end

  def merge(*args, &block); end

  def minimum(*args, &block); end

  def none(*args, &block); end

  def none?(*args, &block); end

  def offset(*args, &block); end

  def one?(*args, &block); end

  def only(*args, &block); end

  def optimizer_hints(*args, &block); end

  def or(*args, &block); end

  def order(*args, &block); end

  def pick(*args, &block); end

  def pluck(*args, &block); end

  def preload(*args, &block); end

  def readonly(*args, &block); end

  def references(*args, &block); end

  def reorder(*args, &block); end

  def reselect(*args, &block); end

  def rewhere(*args, &block); end

  def second(*args, &block); end

  def second!(*args, &block); end

  def second_to_last(*args, &block); end

  def second_to_last!(*args, &block); end

  def select(*args, &block); end

  def sum(*args, &block); end

  def take(*args, &block); end

  def take!(*args, &block); end

  def third(*args, &block); end

  def third!(*args, &block); end

  def third_to_last(*args, &block); end

  def third_to_last!(*args, &block); end

  def touch_all(*args, &block); end

  def unscope(*args, &block); end

  def update_all(*args, &block); end

  def where(*args, &block); end
  QUERYING_METHODS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Railtie
end

class ActiveRecord::Railtie
end

class ActiveRecord::ReadOnlyError
end

class ActiveRecord::ReadOnlyError
end

class ActiveRecord::RecordInvalid
  def initialize(record=T.unsafe(nil)); end
end

class ActiveRecord::RecordNotDestroyed
  def initialize(message=T.unsafe(nil), record=T.unsafe(nil)); end

  def record(); end
end

class ActiveRecord::RecordNotFound
  def id(); end

  def initialize(message=T.unsafe(nil), model=T.unsafe(nil), primary_key=T.unsafe(nil), id=T.unsafe(nil)); end

  def model(); end

  def primary_key(); end
end

class ActiveRecord::RecordNotSaved
  def initialize(message=T.unsafe(nil), record=T.unsafe(nil)); end

  def record(); end
end

class ActiveRecord::Reflection::AbstractReflection
  def actual_source_reflection(); end

  def alias_candidate(name); end

  def build_association(attributes, &block); end

  def build_scope(table, predicate_builder=T.unsafe(nil)); end

  def chain(); end

  def check_validity_of_inverse!(); end

  def class_name(); end

  def constraints(); end

  def counter_cache_column(); end

  def counter_must_be_updated_by_has_many?(); end

  def get_join_keys(association_klass); end

  def has_cached_counter?(); end

  def inverse_of(); end

  def inverse_updates_counter_cache?(); end

  def inverse_updates_counter_in_memory?(); end

  def inverse_which_updates_counter_cache(); end

  def join_foreign_key(); end

  def join_keys(); end

  def join_primary_key(*_); end

  def join_scope(table, foreign_table, foreign_klass); end

  def join_scopes(table, predicate_builder); end

  def klass_join_scope(table, predicate_builder); end

  def scopes(); end

  def table_name(); end

  def through_reflection?(); end
end

class ActiveRecord::Reflection::AbstractReflection::JoinKeys
  def foreign_key(); end

  def foreign_key=(_); end

  def key(); end

  def key=(_); end
end

class ActiveRecord::Reflection::AbstractReflection::JoinKeys
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::Reflection::AbstractReflection
end

class ActiveRecord::Reflection::AggregateReflection
  def mapping(); end
end

class ActiveRecord::Reflection::AggregateReflection
end

class ActiveRecord::Reflection::AssociationReflection
  def active_record_primary_key(); end

  def add_as_polymorphic_through(reflection, seed); end

  def add_as_source(seed); end

  def add_as_through(seed); end

  def association_class(); end

  def association_foreign_key(); end

  def association_primary_key(klass=T.unsafe(nil)); end

  def association_scope_cache(conn, owner, &block); end

  def belongs_to?(); end

  def check_eager_loadable!(); end

  def check_preloadable!(); end

  def check_validity!(); end

  def clear_association_scope_cache(); end

  def collect_join_chain(); end

  def collection?(); end

  def constructable?(); end

  def extensions(); end

  def foreign_key(); end

  def foreign_type(); end

  def has_inverse?(); end

  def has_one?(); end

  def has_scope?(); end

  def join_id_for(owner); end

  def join_table(); end

  def macro(); end

  def nested?(); end

  def parent_reflection(); end

  def parent_reflection=(parent_reflection); end

  def polymorphic?(); end

  def polymorphic_inverse_of(associated_class); end

  def source_reflection(); end

  def through_reflection(); end

  def type(); end

  def validate?(); end
  INVALID_AUTOMATIC_INVERSE_OPTIONS = ::T.let(nil, ::T.untyped)
  VALID_AUTOMATIC_INVERSE_MACROS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Reflection::AssociationReflection
end

class ActiveRecord::Reflection::BelongsToReflection
  def join_primary_key(klass=T.unsafe(nil)); end
end

class ActiveRecord::Reflection::BelongsToReflection
end

module ActiveRecord::Reflection::ClassMethods
  def _reflect_on_association(association); end

  def clear_reflections_cache(); end

  def reflect_on_aggregation(aggregation); end

  def reflect_on_all_aggregations(); end

  def reflect_on_all_associations(macro=T.unsafe(nil)); end

  def reflect_on_all_autosave_associations(); end

  def reflect_on_association(association); end

  def reflections(); end
end

module ActiveRecord::Reflection::ClassMethods
end

class ActiveRecord::Reflection::HasAndBelongsToManyReflection
end

class ActiveRecord::Reflection::HasAndBelongsToManyReflection
end

class ActiveRecord::Reflection::HasManyReflection
end

class ActiveRecord::Reflection::HasManyReflection
end

class ActiveRecord::Reflection::HasOneReflection
end

class ActiveRecord::Reflection::HasOneReflection
end

class ActiveRecord::Reflection::MacroReflection
  def ==(other_aggregation); end

  def active_record(); end

  def autosave=(autosave); end

  def compute_class(name); end

  def initialize(name, scope, options, active_record); end

  def klass(); end

  def name(); end

  def options(); end

  def plural_name(); end

  def scope(); end

  def scope_for(relation, owner=T.unsafe(nil)); end
end

class ActiveRecord::Reflection::MacroReflection
end

class ActiveRecord::Reflection::PolymorphicReflection
  def get_join_keys(*args, &block); end

  def initialize(reflection, previous_reflection); end

  def klass(*args, &block); end

  def plural_name(*args, &block); end

  def scope(*args, &block); end

  def scope_for(*args, &block); end

  def type(*args, &block); end
end

class ActiveRecord::Reflection::PolymorphicReflection
end

class ActiveRecord::Reflection::RuntimeReflection
  def aliased_table(); end

  def all_includes(); end

  def constraints(*args, &block); end

  def get_join_keys(*args, &block); end

  def initialize(reflection, association); end

  def klass(); end

  def scope(*args, &block); end

  def type(*args, &block); end
end

class ActiveRecord::Reflection::RuntimeReflection
end

class ActiveRecord::Reflection::ThroughReflection
  def active_record(*args, &block); end

  def active_record_primary_key(*args, &block); end

  def add_as_polymorphic_through(reflection, seed); end

  def add_as_source(seed); end

  def add_as_through(seed); end

  def association_class(*args, &block); end

  def association_foreign_key(*args, &block); end

  def association_primary_key(klass=T.unsafe(nil)); end

  def association_scope_cache(*args, &block); end

  def autosave=(arg); end

  def belongs_to?(*args, &block); end

  def check_eager_loadable!(*args, &block); end

  def check_preloadable!(*args, &block); end

  def check_validity!(); end

  def clear_association_scope_cache(); end

  def collect_join_chain(); end

  def collection?(*args, &block); end

  def compute_class(*args, &block); end

  def constructable?(*args, &block); end

  def extensions(*args, &block); end

  def foreign_key(*args, &block); end

  def foreign_type(*args, &block); end

  def get_join_keys(*args, &block); end

  def has_inverse?(*args, &block); end

  def has_one?(*args, &block); end

  def has_scope?(); end

  def initialize(delegate_reflection); end

  def join_id_for(*args, &block); end

  def join_table(*args, &block); end

  def klass(); end

  def macro(*args, &block); end

  def name(*args, &block); end

  def nested?(); end

  def options(*args, &block); end

  def parent_reflection(*args, &block); end

  def parent_reflection=(arg); end

  def plural_name(*args, &block); end

  def polymorphic?(*args, &block); end

  def polymorphic_inverse_of(*args, &block); end

  def scope(*args, &block); end

  def scope_for(*args, &block); end

  def source_options(); end

  def source_reflection(); end

  def source_reflection_name(); end

  def source_reflection_names(); end

  def through_options(); end

  def through_reflection(); end

  def type(*args, &block); end

  def validate?(*args, &block); end
end

class ActiveRecord::Reflection::ThroughReflection
end

module ActiveRecord::Reflection
  extend ::ActiveSupport::Concern
  def self.add_aggregate_reflection(ar, name, reflection); end

  def self.add_reflection(ar, name, reflection); end

  def self.create(macro, name, scope, options, ar); end
end

class ActiveRecord::Relation
  include ::Enumerable
  include ::ActiveRecord::Delegation
  include ::ActiveRecord::Explain
  include ::ActiveRecord::Batches
  include ::ActiveRecord::QueryMethods
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveRecord::SpawnMethods
  include ::ActiveRecord::Calculations
  include ::ActiveRecord::FinderMethods
  def ==(other); end

  def _deprecated_scope_source(); end

  def _deprecated_scope_source=(_deprecated_scope_source); end

  def _exec_scope(name, *args, &block); end

  def alias_tracker(joins=T.unsafe(nil), aliases=T.unsafe(nil)); end

  def arel_attribute(name); end

  def bind_attribute(name, value); end

  def build(attributes=T.unsafe(nil), &block); end

  def cache_key(timestamp_column=T.unsafe(nil)); end

  def cache_key_with_version(); end

  def cache_version(timestamp_column=T.unsafe(nil)); end

  def create(attributes=T.unsafe(nil), &block); end

  def create!(attributes=T.unsafe(nil), &block); end

  def create_or_find_by(attributes, &block); end

  def create_or_find_by!(attributes, &block); end

  def delete_by(*args); end

  def destroy_all(); end

  def destroy_by(*args); end

  def eager_loading?(); end

  def empty_scope?(); end

  def encode_with(coder); end

  def explain(); end

  def find_or_create_by(attributes, &block); end

  def find_or_create_by!(attributes, &block); end

  def find_or_initialize_by(attributes, &block); end

  def first_or_create(attributes=T.unsafe(nil), &block); end

  def first_or_create!(attributes=T.unsafe(nil), &block); end

  def first_or_initialize(attributes=T.unsafe(nil), &block); end

  def has_limit_or_offset?(); end

  def initialize(klass, table: T.unsafe(nil), predicate_builder: T.unsafe(nil), values: T.unsafe(nil)); end

  def joined_includes_values(); end

  def klass(); end

  def load(&block); end

  def load_records(records); end

  def loaded(); end

  def loaded?(); end

  def locked?(); end

  def model(); end

  def new(attributes=T.unsafe(nil), &block); end

  def null_relation?(); end

  def predicate_builder(); end

  def preload_associations(records); end

  def records(); end

  def reload(); end

  def reset(); end

  def scope_for_create(); end

  def scoping(); end

  def skip_preloading_value(); end

  def skip_preloading_value=(skip_preloading_value); end

  def table(); end

  def to_a(); end

  def to_ary(); end

  def to_sql(); end

  def touch_all(*names, time: T.unsafe(nil)); end

  def update(id=T.unsafe(nil), attributes); end

  def update_all(updates); end

  def update_counters(counters); end

  def values(); end

  def where_values_hash(relation_table_name=T.unsafe(nil)); end
  CLAUSE_METHODS = ::T.let(nil, ::T.untyped)
  INVALID_METHODS_FOR_DELETE_ALL = ::T.let(nil, ::T.untyped)
  MULTI_VALUE_METHODS = ::T.let(nil, ::T.untyped)
  SINGLE_VALUE_METHODS = ::T.let(nil, ::T.untyped)
  VALUE_METHODS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Relation::FromClause
  def ==(other); end

  def empty?(); end

  def initialize(value, name); end

  def merge(other); end

  def name(); end

  def value(); end
end

class ActiveRecord::Relation::FromClause
  def self.empty(); end
end

class ActiveRecord::Relation::HashMerger
  def initialize(relation, hash); end

  def merge(); end

  def other(); end

  def relation(); end
end

class ActiveRecord::Relation::HashMerger
end

class ActiveRecord::Relation::Merger
  def initialize(relation, other); end

  def merge(); end

  def normal_values(); end

  def other(); end

  def relation(); end

  def values(); end
  NORMAL_VALUES = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Relation::Merger
end

class ActiveRecord::Relation::QueryAttribute
  def infinite?(); end

  def type_cast(value); end

  def unboundable?(); end
end

class ActiveRecord::Relation::QueryAttribute
end

class ActiveRecord::Relation::WhereClause
  def +(other); end

  def -(other); end

  def ==(other); end

  def any?(*args, &block); end

  def ast(); end

  def empty?(*args, &block); end

  def except(*columns); end

  def initialize(predicates); end

  def invert(as=T.unsafe(nil)); end

  def merge(other); end

  def or(other); end

  def predicates(); end

  def referenced_columns(); end

  def to_h(table_name=T.unsafe(nil)); end
  ARRAY_WITH_EMPTY_STRING = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Relation::WhereClause
  def self.empty(); end
end

class ActiveRecord::Relation::WhereClauseFactory
  def build(opts, other); end

  def initialize(klass, predicate_builder); end
end

class ActiveRecord::Relation::WhereClauseFactory
end

class ActiveRecord::Relation
  extend ::ActiveRecord::Delegation::ClassMethods
end

class ActiveRecord::RuntimeRegistry
  def connection_handler(); end

  def connection_handler=(connection_handler); end

  def sql_runtime(); end

  def sql_runtime=(sql_runtime); end
end

class ActiveRecord::RuntimeRegistry
  extend ::ActiveSupport::PerThreadRegistry
  def self.connection_handler(); end

  def self.connection_handler=(x); end

  def self.sql_runtime(); end

  def self.sql_runtime=(x); end
end

module ActiveRecord::Sanitization::ClassMethods
  def disallow_raw_sql!(args, permit: T.unsafe(nil)); end
end

module ActiveRecord::Sanitization
  extend ::ActiveSupport::Concern
end

class ActiveRecord::Schema
  def define(info, &block); end
end

class ActiveRecord::SchemaDumper
  def dump(stream); end

  def fk_ignore_pattern(); end

  def fk_ignore_pattern=(obj); end

  def ignore_tables(); end

  def ignore_tables=(obj); end

  def initialize(connection, options=T.unsafe(nil)); end
end

class ActiveRecord::SchemaDumper
  def self.dump(connection=T.unsafe(nil), stream=T.unsafe(nil), config=T.unsafe(nil)); end

  def self.fk_ignore_pattern(); end

  def self.fk_ignore_pattern=(obj); end

  def self.ignore_tables(); end

  def self.ignore_tables=(obj); end
end

class ActiveRecord::SchemaMigration
  include ::ActiveRecord::SchemaMigration::GeneratedAttributeMethods
  include ::ActiveRecord::SchemaMigration::GeneratedAssociationMethods
  def version(); end
end

module ActiveRecord::SchemaMigration::GeneratedAssociationMethods
end

module ActiveRecord::SchemaMigration::GeneratedAssociationMethods
end

module ActiveRecord::SchemaMigration::GeneratedAttributeMethods
end

module ActiveRecord::SchemaMigration::GeneratedAttributeMethods
  extend ::Mutex_m
end

class ActiveRecord::SchemaMigration
  def self.all_versions(); end

  def self.create_table(); end

  def self.drop_table(); end

  def self.normalize_migration_number(number); end

  def self.normalized_versions(); end
end

module ActiveRecord::Scoping
  def initialize_internals_callback(); end

  def populate_with_current_scope_attributes(); end
end

module ActiveRecord::Scoping::ClassMethods
  def current_scope(skip_inherited_scope=T.unsafe(nil)); end

  def current_scope=(scope); end

  def scope_attributes(); end

  def scope_attributes?(); end
end

module ActiveRecord::Scoping::ClassMethods
end

module ActiveRecord::Scoping::Default
  extend ::ActiveSupport::Concern
end

class ActiveRecord::Scoping::ScopeRegistry
  def set_value_for(scope_type, model, value); end

  def value_for(scope_type, model, skip_inherited_scope=T.unsafe(nil)); end
  VALID_SCOPE_TYPES = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Scoping::ScopeRegistry
  extend ::ActiveSupport::PerThreadRegistry
end

module ActiveRecord::Scoping
  extend ::ActiveSupport::Concern
  extend ::ActiveSupport::Autoload
end

module ActiveRecord::Serialization
  def serializable_hash(options=T.unsafe(nil)); end
end

module ActiveRecord::Serialization
  extend ::ActiveSupport::Concern
end

module ActiveRecord::SpawnMethods
  def except(*skips); end

  def merge(other); end

  def merge!(other); end

  def only(*onlies); end

  def spawn(); end
end

module ActiveRecord::SpawnMethods
end

class ActiveRecord::StaleObjectError
  def attempted_action(); end

  def initialize(record=T.unsafe(nil), attempted_action=T.unsafe(nil)); end

  def record(); end
end

class ActiveRecord::StatementCache
  def execute(params, connection, &block); end

  def initialize(query_builder, bind_map, klass); end
end

class ActiveRecord::StatementCache::BindMap
  def bind(values); end

  def initialize(bound_attributes); end
end

class ActiveRecord::StatementCache::BindMap
end

class ActiveRecord::StatementCache::Params
  def bind(); end
end

class ActiveRecord::StatementCache::Params
end

class ActiveRecord::StatementCache::PartialQuery
  def initialize(values); end
end

class ActiveRecord::StatementCache::PartialQuery
end

class ActiveRecord::StatementCache::PartialQueryCollector
  def <<(str); end

  def add_bind(obj); end

  def value(); end
end

class ActiveRecord::StatementCache::PartialQueryCollector
end

class ActiveRecord::StatementCache::Query
  def initialize(sql); end

  def sql_for(binds, connection); end
end

class ActiveRecord::StatementCache::Query
end

class ActiveRecord::StatementCache::Substitute
end

class ActiveRecord::StatementCache::Substitute
end

class ActiveRecord::StatementCache
  def self.create(connection, callable=T.unsafe(nil), &block); end

  def self.partial_query(values); end

  def self.partial_query_collector(); end

  def self.query(sql); end

  def self.unsupported_value?(value); end
end

class ActiveRecord::StatementInvalid
  def binds(); end

  def initialize(message=T.unsafe(nil), sql: T.unsafe(nil), binds: T.unsafe(nil)); end

  def sql(); end
end

class ActiveRecord::Store::HashAccessor
end

class ActiveRecord::Store::HashAccessor
  def self.prepare(object, attribute); end

  def self.read(object, attribute, key); end

  def self.write(object, attribute, key, value); end
end

class ActiveRecord::Store::IndifferentCoder
  def dump(obj); end

  def initialize(attr_name, coder_or_class_name); end

  def load(yaml); end
end

class ActiveRecord::Store::IndifferentCoder
  def self.as_indifferent_hash(obj); end
end

class ActiveRecord::Store::IndifferentHashAccessor
end

class ActiveRecord::Store::IndifferentHashAccessor
  def self.prepare(object, store_attribute); end
end

class ActiveRecord::Store::StringKeyedHashAccessor
end

class ActiveRecord::Store::StringKeyedHashAccessor
end

class ActiveRecord::TableMetadata
  def aggregated_with?(aggregation_name); end

  def arel_attribute(column_name); end

  def associated_predicate_builder(table_name); end

  def associated_table(table_name); end

  def associated_with?(association_name); end

  def association_foreign_key(*args, &block); end

  def association_foreign_type(*args, &block); end

  def association_join_foreign_key(*args, &block); end

  def association_join_primary_key(*args, &block); end

  def has_column?(column_name); end

  def initialize(klass, arel_table, association=T.unsafe(nil), types=T.unsafe(nil)); end

  def polymorphic_association?(); end

  def predicate_builder(); end

  def reflect_on_aggregation(aggregation_name); end

  def resolve_column_aliases(hash); end

  def type(column_name); end
end

class ActiveRecord::TableMetadata
end

class ActiveRecord::Tasks::MySQLDatabaseTasks
  def charset(); end

  def collation(); end

  def connection(*args, &block); end

  def create(); end

  def drop(); end

  def establish_connection(*args, &block); end

  def initialize(configuration); end

  def purge(); end

  def structure_dump(filename, extra_flags); end

  def structure_load(filename, extra_flags); end
  ER_DB_CREATE_EXISTS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Tasks::MySQLDatabaseTasks
end

class ActiveRecord::Tasks::PostgreSQLDatabaseTasks
  def charset(); end

  def clear_active_connections!(*args, &block); end

  def collation(); end

  def connection(*args, &block); end

  def create(master_established=T.unsafe(nil)); end

  def drop(); end

  def establish_connection(*args, &block); end

  def initialize(configuration); end

  def purge(); end

  def structure_dump(filename, extra_flags); end

  def structure_load(filename, extra_flags); end
  DEFAULT_ENCODING = ::T.let(nil, ::T.untyped)
  ON_ERROR_STOP_1 = ::T.let(nil, ::T.untyped)
  SQL_COMMENT_BEGIN = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Tasks::PostgreSQLDatabaseTasks
end

class ActiveRecord::Tasks::SQLiteDatabaseTasks
  def charset(); end

  def connection(*args, &block); end

  def create(); end

  def drop(); end

  def establish_connection(*args, &block); end

  def initialize(configuration, root=T.unsafe(nil)); end

  def purge(); end

  def structure_dump(filename, extra_flags); end

  def structure_load(filename, extra_flags); end
end

class ActiveRecord::Tasks::SQLiteDatabaseTasks
end

module ActiveRecord::Tasks
  extend ::ActiveSupport::Autoload
end

module ActiveRecord::TestDatabases
end

module ActiveRecord::TestDatabases
  def self.create_and_load_schema(i, env_name:); end
end

module ActiveRecord::TestFixtures
  def after_teardown(); end

  def before_setup(); end

  def enlist_fixture_connections(); end

  def run_in_transaction?(); end

  def setup_fixtures(config=T.unsafe(nil)); end

  def teardown_fixtures(); end
end

module ActiveRecord::TestFixtures::ClassMethods
  def fixtures(*fixture_set_names); end

  def set_fixture_class(class_names=T.unsafe(nil)); end

  def setup_fixture_accessors(fixture_set_names=T.unsafe(nil)); end

  def uses_transaction(*methods); end

  def uses_transaction?(method); end
end

module ActiveRecord::TestFixtures::ClassMethods
end

module ActiveRecord::TestFixtures
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Timestamp::ClassMethods
  def all_timestamp_attributes_in_model(); end

  def current_time_from_proper_timezone(); end

  def timestamp_attributes_for_create_in_model(); end

  def timestamp_attributes_for_update_in_model(); end

  def touch_attributes_with_time(*names, time: T.unsafe(nil)); end
end

module ActiveRecord::Timestamp::ClassMethods
end

module ActiveRecord::Timestamp
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Transactions
  def before_committed!(); end

  def committed!(should_run_callbacks: T.unsafe(nil)); end

  def destroy(); end

  def rolledback!(force_restore_state: T.unsafe(nil), should_run_callbacks: T.unsafe(nil)); end

  def save(*_, **_1); end

  def save!(*_, **_1); end

  def touch(*_, **_1); end

  def transaction(options=T.unsafe(nil), &block); end

  def trigger_transactional_callbacks?(); end

  def with_transaction_returning_status(); end
  ACTIONS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Transactions::ClassMethods
  def after_commit(*args, &block); end

  def after_commit_without_transaction_enrollment(*args, &block); end

  def after_create_commit(*args, &block); end

  def after_destroy_commit(*args, &block); end

  def after_rollback(*args, &block); end

  def after_rollback_without_transaction_enrollment(*args, &block); end

  def after_save_commit(*args, &block); end

  def after_update_commit(*args, &block); end

  def before_commit(*args, &block); end

  def before_commit_without_transaction_enrollment(*args, &block); end
end

module ActiveRecord::Transactions
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Translation
  include ::ActiveModel::Translation
  include ::ActiveModel::Naming
  def i18n_scope(); end

  def lookup_ancestors(); end
end

class ActiveRecord::Type::AdapterSpecificRegistry
  def add_modifier(options, klass, **args); end
end

class ActiveRecord::Type::AdapterSpecificRegistry
end

class ActiveRecord::Type::DecimalWithoutScale
end

class ActiveRecord::Type::DecimalWithoutScale
end

class ActiveRecord::Type::DecorationRegistration
  def call(registry, *args, **kwargs); end

  def initialize(options, klass, adapter: T.unsafe(nil)); end

  def matches?(*args, **kwargs); end
end

class ActiveRecord::Type::DecorationRegistration
end

class ActiveRecord::Type::HashLookupTypeMap
  def alias_type(type, alias_type); end

  def key?(key); end

  def keys(); end
end

class ActiveRecord::Type::HashLookupTypeMap
end

class ActiveRecord::Type::Json
  include ::ActiveModel::Type::Helpers::Mutable
  def accessor(); end
end

class ActiveRecord::Type::Json
end

class ActiveRecord::Type::Registration
  def adapter(); end

  def block(); end

  def call(_registry, *args, adapter: T.unsafe(nil), **kwargs); end

  def initialize(name, block, adapter: T.unsafe(nil), override: T.unsafe(nil)); end

  def matches?(type_name, *args, **kwargs); end

  def name(); end

  def override(); end

  def priority(); end

  def priority_except_adapter(); end
end

class ActiveRecord::Type::Registration
end

class ActiveRecord::Type::Serialized
  include ::ActiveModel::Type::Helpers::Mutable
  def accessor(); end

  def assert_valid_value(value); end

  def changed_in_place?(raw_old_value, value); end

  def coder(); end

  def deserialize(value); end

  def force_equality?(value); end

  def initialize(subtype, coder); end

  def inspect(); end

  def serialize(value); end

  def subtype(); end
end

class ActiveRecord::Type::Serialized
end

class ActiveRecord::Type::Text
end

class ActiveRecord::Type::Text
end

class ActiveRecord::Type::Time
  include ::ActiveRecord::Type::Internal::Timezone
end

class ActiveRecord::Type::Time::Value
end

class ActiveRecord::Type::Time::Value
end

class ActiveRecord::Type::Time
end

class ActiveRecord::Type::TypeMap
  def alias_type(key, target_key); end

  def clear(); end

  def fetch(lookup_key, *args, &block); end

  def lookup(lookup_key, *args); end

  def register_type(key, value=T.unsafe(nil), &block); end
end

class ActiveRecord::Type::TypeMap
end

class ActiveRecord::Type::UnsignedInteger
end

class ActiveRecord::Type::UnsignedInteger
end

module ActiveRecord::Type
  def self.add_modifier(*args, &block); end

  def self.default_value(); end

  def self.lookup(*args, adapter: T.unsafe(nil), **kwargs); end

  def self.register(type_name, klass=T.unsafe(nil), **options, &block); end

  def self.registry(); end

  def self.registry=(registry); end
end

class ActiveRecord::UnknownMigrationVersionError
  def initialize(version=T.unsafe(nil)); end
end

class ActiveRecord::UnknownPrimaryKey
  def initialize(model=T.unsafe(nil), description=T.unsafe(nil)); end

  def model(); end
end

module ActiveRecord::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::VERSION
end

module ActiveRecord::Validations
  def save(**options); end

  def save!(**options); end

  def valid?(context=T.unsafe(nil)); end

  def validate(context=T.unsafe(nil)); end
end

class ActiveRecord::Validations::AbsenceValidator
  def validate_each(record, attribute, association_or_value); end
end

class ActiveRecord::Validations::AbsenceValidator
end

class ActiveRecord::Validations::AssociatedValidator
end

class ActiveRecord::Validations::AssociatedValidator
end

class ActiveRecord::Validations::LengthValidator
  def validate_each(record, attribute, association_or_value); end
end

class ActiveRecord::Validations::LengthValidator
end

class ActiveRecord::Validations::PresenceValidator
  def validate_each(record, attribute, association_or_value); end
end

class ActiveRecord::Validations::PresenceValidator
end

class ActiveRecord::Validations::UniquenessValidator
end

class ActiveRecord::Validations::UniquenessValidator
end

module ActiveRecord::Validations
  extend ::ActiveSupport::Concern
end

module ActiveRecord
  extend ::ActiveSupport::Autoload
  def self.gem_version(); end

  def self.version(); end
end

module ActiveStorage
  def analyzers(); end

  def analyzers=(obj); end

  def binary_content_type(); end

  def binary_content_type=(obj); end

  def content_types_allowed_inline(); end

  def content_types_allowed_inline=(obj); end

  def content_types_to_serve_as_binary(); end

  def content_types_to_serve_as_binary=(obj); end

  def logger(); end

  def logger=(obj); end

  def paths(); end

  def paths=(obj); end

  def previewers(); end

  def previewers=(obj); end

  def queues(); end

  def queues=(obj); end

  def replace_on_assign_to_many(); end

  def replace_on_assign_to_many=(obj); end

  def routes_prefix(); end

  def routes_prefix=(obj); end

  def service_urls_expire_in(); end

  def service_urls_expire_in=(obj); end

  def variable_content_types(); end

  def variable_content_types=(obj); end

  def variant_processor(); end

  def variant_processor=(obj); end

  def verifier(); end

  def verifier=(obj); end
end

class ActiveStorage::Analyzer
  def blob(); end

  def initialize(blob); end

  def metadata(); end
end

class ActiveStorage::Analyzer::ImageAnalyzer
end

class ActiveStorage::Analyzer::ImageAnalyzer
end

class ActiveStorage::Analyzer::VideoAnalyzer
end

class ActiveStorage::Analyzer::VideoAnalyzer
end

class ActiveStorage::Analyzer
  def self.accept?(blob); end
end

class ActiveStorage::Attached
  def initialize(name, record); end

  def name(); end

  def record(); end
end

module ActiveStorage::Attached::Changes
end

class ActiveStorage::Attached::Changes::CreateMany
  def attachables(); end

  def attachments(); end

  def blobs(); end

  def initialize(name, record, attachables); end

  def name(); end

  def record(); end

  def save(); end

  def upload(); end
end

class ActiveStorage::Attached::Changes::CreateMany
end

class ActiveStorage::Attached::Changes::CreateOne
  def attachable(); end

  def attachment(); end

  def blob(); end

  def initialize(name, record, attachable); end

  def name(); end

  def record(); end

  def save(); end

  def upload(); end
end

class ActiveStorage::Attached::Changes::CreateOne
end

class ActiveStorage::Attached::Changes::CreateOneOfMany
end

class ActiveStorage::Attached::Changes::CreateOneOfMany
end

class ActiveStorage::Attached::Changes::DeleteMany
  def attachables(); end

  def attachments(); end

  def blobs(); end

  def initialize(name, record); end

  def name(); end

  def record(); end

  def save(); end
end

class ActiveStorage::Attached::Changes::DeleteMany
end

class ActiveStorage::Attached::Changes::DeleteOne
  def attachment(); end

  def initialize(name, record); end

  def name(); end

  def record(); end

  def save(); end
end

class ActiveStorage::Attached::Changes::DeleteOne
end

module ActiveStorage::Attached::Changes
  extend ::ActiveSupport::Autoload
end

class ActiveStorage::Attached::Many
  def method_missing(method, *args, &block); end
end

module ActiveStorage::Attached::Model
  def attachment_changes(); end

  def changed_for_autosave?(); end

  def reload(*_); end
end

module ActiveStorage::Attached::Model
  extend ::ActiveSupport::Concern
end

class ActiveStorage::Attached::One
  def method_missing(method, *args, &block); end
end

class ActiveStorage::Engine
end

class ActiveStorage::Engine
end

class ActiveStorage::Error
end

class ActiveStorage::Error
end

class ActiveStorage::FileNotFoundError
end

class ActiveStorage::FileNotFoundError
end

class ActiveStorage::IntegrityError
end

class ActiveStorage::IntegrityError
end

class ActiveStorage::InvariableError
end

class ActiveStorage::InvariableError
end

class ActiveStorage::LogSubscriber
  def service_delete(event); end

  def service_delete_prefixed(event); end

  def service_download(event); end

  def service_exist(event); end

  def service_streaming_download(event); end

  def service_upload(event); end

  def service_url(event); end
end

class ActiveStorage::LogSubscriber
end

class ActiveStorage::Previewer
  def blob(); end

  def initialize(blob); end

  def preview(); end
end

class ActiveStorage::Previewer::MuPDFPreviewer
end

class ActiveStorage::Previewer::MuPDFPreviewer
  def self.mutool_exists?(); end

  def self.mutool_path(); end
end

class ActiveStorage::Previewer::PopplerPDFPreviewer
end

class ActiveStorage::Previewer::PopplerPDFPreviewer
  def self.pdftoppm_exists?(); end

  def self.pdftoppm_path(); end
end

class ActiveStorage::Previewer::VideoPreviewer
end

class ActiveStorage::Previewer::VideoPreviewer
  def self.ffmpeg_exists?(); end

  def self.ffmpeg_path(); end
end

class ActiveStorage::Previewer
  def self.accept?(blob); end
end

module ActiveStorage::Reflection
end

module ActiveStorage::Reflection::ActiveRecordExtensions
end

module ActiveStorage::Reflection::ActiveRecordExtensions::ClassMethods
  def reflect_on_all_attachments(); end

  def reflect_on_attachment(attachment); end
end

module ActiveStorage::Reflection::ActiveRecordExtensions::ClassMethods
end

module ActiveStorage::Reflection::ActiveRecordExtensions
  extend ::ActiveSupport::Concern
end

class ActiveStorage::Reflection::HasManyAttachedReflection
  def macro(); end
end

class ActiveStorage::Reflection::HasManyAttachedReflection
end

class ActiveStorage::Reflection::HasOneAttachedReflection
  def macro(); end
end

class ActiveStorage::Reflection::HasOneAttachedReflection
end

module ActiveStorage::Reflection::ReflectionExtension
  def add_attachment_reflection(model, name, reflection); end
end

module ActiveStorage::Reflection::ReflectionExtension
end

module ActiveStorage::Reflection
end

class ActiveStorage::Service
  def delete(key); end

  def delete_prefixed(prefix); end

  def download(key); end

  def download_chunk(key, range); end

  def exist?(key); end

  def headers_for_direct_upload(key, filename:, content_type:, content_length:, checksum:); end

  def open(*args, **options, &block); end

  def update_metadata(key, **metadata); end

  def upload(key, io, checksum: T.unsafe(nil), **options); end

  def url(key, expires_in:, disposition:, filename:, content_type:); end

  def url_for_direct_upload(key, expires_in:, content_type:, content_length:, checksum:); end
end

class ActiveStorage::Service::Configurator
  def build(service_name); end

  def configurations(); end

  def initialize(configurations); end
end

class ActiveStorage::Service::Configurator
  def self.build(service_name, configurations); end
end

class ActiveStorage::Service
  extend ::ActiveSupport::Autoload
  def self.build(configurator:, service: T.unsafe(nil), **service_config); end

  def self.configure(service_name, configurations); end
end

module ActiveStorage::Transformers
end

class ActiveStorage::Transformers::Transformer
  def initialize(transformations); end

  def transform(file, format:); end

  def transformations(); end
end

class ActiveStorage::Transformers::Transformer
end

module ActiveStorage::Transformers
  extend ::ActiveSupport::Autoload
end

class ActiveStorage::UnpreviewableError
end

class ActiveStorage::UnpreviewableError
end

class ActiveStorage::UnrepresentableError
end

class ActiveStorage::UnrepresentableError
end

module ActiveStorage::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveStorage::VERSION
end

module ActiveStorage
  extend ::ActiveSupport::Autoload
  def self.analyzers(); end

  def self.analyzers=(obj); end

  def self.binary_content_type(); end

  def self.binary_content_type=(obj); end

  def self.content_types_allowed_inline(); end

  def self.content_types_allowed_inline=(obj); end

  def self.content_types_to_serve_as_binary(); end

  def self.content_types_to_serve_as_binary=(obj); end

  def self.logger(); end

  def self.logger=(obj); end

  def self.paths(); end

  def self.paths=(obj); end

  def self.previewers(); end

  def self.previewers=(obj); end

  def self.queues(); end

  def self.queues=(obj); end

  def self.railtie_helpers_paths(); end

  def self.railtie_namespace(); end

  def self.railtie_routes_url_helpers(include_path_helpers=T.unsafe(nil)); end

  def self.replace_on_assign_to_many(); end

  def self.replace_on_assign_to_many=(obj); end

  def self.routes_prefix(); end

  def self.routes_prefix=(obj); end

  def self.service_urls_expire_in(); end

  def self.service_urls_expire_in=(obj); end

  def self.table_name_prefix(); end

  def self.use_relative_model_naming?(); end

  def self.variable_content_types(); end

  def self.variable_content_types=(obj); end

  def self.variant_processor(); end

  def self.variant_processor=(obj); end

  def self.verifier(); end

  def self.verifier=(obj); end
end

class ActiveSupport::Concurrency::LoadInterlockAwareMonitor
end

class ActiveSupport::Concurrency::LoadInterlockAwareMonitor
end

module ActiveSupport::Dependencies
  extend ::ActiveSupport::Dependencies::ZeitwerkIntegration::Decorations
  def self.autoload_paths=(obj); end
end

class ActiveSupport::Deprecation
  def self.deprecation_warning(*args, &block); end

  def self.initialize(*args, &block); end

  def self.warn(*args, &block); end
end

class ActiveSupport::TestCase
  extend ::Rails::LineFiltering
end

class Addrinfo
  def connect_internal(local_addrinfo, timeout=T.unsafe(nil)); end
end

module Arel
  VERSION = ::T.let(nil, ::T.untyped)
end

module Arel::AliasPredication
  def as(other); end
end

module Arel::AliasPredication
end

class Arel::ArelError
end

class Arel::ArelError
end

Arel::Attribute = Arel::Attributes::Attribute

module Arel::Attributes
end

class Arel::Attributes::Attribute
  include ::Arel::Expressions
  include ::Arel::Predications
  include ::Arel::AliasPredication
  include ::Arel::OrderPredications
  include ::Arel::Math
  def able_to_type_cast?(); end

  def lower(); end

  def type_cast_for_database(value); end
end

class Arel::Attributes::Attribute
end

class Arel::Attributes::Boolean
end

class Arel::Attributes::Boolean
end

class Arel::Attributes::Decimal
end

class Arel::Attributes::Decimal
end

class Arel::Attributes::Float
end

class Arel::Attributes::Float
end

class Arel::Attributes::Integer
end

class Arel::Attributes::Integer
end

class Arel::Attributes::String
end

class Arel::Attributes::String
end

class Arel::Attributes::Time
end

class Arel::Attributes::Time
end

class Arel::Attributes::Undefined
end

class Arel::Attributes::Undefined
end

module Arel::Attributes
  def self.for(column); end
end

module Arel::Collectors
end

class Arel::Collectors::Bind
  def <<(str); end

  def add_bind(bind); end

  def value(); end
end

class Arel::Collectors::Bind
end

class Arel::Collectors::Composite
  def <<(str); end

  def add_bind(bind, &block); end

  def initialize(left, right); end

  def value(); end
end

class Arel::Collectors::Composite
end

class Arel::Collectors::PlainString
  def <<(str); end

  def value(); end
end

class Arel::Collectors::PlainString
end

class Arel::Collectors::SQLString
  def add_bind(bind); end

  def initialize(*_); end
end

class Arel::Collectors::SQLString
end

class Arel::Collectors::SubstituteBinds
  def <<(str); end

  def add_bind(bind); end

  def initialize(quoter, delegate_collector); end

  def value(); end
end

class Arel::Collectors::SubstituteBinds
end

module Arel::Collectors
end

module Arel::Crud
  def compile_delete(); end

  def compile_insert(values); end

  def compile_update(values, pk); end

  def create_insert(); end
end

module Arel::Crud
end

class Arel::DeleteManager
  include ::Arel::TreeManager::StatementMethods
  def from(relation); end
end

class Arel::DeleteManager
end

class Arel::EmptyJoinError
end

class Arel::EmptyJoinError
end

module Arel::Expressions
  def average(); end

  def count(distinct=T.unsafe(nil)); end

  def extract(field); end

  def maximum(); end

  def minimum(); end

  def sum(); end
end

module Arel::Expressions
end

module Arel::FactoryMethods
  def coalesce(*exprs); end

  def create_and(clauses); end

  def create_false(); end

  def create_join(to, constraint=T.unsafe(nil), klass=T.unsafe(nil)); end

  def create_on(expr); end

  def create_string_join(to); end

  def create_table_alias(relation, name); end

  def create_true(); end

  def grouping(expr); end

  def lower(column); end
end

module Arel::FactoryMethods
end

class Arel::InsertManager
  def columns(); end

  def create_values(values); end

  def create_values_list(rows); end

  def insert(fields); end

  def into(table); end

  def select(select); end

  def values=(val); end
end

class Arel::InsertManager
end

module Arel::Math
  def &(other); end

  def *(other); end

  def +(other); end

  def -(other); end

  def /(other); end

  def <<(other); end

  def >>(other); end

  def ^(other); end

  def |(other); end

  def ~(); end
end

module Arel::Math
end

Arel::Node = Arel::Nodes::Node

module Arel::Nodes
end

class Arel::Nodes::Addition
  def initialize(left, right); end
end

class Arel::Nodes::Addition
end

class Arel::Nodes::And
  def ==(other); end

  def children(); end

  def eql?(other); end

  def initialize(children); end

  def left(); end

  def right(); end
end

class Arel::Nodes::And
end

class Arel::Nodes::As
end

class Arel::Nodes::As
end

class Arel::Nodes::Ascending
  def ascending?(); end

  def descending?(); end

  def direction(); end

  def reverse(); end
end

class Arel::Nodes::Ascending
end

class Arel::Nodes::Assignment
end

class Arel::Nodes::Assignment
end

class Arel::Nodes::Avg
end

class Arel::Nodes::Avg
end

class Arel::Nodes::Between
end

class Arel::Nodes::Between
end

class Arel::Nodes::Bin
end

class Arel::Nodes::Bin
end

class Arel::Nodes::Binary
  def ==(other); end

  def eql?(other); end

  def initialize(left, right); end

  def left(); end

  def left=(left); end

  def right(); end

  def right=(right); end
end

class Arel::Nodes::Binary
end

class Arel::Nodes::BindParam
  def ==(other); end

  def eql?(other); end

  def infinite?(); end

  def initialize(value); end

  def unboundable?(); end

  def value(); end
end

class Arel::Nodes::BindParam
end

class Arel::Nodes::BitwiseAnd
  def initialize(left, right); end
end

class Arel::Nodes::BitwiseAnd
end

class Arel::Nodes::BitwiseNot
  def initialize(operand); end
end

class Arel::Nodes::BitwiseNot
end

class Arel::Nodes::BitwiseOr
  def initialize(left, right); end
end

class Arel::Nodes::BitwiseOr
end

class Arel::Nodes::BitwiseShiftLeft
  def initialize(left, right); end
end

class Arel::Nodes::BitwiseShiftLeft
end

class Arel::Nodes::BitwiseShiftRight
  def initialize(left, right); end
end

class Arel::Nodes::BitwiseShiftRight
end

class Arel::Nodes::BitwiseXor
  def initialize(left, right); end
end

class Arel::Nodes::BitwiseXor
end

class Arel::Nodes::Case
  def ==(other); end

  def case(); end

  def case=(_); end

  def conditions(); end

  def conditions=(conditions); end

  def default(); end

  def default=(default); end

  def else(expression); end

  def eql?(other); end

  def initialize(expression=T.unsafe(nil), default=T.unsafe(nil)); end

  def then(expression); end

  def when(condition, expression=T.unsafe(nil)); end
end

class Arel::Nodes::Case
end

class Arel::Nodes::Casted
  def ==(other); end

  def attribute(); end

  def eql?(other); end

  def initialize(val, attribute); end

  def val(); end
end

class Arel::Nodes::Casted
end

class Arel::Nodes::Comment
  def ==(other); end

  def eql?(other); end

  def initialize(values); end

  def values(); end
end

class Arel::Nodes::Comment
end

class Arel::Nodes::Concat
  def initialize(left, right); end
end

class Arel::Nodes::Concat
end

class Arel::Nodes::Count
  def initialize(expr, distinct=T.unsafe(nil), aliaz=T.unsafe(nil)); end
end

class Arel::Nodes::Count
end

class Arel::Nodes::Cube
end

class Arel::Nodes::Cube
end

class Arel::Nodes::CurrentRow
  def ==(other); end

  def eql?(other); end
end

class Arel::Nodes::CurrentRow
end

class Arel::Nodes::DeleteStatement
  def ==(other); end

  def eql?(other); end

  def initialize(relation=T.unsafe(nil), wheres=T.unsafe(nil)); end

  def key(); end

  def key=(key); end

  def left(); end

  def left=(left); end

  def limit(); end

  def limit=(limit); end

  def offset(); end

  def offset=(offset); end

  def orders(); end

  def orders=(orders); end

  def relation(); end

  def relation=(relation); end

  def right(); end

  def right=(right); end

  def wheres(); end

  def wheres=(wheres); end
end

class Arel::Nodes::DeleteStatement
end

class Arel::Nodes::Descending
  def ascending?(); end

  def descending?(); end

  def direction(); end

  def reverse(); end
end

class Arel::Nodes::Descending
end

class Arel::Nodes::Distinct
  def ==(other); end

  def eql?(other); end
end

class Arel::Nodes::Distinct
end

class Arel::Nodes::DistinctOn
end

class Arel::Nodes::DistinctOn
end

class Arel::Nodes::Division
  def initialize(left, right); end
end

class Arel::Nodes::Division
end

class Arel::Nodes::DoesNotMatch
end

class Arel::Nodes::DoesNotMatch
end

class Arel::Nodes::Else
end

class Arel::Nodes::Else
end

class Arel::Nodes::Equality
  def operand1(); end

  def operand2(); end

  def operator(); end
end

class Arel::Nodes::Equality
end

class Arel::Nodes::Except
end

class Arel::Nodes::Except
end

class Arel::Nodes::Exists
end

class Arel::Nodes::Exists
end

class Arel::Nodes::Extract
  def field(); end

  def field=(field); end

  def initialize(expr, field); end
end

class Arel::Nodes::Extract
end

class Arel::Nodes::False
  def ==(other); end

  def eql?(other); end
end

class Arel::Nodes::False
end

class Arel::Nodes::Following
  def initialize(expr=T.unsafe(nil)); end
end

class Arel::Nodes::Following
end

class Arel::Nodes::FullOuterJoin
end

class Arel::Nodes::FullOuterJoin
end

class Arel::Nodes::Function
  include ::Arel::WindowPredications
  def ==(other); end

  def alias(); end

  def alias=(_); end

  def as(aliaz); end

  def distinct(); end

  def distinct=(distinct); end

  def eql?(other); end

  def expressions(); end

  def expressions=(expressions); end

  def initialize(expr, aliaz=T.unsafe(nil)); end
end

class Arel::Nodes::Function
end

class Arel::Nodes::GreaterThan
end

class Arel::Nodes::GreaterThan
end

class Arel::Nodes::GreaterThanOrEqual
end

class Arel::Nodes::GreaterThanOrEqual
end

class Arel::Nodes::Group
end

class Arel::Nodes::Group
end

class Arel::Nodes::Grouping
end

class Arel::Nodes::Grouping
end

class Arel::Nodes::GroupingElement
end

class Arel::Nodes::GroupingElement
end

class Arel::Nodes::GroupingSet
end

class Arel::Nodes::GroupingSet
end

class Arel::Nodes::In
end

class Arel::Nodes::In
end

class Arel::Nodes::InfixOperation
  def initialize(operator, left, right); end

  def operator(); end
end

class Arel::Nodes::InfixOperation
end

class Arel::Nodes::InnerJoin
end

class Arel::Nodes::InnerJoin
end

class Arel::Nodes::InsertStatement
  def ==(other); end

  def columns(); end

  def columns=(columns); end

  def eql?(other); end

  def relation(); end

  def relation=(relation); end

  def select=(select); end

  def values(); end

  def values=(values); end
end

class Arel::Nodes::InsertStatement
end

class Arel::Nodes::Intersect
end

class Arel::Nodes::Intersect
end

class Arel::Nodes::IsDistinctFrom
end

class Arel::Nodes::IsDistinctFrom
end

class Arel::Nodes::IsNotDistinctFrom
end

class Arel::Nodes::IsNotDistinctFrom
end

class Arel::Nodes::Join
end

class Arel::Nodes::Join
end

class Arel::Nodes::JoinSource
  def empty?(); end

  def initialize(single_source, joinop=T.unsafe(nil)); end
end

class Arel::Nodes::JoinSource
end

class Arel::Nodes::Lateral
end

class Arel::Nodes::Lateral
end

class Arel::Nodes::LessThan
end

class Arel::Nodes::LessThan
end

class Arel::Nodes::LessThanOrEqual
end

class Arel::Nodes::LessThanOrEqual
end

class Arel::Nodes::Limit
end

class Arel::Nodes::Limit
end

class Arel::Nodes::Lock
end

class Arel::Nodes::Lock
end

class Arel::Nodes::Matches
  def case_sensitive(); end

  def case_sensitive=(case_sensitive); end

  def escape(); end

  def initialize(left, right, escape=T.unsafe(nil), case_sensitive=T.unsafe(nil)); end
end

class Arel::Nodes::Matches
end

class Arel::Nodes::Max
end

class Arel::Nodes::Max
end

class Arel::Nodes::Min
end

class Arel::Nodes::Min
end

class Arel::Nodes::Multiplication
  def initialize(left, right); end
end

class Arel::Nodes::Multiplication
end

class Arel::Nodes::NamedFunction
  def initialize(name, expr, aliaz=T.unsafe(nil)); end

  def name(); end

  def name=(name); end
end

class Arel::Nodes::NamedFunction
end

class Arel::Nodes::NamedWindow
  def initialize(name); end

  def name(); end

  def name=(name); end
end

class Arel::Nodes::NamedWindow
end

class Arel::Nodes::Node
  include ::Arel::FactoryMethods
  include ::Enumerable
  def and(right); end

  def each(&block); end

  def not(); end

  def or(right); end

  def to_sql(engine=T.unsafe(nil)); end
end

class Arel::Nodes::Node
end

class Arel::Nodes::NodeExpression
  include ::Arel::Expressions
  include ::Arel::Predications
  include ::Arel::AliasPredication
  include ::Arel::OrderPredications
  include ::Arel::Math
end

class Arel::Nodes::NodeExpression
end

class Arel::Nodes::Not
end

class Arel::Nodes::Not
end

class Arel::Nodes::NotEqual
end

class Arel::Nodes::NotEqual
end

class Arel::Nodes::NotIn
end

class Arel::Nodes::NotIn
end

class Arel::Nodes::NotRegexp
end

class Arel::Nodes::NotRegexp
end

class Arel::Nodes::Offset
end

class Arel::Nodes::Offset
end

class Arel::Nodes::On
end

class Arel::Nodes::On
end

class Arel::Nodes::OptimizerHints
end

class Arel::Nodes::OptimizerHints
end

class Arel::Nodes::Or
end

class Arel::Nodes::Or
end

class Arel::Nodes::Ordering
end

class Arel::Nodes::Ordering
end

class Arel::Nodes::OuterJoin
end

class Arel::Nodes::OuterJoin
end

class Arel::Nodes::Over
  def initialize(left, right=T.unsafe(nil)); end

  def operator(); end
end

class Arel::Nodes::Over
end

class Arel::Nodes::Preceding
  def initialize(expr=T.unsafe(nil)); end
end

class Arel::Nodes::Preceding
end

class Arel::Nodes::Quoted
  def infinite?(); end

  def val(); end
end

class Arel::Nodes::Quoted
end

class Arel::Nodes::Range
  def initialize(expr=T.unsafe(nil)); end
end

class Arel::Nodes::Range
end

class Arel::Nodes::Regexp
  def case_sensitive(); end

  def case_sensitive=(case_sensitive); end

  def initialize(left, right, case_sensitive=T.unsafe(nil)); end
end

class Arel::Nodes::Regexp
end

class Arel::Nodes::RightOuterJoin
end

class Arel::Nodes::RightOuterJoin
end

class Arel::Nodes::RollUp
end

class Arel::Nodes::RollUp
end

class Arel::Nodes::Rows
  def initialize(expr=T.unsafe(nil)); end
end

class Arel::Nodes::Rows
end

class Arel::Nodes::SelectCore
  def ==(other); end

  def comment(); end

  def comment=(comment); end

  def eql?(other); end

  def from(); end

  def from=(value); end

  def froms(); end

  def froms=(value); end

  def groups(); end

  def groups=(groups); end

  def havings(); end

  def havings=(havings); end

  def optimizer_hints(); end

  def optimizer_hints=(optimizer_hints); end

  def projections(); end

  def projections=(projections); end

  def set_quantifier(); end

  def set_quantifier=(set_quantifier); end

  def source(); end

  def source=(source); end

  def wheres(); end

  def wheres=(wheres); end

  def windows(); end

  def windows=(windows); end
end

class Arel::Nodes::SelectCore
end

class Arel::Nodes::SelectStatement
  def ==(other); end

  def cores(); end

  def eql?(other); end

  def initialize(cores=T.unsafe(nil)); end

  def limit(); end

  def limit=(limit); end

  def lock(); end

  def lock=(lock); end

  def offset(); end

  def offset=(offset); end

  def orders(); end

  def orders=(orders); end

  def with(); end

  def with=(with); end
end

class Arel::Nodes::SelectStatement
end

class Arel::Nodes::SqlLiteral
  include ::Arel::Expressions
  include ::Arel::Predications
  include ::Arel::AliasPredication
  include ::Arel::OrderPredications
  def encode_with(coder); end
end

class Arel::Nodes::SqlLiteral
end

class Arel::Nodes::StringJoin
  def initialize(left, right=T.unsafe(nil)); end
end

class Arel::Nodes::StringJoin
end

class Arel::Nodes::Subtraction
  def initialize(left, right); end
end

class Arel::Nodes::Subtraction
end

class Arel::Nodes::Sum
end

class Arel::Nodes::Sum
end

class Arel::Nodes::TableAlias
  def [](name); end

  def able_to_type_cast?(); end

  def name(); end

  def relation(); end

  def table_alias(); end

  def table_name(); end

  def type_cast_for_database(*args); end
end

class Arel::Nodes::TableAlias
end

class Arel::Nodes::True
  def ==(other); end

  def eql?(other); end
end

class Arel::Nodes::True
end

class Arel::Nodes::Unary
  def ==(other); end

  def eql?(other); end

  def expr(); end

  def expr=(expr); end

  def initialize(expr); end

  def value(); end
end

class Arel::Nodes::Unary
end

class Arel::Nodes::UnaryOperation
  def initialize(operator, operand); end

  def operator(); end
end

class Arel::Nodes::UnaryOperation
end

class Arel::Nodes::Union
end

class Arel::Nodes::Union
end

class Arel::Nodes::UnionAll
end

class Arel::Nodes::UnionAll
end

class Arel::Nodes::UnqualifiedColumn
  def attribute(); end

  def attribute=(attribute); end

  def column(); end

  def name(); end

  def relation(); end
end

class Arel::Nodes::UnqualifiedColumn
end

class Arel::Nodes::UpdateStatement
  def ==(other); end

  def eql?(other); end

  def key(); end

  def key=(key); end

  def limit(); end

  def limit=(limit); end

  def offset(); end

  def offset=(offset); end

  def orders(); end

  def orders=(orders); end

  def relation(); end

  def relation=(relation); end

  def values(); end

  def values=(values); end

  def wheres(); end

  def wheres=(wheres); end
end

class Arel::Nodes::UpdateStatement
end

class Arel::Nodes::ValuesList
  def rows(); end
end

class Arel::Nodes::ValuesList
end

class Arel::Nodes::When
end

class Arel::Nodes::When
end

class Arel::Nodes::Window
  def ==(other); end

  def eql?(other); end

  def frame(expr); end

  def framing(); end

  def framing=(framing); end

  def order(*expr); end

  def orders(); end

  def orders=(orders); end

  def partition(*expr); end

  def partitions(); end

  def partitions=(partitions); end

  def range(expr=T.unsafe(nil)); end

  def rows(expr=T.unsafe(nil)); end
end

class Arel::Nodes::Window
end

class Arel::Nodes::With
  def children(); end
end

class Arel::Nodes::With
end

class Arel::Nodes::WithRecursive
end

class Arel::Nodes::WithRecursive
end

module Arel::Nodes
  def self.build_quoted(other, attribute=T.unsafe(nil)); end
end

module Arel::OrderPredications
  def asc(); end

  def desc(); end
end

module Arel::OrderPredications
end

module Arel::Predications
  def between(other); end

  def concat(other); end

  def does_not_match(other, escape=T.unsafe(nil), case_sensitive=T.unsafe(nil)); end

  def does_not_match_all(others, escape=T.unsafe(nil)); end

  def does_not_match_any(others, escape=T.unsafe(nil)); end

  def does_not_match_regexp(other, case_sensitive=T.unsafe(nil)); end

  def eq(other); end

  def eq_all(others); end

  def eq_any(others); end

  def gt(right); end

  def gt_all(others); end

  def gt_any(others); end

  def gteq(right); end

  def gteq_all(others); end

  def gteq_any(others); end

  def in(other); end

  def in_all(others); end

  def in_any(others); end

  def is_distinct_from(other); end

  def is_not_distinct_from(other); end

  def lt(right); end

  def lt_all(others); end

  def lt_any(others); end

  def lteq(right); end

  def lteq_all(others); end

  def lteq_any(others); end

  def matches(other, escape=T.unsafe(nil), case_sensitive=T.unsafe(nil)); end

  def matches_all(others, escape=T.unsafe(nil), case_sensitive=T.unsafe(nil)); end

  def matches_any(others, escape=T.unsafe(nil), case_sensitive=T.unsafe(nil)); end

  def matches_regexp(other, case_sensitive=T.unsafe(nil)); end

  def not_between(other); end

  def not_eq(other); end

  def not_eq_all(others); end

  def not_eq_any(others); end

  def not_in(other); end

  def not_in_all(others); end

  def not_in_any(others); end

  def when(right); end
end

module Arel::Predications
end

class Arel::SelectManager
  include ::Arel::Crud
  def as(other); end

  def comment(*values); end

  def constraints(); end

  def distinct(value=T.unsafe(nil)); end

  def distinct_on(value); end

  def except(other); end

  def exists(); end

  def from(table); end

  def froms(); end

  def group(*columns); end

  def having(expr); end

  def initialize(table=T.unsafe(nil)); end

  def intersect(other); end

  def join(relation, klass=T.unsafe(nil)); end

  def join_sources(); end

  def lateral(table_name=T.unsafe(nil)); end

  def limit(); end

  def limit=(limit); end

  def lock(locking=T.unsafe(nil)); end

  def locked(); end

  def minus(other); end

  def offset(); end

  def offset=(amount); end

  def on(*exprs); end

  def optimizer_hints(*hints); end

  def order(*expr); end

  def orders(); end

  def outer_join(relation); end

  def project(*projections); end

  def projections(); end

  def projections=(projections); end

  def skip(amount); end

  def source(); end

  def take(limit); end

  def taken(); end

  def union(operation, other=T.unsafe(nil)); end

  def where_sql(engine=T.unsafe(nil)); end

  def window(name); end

  def with(*subqueries); end
  STRING_OR_SYMBOL_CLASS = ::T.let(nil, ::T.untyped)
end

class Arel::SelectManager
end

class Arel::Table
  include ::Arel::Crud
  include ::Arel::FactoryMethods
  def ==(other); end

  def [](name); end

  def able_to_type_cast?(); end

  def alias(name=T.unsafe(nil)); end

  def eql?(other); end

  def from(); end

  def group(*columns); end

  def having(expr); end

  def initialize(name, as: T.unsafe(nil), type_caster: T.unsafe(nil)); end

  def join(relation, klass=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def order(*expr); end

  def outer_join(relation); end

  def project(*things); end

  def skip(amount); end

  def table_alias(); end

  def table_alias=(table_alias); end

  def table_name(); end

  def take(amount); end

  def type_cast_for_database(attribute_name, value); end

  def where(condition); end
end

class Arel::Table
  def self.engine(); end

  def self.engine=(engine); end
end

class Arel::TreeManager
  include ::Arel::FactoryMethods
  def ast(); end

  def to_dot(); end

  def to_sql(engine=T.unsafe(nil)); end

  def where(expr); end
end

module Arel::TreeManager::StatementMethods
  def key(); end

  def key=(key); end

  def offset(offset); end

  def order(*expr); end

  def take(limit); end

  def where(expr); end

  def wheres=(exprs); end
end

module Arel::TreeManager::StatementMethods
end

class Arel::TreeManager
end

class Arel::UpdateManager
  include ::Arel::TreeManager::StatementMethods
  def set(values); end

  def table(table); end
end

class Arel::UpdateManager
end

module Arel::Visitors
end

class Arel::Visitors::DepthFirst
  def initialize(block=T.unsafe(nil)); end
  DISPATCH = ::T.let(nil, ::T.untyped)
end

class Arel::Visitors::DepthFirst
end

class Arel::Visitors::Dot
  def accept(object, collector); end
end

class Arel::Visitors::Dot::Edge
end

class Arel::Visitors::Dot::Edge
end

class Arel::Visitors::Dot::Node
  def fields(); end

  def fields=(fields); end

  def id(); end

  def id=(id); end

  def initialize(name, id, fields=T.unsafe(nil)); end

  def name(); end

  def name=(name); end
end

class Arel::Visitors::Dot::Node
end

class Arel::Visitors::Dot
end

class Arel::Visitors::IBM_DB
end

class Arel::Visitors::IBM_DB
end

class Arel::Visitors::Informix
end

class Arel::Visitors::Informix
end

class Arel::Visitors::MSSQL
  def initialize(*_); end
end

class Arel::Visitors::MSSQL::RowNumber
  def children(); end

  def children=(_); end
end

class Arel::Visitors::MSSQL::RowNumber
  def self.[](*_); end

  def self.members(); end
end

class Arel::Visitors::MSSQL
end

class Arel::Visitors::MySQL
end

class Arel::Visitors::MySQL
end

class Arel::Visitors::Oracle
end

class Arel::Visitors::Oracle
end

class Arel::Visitors::Oracle12
end

class Arel::Visitors::Oracle12
end

class Arel::Visitors::PostgreSQL
end

class Arel::Visitors::PostgreSQL
end

class Arel::Visitors::SQLite
end

class Arel::Visitors::SQLite
end

class Arel::Visitors::ToSql
  def compile(node, collector=T.unsafe(nil)); end

  def initialize(connection); end
end

class Arel::Visitors::ToSql
end

class Arel::Visitors::UnsupportedVisitError
  def initialize(object); end
end

class Arel::Visitors::UnsupportedVisitError
end

class Arel::Visitors::Visitor
  def accept(object, collector=T.unsafe(nil)); end
end

class Arel::Visitors::Visitor
  def self.dispatch_cache(); end
end

class Arel::Visitors::WhereSql
  def initialize(inner_visitor, *args, &block); end
end

class Arel::Visitors::WhereSql
end

module Arel::Visitors
end

module Arel::WindowPredications
  def over(expr=T.unsafe(nil)); end
end

module Arel::WindowPredications
end

module Arel
  def self.arel_node?(value); end

  def self.fetch_attribute(value); end

  def self.sql(raw_sql); end

  def self.star(); end
end

class Array
  def bson_type(); end

  def shelljoin(); end

  def to_csv(**options); end

  def to_h(); end
end

class Array
  def self.try_convert(_); end
end

module Backport
  VERSION = ::T.let(nil, ::T.untyped)
end

class Backport::Adapter
  def close(); end

  def closed?(); end

  def closing(); end

  def initialize(output, remote=T.unsafe(nil)); end

  def opening(); end

  def receiving(data); end

  def remote(); end

  def write(data); end

  def write_line(data); end
end

class Backport::Adapter
end

class Backport::Client
  include ::Observable
  def adapter(); end

  def initialize(input, output, adapter, remote=T.unsafe(nil)); end

  def run(); end

  def start(); end

  def stop(); end

  def stopped?(); end

  def tick(); end
end

class Backport::Client
end

class Backport::Machine
  def prepare(server); end

  def run(); end

  def servers(); end

  def stop(); end

  def stopped?(); end

  def update(server); end
end

class Backport::Machine
end

module Backport::Server
end

class Backport::Server::Base
  include ::Observable
  def start(); end

  def started?(); end

  def starting(); end

  def stop(); end

  def stopped?(); end

  def stopping(); end

  def tick(); end
end

class Backport::Server::Base
end

module Backport::Server::Connectable
  def clients(); end

  def starting(); end

  def stopping(); end
end

module Backport::Server::Connectable
end

class Backport::Server::Interval
  def initialize(period, &block); end
end

class Backport::Server::Interval
end

class Backport::Server::Stdio
  include ::Backport::Server::Connectable
  def initialize(input: T.unsafe(nil), output: T.unsafe(nil), adapter: T.unsafe(nil)); end

  def update(client); end
end

class Backport::Server::Stdio
end

class Backport::Server::Tcpip
  include ::Backport::Server::Connectable
  def accept(); end

  def initialize(host: T.unsafe(nil), port: T.unsafe(nil), adapter: T.unsafe(nil), socket_class: T.unsafe(nil)); end

  def update(client); end
end

class Backport::Server::Tcpip
end

module Backport::Server
end

module Backport
  def self.logger(); end

  def self.prepare_interval(period, &block); end

  def self.prepare_stdio_server(adapter: T.unsafe(nil)); end

  def self.prepare_tcp_server(host: T.unsafe(nil), port: T.unsafe(nil), adapter: T.unsafe(nil)); end

  def self.run(&block); end

  def self.stop(); end
end

class BasicObject
  def __binding__(); end
end

BasicObject::BasicObject = BasicObject

class BasicSocket
  def read_nonblock(len, str=T.unsafe(nil), exception: T.unsafe(nil)); end
end

class BigDecimal
  def clone(); end

  def to_digits(); end
end

class BigDecimal
  def self.new(*args, **kwargs); end
end

class Binding
  def clone(); end

  def irb(); end
end

module Bootsnap::LoadPathCache
  DLEXT2 = ::T.let(nil, ::T.untyped)
end

module Bootsnap::LoadPathCache::PathScanner
  NORMALIZE_NATIVE_EXTENSIONS = ::T.let(nil, ::T.untyped)
end

class Bundler::APIResponseInvalidDependenciesError
  def status_code(); end
end

class Bundler::APIResponseInvalidDependenciesError
end

class Bundler::Definition
  def dependencies_for(groups); end

  def most_specific_locked_platform(); end

  def requested_dependencies(); end
end

class Bundler::Dependency
  def branch(); end

  def expanded_platforms(); end

  def git(); end
end

Bundler::Deprecate = Gem::Deprecate

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::EnvironmentPreserver
  def replace_with_backup(); end
end

class Bundler::EnvironmentPreserver
  def self.env_to_hash(env); end

  def self.from_env(); end
end

class Bundler::Fetcher
  def fetch_spec(spec); end

  def fetchers(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def use_api(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  FETCHERS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def initialize(downloader, remote, display_uri); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def fetch_spec(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::Index
  def fetch_spec(spec); end

  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

module Bundler::FileUtils
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::FileUtils::Entry_
  def link(dest); end
end

module Bundler::FileUtils
  def self.cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end

  def self.link_entry(src, dest, dereference_root=T.unsafe(nil), remove_destination=T.unsafe(nil)); end
end

class Bundler::GemHelper
  def allowed_push_host(); end

  def already_tagged?(); end

  def base(); end

  def build_gem(); end

  def built_gem_path(); end

  def clean?(); end

  def committed?(); end

  def default_remote(); end

  def gem_command(); end

  def gem_key(); end

  def gem_push?(); end

  def gem_push_host(); end

  def gemspec(); end

  def git_push(remote=T.unsafe(nil)); end

  def guard_clean(); end

  def initialize(base=T.unsafe(nil), name=T.unsafe(nil)); end

  def install(); end

  def install_gem(built_gem_path=T.unsafe(nil), local=T.unsafe(nil)); end

  def name(); end

  def perform_git_push(options=T.unsafe(nil)); end

  def rubygem_push(path); end

  def sh(cmd, &block); end

  def sh_with_input(cmd); end

  def sh_with_status(cmd, &block); end

  def spec_path(); end

  def tag_prefix=(tag_prefix); end

  def tag_version(); end

  def version(); end

  def version_tag(); end
end

class Bundler::GemHelper
  def self.gemspec(&block); end

  def self.install_tasks(opts=T.unsafe(nil)); end

  def self.instance(); end

  def self.instance=(instance); end

  def self.tag_prefix=(prefix); end
end

class Bundler::GemHelpers::PlatformMatch
  def self.specificity_score(spec_platform, user_platform); end
end

module Bundler::GemHelpers
  def self.local_platform(); end

  def self.same_deps(spec, exemplary_spec); end

  def self.same_specificity(platform, spec, exemplary_spec); end
end

class Bundler::GemVersionPromoter
  def initialize(locked_specs=T.unsafe(nil), unlock_gems=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def locked_specs(); end

  def major?(); end

  def minor?(); end

  def prerelease_specified(); end

  def prerelease_specified=(prerelease_specified); end

  def sort_versions(dep, spec_groups); end

  def strict(); end

  def strict=(strict); end

  def unlock_gems(); end
  DEBUG = ::T.let(nil, ::T.untyped)
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Index
  include ::Enumerable
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::Installer
  def generate_bundler_executable_stubs(spec, options=T.unsafe(nil)); end

  def generate_standalone_bundler_executable_stubs(spec, options=T.unsafe(nil)); end

  def initialize(root, definition); end

  def post_install_messages(); end

  def run(options); end
end

class Bundler::Installer
  def self.ambiguous_gems(); end

  def self.ambiguous_gems=(ambiguous_gems); end

  def self.install(root, definition, options=T.unsafe(nil)); end
end

class Bundler::LazySpecification
  def eql?(other); end
end

class Bundler::Molinillo::DependencyGraph
  include ::Enumerable
end

class Bundler::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Bundler::Molinillo::DependencyGraph::Vertex
  def _recursive_predecessors(vertices=T.unsafe(nil)); end

  def _recursive_successors(vertices=T.unsafe(nil)); end
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def bundler_plugin_api_source?(); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*_); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

class Bundler::Plugin::Index
  def installed_plugins(); end

  def plugin_commands(plugin); end

  def unregister_plugin(name); end
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

module Bundler::Plugin
  def self.list(); end

  def self.uninstall(names, options); end
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::Resolver::SpecGroup
  def activated_platforms(); end

  def activated_platforms=(activated_platforms); end

  def copy_for(platforms); end

  def sorted_activated_platforms(); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::RubygemsIntegration
  def add_default_gems_to(specs); end

  def add_to_load_path(paths); end

  def all_specs(); end

  def backport_ext_builder_monitor(); end

  def correct_for_windows_path(path); end

  def default_stubs(); end

  def find_name(name); end

  def gem_remote_fetcher(); end

  def load_env_plugins(); end

  def plain_specs(); end

  def plain_specs=(specs); end

  def stub_rubygems(specs); end

  def use_gemdeps(gemfile); end
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(&blk); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

class Bundler::Source::Git
  def glob(); end

  def local?(); end
end

class Bundler::SpecSet
  include ::Enumerable
end

class Bundler::StubSpecification
  def default_gem?(); end

  def extensions(); end

  def gem_build_complete_path(); end
end

class Bundler::Thor
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def help(command=T.unsafe(nil), subcommand=T.unsafe(nil)); end
  HELP_MAPPINGS = ::T.let(nil, ::T.untyped)
  TEMPLATE_EXTNAME = ::T.let(nil, ::T.untyped)
  THOR_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module Bundler::Thor::Actions
  def _cleanup_options_and_set(options, key); end

  def _shared_configuration(); end

  def action(instance); end

  def add_file(destination, *args, &block); end

  def add_link(destination, *args); end

  def append_file(path, *args, &block); end

  def append_to_file(path, *args, &block); end

  def apply(path, config=T.unsafe(nil)); end

  def behavior(); end

  def behavior=(behavior); end

  def chmod(path, mode, config=T.unsafe(nil)); end

  def comment_lines(path, flag, *args); end

  def copy_file(source, *args, &block); end

  def create_file(destination, *args, &block); end

  def create_link(destination, *args); end

  def destination_root(); end

  def destination_root=(root); end

  def directory(source, *args, &block); end

  def empty_directory(destination, config=T.unsafe(nil)); end

  def find_in_source_paths(file); end

  def get(source, *args, &block); end

  def gsub_file(path, flag, *args, &block); end

  def in_root(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def inject_into_class(path, klass, *args, &block); end

  def inject_into_file(destination, *args, &block); end

  def inject_into_module(path, module_name, *args, &block); end

  def insert_into_file(destination, *args, &block); end

  def inside(dir=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def link_file(source, *args); end

  def prepend_file(path, *args, &block); end

  def prepend_to_file(path, *args, &block); end

  def relative_to_original_destination_root(path, remove_dot=T.unsafe(nil)); end

  def remove_dir(path, config=T.unsafe(nil)); end

  def remove_file(path, config=T.unsafe(nil)); end

  def run(command, config=T.unsafe(nil)); end

  def run_ruby_script(command, config=T.unsafe(nil)); end

  def source_paths(); end

  def template(source, *args, &block); end

  def thor(command, *args); end

  def uncomment_lines(path, flag, *args); end
  WARNINGS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Actions::CapturableERB
end

class Bundler::Thor::Actions::CapturableERB
end

module Bundler::Thor::Actions::ClassMethods
  def add_runtime_options!(); end

  def source_paths(); end

  def source_paths_for_search(); end

  def source_root(path=T.unsafe(nil)); end
end

module Bundler::Thor::Actions::ClassMethods
end

class Bundler::Thor::Actions::CreateFile
  def data(); end

  def force_on_collision?(); end

  def force_or_skip_or_conflict(force, skip, &block); end

  def identical?(); end

  def initialize(base, destination, data, config=T.unsafe(nil)); end

  def on_conflict_behavior(&block); end

  def render(); end
end

class Bundler::Thor::Actions::CreateFile
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::Directory
  def execute!(); end

  def file_level_lookup(previous_lookup); end

  def files(lookup); end

  def initialize(base, source, destination=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def source(); end
end

class Bundler::Thor::Actions::Directory
end

class Bundler::Thor::Actions::EmptyDirectory
  def base(); end

  def config(); end

  def convert_encoded_instructions(filename); end

  def destination(); end

  def destination=(destination); end

  def exists?(); end

  def given_destination(); end

  def initialize(base, destination, config=T.unsafe(nil)); end

  def invoke!(); end

  def invoke_with_conflict_check(&block); end

  def on_conflict_behavior(); end

  def on_file_clash_behavior(); end

  def pretend?(); end

  def relative_destination(); end

  def revoke!(); end

  def say_status(status, color); end
end

class Bundler::Thor::Actions::EmptyDirectory
end

class Bundler::Thor::Actions::InjectIntoFile
  def behavior(); end

  def flag(); end

  def initialize(base, destination, data, config); end

  def replace!(regexp, string, force); end

  def replacement(); end

  def say_status(behavior, warning: T.unsafe(nil), color: T.unsafe(nil)); end
end

class Bundler::Thor::Actions::InjectIntoFile
end

module Bundler::Thor::Actions
  def self.included(base); end
end

class Bundler::Thor::AmbiguousCommandError
end

class Bundler::Thor::AmbiguousCommandError
end

Bundler::Thor::AmbiguousTaskError = Bundler::Thor::AmbiguousCommandError

class Bundler::Thor::Argument
  def banner(); end

  def default(); end

  def default_banner(); end

  def description(); end

  def enum(); end

  def human_name(); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def required(); end

  def required?(); end

  def show_default?(); end

  def type(); end

  def usage(); end

  def valid_type?(type); end

  def validate!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Argument
end

class Bundler::Thor::Arguments
  def initialize(arguments=T.unsafe(nil)); end

  def parse(args); end

  def remaining(); end
  NUMERIC = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Arguments
  def self.parse(*args); end

  def self.split(args); end
end

module Bundler::Thor::Base
  def args(); end

  def args=(args); end

  def initialize(args=T.unsafe(nil), local_options=T.unsafe(nil), config=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def parent_options(); end

  def parent_options=(parent_options); end
end

module Bundler::Thor::Base::ClassMethods
  def all_commands(); end

  def all_tasks(); end

  def allow_incompatible_default_type!(); end

  def argument(name, options=T.unsafe(nil)); end

  def arguments(); end

  def attr_accessor(*_); end

  def attr_reader(*_); end

  def attr_writer(*_); end

  def baseclass(); end

  def basename(); end

  def build_option(name, options, scope); end

  def build_options(options, scope); end

  def check_default_type(); end

  def check_default_type!(); end

  def check_unknown_options(); end

  def check_unknown_options!(); end

  def check_unknown_options?(config); end

  def class_option(name, options=T.unsafe(nil)); end

  def class_options(options=T.unsafe(nil)); end

  def class_options_help(shell, groups=T.unsafe(nil)); end

  def commands(); end

  def create_command(meth); end

  def create_task(meth); end

  def disable_required_check?(command_name); end

  def dispatch(command, given_args, given_opts, config); end

  def exit_on_failure?(); end

  def find_and_refresh_command(name); end

  def find_and_refresh_task(name); end

  def from_superclass(method, default=T.unsafe(nil)); end

  def group(name=T.unsafe(nil)); end

  def handle_argument_error(command, error, args, arity); end

  def handle_no_command_error(command, has_namespace=T.unsafe(nil)); end

  def handle_no_task_error(command, has_namespace=T.unsafe(nil)); end

  def inherited(klass); end

  def initialize_added(); end

  def is_thor_reserved_word?(word, type); end

  def method_added(meth); end

  def namespace(name=T.unsafe(nil)); end

  def no_commands(&block); end

  def no_commands?(); end

  def no_commands_context(); end

  def no_tasks(&block); end

  def print_options(shell, options, group_name=T.unsafe(nil)); end

  def public_command(*names); end

  def public_task(*names); end

  def remove_argument(*names); end

  def remove_class_option(*names); end

  def remove_command(*names); end

  def remove_task(*names); end

  def start(given_args=T.unsafe(nil), config=T.unsafe(nil)); end

  def stop_on_unknown_option?(command_name); end

  def strict_args_position(); end

  def strict_args_position!(); end

  def strict_args_position?(config); end

  def tasks(); end
end

module Bundler::Thor::Base::ClassMethods
end

module Bundler::Thor::Base
  def self.included(base); end

  def self.register_klass_file(klass); end

  def self.shell(); end

  def self.shell=(shell); end

  def self.subclass_files(); end

  def self.subclasses(); end
end

class Bundler::Thor::Command
  def formatted_usage(klass, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def handle_argument_error?(instance, error, caller); end

  def handle_no_method_error?(instance, error, caller); end

  def hidden?(); end

  def initialize(name, description, long_description, usage, options=T.unsafe(nil)); end

  def local_method?(instance, name); end

  def not_debugging?(instance); end

  def private_method?(instance); end

  def public_method?(instance); end

  def required_arguments_for(klass, usage); end

  def required_options(); end

  def run(instance, args=T.unsafe(nil)); end

  def sans_backtrace(backtrace, caller); end
  FILE_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Command
end

module Bundler::Thor::CoreExt
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
  def [](key); end

  def []=(key, value); end

  def convert_key(key); end

  def delete(key); end

  def fetch(key, *args); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(key); end

  def merge(other); end

  def merge!(other); end

  def method_missing(method, *args); end

  def replace(other_hash); end

  def reverse_merge(other); end

  def values_at(*indices); end
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
end

module Bundler::Thor::CoreExt
end

Bundler::Thor::Correctable = DidYouMean::Correctable

class Bundler::Thor::DynamicCommand
  def initialize(name, options=T.unsafe(nil)); end
end

class Bundler::Thor::DynamicCommand
end

Bundler::Thor::DynamicTask = Bundler::Thor::DynamicCommand

class Bundler::Thor::Error
end

class Bundler::Thor::Error
end

class Bundler::Thor::Group
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def _invoke_for_class_method(klass, command=T.unsafe(nil), *args, &block); end
end

class Bundler::Thor::Group
  extend ::Bundler::Thor::Base::ClassMethods
  extend ::Bundler::Thor::Invocation::ClassMethods
  def self.banner(); end

  def self.desc(description=T.unsafe(nil)); end

  def self.get_options_from_invocations(group_options, base_options); end

  def self.handle_argument_error(command, error, _args, arity); end

  def self.help(shell); end

  def self.invocation_blocks(); end

  def self.invocations(); end

  def self.invoke(*names, &block); end

  def self.invoke_from_option(*names, &block); end

  def self.printable_commands(*_); end

  def self.printable_tasks(*_); end

  def self.remove_invocation(*names); end

  def self.self_command(); end

  def self.self_task(); end
end

class Bundler::Thor::HiddenCommand
end

class Bundler::Thor::HiddenCommand
end

Bundler::Thor::HiddenTask = Bundler::Thor::HiddenCommand

module Bundler::Thor::Invocation
  def _parse_initialization_options(args, opts, config); end

  def _retrieve_class_and_command(name, sent_command=T.unsafe(nil)); end

  def _retrieve_class_and_task(name, sent_command=T.unsafe(nil)); end

  def _shared_configuration(); end

  def current_command_chain(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def invoke(name=T.unsafe(nil), *args); end

  def invoke_all(); end

  def invoke_command(command, *args); end

  def invoke_task(command, *args); end

  def invoke_with_padding(*args); end
end

module Bundler::Thor::Invocation::ClassMethods
  def prepare_for_invocation(key, name); end
end

module Bundler::Thor::Invocation::ClassMethods
end

module Bundler::Thor::Invocation
  def self.included(base); end
end

class Bundler::Thor::InvocationError
end

class Bundler::Thor::InvocationError
end

module Bundler::Thor::LineEditor
end

class Bundler::Thor::LineEditor::Basic
  def initialize(prompt, options); end

  def options(); end

  def prompt(); end

  def readline(); end
end

class Bundler::Thor::LineEditor::Basic
  def self.available?(); end
end

class Bundler::Thor::LineEditor::Readline
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
  def initialize(text); end

  def matches(); end
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
end

class Bundler::Thor::LineEditor::Readline
end

module Bundler::Thor::LineEditor
  def self.best_available(); end

  def self.readline(prompt, options=T.unsafe(nil)); end
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::NestedContext
  def enter(); end

  def entered?(); end
end

class Bundler::Thor::NestedContext
end

class Bundler::Thor::NoKwargSpellChecker
  def initialize(dictionary); end
end

class Bundler::Thor::NoKwargSpellChecker
end

class Bundler::Thor::Option
  def aliases(); end

  def array?(); end

  def boolean?(); end

  def dasherize(str); end

  def dasherized?(); end

  def group(); end

  def hash?(); end

  def hide(); end

  def lazy_default(); end

  def repeatable(); end

  def string?(); end

  def switch_name(); end

  def undasherize(str); end

  def usage(padding=T.unsafe(nil)); end

  def validate_default_type!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Option
  def self.parse(key, value); end
end

class Bundler::Thor::Options
  def assign_result!(option, result); end

  def check_unknown!(); end

  def current_is_switch?(); end

  def current_is_switch_formatted?(); end

  def initialize(hash_options=T.unsafe(nil), defaults=T.unsafe(nil), stop_on_unknown=T.unsafe(nil), disable_required_check=T.unsafe(nil)); end

  def normalize_switch(arg); end

  def parse_boolean(switch); end

  def parse_peek(switch, option); end

  def parsing_options?(); end

  def switch?(arg); end

  def switch_option(arg); end
  EQ_RE = ::T.let(nil, ::T.untyped)
  LONG_RE = ::T.let(nil, ::T.untyped)
  OPTS_END = ::T.let(nil, ::T.untyped)
  SHORT_NUM = ::T.let(nil, ::T.untyped)
  SHORT_RE = ::T.let(nil, ::T.untyped)
  SHORT_SQ_RE = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Options
  def self.to_switches(options); end
end

module Bundler::Thor::RakeCompat
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module Bundler::Thor::RakeCompat
  def self.included(base); end

  def self.rake_classes(); end
end

class Bundler::Thor::RequiredArgumentMissingError
end

class Bundler::Thor::RequiredArgumentMissingError
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Shell
  def _shared_configuration(); end

  def ask(*args, &block); end

  def error(*args, &block); end

  def file_collision(*args, &block); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def no?(*args, &block); end

  def print_in_columns(*args, &block); end

  def print_table(*args, &block); end

  def print_wrapped(*args, &block); end

  def say(*args, &block); end

  def say_status(*args, &block); end

  def set_color(*args, &block); end

  def shell(); end

  def shell=(shell); end

  def terminal_width(*args, &block); end

  def with_padding(); end

  def yes?(*args, &block); end
  SHELL_DELEGATED_METHODS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Basic
  def answer_match(possibilities, answer, case_insensitive); end

  def as_unicode(); end

  def ask(statement, *args); end

  def ask_filtered(statement, color, options); end

  def ask_simply(statement, color, options); end

  def base(); end

  def base=(base); end

  def can_display_colors?(); end

  def dynamic_width(); end

  def dynamic_width_stty(); end

  def dynamic_width_tput(); end

  def error(statement); end

  def file_collision(destination); end

  def file_collision_help(); end

  def git_merge_tool(); end

  def indent(count=T.unsafe(nil)); end

  def is?(value); end

  def lookup_color(color); end

  def merge(destination, content); end

  def merge_tool(); end

  def mute(); end

  def mute?(); end

  def no?(statement, color=T.unsafe(nil)); end

  def padding(); end

  def padding=(value); end

  def prepare_message(message, *color); end

  def print_in_columns(array); end

  def print_table(array, options=T.unsafe(nil)); end

  def print_wrapped(message, options=T.unsafe(nil)); end

  def quiet?(); end

  def say(message=T.unsafe(nil), color=T.unsafe(nil), force_new_line=T.unsafe(nil)); end

  def say_status(status, message, log_status=T.unsafe(nil)); end

  def set_color(string, *_); end

  def show_diff(destination, content); end

  def stderr(); end

  def stdout(); end

  def terminal_width(); end

  def truncate(string, width); end

  def unix?(); end

  def yes?(statement, color=T.unsafe(nil)); end
  DEFAULT_TERMINAL_WIDTH = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Basic
end

class Bundler::Thor::Shell::Color
  def are_colors_disabled?(); end

  def diff_lcs_loaded?(); end

  def output_diff_line(diff); end

  def set_color(string, *colors); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Color
end

class Bundler::Thor::Shell::HTML
  def ask(statement, color=T.unsafe(nil)); end

  def diff_lcs_loaded?(); end

  def output_diff_line(diff); end

  def set_color(string, *colors); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::HTML
end

module Bundler::Thor::Shell
end

Bundler::Thor::Task = Bundler::Thor::Command

class Bundler::Thor::UndefinedCommandError
  include ::DidYouMean::Correctable
  def all_commands(); end

  def command(); end

  def initialize(command, all_commands, namespace); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
end

class Bundler::Thor::UndefinedCommandError
end

Bundler::Thor::UndefinedTaskError = Bundler::Thor::UndefinedCommandError

class Bundler::Thor::UnknownArgumentError
  include ::DidYouMean::Correctable
  def initialize(switches, unknown); end

  def switches(); end

  def unknown(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
end

class Bundler::Thor::UnknownArgumentError
end

module Bundler::Thor::Util
end

module Bundler::Thor::Util
  def self.camel_case(str); end

  def self.escape_globs(path); end

  def self.escape_html(string); end

  def self.find_by_namespace(namespace); end

  def self.find_class_and_command_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.find_class_and_task_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.globs_for(path); end

  def self.load_thorfile(path, content=T.unsafe(nil), debug=T.unsafe(nil)); end

  def self.namespace_from_thor_class(constant); end

  def self.namespaces_in_content(contents, file=T.unsafe(nil)); end

  def self.ruby_command(); end

  def self.snake_case(str); end

  def self.thor_classes_in(klass); end

  def self.thor_root(); end

  def self.thor_root_glob(); end

  def self.user_home(); end
end

class Bundler::Thor
  extend ::Bundler::Thor::Base::ClassMethods
  extend ::Bundler::Thor::Invocation::ClassMethods
  def self.banner(command, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.check_unknown_options!(options=T.unsafe(nil)); end

  def self.command_help(shell, command_name); end

  def self.default_command(meth=T.unsafe(nil)); end

  def self.default_task(meth=T.unsafe(nil)); end

  def self.deprecation_warning(message); end

  def self.desc(usage, description, options=T.unsafe(nil)); end

  def self.disable_required_check(); end

  def self.disable_required_check!(*command_names); end

  def self.disable_required_check?(command); end

  def self.dispatch(meth, given_args, given_opts, config); end

  def self.dynamic_command_class(); end

  def self.find_command_possibilities(meth); end

  def self.find_task_possibilities(meth); end

  def self.help(shell, subcommand=T.unsafe(nil)); end

  def self.long_desc(long_description, options=T.unsafe(nil)); end

  def self.map(mappings=T.unsafe(nil), **kw); end

  def self.method_option(name, options=T.unsafe(nil)); end

  def self.method_options(options=T.unsafe(nil)); end

  def self.normalize_command_name(meth); end

  def self.normalize_task_name(meth); end

  def self.option(name, options=T.unsafe(nil)); end

  def self.options(options=T.unsafe(nil)); end

  def self.package_name(name, _=T.unsafe(nil)); end

  def self.printable_commands(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.printable_tasks(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.register(klass, subcommand_name, usage, description, options=T.unsafe(nil)); end

  def self.retrieve_command_name(args); end

  def self.retrieve_task_name(args); end

  def self.stop_on_unknown_option(); end

  def self.stop_on_unknown_option!(*command_names); end

  def self.stop_on_unknown_option?(command); end

  def self.subcommand(subcommand, subcommand_class); end

  def self.subcommand_classes(); end

  def self.subcommand_help(cmd); end

  def self.subcommands(); end

  def self.subtask(subcommand, subcommand_class); end

  def self.subtask_help(cmd); end

  def self.subtasks(); end

  def self.task_help(shell, command_name); end
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg, newline=T.unsafe(nil)); end

  def debug(msg, newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg, newline=T.unsafe(nil), color=T.unsafe(nil)); end

  def info(msg, newline=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg, newline=T.unsafe(nil), color=T.unsafe(nil)); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

module Bundler::URI
  include ::Bundler::URI::RFC2396_REGEXP
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ABS_URI_REF = ::T.let(nil, ::T.untyped)
  DEFAULT_PARSER = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  OPAQUE = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REGISTRY = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  REL_URI_REF = ::T.let(nil, ::T.untyped)
  RFC3986_PARSER = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TBLDECWWWCOMP_ = ::T.let(nil, ::T.untyped)
  TBLENCWWWCOMP_ = ::T.let(nil, ::T.untyped)
  UNSAFE = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_CODE = ::T.let(nil, ::T.untyped)
  WEB_ENCODINGS_ = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::BadURIError
end

class Bundler::URI::BadURIError
end

class Bundler::URI::Error
end

class Bundler::URI::Error
end

module Bundler::URI::Escape
  def decode(*arg); end

  def encode(*arg); end

  def escape(*arg); end

  def unescape(*arg); end
end

module Bundler::URI::Escape
end

class Bundler::URI::FTP
  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  TYPECODE = ::T.let(nil, ::T.untyped)
  TYPECODE_PREFIX = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class Bundler::URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::File
end

class Bundler::URI::Generic
  include ::Bundler::URI
  include ::Bundler::URI::RFC2396_REGEXP
  def +(oth); end

  def -(oth); end

  def ==(oth); end

  def absolute(); end

  def absolute?(); end

  def coerce(oth); end

  def component(); end

  def component_ary(); end

  def default_port(); end

  def eql?(oth); end

  def find_proxy(env=T.unsafe(nil)); end

  def fragment(); end

  def fragment=(v); end

  def hierarchical?(); end

  def host(); end

  def host=(v); end

  def hostname(); end

  def hostname=(v); end

  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser=T.unsafe(nil), arg_check=T.unsafe(nil)); end

  def merge(oth); end

  def merge!(oth); end

  def normalize(); end

  def normalize!(); end

  def opaque(); end

  def opaque=(v); end

  def parser(); end

  def password(); end

  def password=(password); end

  def path(); end

  def path=(v); end

  def port(); end

  def port=(v); end

  def query(); end

  def query=(v); end

  def registry(); end

  def registry=(v); end

  def relative?(); end

  def route_from(oth); end

  def route_to(oth); end

  def scheme(); end

  def scheme=(v); end

  def select(*components); end

  def set_host(v); end

  def set_opaque(v); end

  def set_password(v); end

  def set_path(v); end

  def set_port(v); end

  def set_registry(v); end

  def set_scheme(v); end

  def set_user(v); end

  def set_userinfo(user, password=T.unsafe(nil)); end

  def user(); end

  def user=(user); end

  def userinfo(); end

  def userinfo=(userinfo); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  USE_REGISTRY = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::Generic
  def self.build(args); end

  def self.build2(args); end

  def self.component(); end

  def self.default_port(); end

  def self.use_proxy?(hostname, addr, port, no_proxy); end

  def self.use_registry(); end
end

class Bundler::URI::HTTP
  def request_uri(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::HTTP
end

class Bundler::URI::HTTPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::HTTPS
end

class Bundler::URI::InvalidComponentError
end

class Bundler::URI::InvalidComponentError
end

class Bundler::URI::InvalidURIError
end

class Bundler::URI::InvalidURIError
end

class Bundler::URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  SCOPE = ::T.let(nil, ::T.untyped)
  SCOPE_BASE = ::T.let(nil, ::T.untyped)
  SCOPE_ONE = ::T.let(nil, ::T.untyped)
  SCOPE_SUB = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::LDAP
end

class Bundler::URI::LDAPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::LDAPS
end

class Bundler::URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  EMAIL_REGEXP = ::T.let(nil, ::T.untyped)
  HEADER_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::MailTo
end

Bundler::URI::Parser = Bundler::URI::RFC2396_Parser

Bundler::URI::REGEXP = Bundler::URI::RFC2396_REGEXP

class Bundler::URI::RFC2396_Parser
  include ::Bundler::URI::RFC2396_REGEXP
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class Bundler::URI::RFC2396_Parser
end

module Bundler::URI::RFC2396_REGEXP
end

module Bundler::URI::RFC2396_REGEXP::PATTERN
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ALNUM = ::T.let(nil, ::T.untyped)
  ALPHA = ::T.let(nil, ::T.untyped)
  DOMLABEL = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HEX = ::T.let(nil, ::T.untyped)
  HIER_PART = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  HOSTNAME = ::T.let(nil, ::T.untyped)
  HOSTPORT = ::T.let(nil, ::T.untyped)
  IPV4ADDR = ::T.let(nil, ::T.untyped)
  IPV6ADDR = ::T.let(nil, ::T.untyped)
  IPV6REF = ::T.let(nil, ::T.untyped)
  NET_PATH = ::T.let(nil, ::T.untyped)
  OPAQUE_PART = ::T.let(nil, ::T.untyped)
  PATH_SEGMENTS = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REG_NAME = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_SEGMENT = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TOPLABEL = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  URIC = ::T.let(nil, ::T.untyped)
  URIC_NO_SLASH = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  X_ABS_URI = ::T.let(nil, ::T.untyped)
  X_REL_URI = ::T.let(nil, ::T.untyped)
end

module Bundler::URI::RFC2396_REGEXP::PATTERN
end

module Bundler::URI::RFC2396_REGEXP
end

class Bundler::URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_URI = ::T.let(nil, ::T.untyped)
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::RFC3986_Parser
end

module Bundler::URI::Util
end

module Bundler::URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module Bundler::URI
  extend ::Bundler::URI::Escape
  def self.decode_www_form(str, enc=T.unsafe(nil), separator: T.unsafe(nil), use__charset_: T.unsafe(nil), isindex: T.unsafe(nil)); end

  def self.decode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.encode_www_form(enum, enc=T.unsafe(nil)); end

  def self.encode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.extract(str, schemes=T.unsafe(nil), &block); end

  def self.get_encoding(label); end

  def self.join(*str); end

  def self.parse(uri); end

  def self.regexp(schemes=T.unsafe(nil)); end

  def self.scheme_list(); end

  def self.split(uri); end
end

module Bundler::VersionRanges
end

class Bundler::VersionRanges::NEq
  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::NEq
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def cover?(v); end

  def empty?(); end

  def left(); end

  def left=(_); end

  def right(); end

  def right=(_); end

  def single?(); end
  INFINITY = ::T.let(nil, ::T.untyped)
  UNIVERSAL = ::T.let(nil, ::T.untyped)
  ZERO = ::T.let(nil, ::T.untyped)
end

class Bundler::VersionRanges::ReqR::Endpoint
  def inclusive(); end

  def inclusive=(_); end

  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::ReqR::Endpoint
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def self.[](*_); end

  def self.members(); end
end

module Bundler::VersionRanges
  def self.empty?(ranges, neqs); end

  def self.for(requirement); end

  def self.for_many(requirements); end
end

module Bundler
  def self.most_specific_locked_platform?(platform); end

  def self.original_exec(*args); end

  def self.original_system(*args); end

  def self.preferred_gemfile_name(); end

  def self.reset_settings_and_root!(); end

  def self.unbundled_env(); end

  def self.unbundled_exec(*args); end

  def self.unbundled_system(*args); end

  def self.with_unbundled_env(); end
end

module Byebug
  include ::Byebug::Helpers::ReflectionHelper
  def displays(); end

  def displays=(displays); end

  def init_file(); end

  def init_file=(init_file); end

  def mode(); end

  def mode=(mode); end

  def run_init_script(); end
  PORT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutoirbSetting
  def banner(); end

  def value=(val); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutoirbSetting
end

class Byebug::AutolistSetting
  def banner(); end

  def value=(val); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutolistSetting
end

class Byebug::AutoprySetting
  def banner(); end

  def value=(val); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutoprySetting
end

class Byebug::AutosaveSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutosaveSetting
end

class Byebug::BasenameSetting
  def banner(); end
end

class Byebug::BasenameSetting
end

class Byebug::BreakCommand
  include ::Byebug::Helpers::EvalHelper
  include ::Byebug::Helpers::FileHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::BreakCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Breakpoint
  def enabled=(enabled); end

  def enabled?(); end

  def expr(); end

  def expr=(expr); end

  def hit_condition(); end

  def hit_condition=(hit_condition); end

  def hit_count(); end

  def hit_value(); end

  def hit_value=(hit_value); end

  def id(); end

  def initialize(_, _1, _2); end

  def pos(); end

  def source(); end
end

class Byebug::Breakpoint
  def self.add(file, line, expr=T.unsafe(nil)); end

  def self.first(); end

  def self.last(); end

  def self.none?(); end

  def self.potential_line?(filename, lineno); end

  def self.potential_lines(filename); end

  def self.remove(id); end
end

class Byebug::CallstyleSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::CallstyleSetting
end

class Byebug::CatchCommand
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::CatchCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Command
  def arguments(); end

  def confirm(*args, &block); end

  def context(); end

  def errmsg(*args, &block); end

  def frame(); end

  def help(*args, &block); end

  def initialize(processor, input=T.unsafe(nil)); end

  def match(*args, &block); end

  def pr(*args, &block); end

  def prc(*args, &block); end

  def print(*args, &block); end

  def processor(); end

  def prv(*args, &block); end

  def puts(*args, &block); end
end

class Byebug::Command
  extend ::Forwardable
  extend ::Byebug::Helpers::StringHelper
  def self.allow_in_control(); end

  def self.allow_in_control=(allow_in_control); end

  def self.allow_in_post_mortem(); end

  def self.allow_in_post_mortem=(allow_in_post_mortem); end

  def self.always_run(); end

  def self.always_run=(always_run); end

  def self.columnize(width); end

  def self.help(); end

  def self.match(input); end
end

class Byebug::CommandList
  include ::Enumerable
  def each(&blk); end

  def initialize(commands); end

  def match(input); end
end

class Byebug::CommandList
end

class Byebug::CommandNotFound
  def initialize(input, parent=T.unsafe(nil)); end
end

class Byebug::CommandNotFound
end

class Byebug::CommandProcessor
  include ::Byebug::Helpers::EvalHelper
  def after_repl(); end

  def at_breakpoint(brkpt); end

  def at_catchpoint(exception); end

  def at_end(); end

  def at_line(); end

  def at_return(return_value); end

  def at_tracing(); end

  def before_repl(); end

  def command_list(); end

  def commands(*args, &block); end

  def confirm(*args, &block); end

  def context(); end

  def errmsg(*args, &block); end

  def frame(*args, &block); end

  def initialize(context, interface=T.unsafe(nil)); end

  def interface(); end

  def pr(*args, &block); end

  def prc(*args, &block); end

  def prev_line(); end

  def prev_line=(prev_line); end

  def printer(); end

  def proceed!(); end

  def process_commands(); end

  def prompt(); end

  def prv(*args, &block); end

  def puts(*args, &block); end

  def repl(); end
end

class Byebug::CommandProcessor
  extend ::Forwardable
end

class Byebug::ConditionCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::ConditionCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Context
  include ::Byebug::Helpers::FileHelper
  def at_breakpoint(breakpoint); end

  def at_catchpoint(exception); end

  def at_end(); end

  def at_line(); end

  def at_return(return_value); end

  def at_tracing(); end

  def backtrace(); end

  def dead?(); end

  def file(*args, &block); end

  def frame(); end

  def frame=(pos); end

  def frame_binding(*_); end

  def frame_class(*_); end

  def frame_file(*_); end

  def frame_line(*_); end

  def frame_method(*_); end

  def frame_self(*_); end

  def full_location(); end

  def ignored?(); end

  def interrupt(); end

  def line(*args, &block); end

  def location(); end

  def resume(); end

  def stack_size(); end

  def step_into(*_); end

  def step_out(*_); end

  def step_over(*_); end

  def stop_reason(); end

  def suspend(); end

  def suspended?(); end

  def switch(); end

  def thnum(); end

  def thread(); end

  def tracing(); end

  def tracing=(tracing); end
end

class Byebug::Context
  extend ::Byebug::Helpers::PathHelper
  extend ::Forwardable
  def self.ignored_files(); end

  def self.ignored_files=(ignored_files); end

  def self.interface(); end

  def self.interface=(interface); end

  def self.processor(); end

  def self.processor=(processor); end
end

class Byebug::ContinueCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::ContinueCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ControlProcessor
  def commands(); end
end

class Byebug::ControlProcessor
end

class Byebug::DebugCommand
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::DebugCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DebugThread
end

class Byebug::DebugThread
  def self.inherited(); end
end

class Byebug::DeleteCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::DeleteCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DisableCommand
  include ::Byebug::Subcommands
end

class Byebug::DisableCommand::BreakpointsCommand
  include ::Byebug::Helpers::ToggleHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::DisableCommand::BreakpointsCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DisableCommand::DisplayCommand
  include ::Byebug::Helpers::ToggleHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::DisableCommand::DisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DisableCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DisplayCommand
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::DisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DownCommand
  include ::Byebug::Helpers::FrameHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::DownCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::EditCommand
  def execute(); end
end

class Byebug::EditCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::EnableCommand
  include ::Byebug::Subcommands
end

class Byebug::EnableCommand::BreakpointsCommand
  include ::Byebug::Helpers::ToggleHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::EnableCommand::BreakpointsCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::EnableCommand::DisplayCommand
  include ::Byebug::Helpers::ToggleHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::EnableCommand::DisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::EnableCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::FinishCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::FinishCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Frame
  include ::Byebug::Helpers::FileHelper
  def _binding(); end

  def _class(); end

  def _method(); end

  def _self(); end

  def args(); end

  def c_frame?(); end

  def current?(); end

  def deco_args(); end

  def deco_block(); end

  def deco_call(); end

  def deco_class(); end

  def deco_file(); end

  def deco_method(); end

  def deco_pos(); end

  def file(); end

  def initialize(context, pos); end

  def line(); end

  def locals(); end

  def mark(); end

  def pos(); end

  def to_hash(); end
end

class Byebug::Frame
end

class Byebug::FrameCommand
  include ::Byebug::Helpers::FrameHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::FrameCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::FullpathSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::FullpathSetting
end

class Byebug::HelpCommand
  def execute(); end
end

class Byebug::HelpCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

module Byebug::Helpers
end

module Byebug::Helpers::BinHelper
  def executable_file_extensions(); end

  def find_executable(path, cmd); end

  def real_executable?(file); end

  def search_paths(); end

  def which(cmd); end
end

module Byebug::Helpers::BinHelper
end

module Byebug::Helpers::EvalHelper
  def error_eval(str, binding=T.unsafe(nil)); end

  def multiple_thread_eval(expression); end

  def separate_thread_eval(expression); end

  def silent_eval(str, binding=T.unsafe(nil)); end

  def warning_eval(str, binding=T.unsafe(nil)); end
end

module Byebug::Helpers::EvalHelper
end

module Byebug::Helpers::FileHelper
  def get_line(filename, lineno); end

  def get_lines(filename); end

  def n_lines(filename); end

  def normalize(filename); end

  def shortpath(fullpath); end

  def virtual_file?(name); end
end

module Byebug::Helpers::FileHelper
end

module Byebug::Helpers::FrameHelper
  def jump_frames(steps); end

  def switch_to_frame(frame); end
end

module Byebug::Helpers::FrameHelper
end

module Byebug::Helpers::ParseHelper
  def get_int(str, cmd, min=T.unsafe(nil), max=T.unsafe(nil)); end

  def parse_steps(str, cmd); end

  def syntax_valid?(code); end
end

module Byebug::Helpers::ParseHelper
end

module Byebug::Helpers::PathHelper
  def all_files(); end

  def bin_file(); end

  def gem_files(); end

  def lib_files(); end

  def root_path(); end

  def test_files(); end
end

module Byebug::Helpers::PathHelper
end

module Byebug::Helpers::ReflectionHelper
  def commands(); end
end

module Byebug::Helpers::ReflectionHelper
end

module Byebug::Helpers::StringHelper
  def camelize(str); end

  def deindent(str, leading_spaces: T.unsafe(nil)); end

  def prettify(str); end
end

module Byebug::Helpers::StringHelper
end

module Byebug::Helpers::ThreadHelper
  def context_from_thread(thnum); end

  def current_thread?(ctx); end

  def display_context(ctx); end

  def thread_arguments(ctx); end
end

module Byebug::Helpers::ThreadHelper
end

module Byebug::Helpers::ToggleHelper
  include ::Byebug::Helpers::ParseHelper
  def enable_disable_breakpoints(is_enable, args); end

  def enable_disable_display(is_enable, args); end
end

module Byebug::Helpers::ToggleHelper
end

module Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper
  def var_args(); end

  def var_global(); end

  def var_instance(str); end

  def var_list(ary, binding=T.unsafe(nil)); end

  def var_local(); end
end

module Byebug::Helpers::VarHelper
end

module Byebug::Helpers
end

class Byebug::HistfileSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::HistfileSetting
end

class Byebug::History
  def buffer(); end

  def clear(); end

  def default_max_size(); end

  def ignore?(buf); end

  def last_ids(number); end

  def pop(); end

  def push(cmd); end

  def restore(); end

  def save(); end

  def size(); end

  def size=(size); end

  def specific_max_size(number); end

  def to_s(n_cmds); end
end

class Byebug::History
end

class Byebug::HistoryCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::HistoryCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::HistsizeSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::HistsizeSetting
end

class Byebug::InfoCommand
  include ::Byebug::Subcommands
end

class Byebug::InfoCommand::BreakpointsCommand
  def execute(); end
end

class Byebug::InfoCommand::BreakpointsCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand::DisplayCommand
  def execute(); end
end

class Byebug::InfoCommand::DisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand::FileCommand
  include ::Byebug::Helpers::FileHelper
  include ::Byebug::Helpers::StringHelper
  def execute(); end
end

class Byebug::InfoCommand::FileCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand::LineCommand
  def execute(); end
end

class Byebug::InfoCommand::LineCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand::ProgramCommand
  def execute(); end
end

class Byebug::InfoCommand::ProgramCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Interface
  include ::Byebug::Helpers::FileHelper
  def autorestore(); end

  def autosave(); end

  def close(); end

  def command_queue(); end

  def command_queue=(command_queue); end

  def confirm(prompt); end

  def errmsg(message); end

  def error(); end

  def history(); end

  def history=(history); end

  def input(); end

  def last_if_empty(input); end

  def output(); end

  def prepare_input(prompt); end

  def print(message); end

  def puts(message); end

  def read_command(prompt); end

  def read_file(filename); end

  def read_input(prompt, save_hist=T.unsafe(nil)); end
end

class Byebug::Interface
end

class Byebug::InterruptCommand
  def execute(); end
end

class Byebug::InterruptCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::IrbCommand
  def execute(); end
end

class Byebug::IrbCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::KillCommand
  def execute(); end
end

class Byebug::KillCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::LinetraceSetting
  def banner(); end

  def value=(val); end
end

class Byebug::LinetraceSetting
end

class Byebug::ListCommand
  include ::Byebug::Helpers::FileHelper
  include ::Byebug::Helpers::ParseHelper
  def amend_final(*args, &block); end

  def execute(); end

  def max_line(*args, &block); end

  def size(*args, &block); end
end

class Byebug::ListCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ListsizeSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::ListsizeSetting
end

class Byebug::LocalInterface
  def readline(prompt); end

  def with_repl_like_sigint(); end

  def without_readline_completion(); end
  EOF_ALIAS = ::T.let(nil, ::T.untyped)
end

class Byebug::LocalInterface
end

class Byebug::MethodCommand
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::MethodCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::NextCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::NextCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::PostMortemProcessor
  def commands(); end
end

class Byebug::PostMortemProcessor
end

class Byebug::PostMortemSetting
  def banner(); end

  def value=(val); end
end

class Byebug::PostMortemSetting
end

module Byebug::Printers
end

class Byebug::Printers::Base
  def type(); end
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Byebug::Printers::Base::MissedArgument
end

class Byebug::Printers::Base::MissedArgument
end

class Byebug::Printers::Base::MissedPath
end

class Byebug::Printers::Base::MissedPath
end

class Byebug::Printers::Base
end

class Byebug::Printers::Plain
  def print(path, args=T.unsafe(nil)); end

  def print_collection(path, collection, &block); end

  def print_variables(variables, *_unused); end
end

class Byebug::Printers::Plain
end

module Byebug::Printers
end

class Byebug::PryCommand
  def execute(); end
end

class Byebug::PryCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::QuitCommand
  def execute(); end
end

class Byebug::QuitCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

module Byebug::Remote
end

class Byebug::Remote::Client
  def initialize(interface); end

  def interface(); end

  def socket(); end

  def start(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def started?(); end
end

class Byebug::Remote::Client
end

class Byebug::Remote::Server
  def actual_port(); end

  def initialize(wait_connection:, &block); end

  def start(host, port); end

  def wait_connection(); end
end

class Byebug::Remote::Server
end

module Byebug::Remote
end

class Byebug::RemoteInterface
  def initialize(socket); end

  def readline(prompt); end
end

class Byebug::RemoteInterface
end

class Byebug::RestartCommand
  include ::Byebug::Helpers::BinHelper
  include ::Byebug::Helpers::PathHelper
  def execute(); end
end

class Byebug::RestartCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::SaveCommand
  def execute(); end
end

class Byebug::SaveCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::SavefileSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::SavefileSetting
end

class Byebug::ScriptInterface
  def initialize(file, verbose=T.unsafe(nil)); end
end

class Byebug::ScriptInterface
end

class Byebug::ScriptProcessor
  def commands(); end
end

class Byebug::ScriptProcessor
end

class Byebug::SetCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::SetCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Setting
  def boolean?(); end

  def help(); end

  def integer?(); end

  def to_sym(); end

  def value(); end

  def value=(value); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::Setting
  def self.[](name); end

  def self.[]=(name, value); end

  def self.find(shortcut); end

  def self.help_all(); end

  def self.settings(); end
end

class Byebug::ShowCommand
  def execute(); end
end

class Byebug::ShowCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::SkipCommand
  include ::Byebug::Helpers::ParseHelper
  def auto_run(); end

  def execute(); end

  def initialize_attributes(); end

  def keep_execution(); end

  def reset_attributes(); end
end

class Byebug::SkipCommand
  def self.description(); end

  def self.file_line(); end

  def self.file_line=(file_line); end

  def self.file_path(); end

  def self.file_path=(file_path); end

  def self.previous_autolist(); end

  def self.regexp(); end

  def self.restore_autolist(); end

  def self.setup_autolist(value); end

  def self.short_description(); end
end

class Byebug::SourceCommand
  def execute(); end
end

class Byebug::SourceCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::SourceFileFormatter
  include ::Byebug::Helpers::FileHelper
  def amend(line, ceiling); end

  def amend_final(line); end

  def amend_initial(line); end

  def annotator(); end

  def file(); end

  def initialize(file, annotator); end

  def lines(min, max); end

  def lines_around(center); end

  def max_initial_line(); end

  def max_line(); end

  def range_around(center); end

  def range_from(min); end

  def size(); end
end

class Byebug::SourceFileFormatter
end

class Byebug::StackOnErrorSetting
  def banner(); end
end

class Byebug::StackOnErrorSetting
end

class Byebug::StepCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::StepCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

module Byebug::Subcommands
  def execute(); end

  def subcommand_list(*args, &block); end
end

module Byebug::Subcommands::ClassMethods
  include ::Byebug::Helpers::ReflectionHelper
  def help(); end

  def subcommand_list(); end
end

module Byebug::Subcommands::ClassMethods
end

module Byebug::Subcommands
  extend ::Forwardable
  def self.included(command); end
end

class Byebug::ThreadCommand
  include ::Byebug::Subcommands
end

class Byebug::ThreadCommand::CurrentCommand
  include ::Byebug::Helpers::ThreadHelper
  def execute(); end
end

class Byebug::ThreadCommand::CurrentCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand::ListCommand
  include ::Byebug::Helpers::ThreadHelper
  def execute(); end
end

class Byebug::ThreadCommand::ListCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand::ResumeCommand
  include ::Byebug::Helpers::ThreadHelper
  def execute(); end
end

class Byebug::ThreadCommand::ResumeCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand::StopCommand
  include ::Byebug::Helpers::ThreadHelper
  def execute(); end
end

class Byebug::ThreadCommand::StopCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand::SwitchCommand
  include ::Byebug::Helpers::ThreadHelper
  def execute(); end
end

class Byebug::ThreadCommand::SwitchCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadsTable
end

class Byebug::ThreadsTable
end

class Byebug::TracevarCommand
  def execute(); end
end

class Byebug::TracevarCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::UndisplayCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::UndisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::UntracevarCommand
  def execute(); end
end

class Byebug::UntracevarCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::UpCommand
  include ::Byebug::Helpers::FrameHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::UpCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand
  include ::Byebug::Subcommands
end

class Byebug::VarCommand::AllCommand
  include ::Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::VarCommand::AllCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::ArgsCommand
  include ::Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::VarCommand::ArgsCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::ConstCommand
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::VarCommand::ConstCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::GlobalCommand
  include ::Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::VarCommand::GlobalCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::InstanceCommand
  include ::Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::VarCommand::InstanceCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::LocalCommand
  include ::Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::VarCommand::LocalCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::WhereCommand
  include ::Byebug::Helpers::FrameHelper
  def execute(); end
end

class Byebug::WhereCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::WidthSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::WidthSetting
end

module Byebug
  extend ::Byebug
  extend ::Byebug::Helpers::ReflectionHelper
  def self.actual_control_port(); end

  def self.actual_port(); end

  def self.handle_post_mortem(); end

  def self.interrupt(); end

  def self.load_settings(); end

  def self.parse_host_and_port(host_port_spec); end

  def self.start_client(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.start_control(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.start_server(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.wait_connection(); end

  def self.wait_connection=(wait_connection); end
end

module CGI::HtmlExtension
  def a(href=T.unsafe(nil)); end

  def base(href=T.unsafe(nil)); end

  def blockquote(cite=T.unsafe(nil)); end

  def caption(align=T.unsafe(nil)); end

  def checkbox(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def checkbox_group(name=T.unsafe(nil), *values); end

  def file_field(name=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def form(method=T.unsafe(nil), action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def hidden(name=T.unsafe(nil), value=T.unsafe(nil)); end

  def html(attributes=T.unsafe(nil)); end

  def image_button(src=T.unsafe(nil), name=T.unsafe(nil), alt=T.unsafe(nil)); end

  def img(src=T.unsafe(nil), alt=T.unsafe(nil), width=T.unsafe(nil), height=T.unsafe(nil)); end

  def multipart_form(action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def password_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def popup_menu(name=T.unsafe(nil), *values); end

  def radio_button(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def radio_group(name=T.unsafe(nil), *values); end

  def reset(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def scrolling_list(name=T.unsafe(nil), *values); end

  def submit(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def text_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def textarea(name=T.unsafe(nil), cols=T.unsafe(nil), rows=T.unsafe(nil)); end
end

module CGI::HtmlExtension
end

class Class
  def json_creatable?(); end
end

module CodeRay
  CODERAY_PATH = ::T.let(nil, ::T.untyped)
  TokenKinds = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class CodeRay::Duo
  def call(code, options=T.unsafe(nil)); end

  def encode(code, options=T.unsafe(nil)); end

  def encoder(); end

  def format(); end

  def format=(format); end

  def highlight(code, options=T.unsafe(nil)); end

  def initialize(lang=T.unsafe(nil), format=T.unsafe(nil), options=T.unsafe(nil)); end

  def lang(); end

  def lang=(lang); end

  def options(); end

  def options=(options); end

  def scanner(); end
end

class CodeRay::Duo
  def self.[](*_); end
end

module CodeRay::Encoders
end

class CodeRay::Encoders::Encoder
  def <<(token); end

  def begin_group(kind); end

  def begin_line(kind); end

  def compile(tokens, options=T.unsafe(nil)); end

  def encode(code, lang, options=T.unsafe(nil)); end

  def encode_tokens(tokens, options=T.unsafe(nil)); end

  def end_group(kind); end

  def end_line(kind); end

  def file_extension(); end

  def finish(options); end

  def get_output(options); end

  def highlight(code, lang, options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def output(data); end

  def scanner(); end

  def scanner=(scanner); end

  def setup(options); end

  def text_token(text, kind); end

  def token(content, kind); end

  def tokens(tokens, options=T.unsafe(nil)); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

CodeRay::Encoders::Encoder::PLUGIN_HOST = CodeRay::Encoders

class CodeRay::Encoders::Encoder
  extend ::CodeRay::Plugin
  def self.const_missing(sym); end

  def self.file_extension(); end
end

class CodeRay::Encoders::Terminal
  TOKEN_COLORS = ::T.let(nil, ::T.untyped)
end

class CodeRay::Encoders::Terminal
end

module CodeRay::Encoders
  extend ::CodeRay::PluginHost
end

module CodeRay::FileType
  TypeFromExt = ::T.let(nil, ::T.untyped)
  TypeFromName = ::T.let(nil, ::T.untyped)
  TypeFromShebang = ::T.let(nil, ::T.untyped)
end

class CodeRay::FileType::UnknownFileType
end

class CodeRay::FileType::UnknownFileType
end

module CodeRay::FileType
  def self.[](filename, read_shebang=T.unsafe(nil)); end

  def self.fetch(filename, default=T.unsafe(nil), read_shebang=T.unsafe(nil)); end

  def self.type_from_shebang(filename); end
end

module CodeRay::Plugin
  def aliases(); end

  def plugin_host(host=T.unsafe(nil)); end

  def plugin_id(); end

  def register_for(id); end

  def title(title=T.unsafe(nil)); end
end

module CodeRay::Plugin
end

module CodeRay::PluginHost
  def [](id, *args, &blk); end

  def all_plugins(); end

  def const_missing(const); end

  def default(id=T.unsafe(nil)); end

  def list(); end

  def load(id, *args, &blk); end

  def load_all(); end

  def load_plugin_map(); end

  def make_plugin_hash(); end

  def map(hash); end

  def path_to(plugin_id); end

  def plugin_hash(); end

  def plugin_path(*args); end

  def register(plugin, id); end

  def validate_id(id); end
  PLUGIN_HOSTS = ::T.let(nil, ::T.untyped)
  PLUGIN_HOSTS_BY_ID = ::T.let(nil, ::T.untyped)
end

class CodeRay::PluginHost::HostNotFound
end

class CodeRay::PluginHost::HostNotFound
end

class CodeRay::PluginHost::PluginNotFound
end

class CodeRay::PluginHost::PluginNotFound
end

module CodeRay::PluginHost
  def self.extended(mod); end
end

module CodeRay::Scanners
end

class CodeRay::Scanners::Scanner
  include ::Enumerable
  def binary_string(); end

  def column(pos=T.unsafe(nil)); end

  def each(&block); end

  def file_extension(); end

  def initialize(code=T.unsafe(nil), options=T.unsafe(nil)); end

  def lang(); end

  def line(pos=T.unsafe(nil)); end

  def raise_inspect(message, tokens, state=T.unsafe(nil), ambit=T.unsafe(nil), backtrace=T.unsafe(nil)); end

  def raise_inspect_arguments(message, tokens, state, ambit); end

  def reset_instance(); end

  def scan_rest(); end

  def scan_tokens(tokens, options); end

  def scanner_state_info(state); end

  def set_string_from_source(source); end

  def set_tokens_from_options(options); end

  def setup(); end

  def state(); end

  def state=(state); end

  def string=(code); end

  def tokenize(source=T.unsafe(nil), options=T.unsafe(nil)); end

  def tokens(); end

  def tokens_last(tokens, n); end

  def tokens_size(tokens); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  KINDS_NOT_LOC = ::T.let(nil, ::T.untyped)
  SCANNER_STATE_INFO = ::T.let(nil, ::T.untyped)
  SCAN_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
end

CodeRay::Scanners::Scanner::PLUGIN_HOST = CodeRay::Scanners

class CodeRay::Scanners::Scanner::ScanError
end

class CodeRay::Scanners::Scanner::ScanError
end

class CodeRay::Scanners::Scanner
  extend ::CodeRay::Plugin
  def self.encode_with_encoding(code, target_encoding); end

  def self.encoding(name=T.unsafe(nil)); end

  def self.file_extension(extension=T.unsafe(nil)); end

  def self.guess_encoding(s); end

  def self.lang(); end

  def self.normalize(code); end

  def self.to_unix(code); end
end

module CodeRay::Scanners
  extend ::CodeRay::PluginHost
end

module CodeRay::Styles
end

class CodeRay::Styles::Style
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

CodeRay::Styles::Style::PLUGIN_HOST = CodeRay::Styles

class CodeRay::Styles::Style
  extend ::CodeRay::Plugin
end

module CodeRay::Styles
  extend ::CodeRay::PluginHost
end

class CodeRay::Tokens
  def begin_group(kind); end

  def begin_line(kind); end

  def count(); end

  def encode(encoder, options=T.unsafe(nil)); end

  def end_group(kind); end

  def end_line(kind); end

  def method_missing(meth, options=T.unsafe(nil)); end

  def scanner(); end

  def scanner=(scanner); end

  def split_into_parts(*sizes); end

  def text_token(*_); end

  def to_s(); end

  def tokens(*_); end
end

class CodeRay::Tokens
end

class CodeRay::TokensProxy
  def block(); end

  def block=(block); end

  def each(*args, &blk); end

  def encode(encoder, options=T.unsafe(nil)); end

  def initialize(input, lang, options=T.unsafe(nil), block=T.unsafe(nil)); end

  def input(); end

  def input=(input); end

  def lang(); end

  def lang=(lang); end

  def method_missing(method, *args, &blk); end

  def options(); end

  def options=(options); end

  def scanner(); end

  def tokens(); end
end

class CodeRay::TokensProxy
end

module CodeRay
  def self.coderay_path(*path); end

  def self.encode(code, lang, format, options=T.unsafe(nil)); end

  def self.encode_file(filename, format, options=T.unsafe(nil)); end

  def self.encode_tokens(tokens, format, options=T.unsafe(nil)); end

  def self.encoder(format, options=T.unsafe(nil)); end

  def self.get_scanner_options(options); end

  def self.highlight(code, lang, options=T.unsafe(nil), format=T.unsafe(nil)); end

  def self.highlight_file(filename, options=T.unsafe(nil), format=T.unsafe(nil)); end

  def self.scan(code, lang, options=T.unsafe(nil), &block); end

  def self.scan_file(filename, lang=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def self.scanner(lang, options=T.unsafe(nil), &block); end
end

class Comment
  def ___id_default__(); end

  def __callbacks(); end

  def __callbacks?(); end

  def _build_callbacks(); end

  def _create_callbacks(); end

  def _declared_scopes(); end

  def _declared_scopes=(val); end

  def _declared_scopes?(); end

  def _destroy_callbacks(); end

  def _find_callbacks(); end

  def _index(); end

  def _index=(_index); end

  def _initialize_callbacks(); end

  def _run_build_callbacks(&block); end

  def _run_create_callbacks(&block); end

  def _run_destroy_callbacks(&block); end

  def _run_find_callbacks(&block); end

  def _run_initialize_callbacks(&block); end

  def _run_save_callbacks(&block); end

  def _run_touch_callbacks(&block); end

  def _run_update_callbacks(&block); end

  def _run_upsert_callbacks(&block); end

  def _run_validate_callbacks(&block); end

  def _run_validation_callbacks(&block); end

  def _save_callbacks(); end

  def _touch_callbacks(); end

  def _update_callbacks(); end

  def _upsert_callbacks(); end

  def _validate_callbacks(); end

  def _validation_callbacks(); end

  def _validators(); end

  def _validators?(); end

  def aliased_fields(); end

  def aliased_fields=(val); end

  def aliased_fields?(); end

  def before_callback_halted(); end

  def before_callback_halted=(before_callback_halted); end

  def build_post(*args); end

  def cache_timestamp_format(); end

  def create_post(*args); end

  def cyclic(); end

  def cyclic=(val); end

  def cyclic?(); end

  def default_scoping(); end

  def default_scoping=(val); end

  def default_scoping?(); end

  def dependents(); end

  def dependents=(val); end

  def dependents?(); end

  def dependents_owner(); end

  def dependents_owner=(val); end

  def dependents_owner?(); end

  def embedded=(val); end

  def embedded_relations(); end

  def embedded_relations=(val); end

  def embedded_relations?(); end

  def fields(); end

  def fields=(val); end

  def fields?(); end

  def has_post?(); end

  def id(); end

  def id=(value); end

  def include_root_in_json(); end

  def include_root_in_json?(); end

  def index_specifications(); end

  def index_specifications=(obj); end

  def localized_fields(); end

  def localized_fields=(val); end

  def localized_fields?(); end

  def model_name(*args, &block); end

  def nested_attributes(); end

  def nested_attributes=(val); end

  def nested_attributes?(); end

  def polymorphic(); end

  def polymorphic=(val); end

  def polymorphic?(); end

  def post(reload=T.unsafe(nil)); end

  def post=(object); end

  def post?(); end

  def post_processed_defaults(); end

  def post_processed_defaults=(val); end

  def post_processed_defaults?(); end

  def pre_processed_defaults(); end

  def pre_processed_defaults=(val); end

  def pre_processed_defaults?(); end

  def readonly_attributes(); end

  def readonly_attributes=(val); end

  def readonly_attributes?(); end

  def relations(); end

  def relations=(val); end

  def relations?(); end

  def shard_config(); end

  def shard_config=(obj); end

  def shard_key_fields=(obj); end

  def storage_options(); end

  def validation_context(); end
end

class Comment
  extend ::ActiveModel::Callbacks
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveModel::Translation
  extend ::ActiveModel::Naming
  extend ::ActiveModel::Validations::HelperMethods
  extend ::Mongoid::Validatable::Macros
  extend ::Mongoid::Findable
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._build_callbacks(); end

  def self._build_callbacks=(value); end

  def self._create_callbacks(); end

  def self._create_callbacks=(value); end

  def self._declared_scopes(); end

  def self._declared_scopes=(val); end

  def self._declared_scopes?(); end

  def self._destroy_callbacks(); end

  def self._destroy_callbacks=(value); end

  def self._find_callbacks(); end

  def self._find_callbacks=(value); end

  def self._initialize_callbacks(); end

  def self._initialize_callbacks=(value); end

  def self._save_callbacks(); end

  def self._save_callbacks=(value); end

  def self._touch_callbacks(); end

  def self._touch_callbacks=(value); end

  def self._update_callbacks(); end

  def self._update_callbacks=(value); end

  def self._upsert_callbacks(); end

  def self._upsert_callbacks=(value); end

  def self._validate_callbacks(); end

  def self._validate_callbacks=(value); end

  def self._validation_callbacks(); end

  def self._validation_callbacks=(value); end

  def self._validators(); end

  def self._validators=(val); end

  def self._validators?(); end

  def self.add_discriminator_mapping(value, klass=T.unsafe(nil)); end

  def self.after_build(*args, **options, &block); end

  def self.after_create(*args, **options, &block); end

  def self.after_destroy(*args, **options, &block); end

  def self.after_find(*args, **options, &block); end

  def self.after_initialize(*args, **options, &block); end

  def self.after_save(*args, **options, &block); end

  def self.after_touch(*args, **options, &block); end

  def self.after_update(*args, **options, &block); end

  def self.after_upsert(*args, **options, &block); end

  def self.aliased_fields(); end

  def self.aliased_fields=(val); end

  def self.aliased_fields?(); end

  def self.around_create(*args, **options, &block); end

  def self.around_destroy(*args, **options, &block); end

  def self.around_save(*args, **options, &block); end

  def self.around_update(*args, **options, &block); end

  def self.around_upsert(*args, **options, &block); end

  def self.before_create(*args, **options, &block); end

  def self.before_destroy(*args, **options, &block); end

  def self.before_save(*args, **options, &block); end

  def self.before_update(*args, **options, &block); end

  def self.before_upsert(*args, **options, &block); end

  def self.cache_timestamp_format(); end

  def self.cache_timestamp_format=(obj); end

  def self.cyclic(); end

  def self.cyclic=(val); end

  def self.cyclic?(); end

  def self.default_scoping(); end

  def self.default_scoping=(val); end

  def self.default_scoping?(); end

  def self.dependents(); end

  def self.dependents=(val); end

  def self.dependents?(); end

  def self.dependents_owner(); end

  def self.dependents_owner=(val); end

  def self.dependents_owner?(); end

  def self.discriminator_key(*args, &block); end

  def self.discriminator_key=(val); end

  def self.discriminator_key?(); end

  def self.discriminator_mapping(); end

  def self.discriminator_mapping=(discriminator_mapping); end

  def self.embedded(); end

  def self.embedded=(val); end

  def self.embedded?(); end

  def self.embedded_relations(); end

  def self.embedded_relations=(val); end

  def self.embedded_relations?(); end

  def self.fields(); end

  def self.fields=(val); end

  def self.fields?(); end

  def self.get_discriminator_mapping(value); end

  def self.include_root_in_json(*args, &block); end

  def self.include_root_in_json=(val); end

  def self.include_root_in_json?(); end

  def self.index_specifications(); end

  def self.index_specifications=(obj); end

  def self.localized_fields(); end

  def self.localized_fields=(val); end

  def self.localized_fields?(); end

  def self.nested_attributes(); end

  def self.nested_attributes=(val); end

  def self.nested_attributes?(); end

  def self.polymorphic(); end

  def self.polymorphic=(val); end

  def self.polymorphic?(); end

  def self.post_processed_defaults(); end

  def self.post_processed_defaults=(val); end

  def self.post_processed_defaults?(); end

  def self.pre_processed_defaults(); end

  def self.pre_processed_defaults=(val); end

  def self.pre_processed_defaults?(); end

  def self.readonly_attributes(); end

  def self.readonly_attributes=(val); end

  def self.readonly_attributes?(); end

  def self.relations(); end

  def self.relations=(val); end

  def self.relations?(); end

  def self.shard_config(); end

  def self.shard_config=(obj); end

  def self.shard_key_fields(); end

  def self.shard_key_fields=(obj); end

  def self.storage_options(); end

  def self.storage_options=(obj); end
end

class Concurrent::Promises::AbstractEventFuture
  include ::Concurrent::Promises::InternalStates
end

module Concurrent::Promises::Resolvable
  include ::Concurrent::Promises::InternalStates
end

class Concurrent::RubyThreadPoolExecutor
  DEFAULT_SYNCHRONOUS = ::T.let(nil, ::T.untyped)
end

class DRb::DRbArray
  def _dump(lv); end
end

class DRb::DRbArray
  def self._load(s); end
end

class DRb::DRbConn
  def alive?(); end

  def close(); end

  def initialize(remote_uri); end

  def send_message(ref, msg_id, arg, block); end

  def uri(); end
end

class DRb::DRbConn
  def self.open(remote_uri); end
end

class DRb::DRbMessage
  def dump(obj, error=T.unsafe(nil)); end

  def initialize(config); end

  def load(soc); end

  def recv_reply(stream); end

  def recv_request(stream); end

  def send_reply(stream, succ, result); end

  def send_request(stream, ref, msg_id, arg, b); end
end

class DRb::DRbObject
  def ==(other); end

  def eql?(other); end

  def initialize(obj, uri=T.unsafe(nil)); end
end

class DRb::DRbObject
  def self.prepare_backtrace(uri, result); end

  def self.with_friend(uri); end
end

module DRb::DRbProtocol
  def self.auto_load(uri); end
end

class DRb::DRbRemoteError
  def initialize(error); end
end

class DRb::DRbServer
  def initialize(uri=T.unsafe(nil), front=T.unsafe(nil), config_or_acl=T.unsafe(nil)); end

  def safe_level(); end
end

class DRb::DRbServer::InvokeMethod
  include ::DRb::DRbServer::InvokeMethod18Mixin
  def initialize(drb_server, client); end

  def perform(); end
end

class DRb::DRbServer::InvokeMethod
end

module DRb::DRbServer::InvokeMethod18Mixin
  def block_yield(x); end

  def perform_with_block(); end
end

module DRb::DRbServer::InvokeMethod18Mixin
end

class DRb::DRbServer
  def self.default_safe_level(level); end

  def self.make_config(hash=T.unsafe(nil)); end
end

class DRb::DRbTCPSocket
  def accept(); end

  def alive?(); end

  def close(); end

  def initialize(uri, soc, config=T.unsafe(nil)); end

  def peeraddr(); end

  def recv_reply(); end

  def recv_request(); end

  def send_reply(succ, result); end

  def send_request(ref, msg_id, arg, b); end

  def set_sockopt(soc); end

  def shutdown(); end

  def stream(); end

  def uri(); end
end

class DRb::DRbTCPSocket
  def self.getservername(); end

  def self.open(uri, config); end

  def self.open_server(uri, config); end

  def self.open_server_inaddr_any(host, port); end

  def self.parse_uri(uri); end

  def self.uri_option(uri, config); end
end

class DRb::DRbUNIXSocket
  def initialize(uri, soc, config=T.unsafe(nil), server_mode=T.unsafe(nil)); end
  Max_try = ::T.let(nil, ::T.untyped)
end

class DRb::DRbUNIXSocket
  def self.temp_server(); end
end

class DRb::DRbURIOption
  def ==(other); end

  def eql?(other); end

  def initialize(option); end

  def option(); end
end

class DRb::DRbURIOption
end

module DRb::DRbUndumped
  def _dump(dummy); end
end

class DRb::DRbUnknown
  def _dump(lv); end
end

class DRb::DRbUnknown
  def self._load(s); end
end

class DRb::DRbUnknownError
  def _dump(lv); end

  def initialize(unknown); end
end

class DRb::DRbUnknownError
  def self._load(s); end
end

module DRb
  def self.mutex(); end
end

DRbIdConv = DRb::DRbIdConv

DRbObject = DRb::DRbObject

DRbUndumped = DRb::DRbUndumped

class Date
  def compare_without_coercion(_); end

  def default_inspect(); end

  def minus_without_duration(_); end

  def plus_without_duration(_); end

  def to_default_s(); end
end

class Date::Infinity
  def initialize(d=T.unsafe(nil)); end
end

class Delegator
  include ::ActiveSupport::Tryable
end

class DidYouMean::ClassNameChecker
  def class_name(); end

  def class_names(); end

  def corrections(); end

  def initialize(exception); end

  def scopes(); end
end

module DidYouMean::Correctable
  def corrections(); end

  def original_message(); end

  def spell_checker(); end

  def to_s(); end
end

module DidYouMean::Jaro
  def self.distance(str1, str2); end
end

module DidYouMean::JaroWinkler
  def self.distance(str1, str2); end
end

class DidYouMean::KeyErrorChecker
  def corrections(); end

  def initialize(key_error); end
end

class DidYouMean::KeyErrorChecker
end

module DidYouMean::Levenshtein
  def self.distance(str1, str2); end

  def self.min3(a, b, c); end
end

class DidYouMean::MethodNameChecker
  def corrections(); end

  def initialize(exception); end

  def method_name(); end

  def method_names(); end

  def receiver(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

class DidYouMean::NullChecker
  def corrections(); end

  def initialize(*_); end
end

class DidYouMean::PlainFormatter
  def message_for(corrections); end
end

class DidYouMean::PlainFormatter
end

class DidYouMean::VariableNameChecker
  def corrections(); end

  def cvar_names(); end

  def initialize(exception); end

  def ivar_names(); end

  def lvar_names(); end

  def method_names(); end

  def name(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module DidYouMean
  def self.formatter(); end

  def self.formatter=(formatter); end
end

class Dir
  def children(); end

  def each_child(); end
end

class Dir
  def self.exists?(_); end
end

class ERB
  def def_method(mod, methodname, fname=T.unsafe(nil)); end

  def def_module(methodname=T.unsafe(nil)); end
end

class ERB::Compiler::Scanner
  DEFAULT_ETAGS = ::T.let(nil, ::T.untyped)
  DEFAULT_STAGS = ::T.let(nil, ::T.untyped)
end

class Encoding
  def _dump(*_); end
end

class Encoding::Converter
  def initialize(*_); end
end

class Encoding
  def self._load(_); end
end

module Enumerable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def chain(*_); end
end

class Enumerator
  def +(_); end

  def each_with_index(); end
end

class Enumerator::ArithmeticSequence
  def begin(); end

  def each(&blk); end

  def end(); end

  def exclude_end?(); end

  def last(*_); end

  def step(); end
end

class Enumerator::ArithmeticSequence
end

class Enumerator::Chain
end

class Enumerator::Chain
end

class Enumerator::Generator
  def each(*_, &blk); end

  def initialize(*_); end
end

Errno::EAUTH = Errno::NOERROR

Errno::EBADARCH = Errno::NOERROR

Errno::EBADEXEC = Errno::NOERROR

Errno::EBADMACHO = Errno::NOERROR

Errno::EBADRPC = Errno::NOERROR

Errno::ECAPMODE = Errno::NOERROR

Errno::EDEADLOCK = Errno::EDEADLK

Errno::EDEVERR = Errno::NOERROR

Errno::EDOOFUS = Errno::NOERROR

Errno::EFTYPE = Errno::NOERROR

Errno::EIPSEC = Errno::NOERROR

Errno::ELAST = Errno::NOERROR

Errno::ENEEDAUTH = Errno::NOERROR

Errno::ENOATTR = Errno::NOERROR

Errno::ENOPOLICY = Errno::NOERROR

Errno::ENOTCAPABLE = Errno::NOERROR

class Errno::ENOTSUP
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOTSUP
end

Errno::EPROCLIM = Errno::NOERROR

Errno::EPROCUNAVAIL = Errno::NOERROR

Errno::EPROGMISMATCH = Errno::NOERROR

Errno::EPROGUNAVAIL = Errno::NOERROR

Errno::EPWROFF = Errno::NOERROR

Errno::EQFULL = Errno::NOERROR

Errno::ERPCMISMATCH = Errno::NOERROR

Errno::ESHLIBVERS = Errno::NOERROR

class Etc::Group
  def gid(); end

  def gid=(_); end

  def mem(); end

  def mem=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end
end

class Etc::Group
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Etc::Passwd
  def dir=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid=(_); end

  def name=(_); end

  def passwd=(_); end

  def shell=(_); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Exception
  def __bb_context(); end
end

module Exception2MessageMapper
  def bind(cl); end
end

Exception2MessageMapper::E2MM = Exception2MessageMapper

class Exception2MessageMapper::ErrNotRegisteredException
end

class Exception2MessageMapper::ErrNotRegisteredException
end

module Exception2MessageMapper
  def self.Fail(klass=T.unsafe(nil), err=T.unsafe(nil), *rest); end

  def self.Raise(klass=T.unsafe(nil), err=T.unsafe(nil), *rest); end

  def self.def_e2message(k, c, m); end

  def self.def_exception(k, n, m, s=T.unsafe(nil)); end

  def self.e2mm_message(klass, exp); end

  def self.extend_object(cl); end

  def self.message(klass, exp); end
end

class ExitCalledError
end

class ExitCalledError
end

module FFI
  CURRENT_PROCESS = ::T.let(nil, ::T.untyped)
  SizeTypes = ::T.let(nil, ::T.untyped)
  TYPE_BOOL = ::T.let(nil, ::T.untyped)
  TYPE_BUFFER_IN = ::T.let(nil, ::T.untyped)
  TYPE_BUFFER_INOUT = ::T.let(nil, ::T.untyped)
  TYPE_BUFFER_OUT = ::T.let(nil, ::T.untyped)
  TYPE_FLOAT32 = ::T.let(nil, ::T.untyped)
  TYPE_FLOAT64 = ::T.let(nil, ::T.untyped)
  TYPE_INT16 = ::T.let(nil, ::T.untyped)
  TYPE_INT32 = ::T.let(nil, ::T.untyped)
  TYPE_INT64 = ::T.let(nil, ::T.untyped)
  TYPE_INT8 = ::T.let(nil, ::T.untyped)
  TYPE_LONG = ::T.let(nil, ::T.untyped)
  TYPE_LONGDOUBLE = ::T.let(nil, ::T.untyped)
  TYPE_POINTER = ::T.let(nil, ::T.untyped)
  TYPE_STRING = ::T.let(nil, ::T.untyped)
  TYPE_UINT16 = ::T.let(nil, ::T.untyped)
  TYPE_UINT32 = ::T.let(nil, ::T.untyped)
  TYPE_UINT64 = ::T.let(nil, ::T.untyped)
  TYPE_UINT8 = ::T.let(nil, ::T.untyped)
  TYPE_ULONG = ::T.let(nil, ::T.untyped)
  TYPE_VARARGS = ::T.let(nil, ::T.untyped)
  TYPE_VOID = ::T.let(nil, ::T.untyped)
  TypeDefs = ::T.let(nil, ::T.untyped)
  USE_THIS_PROCESS_AS_LIBRARY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class FFI::AbstractMemory
  def [](_); end

  def __copy_from__(_, _1); end

  def clear(); end

  def get(_, _1); end

  def get_array_of_char(_, _1); end

  def get_array_of_double(_, _1); end

  def get_array_of_float(_, _1); end

  def get_array_of_float32(_, _1); end

  def get_array_of_float64(_, _1); end

  def get_array_of_int(_, _1); end

  def get_array_of_int16(_, _1); end

  def get_array_of_int32(_, _1); end

  def get_array_of_int64(_, _1); end

  def get_array_of_int8(_, _1); end

  def get_array_of_long(_, _1); end

  def get_array_of_long_long(_, _1); end

  def get_array_of_pointer(_, _1); end

  def get_array_of_short(_, _1); end

  def get_array_of_string(*_); end

  def get_array_of_uchar(_, _1); end

  def get_array_of_uint(_, _1); end

  def get_array_of_uint16(_, _1); end

  def get_array_of_uint32(_, _1); end

  def get_array_of_uint64(_, _1); end

  def get_array_of_uint8(_, _1); end

  def get_array_of_ulong(_, _1); end

  def get_array_of_ulong_long(_, _1); end

  def get_array_of_ushort(_, _1); end

  def get_bytes(_, _1); end

  def get_char(_); end

  def get_double(_); end

  def get_float(_); end

  def get_float32(_); end

  def get_float64(_); end

  def get_int(_); end

  def get_int16(_); end

  def get_int32(_); end

  def get_int64(_); end

  def get_int8(_); end

  def get_long(_); end

  def get_long_long(_); end

  def get_pointer(_); end

  def get_short(_); end

  def get_string(*_); end

  def get_uchar(_); end

  def get_uint(_); end

  def get_uint16(_); end

  def get_uint32(_); end

  def get_uint64(_); end

  def get_uint8(_); end

  def get_ulong(_); end

  def get_ulong_long(_); end

  def get_ushort(_); end

  def put(_, _1, _2); end

  def put_array_of_char(_, _1); end

  def put_array_of_double(_, _1); end

  def put_array_of_float(_, _1); end

  def put_array_of_float32(_, _1); end

  def put_array_of_float64(_, _1); end

  def put_array_of_int(_, _1); end

  def put_array_of_int16(_, _1); end

  def put_array_of_int32(_, _1); end

  def put_array_of_int64(_, _1); end

  def put_array_of_int8(_, _1); end

  def put_array_of_long(_, _1); end

  def put_array_of_long_long(_, _1); end

  def put_array_of_pointer(_, _1); end

  def put_array_of_short(_, _1); end

  def put_array_of_uchar(_, _1); end

  def put_array_of_uint(_, _1); end

  def put_array_of_uint16(_, _1); end

  def put_array_of_uint32(_, _1); end

  def put_array_of_uint64(_, _1); end

  def put_array_of_uint8(_, _1); end

  def put_array_of_ulong(_, _1); end

  def put_array_of_ulong_long(_, _1); end

  def put_array_of_ushort(_, _1); end

  def put_bytes(*_); end

  def put_char(_, _1); end

  def put_double(_, _1); end

  def put_float(_, _1); end

  def put_float32(_, _1); end

  def put_float64(_, _1); end

  def put_int(_, _1); end

  def put_int16(_, _1); end

  def put_int32(_, _1); end

  def put_int64(_, _1); end

  def put_int8(_, _1); end

  def put_long(_, _1); end

  def put_long_long(_, _1); end

  def put_pointer(_, _1); end

  def put_short(_, _1); end

  def put_string(_, _1); end

  def put_uchar(_, _1); end

  def put_uint(_, _1); end

  def put_uint16(_, _1); end

  def put_uint32(_, _1); end

  def put_uint64(_, _1); end

  def put_uint8(_, _1); end

  def put_ulong(_, _1); end

  def put_ulong_long(_, _1); end

  def put_ushort(_, _1); end

  def read_array_of_char(_); end

  def read_array_of_double(_); end

  def read_array_of_float(_); end

  def read_array_of_int(_); end

  def read_array_of_int16(_); end

  def read_array_of_int32(_); end

  def read_array_of_int64(_); end

  def read_array_of_int8(_); end

  def read_array_of_long(_); end

  def read_array_of_long_long(_); end

  def read_array_of_pointer(_); end

  def read_array_of_short(_); end

  def read_array_of_uchar(_); end

  def read_array_of_uint(_); end

  def read_array_of_uint16(_); end

  def read_array_of_uint32(_); end

  def read_array_of_uint64(_); end

  def read_array_of_uint8(_); end

  def read_array_of_ulong(_); end

  def read_array_of_ulong_long(_); end

  def read_array_of_ushort(_); end

  def read_bytes(_); end

  def read_char(); end

  def read_double(); end

  def read_float(); end

  def read_int(); end

  def read_int16(); end

  def read_int32(); end

  def read_int64(); end

  def read_int8(); end

  def read_long(); end

  def read_long_long(); end

  def read_pointer(); end

  def read_short(); end

  def read_uchar(); end

  def read_uint(); end

  def read_uint16(); end

  def read_uint32(); end

  def read_uint64(); end

  def read_uint8(); end

  def read_ulong(); end

  def read_ulong_long(); end

  def read_ushort(); end

  def size(); end

  def size_limit?(); end

  def total(); end

  def type_size(); end

  def write_array_of_char(_); end

  def write_array_of_double(_); end

  def write_array_of_float(_); end

  def write_array_of_int(_); end

  def write_array_of_int16(_); end

  def write_array_of_int32(_); end

  def write_array_of_int64(_); end

  def write_array_of_int8(_); end

  def write_array_of_long(_); end

  def write_array_of_long_long(_); end

  def write_array_of_pointer(_); end

  def write_array_of_short(_); end

  def write_array_of_uchar(_); end

  def write_array_of_uint(_); end

  def write_array_of_uint16(_); end

  def write_array_of_uint32(_); end

  def write_array_of_uint64(_); end

  def write_array_of_uint8(_); end

  def write_array_of_ulong(_); end

  def write_array_of_ulong_long(_); end

  def write_array_of_ushort(_); end

  def write_bytes(*_); end

  def write_char(_); end

  def write_double(_); end

  def write_float(_); end

  def write_int(_); end

  def write_int16(_); end

  def write_int32(_); end

  def write_int64(_); end

  def write_int8(_); end

  def write_long(_); end

  def write_long_long(_); end

  def write_pointer(_); end

  def write_short(_); end

  def write_uchar(_); end

  def write_uint(_); end

  def write_uint16(_); end

  def write_uint32(_); end

  def write_uint64(_); end

  def write_uint8(_); end

  def write_ulong(_); end

  def write_ulong_long(_); end

  def write_ushort(_); end
end

class FFI::AbstractMemory
end

class FFI::ArrayType
  def elem_type(); end

  def initialize(_, _1); end

  def length(); end
end

class FFI::ArrayType
end

class FFI::AutoPointer
  def autorelease=(autorelease); end

  def initialize(ptr, proc=T.unsafe(nil), &block); end
end

class FFI::AutoPointer::CallableReleaser
  def release(ptr); end
end

class FFI::AutoPointer::CallableReleaser
end

class FFI::AutoPointer::DefaultReleaser
  def release(ptr); end
end

class FFI::AutoPointer::DefaultReleaser
end

class FFI::AutoPointer::Releaser
  def autorelease(); end

  def autorelease=(autorelease); end

  def call(*args); end

  def free(); end

  def initialize(ptr, proc); end
end

class FFI::AutoPointer::Releaser
end

class FFI::AutoPointer
  extend ::FFI::DataConverter
  def self.from_native(val, ctx); end

  def self.native_type(); end
end

class FFI::Bitmask
  def [](*query); end

  def to_native(query, ctx); end
end

class FFI::Bitmask
end

class FFI::Buffer
  def +(_); end

  def initialize(*_); end

  def length(); end

  def order(*_); end

  def slice(_, _1); end
end

class FFI::Buffer
  def self.alloc_in(*_); end

  def self.alloc_inout(*_); end

  def self.alloc_out(*_); end

  def self.new_in(*_); end

  def self.new_inout(*_); end

  def self.new_out(*_); end
end

FFI::CallbackInfo = FFI::FunctionType

module FFI::DataConverter
  def from_native(value, ctx); end

  def native_type(type=T.unsafe(nil)); end

  def to_native(value, ctx); end
end

module FFI::DataConverter
end

class FFI::DynamicLibrary
  def find_function(_); end

  def find_symbol(_); end

  def find_variable(_); end

  def initialize(_, _1); end

  def last_error(); end

  def name(); end
  RTLD_ALL_MASK = ::T.let(nil, ::T.untyped)
  RTLD_BINDING_MASK = ::T.let(nil, ::T.untyped)
  RTLD_DEEPBIND = ::T.let(nil, ::T.untyped)
  RTLD_FIRST = ::T.let(nil, ::T.untyped)
  RTLD_GLOBAL = ::T.let(nil, ::T.untyped)
  RTLD_LAZY = ::T.let(nil, ::T.untyped)
  RTLD_LOCAL = ::T.let(nil, ::T.untyped)
  RTLD_LOCATION_MASK = ::T.let(nil, ::T.untyped)
  RTLD_MEMBER = ::T.let(nil, ::T.untyped)
  RTLD_NODELETE = ::T.let(nil, ::T.untyped)
  RTLD_NOLOAD = ::T.let(nil, ::T.untyped)
  RTLD_NOW = ::T.let(nil, ::T.untyped)
end

class FFI::DynamicLibrary::Symbol
end

class FFI::DynamicLibrary::Symbol
end

class FFI::DynamicLibrary
  def self.last_error(); end

  def self.open(_, _1); end
end

class FFI::Enum
  include ::FFI::DataConverter
  def [](query); end

  def find(query); end

  def from_native(val, ctx); end

  def initialize(*args); end

  def native_type(); end

  def symbol_map(); end

  def symbols(); end

  def tag(); end

  def to_h(); end

  def to_hash(); end

  def to_native(val, ctx); end
end

class FFI::Enum
end

class FFI::Enums
  def <<(enum); end

  def __map_symbol(symbol); end

  def find(query); end
end

class FFI::Enums
end

class FFI::Function
  def attach(_, _1); end

  def autorelease(); end

  def call(*_); end
end

class FFI::Function
end

FFI::FunctionInfo = FFI::FunctionType

class FFI::FunctionType
  def initialize(*_); end

  def param_types(); end

  def result_type(); end
end

class FFI::FunctionType
end

module FFI::IO
end

module FFI::IO
  def self.for_fd(fd, mode=T.unsafe(nil)); end

  def self.native_read(io, buf, len); end
end

module FFI::LastError
end

module FFI::LastError
  def self.error(); end

  def self.error=(error); end
end

module FFI::Library
  def attach_function(name, func, args, returns=T.unsafe(nil), options=T.unsafe(nil)); end

  def attach_variable(mname, a1, a2=T.unsafe(nil)); end

  def bitmask(*args); end

  def callback(*args); end

  def enum(*args); end

  def enum_type(name); end

  def enum_value(symbol); end

  def ffi_convention(convention=T.unsafe(nil)); end

  def ffi_lib(*names); end

  def ffi_lib_flags(*flags); end

  def ffi_libraries(); end

  def find_type(t); end

  def function_names(name, arg_types); end

  def typedef(old, add, info=T.unsafe(nil)); end
  CURRENT_PROCESS = ::T.let(nil, ::T.untyped)
  FlagsMap = ::T.let(nil, ::T.untyped)
  LIBC = ::T.let(nil, ::T.untyped)
end

module FFI::Library
  def self.extended(mod); end
end

class FFI::ManagedStruct
  def initialize(pointer=T.unsafe(nil)); end
end

class FFI::ManagedStruct
end

class FFI::MemoryPointer
end

class FFI::MemoryPointer
  def self.from_string(_); end
end

FFI::NativeLibrary = FFI::DynamicLibrary

module FFI::NativeType
  BOOL = ::T.let(nil, ::T.untyped)
  BUFFER_IN = ::T.let(nil, ::T.untyped)
  BUFFER_INOUT = ::T.let(nil, ::T.untyped)
  BUFFER_OUT = ::T.let(nil, ::T.untyped)
  FLOAT32 = ::T.let(nil, ::T.untyped)
  FLOAT64 = ::T.let(nil, ::T.untyped)
  INT16 = ::T.let(nil, ::T.untyped)
  INT32 = ::T.let(nil, ::T.untyped)
  INT64 = ::T.let(nil, ::T.untyped)
  INT8 = ::T.let(nil, ::T.untyped)
  LONG = ::T.let(nil, ::T.untyped)
  LONGDOUBLE = ::T.let(nil, ::T.untyped)
  POINTER = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  UINT16 = ::T.let(nil, ::T.untyped)
  UINT32 = ::T.let(nil, ::T.untyped)
  UINT64 = ::T.let(nil, ::T.untyped)
  UINT8 = ::T.let(nil, ::T.untyped)
  ULONG = ::T.let(nil, ::T.untyped)
  VARARGS = ::T.let(nil, ::T.untyped)
  VOID = ::T.let(nil, ::T.untyped)
end

module FFI::NativeType
end

class FFI::NotFoundError
  def initialize(function, *libraries); end
end

class FFI::NotFoundError
end

class FFI::NullPointerError
end

class FFI::NullPointerError
end

module FFI::Platform
  ADDRESS_ALIGN = ::T.let(nil, ::T.untyped)
  ADDRESS_SIZE = ::T.let(nil, ::T.untyped)
  ARCH = ::T.let(nil, ::T.untyped)
  BIG_ENDIAN = ::T.let(nil, ::T.untyped)
  BYTE_ORDER = ::T.let(nil, ::T.untyped)
  CONF_DIR = ::T.let(nil, ::T.untyped)
  CPU = ::T.let(nil, ::T.untyped)
  DOUBLE_ALIGN = ::T.let(nil, ::T.untyped)
  DOUBLE_SIZE = ::T.let(nil, ::T.untyped)
  FLOAT_ALIGN = ::T.let(nil, ::T.untyped)
  FLOAT_SIZE = ::T.let(nil, ::T.untyped)
  GNU_LIBC = ::T.let(nil, ::T.untyped)
  INT16_ALIGN = ::T.let(nil, ::T.untyped)
  INT16_SIZE = ::T.let(nil, ::T.untyped)
  INT32_ALIGN = ::T.let(nil, ::T.untyped)
  INT32_SIZE = ::T.let(nil, ::T.untyped)
  INT64_ALIGN = ::T.let(nil, ::T.untyped)
  INT64_SIZE = ::T.let(nil, ::T.untyped)
  INT8_ALIGN = ::T.let(nil, ::T.untyped)
  INT8_SIZE = ::T.let(nil, ::T.untyped)
  IS_BSD = ::T.let(nil, ::T.untyped)
  IS_DRAGONFLYBSD = ::T.let(nil, ::T.untyped)
  IS_FREEBSD = ::T.let(nil, ::T.untyped)
  IS_GNU = ::T.let(nil, ::T.untyped)
  IS_LINUX = ::T.let(nil, ::T.untyped)
  IS_MAC = ::T.let(nil, ::T.untyped)
  IS_NETBSD = ::T.let(nil, ::T.untyped)
  IS_OPENBSD = ::T.let(nil, ::T.untyped)
  IS_SOLARIS = ::T.let(nil, ::T.untyped)
  IS_WINDOWS = ::T.let(nil, ::T.untyped)
  LIBC = ::T.let(nil, ::T.untyped)
  LIBPREFIX = ::T.let(nil, ::T.untyped)
  LIBSUFFIX = ::T.let(nil, ::T.untyped)
  LITTLE_ENDIAN = ::T.let(nil, ::T.untyped)
  LONG_ALIGN = ::T.let(nil, ::T.untyped)
  LONG_DOUBLE_ALIGN = ::T.let(nil, ::T.untyped)
  LONG_DOUBLE_SIZE = ::T.let(nil, ::T.untyped)
  LONG_SIZE = ::T.let(nil, ::T.untyped)
  NAME = ::T.let(nil, ::T.untyped)
  OS = ::T.let(nil, ::T.untyped)
  OSVERSION = ::T.let(nil, ::T.untyped)
end

module FFI::Platform
  def self.bsd?(); end

  def self.is_os(os); end

  def self.mac?(); end

  def self.solaris?(); end

  def self.unix?(); end

  def self.windows?(); end
end

class FFI::PlatformError
end

class FFI::PlatformError
end

class FFI::Pointer
  def +(_); end

  def address(); end

  def autorelease=(autorelease); end

  def autorelease?(); end

  def free(); end

  def initialize(*_); end

  def null?(); end

  def order(*_); end

  def read(type); end

  def read_array_of_type(type, reader, length); end

  def read_string(len=T.unsafe(nil)); end

  def read_string_length(len); end

  def read_string_to_null(); end

  def slice(_, _1); end

  def to_i(); end

  def to_ptr(); end

  def write(type, value); end

  def write_array_of_type(type, writer, ary); end

  def write_string(str, len=T.unsafe(nil)); end

  def write_string_length(str, len); end
  NULL = ::T.let(nil, ::T.untyped)
  SIZE = ::T.let(nil, ::T.untyped)
end

class FFI::Pointer
  def self.size(); end
end

class FFI::StrPtrConverter
end

class FFI::StrPtrConverter
  extend ::FFI::DataConverter
  def self.from_native(val, ctx); end
end

class FFI::Struct
  def [](_); end

  def []=(_, _1); end

  def align(); end

  def alignment(); end

  def clear(); end

  def initialize(*_); end

  def layout(); end

  def members(); end

  def null?(); end

  def offset_of(name); end

  def offsets(); end

  def order(*_); end

  def pointer(); end

  def size(); end

  def to_ptr(); end

  def values(); end
end

class FFI::Struct::InlineArray
  include ::Enumerable
  def [](_); end

  def []=(_, _1); end

  def each(&blk); end

  def initialize(_, _1); end

  def size(); end

  def to_a(); end

  def to_ptr(); end
end

class FFI::Struct::InlineArray
end

class FFI::Struct::ManagedStructConverter
  def from_native(ptr, ctx); end
end

class FFI::Struct::ManagedStructConverter
end

class FFI::Struct
  def self.align(alignment=T.unsafe(nil)); end

  def self.aligned(alignment=T.unsafe(nil)); end

  def self.alignment(); end

  def self.alloc_in(*_); end

  def self.alloc_inout(*_); end

  def self.alloc_out(*_); end

  def self.auto_ptr(); end

  def self.by_ref(flags=T.unsafe(nil)); end

  def self.by_value(); end

  def self.callback(params, ret); end

  def self.enclosing_module(); end

  def self.find_field_type(type, mod=T.unsafe(nil)); end

  def self.find_type(type, mod=T.unsafe(nil)); end

  def self.in(); end

  def self.layout(*spec); end

  def self.members(); end

  def self.new_in(*_); end

  def self.new_inout(*_); end

  def self.new_out(*_); end

  def self.offset_of(name); end

  def self.offsets(); end

  def self.out(); end

  def self.pack(packed=T.unsafe(nil)); end

  def self.packed(packed=T.unsafe(nil)); end

  def self.ptr(flags=T.unsafe(nil)); end

  def self.size(); end

  def self.size=(size); end

  def self.val(); end
end

class FFI::StructByReference
  include ::FFI::DataConverter
  def initialize(struct_class); end

  def native_type(); end

  def struct_class(); end
end

class FFI::StructByReference
end

class FFI::StructByValue
  def layout(); end

  def struct_class(); end
end

class FFI::StructByValue
end

class FFI::StructLayout
  def [](_); end

  def __union!(); end

  def fields(); end

  def initialize(_, _1, _2); end

  def members(); end

  def offset_of(field_name); end

  def offsets(); end

  def to_a(); end
end

class FFI::StructLayout::Array
end

class FFI::StructLayout::Array
end

class FFI::StructLayout::CharArray
  def to_str(); end
end

class FFI::StructLayout::CharArray
end

class FFI::StructLayout::Enum
  def get(ptr); end

  def put(ptr, value); end
end

class FFI::StructLayout::Enum
end

class FFI::StructLayout::Field
  def alignment(); end

  def get(_); end

  def initialize(*_); end

  def name(); end

  def offset(); end

  def put(_, _1); end

  def size(); end

  def type(); end
end

class FFI::StructLayout::Field
end

class FFI::StructLayout::Function
end

class FFI::StructLayout::Function
end

class FFI::StructLayout::InnerStruct
  def get(ptr); end

  def put(ptr, value); end
end

class FFI::StructLayout::InnerStruct
end

class FFI::StructLayout::Mapped
  def get(ptr); end

  def initialize(name, offset, type, orig_field); end

  def put(ptr, value); end
end

class FFI::StructLayout::Mapped
end

class FFI::StructLayout::Number
end

class FFI::StructLayout::Number
end

class FFI::StructLayout::Pointer
end

class FFI::StructLayout::Pointer
end

class FFI::StructLayout::String
end

class FFI::StructLayout::String
end

class FFI::StructLayout
end

class FFI::StructLayoutBuilder
  def add(name, type, offset=T.unsafe(nil)); end

  def add_array(name, type, count, offset=T.unsafe(nil)); end

  def add_field(name, type, offset=T.unsafe(nil)); end

  def add_struct(name, type, offset=T.unsafe(nil)); end

  def alignment(); end

  def alignment=(align); end

  def build(); end

  def packed=(packed); end

  def size(); end

  def size=(size); end

  def union=(is_union); end

  def union?(); end
  NUMBER_TYPES = ::T.let(nil, ::T.untyped)
end

class FFI::StructLayoutBuilder
end

class FFI::Type
  def alignment(); end

  def initialize(_); end

  def size(); end
  BOOL = ::T.let(nil, ::T.untyped)
  BUFFER_IN = ::T.let(nil, ::T.untyped)
  BUFFER_INOUT = ::T.let(nil, ::T.untyped)
  BUFFER_OUT = ::T.let(nil, ::T.untyped)
  CHAR = ::T.let(nil, ::T.untyped)
  DOUBLE = ::T.let(nil, ::T.untyped)
  FLOAT = ::T.let(nil, ::T.untyped)
  FLOAT32 = ::T.let(nil, ::T.untyped)
  FLOAT64 = ::T.let(nil, ::T.untyped)
  INT = ::T.let(nil, ::T.untyped)
  INT16 = ::T.let(nil, ::T.untyped)
  INT32 = ::T.let(nil, ::T.untyped)
  INT64 = ::T.let(nil, ::T.untyped)
  INT8 = ::T.let(nil, ::T.untyped)
  LONG = ::T.let(nil, ::T.untyped)
  LONGDOUBLE = ::T.let(nil, ::T.untyped)
  LONG_LONG = ::T.let(nil, ::T.untyped)
  POINTER = ::T.let(nil, ::T.untyped)
  SCHAR = ::T.let(nil, ::T.untyped)
  SHORT = ::T.let(nil, ::T.untyped)
  SINT = ::T.let(nil, ::T.untyped)
  SLONG = ::T.let(nil, ::T.untyped)
  SLONG_LONG = ::T.let(nil, ::T.untyped)
  SSHORT = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  UCHAR = ::T.let(nil, ::T.untyped)
  UINT = ::T.let(nil, ::T.untyped)
  UINT16 = ::T.let(nil, ::T.untyped)
  UINT32 = ::T.let(nil, ::T.untyped)
  UINT64 = ::T.let(nil, ::T.untyped)
  UINT8 = ::T.let(nil, ::T.untyped)
  ULONG = ::T.let(nil, ::T.untyped)
  ULONG_LONG = ::T.let(nil, ::T.untyped)
  USHORT = ::T.let(nil, ::T.untyped)
  VARARGS = ::T.let(nil, ::T.untyped)
  VOID = ::T.let(nil, ::T.untyped)
end

FFI::Type::Array = FFI::ArrayType

class FFI::Type::Builtin
end

class FFI::Type::Builtin
end

FFI::Type::Function = FFI::FunctionType

class FFI::Type::Mapped
  def from_native(*_); end

  def native_type(); end

  def to_native(*_); end

  def type(); end
end

class FFI::Type::Mapped
end

FFI::Type::Struct = FFI::StructByValue

class FFI::Type
end

class FFI::Union
end

class FFI::Union
  def self.builder(); end
end

class FFI::VariadicInvoker
  def attach(mod, mname); end

  def call(*args, &block); end

  def init(arg_types, type_map); end

  def initialize(_, _1, _2, _3); end

  def invoke(_, _1); end
end

class FFI::VariadicInvoker
end

module FFI
  def self.add_typedef(old, add); end

  def self.errno(); end

  def self.errno=(error); end

  def self.find_type(name, type_map=T.unsafe(nil)); end

  def self.map_library_name(lib); end

  def self.type_size(type); end

  def self.typedef(old, add); end
end

class FSEvent
  def callback(); end

  def initialize(args=T.unsafe(nil), &block); end

  def open_pipe(); end

  def paths(); end

  def process_running?(pid); end

  def run(); end

  def stop(); end

  def watch(watch_paths, options=T.unsafe(nil), &block); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class FSEvent
  def self.root_path(); end

  def self.watcher_path(); end
end

class Fiber
  def transfer(*_); end
end

class Fiber
  def self.current(); end
end

class File
  def self.atomic_write(file_name, temp_dir=T.unsafe(nil)); end

  def self.exists?(_); end

  def self.probe_stat_in(dir); end
end

module FileUtils::DryRun
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::DryRun
  extend ::FileUtils::DryRun
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  extend ::FileUtils::NoWrite
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

class Float
  def bson_type(); end
end

module Forwardable
  VERSION = ::T.let(nil, ::T.untyped)
end

module Forwardable
  def self._compile_method(src, file, line); end

  def self._delegator_method(obj, accessor, method, ali); end

  def self._valid_method?(method); end

  def self.debug(); end

  def self.debug=(debug); end
end

module GC
  def garbage_collect(*_); end
end

module GC
  def self.verify_transient_heap_internal_consistency(); end
end

class Gem::DependencyInstaller
  def _deprecated_add_found_dependencies(to_do, dependency_list); end

  def _deprecated_gather_dependencies(); end

  def add_found_dependencies(*args, &block); end

  def gather_dependencies(*args, &block); end
end

class Gem::Exception
  extend ::Gem::Deprecate
end

class Gem::Ext::BuildError
end

class Gem::Ext::BuildError
end

class Gem::Ext::Builder
  def self.redirector(); end
end

class Gem::Ext::ExtConfBuilder
end

Gem::Ext::ExtConfBuilder::FileEntry = FileUtils::Entry_

class Gem::Ext::ExtConfBuilder
  def self.build(extension, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil)); end

  def self.get_relative_path(path); end
end

class Gem::Package::DigestIO
  def digests(); end

  def initialize(io, digests); end

  def write(data); end
end

class Gem::Package::DigestIO
  def self.wrap(io, digests); end
end

class Gem::Package::FileSource
  def initialize(path); end

  def path(); end

  def start(); end

  def with_read_io(&block); end

  def with_write_io(&block); end
end

class Gem::Package::FileSource
end

class Gem::Package::IOSource
  def initialize(io); end

  def io(); end

  def path(); end

  def start(); end

  def with_read_io(); end

  def with_write_io(); end
end

class Gem::Package::IOSource
end

class Gem::Package::Old
  def extract_files(destination_dir); end

  def file_list(io); end

  def read_until_dashes(io); end

  def skip_ruby(io); end
end

class Gem::Package::Old
end

class Gem::Package::Source
end

class Gem::Package::Source
end

class Gem::Package::TarHeader
  def ==(other); end

  def checksum(); end

  def devmajor(); end

  def devminor(); end

  def empty?(); end

  def gid(); end

  def gname(); end

  def initialize(vals); end

  def linkname(); end

  def magic(); end

  def mode(); end

  def mtime(); end

  def name(); end

  def prefix(); end

  def size(); end

  def typeflag(); end

  def uid(); end

  def uname(); end

  def update_checksum(); end

  def version(); end
  EMPTY_HEADER = ::T.let(nil, ::T.untyped)
  FIELDS = ::T.let(nil, ::T.untyped)
  PACK_FORMAT = ::T.let(nil, ::T.untyped)
  UNPACK_FORMAT = ::T.let(nil, ::T.untyped)
end

class Gem::Package::TarHeader
  def self.from(stream); end

  def self.oct_or_256based(str); end

  def self.strict_oct(str); end
end

class Gem::Package::TarReader::Entry
  def bytes_read(); end

  def check_closed(); end

  def close(); end

  def closed?(); end

  def directory?(); end

  def eof?(); end

  def file?(); end

  def full_name(); end

  def getc(); end

  def header(); end

  def initialize(header, io); end

  def length(); end

  def pos(); end

  def read(len=T.unsafe(nil)); end

  def readpartial(maxlen=T.unsafe(nil), outbuf=T.unsafe(nil)); end

  def rewind(); end

  def size(); end

  def symlink?(); end
end

class Gem::Package::TarReader::Entry
end

class Gem::Package::TarReader
  def self.new(io); end
end

class Gem::Package::TarWriter
  def self.new(io); end
end

class Gem::Package
  def self.new(gem, security_policy=T.unsafe(nil)); end
end

class Gem::PathSupport
  def home(); end

  def initialize(env); end

  def path(); end

  def spec_cache_dir(); end
end

class Gem::RemoteFetcher::FetchError
  def initialize(message, uri); end

  def uri(); end

  def uri=(uri); end
end

class Gem::RemoteFetcher::FetchError
end

class Gem::RemoteFetcher::UnknownHostError
end

class Gem::RemoteFetcher::UnknownHostError
end

class Gem::Request
  extend ::Gem::UserInteraction
  extend ::Gem::DefaultUserInteraction
  extend ::Gem::Text
end

class Gem::Resolver::ActivationRequest
  def others_possible?(); end
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::CurrentSet
end

Gem::Resolver::DependencyConflict = Gem::Resolver::Conflict

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  def add_edge_no_circular(graph, origin, destination, requirement); end

  def add_vertex(graph, name, payload, root); end

  def delete_edge(graph, origin_name, destination_name, requirement); end

  def detach_vertex_named(graph, name); end

  def each(&blk); end

  def pop!(graph); end

  def reverse_each(); end

  def rewind_to(graph, tag); end

  def set_payload(graph, name, payload); end

  def tag(graph, tag); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Gem::Security::Exception
end

class Gem::Security::Exception
end

Gem::Security::KEY_ALGORITHM = OpenSSL::PKey::RSA

class Gem::Security::Policy
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def check_cert(signer, issuer, time); end

  def check_chain(chain, time); end

  def check_data(public_key, digest, signature, data); end

  def check_key(signer, key); end

  def check_root(chain, time); end

  def check_trust(chain, digester, trust_dir); end

  def initialize(name, policy=T.unsafe(nil), opt=T.unsafe(nil)); end

  def name(); end

  def only_signed(); end

  def only_signed=(only_signed); end

  def only_trusted(); end

  def only_trusted=(only_trusted); end

  def subject(certificate); end

  def verify(chain, key=T.unsafe(nil), digests=T.unsafe(nil), signatures=T.unsafe(nil), full_name=T.unsafe(nil)); end

  def verify_chain(); end

  def verify_chain=(verify_chain); end

  def verify_data(); end

  def verify_data=(verify_data); end

  def verify_root(); end

  def verify_root=(verify_root); end

  def verify_signatures(spec, digests, signatures); end

  def verify_signer(); end

  def verify_signer=(verify_signer); end
end

class Gem::Security::Policy
end

class Gem::Security::Signer
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def cert_chain(); end

  def cert_chain=(cert_chain); end

  def digest_algorithm(); end

  def digest_name(); end

  def extract_name(cert); end

  def initialize(key, cert_chain, passphrase=T.unsafe(nil), options=T.unsafe(nil)); end

  def key(); end

  def key=(key); end

  def load_cert_chain(); end

  def options(); end

  def re_sign_key(expiration_length: T.unsafe(nil)); end

  def sign(data); end
end

class Gem::Security::Signer
  def self.re_sign_cert(expired_cert, expired_cert_path, private_key); end
end

class Gem::Security::TrustDir
  def cert_path(certificate); end

  def dir(); end

  def each_certificate(); end

  def initialize(dir, permissions=T.unsafe(nil)); end

  def issuer_of(certificate); end

  def load_certificate(certificate_file); end

  def name_path(name); end

  def trust_cert(certificate); end

  def verify(); end
end

module Gem::Security
  def self.alt_name_or_x509_entry(certificate, x509_entry); end

  def self.create_cert(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_cert_email(email, key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.create_cert_self_signed(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_key(length=T.unsafe(nil), algorithm=T.unsafe(nil)); end

  def self.email_to_name(email_address); end

  def self.re_sign(expired_certificate, private_key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.reset(); end

  def self.sign(certificate, signing_key, signing_cert, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.trust_dir(); end

  def self.trusted_certificates(&block); end

  def self.write(pemmable, path, permissions=T.unsafe(nil), passphrase=T.unsafe(nil), cipher=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def available_specs(type); end

  def detect(type=T.unsafe(nil)); end

  def initialize(sources=T.unsafe(nil)); end

  def latest_specs(); end

  def prerelease_specs(); end

  def search_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def sources(); end

  def spec_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def specs(); end

  def suggest_gems_from_name(gem_name, type=T.unsafe(nil)); end

  def tuples_for(source, type, gracefully_ignore=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  def self.fetcher(); end

  def self.fetcher=(fetcher); end
end

class Gem::Specification
  include ::Bundler::MatchPlatform
  include ::Bundler::GemHelpers
  def to_ruby(); end
end

class Gem::Specification
  extend ::Gem::Deprecate
  extend ::Enumerable
  def self.add_spec(spec); end

  def self.add_specs(*specs); end

  def self.remove_spec(spec); end
end

class Gem::StreamUI
  def _deprecated_debug(statement); end
end

class Gem::StubSpecification
  def build_extensions(); end

  def extensions(); end

  def initialize(filename, base_dir, gems_dir, default_gem); end

  def missing_extensions?(); end

  def valid?(); end
end

class Gem::StubSpecification::StubLine
  def extensions(); end

  def full_name(); end

  def initialize(data, extensions); end

  def name(); end

  def platform(); end

  def require_paths(); end

  def version(); end
end

class Gem::StubSpecification
  def self.default_gemspec_stub(filename, base_dir, gems_dir); end

  def self.gemspec_stub(filename, base_dir, gems_dir); end
end

Gem::Version::Requirement = Gem::Requirement

module Gem
  def self.default_gems_use_full_paths?(); end

  def self.remove_unresolved_default_spec(spec); end
end

class Hash
  def bson_type(); end
end

class Hash
  def self.ruby2_keywords_hash(hash); end

  def self.ruby2_keywords_hash?(hash); end

  def self.try_convert(_); end
end

module I18n
  def self.cache_key_digest(); end

  def self.cache_key_digest=(key_digest); end

  def self.cache_namespace(); end

  def self.cache_namespace=(namespace); end

  def self.cache_store(); end

  def self.cache_store=(store); end

  def self.fallbacks(); end

  def self.fallbacks=(fallbacks); end

  def self.perform_caching?(); end
end

module INotify
  VERSION = ::T.let(nil, ::T.untyped)
end

class INotify::Event
  def absolute_name(); end

  def callback!(); end

  def cookie(); end

  def flags(); end

  def initialize(data, notifier); end

  def name(); end

  def notifier(); end

  def related(); end

  def size(); end

  def watcher(); end

  def watcher_id(); end
end

class INotify::Event
  def self.consume(data, notifier); end
end

module INotify::Native
  def fpathconf(*_); end

  def inotify_add_watch(*_); end

  def inotify_init(*_); end

  def inotify_rm_watch(*_); end
end

class INotify::Native::Event
end

class INotify::Native::Event
end

module INotify::Native::Flags
  IN_ACCESS = ::T.let(nil, ::T.untyped)
  IN_ALL_EVENTS = ::T.let(nil, ::T.untyped)
  IN_ATTRIB = ::T.let(nil, ::T.untyped)
  IN_CLOSE = ::T.let(nil, ::T.untyped)
  IN_CLOSE_NOWRITE = ::T.let(nil, ::T.untyped)
  IN_CLOSE_WRITE = ::T.let(nil, ::T.untyped)
  IN_CREATE = ::T.let(nil, ::T.untyped)
  IN_DELETE = ::T.let(nil, ::T.untyped)
  IN_DELETE_SELF = ::T.let(nil, ::T.untyped)
  IN_DONT_FOLLOW = ::T.let(nil, ::T.untyped)
  IN_IGNORED = ::T.let(nil, ::T.untyped)
  IN_ISDIR = ::T.let(nil, ::T.untyped)
  IN_MASK_ADD = ::T.let(nil, ::T.untyped)
  IN_MODIFY = ::T.let(nil, ::T.untyped)
  IN_MOVE = ::T.let(nil, ::T.untyped)
  IN_MOVED_FROM = ::T.let(nil, ::T.untyped)
  IN_MOVED_TO = ::T.let(nil, ::T.untyped)
  IN_MOVE_SELF = ::T.let(nil, ::T.untyped)
  IN_ONESHOT = ::T.let(nil, ::T.untyped)
  IN_ONLYDIR = ::T.let(nil, ::T.untyped)
  IN_OPEN = ::T.let(nil, ::T.untyped)
  IN_Q_OVERFLOW = ::T.let(nil, ::T.untyped)
  IN_UNMOUNT = ::T.let(nil, ::T.untyped)
  PC_NAME_MAX = ::T.let(nil, ::T.untyped)
end

module INotify::Native::Flags
  def self.from_mask(mask); end

  def self.to_mask(flags); end
end

module INotify::Native
  extend ::FFI::Library
  def self.fpathconf(*_); end

  def self.inotify_add_watch(*_); end

  def self.inotify_init(*_); end

  def self.inotify_rm_watch(*_); end
end

class INotify::Notifier
  def close(); end

  def fd(); end

  def process(); end

  def read_events(); end

  def run(); end

  def stop(); end

  def to_io(); end

  def watch(path, *flags, &callback); end

  def watchers(); end
  RECURSIVE_BLACKLIST = ::T.let(nil, ::T.untyped)
end

class INotify::Notifier
end

class INotify::QueueOverflowError
end

class INotify::QueueOverflowError
end

class INotify::Watcher
  def callback!(event); end

  def close(); end

  def flags(); end

  def id(); end

  def initialize(notifier, path, *flags, &callback); end

  def notifier(); end

  def path(); end
end

class INotify::Watcher
end

module INotify
end

class IO
  def beep(); end

  def cooked(); end

  def cooked!(); end

  def cursor(); end

  def cursor=(); end

  def echo=(echo); end

  def echo?(); end

  def getch(*_); end

  def getpass(*_); end

  def goto(); end

  def iflush(); end

  def ioflush(); end

  def noecho(); end

  def nonblock(*_); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def oflush(); end

  def pathconf(_); end

  def pressed?(); end

  def raw(*_); end

  def raw!(*_); end

  def ready?(); end

  def wait(*_); end

  def wait_readable(*_); end

  def wait_writable(*_); end

  def winsize(); end

  def winsize=(winsize); end
end

class IO
  def self.console(*_); end

  def self.console_size(); end

  def self.default_console_size(); end
end

class IPAddr
  def ==(other); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end
end

module IRB
  IRBRC_EXT = ::T.let(nil, ::T.untyped)
  MagicFile = ::T.let(nil, ::T.untyped)
  STDIN_FILE_NAME = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class IRB::Context
  def __exit__(*_); end

  def __inspect__(); end

  def __to_s__(); end

  def evaluate(line, line_no, exception: T.unsafe(nil)); end

  def initialize(irb, workspace=T.unsafe(nil), input_method=T.unsafe(nil), output_method=T.unsafe(nil)); end

  def inspect_last_value(); end
  IDNAME_IVARS = ::T.let(nil, ::T.untyped)
  NOPRINTING_IVARS = ::T.let(nil, ::T.untyped)
  NO_INSPECTING_IVARS = ::T.let(nil, ::T.untyped)
end

class IRB::DefaultEncodings
  def external(); end

  def external=(_); end

  def internal(); end

  def internal=(_); end
end

class IRB::DefaultEncodings
  def self.[](*_); end

  def self.members(); end
end

module IRB::ExtendCommandBundle
  def irb(*opts, &b); end

  def irb_change_workspace(*opts, &b); end

  def irb_current_working_workspace(*opts, &b); end

  def irb_fg(*opts, &b); end

  def irb_help(*opts, &b); end

  def irb_jobs(*opts, &b); end

  def irb_kill(*opts, &b); end

  def irb_pop_workspace(*opts, &b); end

  def irb_push_workspace(*opts, &b); end

  def irb_source(*opts, &b); end

  def irb_workspaces(*opts, &b); end
end

IRB::ExtendCommandBundle::EXCB = IRB::ExtendCommandBundle

module IRB::ExtendCommandBundle
  def self.irb_original_method_name(method_name); end
end

class IRB::FileInputMethod
  def initialize(file); end
end

class IRB::InputMethod
  def initialize(file=T.unsafe(nil)); end
end

class IRB::Inspector
  def initialize(inspect_proc, init_proc=T.unsafe(nil)); end
end

class IRB::Irb
  def handle_exception(exc); end

  def initialize(workspace=T.unsafe(nil), input_method=T.unsafe(nil), output_method=T.unsafe(nil)); end

  def output_value(); end

  def prompt(prompt, ltype, indent, line_no); end
end

class IRB::Locale
  def String(mes); end

  def encoding(); end

  def find(file, paths=T.unsafe(nil)); end

  def format(*opts); end

  def gets(*rs); end

  def initialize(locale=T.unsafe(nil)); end

  def lang(); end

  def load(file, priv=T.unsafe(nil)); end

  def modifier(); end

  def print(*opts); end

  def printf(*opts); end

  def puts(*opts); end

  def readline(*rs); end

  def require(file, priv=T.unsafe(nil)); end

  def territory(); end
  LOCALE_DIR = ::T.let(nil, ::T.untyped)
  LOCALE_NAME_RE = ::T.let(nil, ::T.untyped)
end

class IRB::Locale
end

class IRB::Notifier::AbstractNotifier
  def initialize(prefix, base_notifier); end
end

class IRB::Notifier::LeveledNotifier
  def initialize(base, level, prefix); end
end

class IRB::Notifier::NoMsgNotifier
  def initialize(); end
end

class IRB::ReadlineInputMethod
  def initialize(); end
end

class IRB::SLex
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end
end

class IRB::SLex::ErrNodeAlreadyExists
end

class IRB::SLex::ErrNodeAlreadyExists
end

class IRB::SLex::ErrNodeNothing
end

class IRB::SLex::ErrNodeNothing
end

class IRB::SLex
  extend ::Exception2MessageMapper
  def self.included(mod); end
end

class IRB::StdioInputMethod
  def initialize(); end
end

class IRB::WorkSpace
  def initialize(*main); end

  def local_variable_get(name); end

  def local_variable_set(name, value); end
end

module IRB
  def self.Inspector(inspect, init=T.unsafe(nil)); end

  def self.delete_caller(); end

  def self.init_config(ap_path); end

  def self.init_error(); end

  def self.load_modules(); end

  def self.parse_opts(argv: T.unsafe(nil)); end

  def self.rc_file(ext=T.unsafe(nil)); end

  def self.rc_file_generators(); end

  def self.run_config(); end

  def self.setup(ap_path, argv: T.unsafe(nil)); end
end

class Integer
  def to_bn(); end
end

class JSON::Ext::Generator::State
  def self.from_state(_); end
end

class JSON::Ext::Parser
  def initialize(*_); end
end

JSON::Parser = JSON::Ext::Parser

JSON::State = JSON::Ext::Generator::State

JSON::UnparserError = JSON::GeneratorError

module JaroWinkler
  VERSION = ::T.let(nil, ::T.untyped)
end

class JaroWinkler::Error
end

class JaroWinkler::Error
end

class JaroWinkler::InvalidWeightError
end

class JaroWinkler::InvalidWeightError
end

module JaroWinkler
  def self.distance(*_); end

  def self.jaro_distance(*_); end
end

module Kernel
  def itself(); end

  def object_id(); end

  def pretty_inspect(); end

  def then(); end

  def yield_self(); end
end

module Kernel
  def self.at_exit(); end

  def self.autoload(_, _1); end
end

class KeyError
  include ::DidYouMean::Correctable
end

module Kramdown
  VERSION = ::T.let(nil, ::T.untyped)
end

module Kramdown::Converter
end

class Kramdown::Converter::Base
  def apply_template_after?(); end

  def apply_template_before?(); end

  def basic_generate_id(str); end

  def convert(_el); end

  def data(); end

  def extract_code_language(attr); end

  def extract_code_language!(attr); end

  def format_math(el, opts=T.unsafe(nil)); end

  def generate_id(str); end

  def highlight_code(text, lang, type, opts=T.unsafe(nil)); end

  def in_toc?(el); end

  def initialize(root, options); end

  def options(); end

  def output_header_level(level); end

  def root(); end

  def smart_quote_entity(el); end

  def warning(text); end

  def warnings(); end
  SMART_QUOTE_INDICES = ::T.let(nil, ::T.untyped)
end

class Kramdown::Converter::Base
  def self.apply_template(converter, body); end

  def self.convert(tree, options=T.unsafe(nil)); end

  def self.get_template(template); end
end

class Kramdown::Converter::HashAST
  def convert(el); end
end

class Kramdown::Converter::HashAST
end

Kramdown::Converter::HashAst = Kramdown::Converter::HashAST

class Kramdown::Converter::Html
  include ::Kramdown::Utils::Html
  include ::Kramdown::Parser::Html::Constants
  def add_syntax_highlighter_to_class_attr(attr, lang=T.unsafe(nil)); end

  def convert(el, indent=T.unsafe(nil)); end

  def convert_a(el, indent); end

  def convert_abbreviation(el, _indent); end

  def convert_blank(_el, _indent); end

  def convert_blockquote(el, indent); end

  def convert_br(_el, _indent); end

  def convert_codeblock(el, indent); end

  def convert_codespan(el, _indent); end

  def convert_comment(el, indent); end

  def convert_dd(el, indent); end

  def convert_dl(el, indent); end

  def convert_dt(el, indent); end

  def convert_em(el, indent); end

  def convert_entity(el, _indent); end

  def convert_footnote(el, _indent); end

  def convert_header(el, indent); end

  def convert_hr(el, indent); end

  def convert_html_element(el, indent); end

  def convert_img(el, _indent); end

  def convert_li(el, indent); end

  def convert_math(el, indent); end

  def convert_ol(el, indent); end

  def convert_p(el, indent); end

  def convert_raw(el, _indent); end

  def convert_root(el, indent); end

  def convert_smart_quote(el, _indent); end

  def convert_standalone_image(el, indent); end

  def convert_strong(el, indent); end

  def convert_table(el, indent); end

  def convert_tbody(el, indent); end

  def convert_td(el, indent); end

  def convert_text(el, _indent); end

  def convert_tfoot(el, indent); end

  def convert_thead(el, indent); end

  def convert_tr(el, indent); end

  def convert_typographic_sym(el, _indent); end

  def convert_ul(el, indent); end

  def convert_xml_comment(el, indent); end

  def convert_xml_pi(el, indent); end

  def fix_for_toc_entry(elements); end

  def footnote_content(); end

  def format_as_block_html(name, attr, body, indent); end

  def format_as_indented_block_html(name, attr, body, indent); end

  def format_as_span_html(name, attr, body); end

  def generate_toc_tree(toc, type, attr); end

  def indent(); end

  def indent=(indent); end

  def inner(el, indent); end

  def obfuscate(text); end

  def remove_footnotes(elements); end

  def unwrap_links(elements); end
  ENTITY_NBSP = ::T.let(nil, ::T.untyped)
  FOOTNOTE_BACKLINK_FMT = ::T.let(nil, ::T.untyped)
  TYPOGRAPHIC_SYMS = ::T.let(nil, ::T.untyped)
end

class Kramdown::Converter::Html
end

class Kramdown::Converter::Kramdown
  include ::Kramdown::Utils::Html
  def convert(el, opts=T.unsafe(nil)); end

  def convert_a(el, opts); end

  def convert_abbreviation(el, _opts); end

  def convert_blank(_el, _opts); end

  def convert_blockquote(el, opts); end

  def convert_br(_el, _opts); end

  def convert_codeblock(el, _opts); end

  def convert_codespan(el, _opts); end

  def convert_comment(el, _opts); end

  def convert_dd(el, opts); end

  def convert_dl(el, opts); end

  def convert_dt(el, opts); end

  def convert_em(el, opts); end

  def convert_entity(el, _opts); end

  def convert_footnote(el, _opts); end

  def convert_header(el, opts); end

  def convert_hr(_el, _opts); end

  def convert_html_element(el, opts); end

  def convert_img(el, _opts); end

  def convert_li(el, opts); end

  def convert_math(el, _opts); end

  def convert_ol(el, opts); end

  def convert_p(el, opts); end

  def convert_raw(el, _opts); end

  def convert_root(el, opts); end

  def convert_smart_quote(el, _opts); end

  def convert_strong(el, opts); end

  def convert_table(el, opts); end

  def convert_tbody(el, opts); end

  def convert_td(el, opts); end

  def convert_text(el, opts); end

  def convert_tfoot(el, opts); end

  def convert_thead(el, opts); end

  def convert_tr(el, opts); end

  def convert_typographic_sym(el, _opts); end

  def convert_ul(el, opts); end

  def convert_xml_comment(el, _opts); end

  def convert_xml_pi(el, _opts); end

  def create_abbrev_defs(); end

  def create_footnote_defs(); end

  def create_link_defs(); end

  def ial_for_element(el); end

  def inner(el, opts=T.unsafe(nil)); end

  def parse_title(attr); end
  ESCAPED_CHAR_RE = ::T.let(nil, ::T.untyped)
  HTML_TAGS_WITH_BODY = ::T.let(nil, ::T.untyped)
  TYPOGRAPHIC_SYMS = ::T.let(nil, ::T.untyped)
end

class Kramdown::Converter::Kramdown
end

class Kramdown::Converter::Latex
  def attribute_list(el); end

  def convert(el, opts=T.unsafe(nil)); end

  def convert_a(el, opts); end

  def convert_abbreviation(el, _opts); end

  def convert_blank(_el, opts); end

  def convert_blockquote(el, opts); end

  def convert_br(_el, opts); end

  def convert_codeblock(el, _opts); end

  def convert_codespan(el, _opts); end

  def convert_comment(el, _opts); end

  def convert_dd(el, opts); end

  def convert_dl(el, opts); end

  def convert_dt(el, opts); end

  def convert_em(el, opts); end

  def convert_entity(el, _opts); end

  def convert_footnote(el, opts); end

  def convert_header(el, opts); end

  def convert_hr(el, _opts); end

  def convert_html_element(el, opts); end

  def convert_img(el, _opts); end

  def convert_li(el, opts); end

  def convert_math(el, _opts); end

  def convert_ol(el, opts); end

  def convert_p(el, opts); end

  def convert_raw(el, _opts); end

  def convert_root(el, opts); end

  def convert_smart_quote(el, opts); end

  def convert_standalone_image(el, _opts, img); end

  def convert_strong(el, opts); end

  def convert_table(el, opts); end

  def convert_tbody(el, opts); end

  def convert_td(el, opts); end

  def convert_text(el, _opts); end

  def convert_tfoot(el, opts); end

  def convert_thead(el, opts); end

  def convert_tr(el, opts); end

  def convert_typographic_sym(el, _opts); end

  def convert_ul(el, opts); end

  def convert_xml_comment(el, _opts); end

  def convert_xml_pi(_el, _opts); end

  def entity_to_latex(entity); end

  def escape(str); end

  def inner(el, opts); end

  def latex_environment(type, el, text); end

  def latex_link_target(el, add_label=T.unsafe(nil)); end

  def normalize_abbreviation_key(key); end
  ENTITY_CONV_TABLE = ::T.let(nil, ::T.untyped)
  ESCAPE_MAP = ::T.let(nil, ::T.untyped)
  ESCAPE_RE = ::T.let(nil, ::T.untyped)
  TABLE_ALIGNMENT_CHAR = ::T.let(nil, ::T.untyped)
  TYPOGRAPHIC_SYMS = ::T.let(nil, ::T.untyped)
end

class Kramdown::Converter::Latex
end

class Kramdown::Converter::Man
  def convert(el, opts=T.unsafe(nil)); end
  TABLE_CELL_ALIGNMENT = ::T.let(nil, ::T.untyped)
  TYPOGRAPHIC_SYMS_MAP = ::T.let(nil, ::T.untyped)
end

class Kramdown::Converter::Man
end

class Kramdown::Converter::RemoveHtmlTags
  def convert(el); end
end

class Kramdown::Converter::RemoveHtmlTags
end

class Kramdown::Converter::Toc
  def convert(el); end
end

class Kramdown::Converter::Toc
end

module Kramdown::Converter
  extend ::Kramdown::Utils::Configurable
  def self.add_math_engine(data, *args, &block); end

  def self.add_syntax_highlighter(data, *args, &block); end

  def self.configurables(); end

  def self.math_engine(data); end

  def self.syntax_highlighter(data); end
end

class Kramdown::Document
  def initialize(source, options=T.unsafe(nil)); end

  def method_missing(id, *attr, &block); end

  def options(); end

  def root(); end

  def root=(root); end

  def try_require(type, name); end

  def warnings(); end
end

class Kramdown::Document
end

class Kramdown::Element
  def attr(); end

  def block?(); end

  def children(); end

  def children=(children); end

  def initialize(type, value=T.unsafe(nil), attr=T.unsafe(nil), options=T.unsafe(nil)); end

  def options(); end

  def span?(); end

  def type(); end

  def type=(type); end

  def value(); end

  def value=(value); end
  CATEGORY = ::T.let(nil, ::T.untyped)
end

class Kramdown::Element
  def self.category(el); end
end

class Kramdown::Error
end

class Kramdown::Error
end

module Kramdown::Options
  ALLOWED_TYPES = ::T.let(nil, ::T.untyped)
end

class Kramdown::Options::Boolean
end

class Kramdown::Options::Boolean
  def self.===(other); end
end

class Kramdown::Options::Definition
  def default(); end

  def default=(_); end

  def desc(); end

  def desc=(_); end

  def name(); end

  def name=(_); end

  def type(); end

  def type=(_); end

  def validator(); end

  def validator=(_); end
end

class Kramdown::Options::Definition
  def self.[](*_); end

  def self.members(); end
end

module Kramdown::Options
  def self.defaults(); end

  def self.define(name, type, default, desc, &block); end

  def self.defined?(name); end

  def self.definitions(); end

  def self.merge(hash); end

  def self.parse(name, data); end

  def self.simple_array_validator(val, name, size=T.unsafe(nil)); end

  def self.simple_hash_validator(val, name); end

  def self.str_to_sym(data); end
end

module Kramdown::Parser
end

class Kramdown::Parser::Base
  def adapt_source(source); end

  def add_text(text, tree=T.unsafe(nil), type=T.unsafe(nil)); end

  def extract_string(range, strscan); end

  def initialize(source, options); end

  def options(); end

  def parse(); end

  def root(); end

  def source(); end

  def warning(text); end

  def warnings(); end
end

class Kramdown::Parser::Base
  def self.parse(source, options=T.unsafe(nil)); end
end

class Kramdown::Parser::GFM
  def generate_gfm_header_id(text); end

  def parse_atx_header_gfm_quirk(); end

  def parse_strikethrough_gfm(); end

  def update_elements(element); end
  ATX_HEADER_START = ::T.let(nil, ::T.untyped)
  ESCAPED_CHARS_GFM = ::T.let(nil, ::T.untyped)
  FENCED_CODEBLOCK_MATCH = ::T.let(nil, ::T.untyped)
  FENCED_CODEBLOCK_START = ::T.let(nil, ::T.untyped)
  LIST_TYPES = ::T.let(nil, ::T.untyped)
  NON_WORD_RE = ::T.let(nil, ::T.untyped)
  PARAGRAPH_END_GFM = ::T.let(nil, ::T.untyped)
  STRIKETHROUGH_DELIM = ::T.let(nil, ::T.untyped)
  STRIKETHROUGH_MATCH = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Kramdown::Parser::GFM
end

class Kramdown::Parser::Html
  include ::Kramdown::Parser::Html::Parser
  include ::Kramdown::Parser::Html::Constants
end

module Kramdown::Parser::Html::Constants
  HTML_ATTRIBUTE_RE = ::T.let(nil, ::T.untyped)
  HTML_BLOCK_ELEMENTS = ::T.let(nil, ::T.untyped)
  HTML_COMMENT_RE = ::T.let(nil, ::T.untyped)
  HTML_CONTENT_MODEL = ::T.let(nil, ::T.untyped)
  HTML_CONTENT_MODEL_BLOCK = ::T.let(nil, ::T.untyped)
  HTML_CONTENT_MODEL_RAW = ::T.let(nil, ::T.untyped)
  HTML_CONTENT_MODEL_SPAN = ::T.let(nil, ::T.untyped)
  HTML_DOCTYPE_RE = ::T.let(nil, ::T.untyped)
  HTML_ELEMENT = ::T.let(nil, ::T.untyped)
  HTML_ELEMENTS_WITHOUT_BODY = ::T.let(nil, ::T.untyped)
  HTML_ENTITY_RE = ::T.let(nil, ::T.untyped)
  HTML_INSTRUCTION_RE = ::T.let(nil, ::T.untyped)
  HTML_SPAN_ELEMENTS = ::T.let(nil, ::T.untyped)
  HTML_TAG_CLOSE_RE = ::T.let(nil, ::T.untyped)
  HTML_TAG_RE = ::T.let(nil, ::T.untyped)
end

module Kramdown::Parser::Html::Constants
end

class Kramdown::Parser::Html::ElementConverter
  include ::Kramdown::Parser::Html::Constants
  include ::Kramdown::Utils::Entities
  def convert_a(el); end

  def convert_b(el); end

  def convert_code(el); end

  def convert_em(el); end

  def convert_h1(el); end

  def convert_h2(el); end

  def convert_h3(el); end

  def convert_h4(el); end

  def convert_h5(el); end

  def convert_h6(el); end

  def convert_i(el); end

  def convert_pre(el); end

  def convert_script(el); end

  def convert_strong(el); end

  def convert_table(el); end

  def convert_textarea(el); end

  def extract_text(el, raw); end

  def handle_math_tag(el); end

  def initialize(root); end

  def is_math_tag?(el); end

  def is_simple_table?(el); end

  def process(el, do_conversion=T.unsafe(nil), preserve_text=T.unsafe(nil), parent=T.unsafe(nil)); end

  def process_children(el, do_conversion=T.unsafe(nil), preserve_text=T.unsafe(nil)); end

  def process_html_element(el, do_conversion=T.unsafe(nil), preserve_text=T.unsafe(nil)); end

  def process_text(raw, preserve=T.unsafe(nil)); end

  def remove_text_children(el); end

  def remove_whitespace_children(el); end

  def set_basics(el, type, opts=T.unsafe(nil)); end

  def strip_whitespace(el); end

  def wrap_text_children(el); end
  EMPHASIS_TYPE_MAP = ::T.let(nil, ::T.untyped)
  REMOVE_TEXT_CHILDREN = ::T.let(nil, ::T.untyped)
  REMOVE_WHITESPACE_CHILDREN = ::T.let(nil, ::T.untyped)
  SIMPLE_ELEMENTS = ::T.let(nil, ::T.untyped)
  STRIP_WHITESPACE = ::T.let(nil, ::T.untyped)
  WRAP_TEXT_CHILDREN = ::T.let(nil, ::T.untyped)
end

class Kramdown::Parser::Html::ElementConverter
  def self.convert(root, el=T.unsafe(nil)); end
end

module Kramdown::Parser::Html::Parser
  include ::Kramdown::Parser::Html::Constants
  def handle_html_start_tag(line=T.unsafe(nil)); end

  def handle_raw_html_tag(name); end

  def parse_html_attributes(str, line=T.unsafe(nil), in_html_tag=T.unsafe(nil)); end

  def parse_raw_html(el, &block); end
  HTML_RAW_START = ::T.let(nil, ::T.untyped)
end

module Kramdown::Parser::Html::Parser
end

class Kramdown::Parser::Html
end

class Kramdown::Parser::Kramdown
  include ::Kramdown
  include ::Kramdown::Parser::Html::Parser
  include ::Kramdown::Parser::Html::Constants
  def add_header(level, text, id); end

  def add_link(el, href, title, alt_text=T.unsafe(nil), ial=T.unsafe(nil)); end

  def after_block_boundary?(); end

  def before_block_boundary?(); end

  def configure_parser(); end

  def correct_abbreviations_attributes(); end

  def handle_extension(name, opts, body, type, line_no=T.unsafe(nil)); end

  def handle_kramdown_html_tag(el, closed, handle_body); end

  def new_block_el(*args); end

  def normalize_link_id(id); end

  def paragraph_end(); end

  def parse_abbrev_definition(); end

  def parse_attribute_list(str, opts); end

  def parse_atx_header(); end

  def parse_autolink(); end

  def parse_blank_line(); end

  def parse_block_extensions(); end

  def parse_block_html(); end

  def parse_block_math(); end

  def parse_blockquote(); end

  def parse_blocks(el, text=T.unsafe(nil)); end

  def parse_codeblock(); end

  def parse_codeblock_fenced(); end

  def parse_codespan(); end

  def parse_definition_list(); end

  def parse_emphasis(); end

  def parse_eob_marker(); end

  def parse_escaped_chars(); end

  def parse_extension_start_tag(type); end

  def parse_first_list_line(indentation, content); end

  def parse_footnote_definition(); end

  def parse_footnote_marker(); end

  def parse_header_contents(); end

  def parse_horizontal_rule(); end

  def parse_html_entity(); end

  def parse_inline_math(); end

  def parse_line_break(); end

  def parse_link(); end

  def parse_link_definition(); end

  def parse_list(); end

  def parse_paragraph(); end

  def parse_setext_header(); end

  def parse_smart_quotes(); end

  def parse_span_extensions(); end

  def parse_span_html(); end

  def parse_spans(el, stop_re=T.unsafe(nil), parsers=T.unsafe(nil), text_type=T.unsafe(nil)); end

  def parse_table(); end

  def parse_typographic_syms(); end

  def replace_abbreviations(el, regexps=T.unsafe(nil)); end

  def reset_env(opts=T.unsafe(nil)); end

  def restore_env(env); end

  def save_env(); end

  def span_parser_regexps(parsers=T.unsafe(nil)); end

  def update_attr_with_ial(attr, ial); end

  def update_ial_with_ial(ial, opts); end

  def update_link_definitions(link_defs); end

  def update_raw_text(item); end

  def update_tree(element); end
  ABBREV_DEFINITION_START = ::T.let(nil, ::T.untyped)
  ACHARS = ::T.let(nil, ::T.untyped)
  ALD_ANY_CHARS = ::T.let(nil, ::T.untyped)
  ALD_CLASS_NAME = ::T.let(nil, ::T.untyped)
  ALD_ID_CHARS = ::T.let(nil, ::T.untyped)
  ALD_ID_NAME = ::T.let(nil, ::T.untyped)
  ALD_START = ::T.let(nil, ::T.untyped)
  ALD_TYPE_ANY = ::T.let(nil, ::T.untyped)
  ALD_TYPE_CLASS_NAME = ::T.let(nil, ::T.untyped)
  ALD_TYPE_ID_NAME = ::T.let(nil, ::T.untyped)
  ALD_TYPE_ID_OR_CLASS = ::T.let(nil, ::T.untyped)
  ALD_TYPE_ID_OR_CLASS_MULTI = ::T.let(nil, ::T.untyped)
  ALD_TYPE_KEY_VALUE_PAIR = ::T.let(nil, ::T.untyped)
  ALD_TYPE_REF = ::T.let(nil, ::T.untyped)
  ATX_HEADER_START = ::T.let(nil, ::T.untyped)
  AUTOLINK_START = ::T.let(nil, ::T.untyped)
  AUTOLINK_START_STR = ::T.let(nil, ::T.untyped)
  BLANK_LINE = ::T.let(nil, ::T.untyped)
  BLOCKQUOTE_START = ::T.let(nil, ::T.untyped)
  BLOCK_BOUNDARY = ::T.let(nil, ::T.untyped)
  BLOCK_EXTENSIONS_START = ::T.let(nil, ::T.untyped)
  BLOCK_MATH_START = ::T.let(nil, ::T.untyped)
  CODEBLOCK_MATCH = ::T.let(nil, ::T.untyped)
  CODEBLOCK_START = ::T.let(nil, ::T.untyped)
  CODESPAN_DELIMITER = ::T.let(nil, ::T.untyped)
  DEFINITION_LIST_START = ::T.let(nil, ::T.untyped)
  EMPHASIS_START = ::T.let(nil, ::T.untyped)
  EOB_MARKER = ::T.let(nil, ::T.untyped)
  ESCAPED_CHARS = ::T.let(nil, ::T.untyped)
  EXT_BLOCK_START = ::T.let(nil, ::T.untyped)
  EXT_BLOCK_STOP_STR = ::T.let(nil, ::T.untyped)
  EXT_SPAN_START = ::T.let(nil, ::T.untyped)
  EXT_START_STR = ::T.let(nil, ::T.untyped)
  EXT_STOP_STR = ::T.let(nil, ::T.untyped)
  FENCED_CODEBLOCK_MATCH = ::T.let(nil, ::T.untyped)
  FENCED_CODEBLOCK_START = ::T.let(nil, ::T.untyped)
  FOOTNOTE_DEFINITION_START = ::T.let(nil, ::T.untyped)
  FOOTNOTE_MARKER_START = ::T.let(nil, ::T.untyped)
  HEADER_ID = ::T.let(nil, ::T.untyped)
  HR_START = ::T.let(nil, ::T.untyped)
  HTML_BLOCK_START = ::T.let(nil, ::T.untyped)
  HTML_MARKDOWN_ATTR_MAP = ::T.let(nil, ::T.untyped)
  HTML_SPAN_START = ::T.let(nil, ::T.untyped)
  IAL_BLOCK = ::T.let(nil, ::T.untyped)
  IAL_BLOCK_START = ::T.let(nil, ::T.untyped)
  IAL_CLASS_ATTR = ::T.let(nil, ::T.untyped)
  IAL_SPAN_START = ::T.let(nil, ::T.untyped)
  INDENT = ::T.let(nil, ::T.untyped)
  INLINE_MATH_START = ::T.let(nil, ::T.untyped)
  LAZY_END = ::T.let(nil, ::T.untyped)
  LAZY_END_HTML_SPAN_ELEMENTS = ::T.let(nil, ::T.untyped)
  LAZY_END_HTML_START = ::T.let(nil, ::T.untyped)
  LAZY_END_HTML_STOP = ::T.let(nil, ::T.untyped)
  LINE_BREAK = ::T.let(nil, ::T.untyped)
  LINK_BRACKET_STOP_RE = ::T.let(nil, ::T.untyped)
  LINK_DEFINITION_START = ::T.let(nil, ::T.untyped)
  LINK_INLINE_ID_RE = ::T.let(nil, ::T.untyped)
  LINK_INLINE_TITLE_RE = ::T.let(nil, ::T.untyped)
  LINK_PAREN_STOP_RE = ::T.let(nil, ::T.untyped)
  LINK_START = ::T.let(nil, ::T.untyped)
  LIST_ITEM_IAL = ::T.let(nil, ::T.untyped)
  LIST_ITEM_IAL_CHECK = ::T.let(nil, ::T.untyped)
  LIST_START = ::T.let(nil, ::T.untyped)
  LIST_START_OL = ::T.let(nil, ::T.untyped)
  LIST_START_UL = ::T.let(nil, ::T.untyped)
  OPT_SPACE = ::T.let(nil, ::T.untyped)
  PARAGRAPH_END = ::T.let(nil, ::T.untyped)
  PARAGRAPH_MATCH = ::T.let(nil, ::T.untyped)
  PARAGRAPH_START = ::T.let(nil, ::T.untyped)
  PARSE_FIRST_LIST_LINE_REGEXP_CACHE = ::T.let(nil, ::T.untyped)
  PATTERN_TAIL = ::T.let(nil, ::T.untyped)
  SETEXT_HEADER_START = ::T.let(nil, ::T.untyped)
  SMART_QUOTES_RE = ::T.let(nil, ::T.untyped)
  SPAN_EXTENSIONS_START = ::T.let(nil, ::T.untyped)
  SQ_CLOSE = ::T.let(nil, ::T.untyped)
  SQ_PUNCT = ::T.let(nil, ::T.untyped)
  SQ_RULES = ::T.let(nil, ::T.untyped)
  SQ_SUBSTS = ::T.let(nil, ::T.untyped)
  TABLE_FSEP_LINE = ::T.let(nil, ::T.untyped)
  TABLE_HSEP_ALIGN = ::T.let(nil, ::T.untyped)
  TABLE_LINE = ::T.let(nil, ::T.untyped)
  TABLE_PIPE_CHECK = ::T.let(nil, ::T.untyped)
  TABLE_ROW_LINE = ::T.let(nil, ::T.untyped)
  TABLE_SEP_LINE = ::T.let(nil, ::T.untyped)
  TABLE_START = ::T.let(nil, ::T.untyped)
  TRAILING_WHITESPACE = ::T.let(nil, ::T.untyped)
  TYPOGRAPHIC_SYMS = ::T.let(nil, ::T.untyped)
  TYPOGRAPHIC_SYMS_RE = ::T.let(nil, ::T.untyped)
  TYPOGRAPHIC_SYMS_SUBST = ::T.let(nil, ::T.untyped)
end

class Kramdown::Parser::Kramdown::Data
  def method(); end

  def method=(_); end

  def name(); end

  def name=(_); end

  def span_start(); end

  def span_start=(_); end

  def start_re(); end

  def start_re=(_); end
end

class Kramdown::Parser::Kramdown::Data
  def self.[](*_); end

  def self.members(); end
end

class Kramdown::Parser::Kramdown
  def self.define_parser(name, start_re, span_start=T.unsafe(nil), meth_name=T.unsafe(nil)); end

  def self.has_parser?(name); end

  def self.parser(name=T.unsafe(nil)); end
end

class Kramdown::Parser::Markdown
  BLOCK_BOUNDARY = ::T.let(nil, ::T.untyped)
  CODEBLOCK_MATCH = ::T.let(nil, ::T.untyped)
  EXTENDED = ::T.let(nil, ::T.untyped)
  IAL_RAND_CHARS = ::T.let(nil, ::T.untyped)
  IAL_RAND_STRING = ::T.let(nil, ::T.untyped)
  IAL_SPAN_START = ::T.let(nil, ::T.untyped)
  LAZY_END = ::T.let(nil, ::T.untyped)
  LIST_ITEM_IAL = ::T.let(nil, ::T.untyped)
  PARAGRAPH_END = ::T.let(nil, ::T.untyped)
end

class Kramdown::Parser::Markdown
end

module Kramdown::Parser
end

module Kramdown::Utils
end

module Kramdown::Utils::Configurable
  def configurable(name); end
end

module Kramdown::Utils::Configurable
end

module Kramdown::Utils::Entities
  ENTITY_MAP = ::T.let(nil, ::T.untyped)
  ENTITY_TABLE = ::T.let(nil, ::T.untyped)
end

module Kramdown::Utils::Entities
  def self.entity(point_or_name); end
end

module Kramdown::Utils::Html
  def entity_to_str(e, original=T.unsafe(nil)); end

  def escape_html(str, type=T.unsafe(nil)); end

  def fix_cjk_line_break(str); end

  def html_attributes(attr); end
  ESCAPE_ALL_RE = ::T.let(nil, ::T.untyped)
  ESCAPE_ATTRIBUTE_RE = ::T.let(nil, ::T.untyped)
  ESCAPE_MAP = ::T.let(nil, ::T.untyped)
  ESCAPE_RE_FROM_TYPE = ::T.let(nil, ::T.untyped)
  ESCAPE_TEXT_RE = ::T.let(nil, ::T.untyped)
  REDUNDANT_LINE_BREAK_REGEX = ::T.let(nil, ::T.untyped)
end

module Kramdown::Utils::Html
end

class Kramdown::Utils::LRUCache
  def [](key); end

  def []=(key, value); end

  def initialize(size); end
end

class Kramdown::Utils::LRUCache
end

class Kramdown::Utils::StringScanner
  def current_line_number(); end

  def initialize(string, start_line_number=T.unsafe(nil)); end

  def pos=(pos); end

  def revert_pos(data); end

  def save_pos(); end

  def start_line_number(); end
end

class Kramdown::Utils::StringScanner
end

module Kramdown::Utils
  def self.camelize(name); end

  def self.deep_const_get(str); end

  def self.snake_case(name); end
end

module Kramdown
  def self.data_dir(); end
end

class Logger
  SEV_LABEL = ::T.let(nil, ::T.untyped)
end

class Logger::Formatter
  Format = ::T.let(nil, ::T.untyped)
end

class Logger::LogDevice
  include ::MonitorMixin
end

module Logger::Period
  SiD = ::T.let(nil, ::T.untyped)
end

class Mail::Address
  def ==(other_address); end
end

class Mail::Address
  def self.wrap(address); end
end

class Mail::Message
  def bcc_addresses(); end

  def cc_addresses(); end

  def from_address(); end

  def recipients(); end

  def recipients_addresses(); end

  def to_addresses(); end

  def x_original_to_addresses(); end
end

module Mail::VERSION
  BUILD = ::T.let(nil, ::T.untyped)
end

module Mail
  def self.from_source(source); end
end

module Marcel
  VERSION = ::T.let(nil, ::T.untyped)
end

class Marcel::MimeType
  BINARY = ::T.let(nil, ::T.untyped)
end

class Marcel::MimeType
  def self.extend(type, extensions: T.unsafe(nil), parents: T.unsafe(nil), magic: T.unsafe(nil)); end

  def self.for(pathname_or_io=T.unsafe(nil), name: T.unsafe(nil), extension: T.unsafe(nil), declared_type: T.unsafe(nil)); end
end

module Marcel
end

module Marshal
  extend ::ActiveSupport::MarshalWithAutoloading
end

class MessagePack::Packer
  def write_bin(_); end

  def write_bin_header(_); end
end

class MessagePack::Unpacker
  def feed_reference(_); end
end

MiniTest = Minitest

class Module
  def autoload_without_bootsnap(_, _1); end
end

class Mongo::WriteConcern::Unacknowledged
  NOOP = ::T.let(nil, ::T.untyped)
end

class Mongoid::GlobalDiscriminatorKeyAssignment::InvalidFieldHost
  def self.discriminator_key=(val); end
end

module Mongoid::Railties
end

module Mongoid::Railties::ControllerRuntime
end

class Mongoid::Railties::ControllerRuntime::Collector
  def _completed(e); end

  def failed(e); end

  def started(_); end

  def succeeded(e); end
  VARIABLE_NAME = ::T.let(nil, ::T.untyped)
end

class Mongoid::Railties::ControllerRuntime::Collector
  def self.reset_runtime(); end

  def self.runtime(); end

  def self.runtime=(value); end
end

module Mongoid::Railties::ControllerRuntime::ControllerExtension
  def append_info_to_payload(payload); end

  def cleanup_view_runtime(); end

  def mongoid_runtime(); end

  def mongoid_runtime=(mongoid_runtime); end

  def process_action(action, *args); end
end

module Mongoid::Railties::ControllerRuntime::ControllerExtension
  extend ::ActiveSupport::Concern
end

module Mongoid::Railties::ControllerRuntime
end

module Mongoid::Railties
end

class Monitor
  def enter(); end

  def exit(); end

  def try_enter(); end
end

module MonitorMixin
  def initialize(*args); end
  EXCEPTION_IMMEDIATE = ::T.let(nil, ::T.untyped)
  EXCEPTION_NEVER = ::T.let(nil, ::T.untyped)
end

class MonitorMixin::ConditionVariable
  def initialize(monitor); end
end

module Mutex_m
  VERSION = ::T.let(nil, ::T.untyped)
end

class Net::APOP
end

class Net::APOP
end

Net::APOPSession = Net::APOP

class Net::BufferedIO
  def write_timeout(); end

  def write_timeout=(write_timeout); end
end

class Net::HTTP
  def max_retries(); end

  def max_retries=(retries); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end

  def write_timeout(); end

  def write_timeout=(sec); end
  ENVIRONMENT_VARIABLE_IS_MULTIUSER_SAFE = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
end

Net::HTTPClientError::EXCEPTION_TYPE = Net::HTTPServerException

Net::HTTPClientErrorCode = Net::HTTPClientError

class Net::HTTPEarlyHints
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPEarlyHints
end

Net::HTTPFatalErrorCode = Net::HTTPClientError

class Net::HTTPInformation
end

Net::HTTPInformationCode::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPInformation
end

class Net::HTTPLoopDetected
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPLoopDetected
end

class Net::HTTPMisdirectedRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPMisdirectedRequest
end

Net::HTTPMovedTemporarily = Net::HTTPFound

Net::HTTPMultipleChoice = Net::HTTPMultipleChoices

class Net::HTTPNotExtended
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPNotExtended
end

class Net::HTTPPayloadTooLarge
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPPayloadTooLarge
end

class Net::HTTPProcessing
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPProcessing
end

class Net::HTTPRangeNotSatisfiable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRangeNotSatisfiable
end

Net::HTTPRedirection::EXCEPTION_TYPE = Net::HTTPRetriableError

Net::HTTPRedirectionCode = Net::HTTPRedirection

Net::HTTPRequestURITooLarge = Net::HTTPURITooLong

Net::HTTPResponceReceiver = Net::HTTPResponse

Net::HTTPRetriableCode = Net::HTTPRedirection

Net::HTTPServerError::EXCEPTION_TYPE = Net::HTTPFatalError

Net::HTTPServerErrorCode = Net::HTTPServerError

Net::HTTPSession = Net::HTTP

Net::HTTPSuccess::EXCEPTION_TYPE = Net::HTTPError

Net::HTTPSuccessCode = Net::HTTPSuccess

class Net::HTTPURITooLong
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPURITooLong
end

Net::HTTPUnknownResponse::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPVariantAlsoNegotiates
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPVariantAlsoNegotiates
end

class Net::IMAP
  def open_timeout(); end
  RESPONSE_ERRORS = ::T.let(nil, ::T.untyped)
end

module Net::IMAP::NumValidator
  def self.ensure_mod_sequence_value(num); end

  def self.valid_mod_sequence_value?(num); end
end

Net::NetPrivate::HTTPRequest = Net::HTTPRequest

Net::NetPrivate::Socket = Net::InternetMessageIO

Net::POP = Net::POP3

class Net::POP3
  def active?(); end

  def address(); end

  def apop?(); end

  def auth_only(account, password); end

  def delete_all(); end

  def disable_ssl(); end

  def each(&block); end

  def each_mail(&block); end

  def enable_ssl(verify_or_params=T.unsafe(nil), certs=T.unsafe(nil), port=T.unsafe(nil)); end

  def finish(); end

  def initialize(addr, port=T.unsafe(nil), isapop=T.unsafe(nil)); end

  def logging(msg); end

  def mails(); end

  def n_bytes(); end

  def n_mails(); end

  def open_timeout(); end

  def open_timeout=(open_timeout); end

  def port(); end

  def read_timeout(); end

  def read_timeout=(sec); end

  def reset(); end

  def set_all_uids(); end

  def set_debug_output(arg); end

  def start(account, password); end

  def started?(); end

  def use_ssl?(); end
  Revision = ::T.let(nil, ::T.untyped)
end

class Net::POP3
  def self.APOP(isapop); end

  def self.auth_only(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil)); end

  def self.certs(); end

  def self.create_ssl_params(verify_or_params=T.unsafe(nil), certs=T.unsafe(nil)); end

  def self.default_pop3_port(); end

  def self.default_pop3s_port(); end

  def self.default_port(); end

  def self.delete_all(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil), &block); end

  def self.disable_ssl(); end

  def self.enable_ssl(*args); end

  def self.foreach(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil), &block); end

  def self.socket_type(); end

  def self.ssl_params(); end

  def self.start(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil), &block); end

  def self.use_ssl?(); end

  def self.verify(); end
end

class Net::POP3Command
  def apop(account, password); end

  def auth(account, password); end

  def dele(num); end

  def initialize(sock); end

  def list(); end

  def quit(); end

  def retr(num, &block); end

  def rset(); end

  def socket(); end

  def stat(); end

  def top(num, lines=T.unsafe(nil), &block); end

  def uidl(num=T.unsafe(nil)); end
end

class Net::POP3Command
end

Net::POP3Session = Net::POP3

class Net::POPAuthenticationError
end

class Net::POPAuthenticationError
end

class Net::POPBadResponse
end

class Net::POPBadResponse
end

class Net::POPError
end

class Net::POPError
end

class Net::POPMail
  def all(dest=T.unsafe(nil), &block); end

  def delete(); end

  def delete!(); end

  def deleted?(); end

  def header(dest=T.unsafe(nil)); end

  def initialize(num, len, pop, cmd); end

  def length(); end

  def mail(dest=T.unsafe(nil), &block); end

  def number(); end

  def pop(dest=T.unsafe(nil), &block); end

  def size(); end

  def top(lines, dest=T.unsafe(nil)); end

  def uid=(uid); end

  def uidl(); end

  def unique_id(); end
end

class Net::POPMail
end

Net::POPSession = Net::POP3

Net::ProtocRetryError = Net::ProtoRetriableError

class Net::ReadTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

Net::SMTPSession = Net::SMTP

class Net::WriteTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class NilClass
  def bson_type(); end

  def to_d(); end
end

class Nokogiri::CSS::Parser
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
end

module OTNetstring
end

class OTNetstring::Error
end

class OTNetstring::Error
end

module OTNetstring
  def self.encode(obj, string_sep=T.unsafe(nil)); end

  def self.parse(io, encoding=T.unsafe(nil), fallback_encoding=T.unsafe(nil)); end
end

class Object
  include ::ActiveSupport::Dependencies::ZeitwerkIntegration::RequireDependency
  def dclone(); end

  def pry(object=T.unsafe(nil), hash=T.unsafe(nil)); end

  def to_yaml(options=T.unsafe(nil)); end
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  RUBY18 = ::T.let(nil, ::T.untyped)
  RUBY19 = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
end

class Object
  def self.yaml_tag(url); end
end

class OpenSSL::ASN1::ASN1Data
  def indefinite_length(); end

  def indefinite_length=(indefinite_length); end
end

class OpenSSL::BN
  def +@(); end

  def -@(); end

  def /(_); end

  def negative?(); end
end

module OpenSSL::KDF
end

class OpenSSL::KDF::KDFError
end

class OpenSSL::KDF::KDFError
end

module OpenSSL::KDF
  def self.hkdf(*_); end

  def self.pbkdf2_hmac(*_); end

  def self.scrypt(*_); end
end

class OpenSSL::OCSP::Request
  def signed?(); end
end

OpenSSL::PKCS7::Signer = OpenSSL::PKCS7::SignerInfo

class OpenSSL::PKey::EC
  EXPLICIT_CURVE = ::T.let(nil, ::T.untyped)
end

class OpenSSL::PKey::EC::Point
  def to_octet_string(_); end
end

module OpenSSL::SSL
  OP_ALLOW_NO_DHE_KEX = ::T.let(nil, ::T.untyped)
  OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_CRYPTOPRO_TLSEXT_BUG = ::T.let(nil, ::T.untyped)
  OP_LEGACY_SERVER_CONNECT = ::T.let(nil, ::T.untyped)
  OP_NO_ENCRYPT_THEN_MAC = ::T.let(nil, ::T.untyped)
  OP_NO_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_NO_TLSv1_3 = ::T.let(nil, ::T.untyped)
  OP_SAFARI_ECDHE_ECDSA_BUG = ::T.let(nil, ::T.untyped)
  OP_TLSEXT_PADDING = ::T.let(nil, ::T.untyped)
  SSL2_VERSION = ::T.let(nil, ::T.untyped)
  SSL3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_1_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_2_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_VERSION = ::T.let(nil, ::T.untyped)
end

module OpenSSL::X509
  V_FLAG_NO_CHECK_TIME = ::T.let(nil, ::T.untyped)
  V_FLAG_TRUSTED_FIRST = ::T.let(nil, ::T.untyped)
end

class OpenSSL::X509::Attribute
  def ==(other); end
end

class OpenSSL::X509::CRL
  def ==(other); end
end

class OpenSSL::X509::Extension
  def ==(other); end
end

class OpenSSL::X509::Name
  def to_utf8(); end
end

class OpenSSL::X509::Request
  def ==(other); end
end

class OpenSSL::X509::Revoked
  def ==(other); end

  def to_der(); end
end

module OpenSSL
  def self.fips_mode(); end
end

class OpenStruct
  include ::BSON::OpenStruct
end

module Parallel
  Stop = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Parallel::Break
  def initialize(value=T.unsafe(nil)); end

  def value(); end
end

class Parallel::Break
end

class Parallel::DeadWorker
end

class Parallel::DeadWorker
end

class Parallel::ExceptionWrapper
  def exception(); end

  def initialize(exception); end
end

class Parallel::ExceptionWrapper
end

class Parallel::JobFactory
  def initialize(source, mutex); end

  def next(); end

  def pack(item, index); end

  def size(); end

  def unpack(data); end
end

class Parallel::JobFactory
end

class Parallel::Kill
end

class Parallel::Kill
end

module Parallel::ProcessorCount
  def physical_processor_count(); end

  def processor_count(); end
end

module Parallel::ProcessorCount
end

class Parallel::UndumpableException
  def initialize(original); end
end

class Parallel::UndumpableException
end

class Parallel::UserInterruptHandler
  INTERRUPT_SIGNAL = ::T.let(nil, ::T.untyped)
end

class Parallel::UserInterruptHandler
  def self.kill(thing); end

  def self.kill_on_ctrl_c(pids, options); end
end

class Parallel::Worker
  def close_pipes(); end

  def initialize(read, write, pid); end

  def pid(); end

  def read(); end

  def stop(); end

  def thread(); end

  def thread=(thread); end

  def work(data); end

  def write(); end
end

class Parallel::Worker
end

module Parallel
  extend ::Parallel::ProcessorCount
  def self.all?(*args, &block); end

  def self.any?(*args, &block); end

  def self.each(array, options=T.unsafe(nil), &block); end

  def self.each_with_index(array, options=T.unsafe(nil), &block); end

  def self.flat_map(*args, &block); end

  def self.in_processes(options=T.unsafe(nil), &block); end

  def self.in_threads(options=T.unsafe(nil)); end

  def self.map(source, options=T.unsafe(nil), &block); end

  def self.map_with_index(array, options=T.unsafe(nil), &block); end

  def self.worker_number(); end

  def self.worker_number=(worker_num); end
end

class Parlour::ConflictResolver
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Parlour::Debugging::Tree
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Parlour::Debugging
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Parlour::ParseError
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Parlour::Plugin
  extend ::T::Sig
  extend ::T::Helpers
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Parlour::RbiGenerator::Options
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Parlour::RbiGenerator::Parameter
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Parlour::RbiGenerator::RbiObject
  extend ::T::Helpers
  extend ::T::Sig
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Parlour::RbiGenerator::StructProp
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Parlour::RbiGenerator
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Parlour::TypeLoader
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Parlour::TypeParser::NodePath
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Parlour::TypeParser
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

ParseError = Racc::ParseError

class Parser::Ruby24
  def _reduce_10(val, _values, result); end

  def _reduce_100(val, _values, result); end

  def _reduce_101(val, _values, result); end

  def _reduce_102(val, _values, result); end

  def _reduce_103(val, _values, result); end

  def _reduce_104(val, _values, result); end

  def _reduce_105(val, _values, result); end

  def _reduce_106(val, _values, result); end

  def _reduce_107(val, _values, result); end

  def _reduce_108(val, _values, result); end

  def _reduce_11(val, _values, result); end

  def _reduce_110(val, _values, result); end

  def _reduce_111(val, _values, result); end

  def _reduce_112(val, _values, result); end

  def _reduce_118(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_122(val, _values, result); end

  def _reduce_123(val, _values, result); end

  def _reduce_124(val, _values, result); end

  def _reduce_13(val, _values, result); end

  def _reduce_14(val, _values, result); end

  def _reduce_16(val, _values, result); end

  def _reduce_17(val, _values, result); end

  def _reduce_18(val, _values, result); end

  def _reduce_19(val, _values, result); end

  def _reduce_196(val, _values, result); end

  def _reduce_197(val, _values, result); end

  def _reduce_198(val, _values, result); end

  def _reduce_199(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_200(val, _values, result); end

  def _reduce_201(val, _values, result); end

  def _reduce_202(val, _values, result); end

  def _reduce_203(val, _values, result); end

  def _reduce_204(val, _values, result); end

  def _reduce_205(val, _values, result); end

  def _reduce_206(val, _values, result); end

  def _reduce_207(val, _values, result); end

  def _reduce_208(val, _values, result); end

  def _reduce_209(val, _values, result); end

  def _reduce_21(val, _values, result); end

  def _reduce_210(val, _values, result); end

  def _reduce_211(val, _values, result); end

  def _reduce_212(val, _values, result); end

  def _reduce_213(val, _values, result); end

  def _reduce_214(val, _values, result); end

  def _reduce_215(val, _values, result); end

  def _reduce_216(val, _values, result); end

  def _reduce_217(val, _values, result); end

  def _reduce_218(val, _values, result); end

  def _reduce_219(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_220(val, _values, result); end

  def _reduce_221(val, _values, result); end

  def _reduce_222(val, _values, result); end

  def _reduce_223(val, _values, result); end

  def _reduce_224(val, _values, result); end

  def _reduce_225(val, _values, result); end

  def _reduce_226(val, _values, result); end

  def _reduce_227(val, _values, result); end

  def _reduce_228(val, _values, result); end

  def _reduce_229(val, _values, result); end

  def _reduce_23(val, _values, result); end

  def _reduce_230(val, _values, result); end

  def _reduce_231(val, _values, result); end

  def _reduce_232(val, _values, result); end

  def _reduce_233(val, _values, result); end

  def _reduce_234(val, _values, result); end

  def _reduce_235(val, _values, result); end

  def _reduce_236(val, _values, result); end

  def _reduce_24(val, _values, result); end

  def _reduce_241(val, _values, result); end

  def _reduce_242(val, _values, result); end

  def _reduce_244(val, _values, result); end

  def _reduce_245(val, _values, result); end

  def _reduce_246(val, _values, result); end

  def _reduce_248(val, _values, result); end

  def _reduce_25(val, _values, result); end

  def _reduce_251(val, _values, result); end

  def _reduce_252(val, _values, result); end

  def _reduce_253(val, _values, result); end

  def _reduce_254(val, _values, result); end

  def _reduce_255(val, _values, result); end

  def _reduce_256(val, _values, result); end

  def _reduce_257(val, _values, result); end

  def _reduce_258(val, _values, result); end

  def _reduce_259(val, _values, result); end

  def _reduce_26(val, _values, result); end

  def _reduce_260(val, _values, result); end

  def _reduce_261(val, _values, result); end

  def _reduce_262(val, _values, result); end

  def _reduce_263(val, _values, result); end

  def _reduce_264(val, _values, result); end

  def _reduce_265(val, _values, result); end

  def _reduce_266(val, _values, result); end

  def _reduce_267(val, _values, result); end

  def _reduce_269(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_270(val, _values, result); end

  def _reduce_271(val, _values, result); end

  def _reduce_28(val, _values, result); end

  def _reduce_282(val, _values, result); end

  def _reduce_283(val, _values, result); end

  def _reduce_284(val, _values, result); end

  def _reduce_285(val, _values, result); end

  def _reduce_286(val, _values, result); end

  def _reduce_287(val, _values, result); end

  def _reduce_288(val, _values, result); end

  def _reduce_289(val, _values, result); end

  def _reduce_290(val, _values, result); end

  def _reduce_291(val, _values, result); end

  def _reduce_292(val, _values, result); end

  def _reduce_293(val, _values, result); end

  def _reduce_294(val, _values, result); end

  def _reduce_295(val, _values, result); end

  def _reduce_296(val, _values, result); end

  def _reduce_297(val, _values, result); end

  def _reduce_298(val, _values, result); end

  def _reduce_299(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_30(val, _values, result); end

  def _reduce_300(val, _values, result); end

  def _reduce_301(val, _values, result); end

  def _reduce_303(val, _values, result); end

  def _reduce_304(val, _values, result); end

  def _reduce_305(val, _values, result); end

  def _reduce_306(val, _values, result); end

  def _reduce_307(val, _values, result); end

  def _reduce_308(val, _values, result); end

  def _reduce_309(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_310(val, _values, result); end

  def _reduce_311(val, _values, result); end

  def _reduce_312(val, _values, result); end

  def _reduce_313(val, _values, result); end

  def _reduce_314(val, _values, result); end

  def _reduce_315(val, _values, result); end

  def _reduce_316(val, _values, result); end

  def _reduce_317(val, _values, result); end

  def _reduce_318(val, _values, result); end

  def _reduce_319(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_320(val, _values, result); end

  def _reduce_321(val, _values, result); end

  def _reduce_322(val, _values, result); end

  def _reduce_323(val, _values, result); end

  def _reduce_324(val, _values, result); end

  def _reduce_325(val, _values, result); end

  def _reduce_326(val, _values, result); end

  def _reduce_327(val, _values, result); end

  def _reduce_328(val, _values, result); end

  def _reduce_329(val, _values, result); end

  def _reduce_330(val, _values, result); end

  def _reduce_331(val, _values, result); end

  def _reduce_332(val, _values, result); end

  def _reduce_333(val, _values, result); end

  def _reduce_337(val, _values, result); end

  def _reduce_34(val, _values, result); end

  def _reduce_341(val, _values, result); end

  def _reduce_343(val, _values, result); end

  def _reduce_346(val, _values, result); end

  def _reduce_347(val, _values, result); end

  def _reduce_348(val, _values, result); end

  def _reduce_349(val, _values, result); end

  def _reduce_35(val, _values, result); end

  def _reduce_351(val, _values, result); end

  def _reduce_352(val, _values, result); end

  def _reduce_353(val, _values, result); end

  def _reduce_354(val, _values, result); end

  def _reduce_355(val, _values, result); end

  def _reduce_356(val, _values, result); end

  def _reduce_357(val, _values, result); end

  def _reduce_358(val, _values, result); end

  def _reduce_359(val, _values, result); end

  def _reduce_36(val, _values, result); end

  def _reduce_360(val, _values, result); end

  def _reduce_361(val, _values, result); end

  def _reduce_362(val, _values, result); end

  def _reduce_363(val, _values, result); end

  def _reduce_364(val, _values, result); end

  def _reduce_365(val, _values, result); end

  def _reduce_366(val, _values, result); end

  def _reduce_367(val, _values, result); end

  def _reduce_368(val, _values, result); end

  def _reduce_369(val, _values, result); end

  def _reduce_37(val, _values, result); end

  def _reduce_371(val, _values, result); end

  def _reduce_372(val, _values, result); end

  def _reduce_373(val, _values, result); end

  def _reduce_374(val, _values, result); end

  def _reduce_375(val, _values, result); end

  def _reduce_376(val, _values, result); end

  def _reduce_377(val, _values, result); end

  def _reduce_378(val, _values, result); end

  def _reduce_38(val, _values, result); end

  def _reduce_380(val, _values, result); end

  def _reduce_381(val, _values, result); end

  def _reduce_382(val, _values, result); end

  def _reduce_383(val, _values, result); end

  def _reduce_384(val, _values, result); end

  def _reduce_385(val, _values, result); end

  def _reduce_386(val, _values, result); end

  def _reduce_387(val, _values, result); end

  def _reduce_388(val, _values, result); end

  def _reduce_389(val, _values, result); end

  def _reduce_39(val, _values, result); end

  def _reduce_391(val, _values, result); end

  def _reduce_392(val, _values, result); end

  def _reduce_393(val, _values, result); end

  def _reduce_394(val, _values, result); end

  def _reduce_395(val, _values, result); end

  def _reduce_396(val, _values, result); end

  def _reduce_397(val, _values, result); end

  def _reduce_398(val, _values, result); end

  def _reduce_399(val, _values, result); end

  def _reduce_4(val, _values, result); end

  def _reduce_40(val, _values, result); end

  def _reduce_400(val, _values, result); end

  def _reduce_401(val, _values, result); end

  def _reduce_402(val, _values, result); end

  def _reduce_403(val, _values, result); end

  def _reduce_404(val, _values, result); end

  def _reduce_405(val, _values, result); end

  def _reduce_406(val, _values, result); end

  def _reduce_407(val, _values, result); end

  def _reduce_408(val, _values, result); end

  def _reduce_409(val, _values, result); end

  def _reduce_41(val, _values, result); end

  def _reduce_410(val, _values, result); end

  def _reduce_411(val, _values, result); end

  def _reduce_412(val, _values, result); end

  def _reduce_413(val, _values, result); end

  def _reduce_414(val, _values, result); end

  def _reduce_415(val, _values, result); end

  def _reduce_416(val, _values, result); end

  def _reduce_417(val, _values, result); end

  def _reduce_418(val, _values, result); end

  def _reduce_419(val, _values, result); end

  def _reduce_420(val, _values, result); end

  def _reduce_421(val, _values, result); end

  def _reduce_422(val, _values, result); end

  def _reduce_423(val, _values, result); end

  def _reduce_424(val, _values, result); end

  def _reduce_425(val, _values, result); end

  def _reduce_427(val, _values, result); end

  def _reduce_428(val, _values, result); end

  def _reduce_429(val, _values, result); end

  def _reduce_43(val, _values, result); end

  def _reduce_432(val, _values, result); end

  def _reduce_434(val, _values, result); end

  def _reduce_439(val, _values, result); end

  def _reduce_440(val, _values, result); end

  def _reduce_441(val, _values, result); end

  def _reduce_442(val, _values, result); end

  def _reduce_443(val, _values, result); end

  def _reduce_444(val, _values, result); end

  def _reduce_445(val, _values, result); end

  def _reduce_446(val, _values, result); end

  def _reduce_447(val, _values, result); end

  def _reduce_448(val, _values, result); end

  def _reduce_449(val, _values, result); end

  def _reduce_450(val, _values, result); end

  def _reduce_451(val, _values, result); end

  def _reduce_452(val, _values, result); end

  def _reduce_453(val, _values, result); end

  def _reduce_454(val, _values, result); end

  def _reduce_455(val, _values, result); end

  def _reduce_456(val, _values, result); end

  def _reduce_457(val, _values, result); end

  def _reduce_458(val, _values, result); end

  def _reduce_459(val, _values, result); end

  def _reduce_46(val, _values, result); end

  def _reduce_460(val, _values, result); end

  def _reduce_461(val, _values, result); end

  def _reduce_462(val, _values, result); end

  def _reduce_463(val, _values, result); end

  def _reduce_464(val, _values, result); end

  def _reduce_465(val, _values, result); end

  def _reduce_466(val, _values, result); end

  def _reduce_467(val, _values, result); end

  def _reduce_468(val, _values, result); end

  def _reduce_469(val, _values, result); end

  def _reduce_47(val, _values, result); end

  def _reduce_470(val, _values, result); end

  def _reduce_471(val, _values, result); end

  def _reduce_472(val, _values, result); end

  def _reduce_473(val, _values, result); end

  def _reduce_475(val, _values, result); end

  def _reduce_476(val, _values, result); end

  def _reduce_477(val, _values, result); end

  def _reduce_478(val, _values, result); end

  def _reduce_479(val, _values, result); end

  def _reduce_48(val, _values, result); end

  def _reduce_480(val, _values, result); end

  def _reduce_481(val, _values, result); end

  def _reduce_482(val, _values, result); end

  def _reduce_483(val, _values, result); end

  def _reduce_484(val, _values, result); end

  def _reduce_485(val, _values, result); end

  def _reduce_486(val, _values, result); end

  def _reduce_487(val, _values, result); end

  def _reduce_488(val, _values, result); end

  def _reduce_489(val, _values, result); end

  def _reduce_49(val, _values, result); end

  def _reduce_490(val, _values, result); end

  def _reduce_491(val, _values, result); end

  def _reduce_492(val, _values, result); end

  def _reduce_493(val, _values, result); end

  def _reduce_494(val, _values, result); end

  def _reduce_495(val, _values, result); end

  def _reduce_496(val, _values, result); end

  def _reduce_497(val, _values, result); end

  def _reduce_498(val, _values, result); end

  def _reduce_499(val, _values, result); end

  def _reduce_5(val, _values, result); end

  def _reduce_500(val, _values, result); end

  def _reduce_501(val, _values, result); end

  def _reduce_502(val, _values, result); end

  def _reduce_503(val, _values, result); end

  def _reduce_504(val, _values, result); end

  def _reduce_505(val, _values, result); end

  def _reduce_506(val, _values, result); end

  def _reduce_507(val, _values, result); end

  def _reduce_508(val, _values, result); end

  def _reduce_509(val, _values, result); end

  def _reduce_510(val, _values, result); end

  def _reduce_511(val, _values, result); end

  def _reduce_512(val, _values, result); end

  def _reduce_513(val, _values, result); end

  def _reduce_514(val, _values, result); end

  def _reduce_515(val, _values, result); end

  def _reduce_516(val, _values, result); end

  def _reduce_517(val, _values, result); end

  def _reduce_518(val, _values, result); end

  def _reduce_519(val, _values, result); end

  def _reduce_520(val, _values, result); end

  def _reduce_521(val, _values, result); end

  def _reduce_522(val, _values, result); end

  def _reduce_523(val, _values, result); end

  def _reduce_524(val, _values, result); end

  def _reduce_525(val, _values, result); end

  def _reduce_526(val, _values, result); end

  def _reduce_527(val, _values, result); end

  def _reduce_528(val, _values, result); end

  def _reduce_529(val, _values, result); end

  def _reduce_530(val, _values, result); end

  def _reduce_531(val, _values, result); end

  def _reduce_533(val, _values, result); end

  def _reduce_534(val, _values, result); end

  def _reduce_535(val, _values, result); end

  def _reduce_536(val, _values, result); end

  def _reduce_537(val, _values, result); end

  def _reduce_538(val, _values, result); end

  def _reduce_539(val, _values, result); end

  def _reduce_540(val, _values, result); end

  def _reduce_541(val, _values, result); end

  def _reduce_542(val, _values, result); end

  def _reduce_543(val, _values, result); end

  def _reduce_544(val, _values, result); end

  def _reduce_545(val, _values, result); end

  def _reduce_546(val, _values, result); end

  def _reduce_547(val, _values, result); end

  def _reduce_55(val, _values, result); end

  def _reduce_550(val, _values, result); end

  def _reduce_551(val, _values, result); end

  def _reduce_552(val, _values, result); end

  def _reduce_553(val, _values, result); end

  def _reduce_554(val, _values, result); end

  def _reduce_555(val, _values, result); end

  def _reduce_556(val, _values, result); end

  def _reduce_557(val, _values, result); end

  def _reduce_56(val, _values, result); end

  def _reduce_560(val, _values, result); end

  def _reduce_561(val, _values, result); end

  def _reduce_564(val, _values, result); end

  def _reduce_565(val, _values, result); end

  def _reduce_566(val, _values, result); end

  def _reduce_568(val, _values, result); end

  def _reduce_569(val, _values, result); end

  def _reduce_57(val, _values, result); end

  def _reduce_571(val, _values, result); end

  def _reduce_572(val, _values, result); end

  def _reduce_573(val, _values, result); end

  def _reduce_574(val, _values, result); end

  def _reduce_575(val, _values, result); end

  def _reduce_576(val, _values, result); end

  def _reduce_589(val, _values, result); end

  def _reduce_59(val, _values, result); end

  def _reduce_590(val, _values, result); end

  def _reduce_595(val, _values, result); end

  def _reduce_596(val, _values, result); end

  def _reduce_6(val, _values, result); end

  def _reduce_60(val, _values, result); end

  def _reduce_600(val, _values, result); end

  def _reduce_604(val, _values, result); end

  def _reduce_61(val, _values, result); end

  def _reduce_62(val, _values, result); end

  def _reduce_63(val, _values, result); end

  def _reduce_64(val, _values, result); end

  def _reduce_65(val, _values, result); end

  def _reduce_66(val, _values, result); end

  def _reduce_67(val, _values, result); end

  def _reduce_68(val, _values, result); end

  def _reduce_69(val, _values, result); end

  def _reduce_70(val, _values, result); end

  def _reduce_71(val, _values, result); end

  def _reduce_72(val, _values, result); end

  def _reduce_73(val, _values, result); end

  def _reduce_75(val, _values, result); end

  def _reduce_76(val, _values, result); end

  def _reduce_77(val, _values, result); end

  def _reduce_78(val, _values, result); end

  def _reduce_79(val, _values, result); end

  def _reduce_8(val, _values, result); end

  def _reduce_80(val, _values, result); end

  def _reduce_81(val, _values, result); end

  def _reduce_82(val, _values, result); end

  def _reduce_83(val, _values, result); end

  def _reduce_85(val, _values, result); end

  def _reduce_86(val, _values, result); end

  def _reduce_87(val, _values, result); end

  def _reduce_88(val, _values, result); end

  def _reduce_89(val, _values, result); end

  def _reduce_9(val, _values, result); end

  def _reduce_90(val, _values, result); end

  def _reduce_91(val, _values, result); end

  def _reduce_92(val, _values, result); end

  def _reduce_93(val, _values, result); end

  def _reduce_94(val, _values, result); end

  def _reduce_95(val, _values, result); end

  def _reduce_96(val, _values, result); end

  def _reduce_97(val, _values, result); end

  def _reduce_98(val, _values, result); end

  def _reduce_99(val, _values, result); end

  def _reduce_none(val, _values, result); end

  def default_encoding(); end

  def version(); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Parser::Ruby24
end

class Parser::Ruby26
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Range
  include ::RuboCop::AST::Ext::Range
end

class Pathname
  def fnmatch?(*_); end

  def glob(*_); end

  def make_symlink(_); end
end

class Post
  def ___id_default__(); end

  def __callbacks(); end

  def __callbacks?(); end

  def _build_callbacks(); end

  def _create_callbacks(); end

  def _declared_scopes(); end

  def _declared_scopes=(val); end

  def _declared_scopes?(); end

  def _destroy_callbacks(); end

  def _find_callbacks(); end

  def _index(); end

  def _index=(_index); end

  def _initialize_callbacks(); end

  def _run_build_callbacks(&block); end

  def _run_create_callbacks(&block); end

  def _run_destroy_callbacks(&block); end

  def _run_find_callbacks(&block); end

  def _run_initialize_callbacks(&block); end

  def _run_save_callbacks(&block); end

  def _run_touch_callbacks(&block); end

  def _run_update_callbacks(&block); end

  def _run_upsert_callbacks(&block); end

  def _run_validate_callbacks(&block); end

  def _run_validation_callbacks(&block); end

  def _save_callbacks(); end

  def _touch_callbacks(); end

  def _update_callbacks(); end

  def _upsert_callbacks(); end

  def _validate_callbacks(); end

  def _validation_callbacks(); end

  def _validators(); end

  def _validators?(); end

  def aliased_fields(); end

  def aliased_fields=(val); end

  def aliased_fields?(); end

  def before_callback_halted(); end

  def before_callback_halted=(before_callback_halted); end

  def cache_timestamp_format(); end

  def comment_ids(); end

  def comment_ids=(ids); end

  def comments(reload=T.unsafe(nil)); end

  def comments=(object); end

  def comments?(); end

  def cyclic(); end

  def cyclic=(val); end

  def cyclic?(); end

  def default_scoping(); end

  def default_scoping=(val); end

  def default_scoping?(); end

  def dependents(); end

  def dependents=(val); end

  def dependents?(); end

  def dependents_owner(); end

  def dependents_owner=(val); end

  def dependents_owner?(); end

  def embedded=(val); end

  def embedded_relations(); end

  def embedded_relations=(val); end

  def embedded_relations?(); end

  def fields(); end

  def fields=(val); end

  def fields?(); end

  def has_comments?(); end

  def id(); end

  def id=(value); end

  def include_root_in_json(); end

  def include_root_in_json?(); end

  def index_specifications(); end

  def index_specifications=(obj); end

  def localized_fields(); end

  def localized_fields=(val); end

  def localized_fields?(); end

  def model_name(*args, &block); end

  def nested_attributes(); end

  def nested_attributes=(val); end

  def nested_attributes?(); end

  def polymorphic(); end

  def polymorphic=(val); end

  def polymorphic?(); end

  def post_processed_defaults(); end

  def post_processed_defaults=(val); end

  def post_processed_defaults?(); end

  def pre_processed_defaults(); end

  def pre_processed_defaults=(val); end

  def pre_processed_defaults?(); end

  def readonly_attributes(); end

  def readonly_attributes=(val); end

  def readonly_attributes?(); end

  def relations(); end

  def relations=(val); end

  def relations?(); end

  def shard_config(); end

  def shard_config=(obj); end

  def shard_key_fields=(obj); end

  def storage_options(); end

  def validation_context(); end
end

class Post
  extend ::ActiveModel::Callbacks
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveModel::Translation
  extend ::ActiveModel::Naming
  extend ::ActiveModel::Validations::HelperMethods
  extend ::Mongoid::Validatable::Macros
  extend ::Mongoid::Findable
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._build_callbacks(); end

  def self._build_callbacks=(value); end

  def self._create_callbacks(); end

  def self._create_callbacks=(value); end

  def self._declared_scopes(); end

  def self._declared_scopes=(val); end

  def self._declared_scopes?(); end

  def self._destroy_callbacks(); end

  def self._destroy_callbacks=(value); end

  def self._find_callbacks(); end

  def self._find_callbacks=(value); end

  def self._initialize_callbacks(); end

  def self._initialize_callbacks=(value); end

  def self._save_callbacks(); end

  def self._save_callbacks=(value); end

  def self._touch_callbacks(); end

  def self._touch_callbacks=(value); end

  def self._update_callbacks(); end

  def self._update_callbacks=(value); end

  def self._upsert_callbacks(); end

  def self._upsert_callbacks=(value); end

  def self._validate_callbacks(); end

  def self._validate_callbacks=(value); end

  def self._validation_callbacks(); end

  def self._validation_callbacks=(value); end

  def self._validators(); end

  def self._validators=(val); end

  def self._validators?(); end

  def self.add_discriminator_mapping(value, klass=T.unsafe(nil)); end

  def self.after_build(*args, **options, &block); end

  def self.after_create(*args, **options, &block); end

  def self.after_destroy(*args, **options, &block); end

  def self.after_find(*args, **options, &block); end

  def self.after_initialize(*args, **options, &block); end

  def self.after_save(*args, **options, &block); end

  def self.after_touch(*args, **options, &block); end

  def self.after_update(*args, **options, &block); end

  def self.after_upsert(*args, **options, &block); end

  def self.aliased_fields(); end

  def self.aliased_fields=(val); end

  def self.aliased_fields?(); end

  def self.around_create(*args, **options, &block); end

  def self.around_destroy(*args, **options, &block); end

  def self.around_save(*args, **options, &block); end

  def self.around_update(*args, **options, &block); end

  def self.around_upsert(*args, **options, &block); end

  def self.before_create(*args, **options, &block); end

  def self.before_destroy(*args, **options, &block); end

  def self.before_save(*args, **options, &block); end

  def self.before_update(*args, **options, &block); end

  def self.before_upsert(*args, **options, &block); end

  def self.cache_timestamp_format(); end

  def self.cache_timestamp_format=(obj); end

  def self.cyclic(); end

  def self.cyclic=(val); end

  def self.cyclic?(); end

  def self.default_scoping(); end

  def self.default_scoping=(val); end

  def self.default_scoping?(); end

  def self.dependents(); end

  def self.dependents=(val); end

  def self.dependents?(); end

  def self.dependents_owner(); end

  def self.dependents_owner=(val); end

  def self.dependents_owner?(); end

  def self.discriminator_key(*args, &block); end

  def self.discriminator_key=(val); end

  def self.discriminator_key?(); end

  def self.discriminator_mapping(); end

  def self.discriminator_mapping=(discriminator_mapping); end

  def self.embedded(); end

  def self.embedded=(val); end

  def self.embedded?(); end

  def self.embedded_relations(); end

  def self.embedded_relations=(val); end

  def self.embedded_relations?(); end

  def self.fields(); end

  def self.fields=(val); end

  def self.fields?(); end

  def self.get_discriminator_mapping(value); end

  def self.include_root_in_json(*args, &block); end

  def self.include_root_in_json=(val); end

  def self.include_root_in_json?(); end

  def self.index_specifications(); end

  def self.index_specifications=(obj); end

  def self.localized_fields(); end

  def self.localized_fields=(val); end

  def self.localized_fields?(); end

  def self.nested_attributes(); end

  def self.nested_attributes=(val); end

  def self.nested_attributes?(); end

  def self.polymorphic(); end

  def self.polymorphic=(val); end

  def self.polymorphic?(); end

  def self.post_processed_defaults(); end

  def self.post_processed_defaults=(val); end

  def self.post_processed_defaults?(); end

  def self.pre_processed_defaults(); end

  def self.pre_processed_defaults=(val); end

  def self.pre_processed_defaults?(); end

  def self.readonly_attributes(); end

  def self.readonly_attributes=(val); end

  def self.readonly_attributes?(); end

  def self.relations(); end

  def self.relations=(val); end

  def self.relations?(); end

  def self.shard_config(); end

  def self.shard_config=(obj); end

  def self.shard_key_fields(); end

  def self.shard_key_fields=(obj); end

  def self.storage_options(); end

  def self.storage_options=(obj); end
end

class Proc
  include ::MethodSource::SourceLocation::ProcExtensions
  include ::MethodSource::MethodExtensions
  def <<(_); end

  def >>(_); end

  def clone(); end
end

class ProgressBar
end

class ProgressBar::Base
  def autofinish(); end

  def autofinish=(autofinish); end

  def autostart(); end

  def autostart=(autostart); end

  def bar(); end

  def bar=(bar); end

  def clear(*args, &block); end

  def decrement(); end

  def finish(); end

  def finished(); end

  def finished=(finished); end

  def finished?(); end

  def format(other); end

  def format=(other); end

  def increment(); end

  def initialize(options=T.unsafe(nil)); end

  def log(*args, &block); end

  def output(); end

  def output=(output); end

  def pause(); end

  def paused?(); end

  def percentage(); end

  def percentage=(percentage); end

  def progress(*args, &block); end

  def progress=(new_progress); end

  def progress_mark=(mark); end

  def progressable(); end

  def progressable=(progressable); end

  def rate(); end

  def rate=(rate); end

  def refresh(*args, &block); end

  def remainder_mark=(mark); end

  def reset(); end

  def resume(); end

  def start(options=T.unsafe(nil)); end

  def started?(); end

  def stop(); end

  def stopped?(); end

  def time(); end

  def time=(time); end

  def timer(); end

  def timer=(timer); end

  def title(); end

  def title=(title); end

  def title_comp(); end

  def title_comp=(title_comp); end

  def to_h(); end

  def to_s(new_format=T.unsafe(nil)); end

  def total(*args, &block); end

  def total=(new_total); end

  def update_progress(*args); end
end

class ProgressBar::Base
  extend ::Forwardable
end

module ProgressBar::Calculators
end

class ProgressBar::Calculators::Length
  def calculate_length(); end

  def current_length(); end

  def current_length=(current_length); end

  def initialize(options=T.unsafe(nil)); end

  def length(); end

  def length_changed?(); end

  def length_override(); end

  def length_override=(other); end

  def output(); end

  def output=(output); end

  def reset_length(); end
end

class ProgressBar::Calculators::Length
end

class ProgressBar::Calculators::RunningAverage
end

class ProgressBar::Calculators::RunningAverage
  def self.calculate(current_average, new_value_to_average, smoothing_factor); end
end

module ProgressBar::Calculators
end

module ProgressBar::Components
end

class ProgressBar::Components::Bar
  def initialize(options=T.unsafe(nil)); end

  def length(); end

  def length=(length); end

  def progress(); end

  def progress=(progress); end

  def progress_mark(); end

  def progress_mark=(progress_mark); end

  def remainder_mark(); end

  def remainder_mark=(remainder_mark); end

  def to_s(options=T.unsafe(nil)); end

  def upa_steps(); end

  def upa_steps=(upa_steps); end
  DEFAULT_PROGRESS_MARK = ::T.let(nil, ::T.untyped)
  DEFAULT_REMAINDER_MARK = ::T.let(nil, ::T.untyped)
  DEFAULT_UPA_STEPS = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Bar
end

class ProgressBar::Components::Percentage
  def initialize(options=T.unsafe(nil)); end

  def progress(); end

  def progress=(progress); end
end

class ProgressBar::Components::Percentage
end

class ProgressBar::Components::Rate
  def initialize(options=T.unsafe(nil)); end

  def progress(); end

  def progress=(progress); end

  def rate_scale(); end

  def rate_scale=(rate_scale); end

  def started_at(); end

  def started_at=(started_at); end

  def stopped_at(); end

  def stopped_at=(stopped_at); end

  def timer(); end

  def timer=(timer); end
end

class ProgressBar::Components::Rate
end

class ProgressBar::Components::Time
  def elapsed_with_label(); end

  def estimated_with_friendly_oob(); end

  def estimated_with_label(); end

  def estimated_with_no_oob(); end

  def estimated_with_unknown_oob(); end

  def initialize(options=T.unsafe(nil)); end

  def out_of_bounds_time_format(); end

  def out_of_bounds_time_format=(format); end

  def progress(); end

  def progress=(progress); end

  def timer(); end

  def timer=(timer); end
  ELAPSED_LABEL = ::T.let(nil, ::T.untyped)
  ESTIMATED_LABEL = ::T.let(nil, ::T.untyped)
  NO_TIME_ELAPSED_TEXT = ::T.let(nil, ::T.untyped)
  OOB_FRIENDLY_TIME_TEXT = ::T.let(nil, ::T.untyped)
  OOB_LIMIT_IN_HOURS = ::T.let(nil, ::T.untyped)
  OOB_TIME_FORMATS = ::T.let(nil, ::T.untyped)
  OOB_UNKNOWN_TIME_TEXT = ::T.let(nil, ::T.untyped)
  TIME_FORMAT = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Time
end

class ProgressBar::Components::Title
  def initialize(options=T.unsafe(nil)); end

  def title(); end

  def title=(title); end
  DEFAULT_TITLE = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Title
end

module ProgressBar::Components
end

module ProgressBar::Format
end

class ProgressBar::Format::Formatter
end

class ProgressBar::Format::Formatter
  def self.process(format_string, max_length, bar); end
end

class ProgressBar::Format::Molecule
  def bar_molecule?(); end

  def full_key(); end

  def initialize(letter); end

  def key(); end

  def key=(key); end

  def lookup_value(environment, length=T.unsafe(nil)); end

  def method_name(); end

  def method_name=(method_name); end

  def non_bar_molecule?(); end
  BAR_MOLECULES = ::T.let(nil, ::T.untyped)
  MOLECULES = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Format::Molecule
end

class ProgressBar::Format::String
  def bar_molecule_placeholder_length(); end

  def bar_molecules(); end

  def displayable_length(); end

  def molecules(); end

  def non_bar_molecules(); end
  ANSI_SGR_PATTERN = ::T.let(nil, ::T.untyped)
  MOLECULE_PATTERN = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Format::String
end

module ProgressBar::Format
end

class ProgressBar::InvalidProgressError
end

class ProgressBar::InvalidProgressError
end

class ProgressBar::Output
  def bar(); end

  def bar=(bar); end

  def clear_string(); end

  def initialize(options=T.unsafe(nil)); end

  def length(); end

  def length_calculator(); end

  def length_calculator=(length_calculator); end

  def log(string); end

  def refresh(options=T.unsafe(nil)); end

  def stream(); end

  def stream=(stream); end

  def throttle(); end

  def throttle=(throttle); end

  def with_refresh(); end
  DEFAULT_OUTPUT_STREAM = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Output
  def self.detect(options=T.unsafe(nil)); end
end

module ProgressBar::Outputs
end

class ProgressBar::Outputs::NonTty
  def bar_update_string(); end

  def clear(); end

  def default_format(); end

  def eol(); end

  def last_update_length(); end

  def last_update_length=(last_update_length); end

  def refresh_with_format_change(*_); end

  def resolve_format(*_); end
  DEFAULT_FORMAT_STRING = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Outputs::NonTty
end

class ProgressBar::Outputs::Tty
  def bar_update_string(); end

  def clear(); end

  def default_format(); end

  def eol(); end

  def refresh_with_format_change(); end

  def resolve_format(other_format); end
  DEFAULT_FORMAT_STRING = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Outputs::Tty
end

module ProgressBar::Outputs
end

class ProgressBar::Progress
  def absolute(); end

  def decrement(); end

  def finish(); end

  def finished?(); end

  def increment(); end

  def initialize(options=T.unsafe(nil)); end

  def none?(); end

  def percentage_completed(); end

  def percentage_completed_with_precision(); end

  def progress(); end

  def progress=(new_progress); end

  def reset(); end

  def running_average(); end

  def running_average=(running_average); end

  def smoothing(); end

  def smoothing=(smoothing); end

  def start(options=T.unsafe(nil)); end

  def starting_position(); end

  def starting_position=(starting_position); end

  def total(); end

  def total=(new_total); end

  def total_with_unknown_indicator(); end

  def unknown?(); end
  DEFAULT_BEGINNING_POSITION = ::T.let(nil, ::T.untyped)
  DEFAULT_SMOOTHING = ::T.let(nil, ::T.untyped)
  DEFAULT_TOTAL = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Progress
end

module ProgressBar::Refinements
end

module ProgressBar::Refinements::Enumerator
end

module ProgressBar::Refinements::Enumerator
end

module ProgressBar::Refinements
end

class ProgressBar::Throttle
  def choke(options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def rate(); end

  def rate=(rate); end

  def started_at(); end

  def started_at=(started_at); end

  def stopped_at(); end

  def stopped_at=(stopped_at); end

  def timer(); end

  def timer=(timer); end
end

class ProgressBar::Throttle
end

class ProgressBar::Time
  def initialize(time=T.unsafe(nil)); end

  def now(); end

  def time(); end

  def time=(time); end

  def unmocked_time_method(); end
  TIME_MOCKING_LIBRARY_METHODS = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Time
end

class ProgressBar::Timer
  def divide_seconds(seconds); end

  def elapsed_seconds(); end

  def elapsed_whole_seconds(); end

  def initialize(options=T.unsafe(nil)); end

  def pause(); end

  def reset(); end

  def reset?(); end

  def restart(); end

  def resume(); end

  def start(); end

  def started?(); end

  def started_at(); end

  def started_at=(started_at); end

  def stop(); end

  def stopped?(); end

  def stopped_at(); end

  def stopped_at=(stopped_at); end

  def time(); end

  def time=(time); end
end

class ProgressBar::Timer
end

class ProgressBar
  def self.create(*args); end
end

class Pry
  def add_sticky_local(name, &block); end

  def backtrace(); end

  def backtrace=(backtrace); end

  def binding_stack(); end

  def binding_stack=(binding_stack); end

  def color(*args, &block); end

  def color=(*args, &block); end

  def commands(*args, &block); end

  def commands=(*args, &block); end

  def complete(str); end

  def config(); end

  def current_binding(); end

  def current_context(); end

  def custom_completions(); end

  def custom_completions=(custom_completions); end

  def editor(*args, &block); end

  def editor=(*args, &block); end

  def eval(line, options=T.unsafe(nil)); end

  def eval_string(); end

  def eval_string=(eval_string); end

  def evaluate_ruby(code); end

  def exception_handler(*args, &block); end

  def exception_handler=(*args, &block); end

  def exec_hook(name, *args, &block); end

  def exit_value(); end

  def extra_sticky_locals(*args, &block); end

  def extra_sticky_locals=(*args, &block); end

  def hooks(*args, &block); end

  def hooks=(*args, &block); end

  def initialize(options=T.unsafe(nil)); end

  def inject_local(name, value, binding); end

  def inject_sticky_locals!(); end

  def input(*args, &block); end

  def input=(*args, &block); end

  def input_ring(); end

  def last_dir(); end

  def last_dir=(last_dir); end

  def last_exception(); end

  def last_exception=(exception); end

  def last_file(); end

  def last_file=(last_file); end

  def last_result(); end

  def last_result=(last_result); end

  def last_result_is_exception?(); end

  def memory_size(); end

  def memory_size=(size); end

  def output(); end

  def output=(*args, &block); end

  def output_ring(); end

  def pager(); end

  def pager=(*args, &block); end

  def pop_prompt(); end

  def print(*args, &block); end

  def print=(*args, &block); end

  def process_command(val); end

  def process_command_safely(val); end

  def prompt(); end

  def prompt=(new_prompt); end

  def push_binding(object); end

  def push_initial_binding(target=T.unsafe(nil)); end

  def push_prompt(new_prompt); end

  def quiet?(); end

  def raise_up(*args); end

  def raise_up!(*args); end

  def raise_up_common(force, *args); end

  def repl(target=T.unsafe(nil)); end

  def reset_eval_string(); end

  def run_command(val); end

  def select_prompt(); end

  def set_last_result(result, code=T.unsafe(nil)); end

  def should_print?(); end

  def show_result(result); end

  def sticky_locals(); end

  def suppress_output(); end

  def suppress_output=(suppress_output); end

  def update_input_history(code); end
  BINDING_METHOD_IMPL = ::T.let(nil, ::T.untyped)
  Commands = ::T.let(nil, ::T.untyped)
  EMPTY_COMPLETIONS = ::T.let(nil, ::T.untyped)
  HAS_SAFE_LEVEL = ::T.let(nil, ::T.untyped)
  LOCAL_RC_FILE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Pry::BasicObject
  include ::Kernel
  ENV = ::T.let(nil, ::T.untyped)
end

Pry::BasicObject::Dir = Dir

Pry::BasicObject::File = File

Pry::BasicObject::Kernel = Kernel

Pry::BasicObject::LoadError = LoadError

Pry::BasicObject::Pry = Pry

class Pry::BasicObject
end

class Pry::BlockCommand
  def call(*args); end

  def help(); end
end

class Pry::BlockCommand
end

class Pry::CLI
end

class Pry::CLI::NoOptionsError
end

class Pry::CLI::NoOptionsError
end

class Pry::CLI
  def self.add_option_processor(&block); end

  def self.add_options(&block); end

  def self.add_plugin_options(); end

  def self.input_args(); end

  def self.input_args=(input_args); end

  def self.option_processors(); end

  def self.option_processors=(option_processors); end

  def self.options(); end

  def self.options=(options); end

  def self.parse_options(args=T.unsafe(nil)); end

  def self.reset(); end

  def self.start(opts); end
end

class Pry::ClassCommand
  def args(); end

  def args=(args); end

  def call(*args); end

  def complete(search); end

  def help(); end

  def options(opt); end

  def opts(); end

  def opts=(opts); end

  def process(); end

  def setup(); end

  def slop(); end

  def subcommands(cmd); end
end

class Pry::ClassCommand
  def self.inherited(klass); end

  def self.source_location(); end
end

class Pry::Code
  def <<(line); end

  def ==(other); end

  def after(lineno, lines=T.unsafe(nil)); end

  def alter(&block); end

  def around(lineno, lines=T.unsafe(nil)); end

  def before(lineno, lines=T.unsafe(nil)); end

  def between(start_line, end_line=T.unsafe(nil)); end

  def code_type(); end

  def code_type=(code_type); end

  def comment_describing(line_number); end

  def expression_at(line_number, consume=T.unsafe(nil)); end

  def grep(pattern); end

  def highlighted(); end

  def initialize(lines=T.unsafe(nil), start_line=T.unsafe(nil), code_type=T.unsafe(nil)); end

  def length(); end

  def max_lineno_width(); end

  def method_missing(method_name, *args, &block); end

  def nesting_at(line_number); end

  def print_to_output(output, color=T.unsafe(nil)); end

  def push(line); end

  def raw(); end

  def reject(&block); end

  def select(&block); end

  def take_lines(start_line, num_lines); end

  def with_indentation(spaces=T.unsafe(nil)); end

  def with_line_numbers(y_n=T.unsafe(nil)); end

  def with_marker(lineno=T.unsafe(nil)); end
end

class Pry::Code::CodeRange
  def indices_range(lines); end

  def initialize(start_line, end_line=T.unsafe(nil)); end
end

class Pry::Code::CodeRange
end

class Pry::Code::LOC
  def ==(other); end

  def add_line_number(max_width=T.unsafe(nil), color=T.unsafe(nil)); end

  def add_marker(marker_lineno); end

  def colorize(code_type); end

  def handle_multiline_entries_from_edit_command(line, max_width); end

  def indent(distance); end

  def initialize(line, lineno); end

  def line(); end

  def lineno(); end

  def tuple(); end
end

class Pry::Code::LOC
end

class Pry::Code
  extend ::MethodSource::CodeHelpers
  def self.from_file(filename, code_type=T.unsafe(nil)); end

  def self.from_method(meth, start_line=T.unsafe(nil)); end

  def self.from_module(mod, candidate_rank=T.unsafe(nil), start_line=T.unsafe(nil)); end
end

class Pry::CodeFile
  def code(); end

  def code_type(); end

  def initialize(filename, code_type=T.unsafe(nil)); end
  DEFAULT_EXT = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
  FILES = ::T.let(nil, ::T.untyped)
  INITIAL_PWD = ::T.let(nil, ::T.untyped)
end

class Pry::CodeFile
end

class Pry::CodeObject
  include ::Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
  def command_lookup(); end

  def default_lookup(); end

  def empty_lookup(); end

  def initialize(str, pry_instance, options=T.unsafe(nil)); end

  def method_or_class_lookup(); end

  def pry_instance(); end

  def pry_instance=(pry_instance); end

  def str(); end

  def str=(str); end

  def super_level(); end

  def super_level=(super_level); end

  def target(); end

  def target=(target); end
end

module Pry::CodeObject::Helpers
  def c_method?(); end

  def c_module?(); end

  def command?(); end

  def module_with_yard_docs?(); end

  def real_method_object?(); end
end

module Pry::CodeObject::Helpers
end

class Pry::CodeObject
  def self.lookup(str, pry_instance, options=T.unsafe(nil)); end
end

class Pry::ColorPrinter
  def pp(object); end

  def text(str, max_width=T.unsafe(nil)); end
end

class Pry::ColorPrinter
  def self.default(_output, value, pry_instance); end

  def self.pp(obj, output=T.unsafe(nil), max_width=T.unsafe(nil)); end
end

class Pry::Command
  include ::Pry::Helpers::BaseHelpers
  include ::Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
  include ::Pry::Helpers::Text
  def _pry_(); end

  def _pry_=(_pry_); end

  def arg_string(); end

  def arg_string=(arg_string); end

  def block(); end

  def captures(); end

  def captures=(captures); end

  def check_for_command_collision(command_match, arg_string); end

  def command_block(); end

  def command_block=(command_block); end

  def command_name(); end

  def command_options(); end

  def command_set(); end

  def command_set=(command_set); end

  def commands(); end

  def complete(_search); end

  def context(); end

  def context=(context); end

  def description(); end

  def eval_string(); end

  def eval_string=(eval_string); end

  def hooks(); end

  def hooks=(hooks); end

  def initialize(context=T.unsafe(nil)); end

  def interpolate_string(str); end

  def match(); end

  def name(); end

  def output(); end

  def output=(output); end

  def process_line(line); end

  def pry_instance(); end

  def pry_instance=(pry_instance); end

  def run(command_string, *args); end

  def source(); end

  def state(); end

  def target(); end

  def target=(target); end

  def target_self(); end

  def tokenize(val); end

  def void(); end
  VOID_VALUE = ::T.let(nil, ::T.untyped)
end

class Pry::Command::AmendLine
end

class Pry::Command::AmendLine
end

class Pry::Command::Bang
end

class Pry::Command::Bang
end

class Pry::Command::BangPry
end

class Pry::Command::BangPry
end

class Pry::Command::Cat
  def load_path_completions(); end
end

class Pry::Command::Cat::AbstractFormatter
  include ::Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
  include ::Pry::Helpers::BaseHelpers
end

class Pry::Command::Cat::AbstractFormatter
end

class Pry::Command::Cat::ExceptionFormatter
  include ::Pry::Helpers::Text
  def ex(); end

  def format(); end

  def initialize(exception, pry_instance, opts); end

  def opts(); end

  def pry_instance(); end
end

class Pry::Command::Cat::ExceptionFormatter
end

class Pry::Command::Cat::FileFormatter
  def file_and_line(); end

  def file_with_embedded_line(); end

  def format(); end

  def initialize(file_with_embedded_line, pry_instance, opts); end

  def opts(); end

  def pry_instance(); end
end

class Pry::Command::Cat::FileFormatter
end

class Pry::Command::Cat::InputExpressionFormatter
  def format(); end

  def initialize(input_expressions, opts); end

  def input_expressions(); end

  def input_expressions=(input_expressions); end

  def opts(); end

  def opts=(opts); end
end

class Pry::Command::Cat::InputExpressionFormatter
end

class Pry::Command::Cat
end

class Pry::Command::Cd
end

class Pry::Command::Cd
end

class Pry::Command::ChangeInspector
  def process(inspector); end
end

class Pry::Command::ChangeInspector
end

class Pry::Command::ChangePrompt
  def process(prompt); end
end

class Pry::Command::ChangePrompt
end

class Pry::Command::ClearScreen
end

class Pry::Command::ClearScreen
end

class Pry::Command::CodeCollector
  include ::Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
  def args(); end

  def code_object(); end

  def content(); end

  def file(); end

  def file=(file); end

  def initialize(args, opts, pry_instance); end

  def line_range(); end

  def obj_name(); end

  def opts(); end

  def pry_input_content(); end

  def pry_instance(); end

  def pry_output_content(); end

  def restrict_to_lines(content, range); end
end

class Pry::Command::CodeCollector
  def self.inject_options(opt); end

  def self.input_expression_ranges(); end

  def self.input_expression_ranges=(input_expression_ranges); end

  def self.output_result_ranges(); end

  def self.output_result_ranges=(output_result_ranges); end
end

class Pry::Command::DisablePry
end

class Pry::Command::DisablePry
end

class Pry::Command::Edit
  def apply_runtime_patch(); end

  def bad_option_combination?(); end

  def code_object(); end

  def ensure_file_name_is_valid(file_name); end

  def file_and_line(); end

  def file_and_line_for_current_exception(); end

  def file_based_exception?(); end

  def file_edit(); end

  def filename_argument(); end

  def initial_temp_file_content(); end

  def input_expression(); end

  def never_reload?(); end

  def patch_exception?(); end

  def previously_patched?(code_object); end

  def probably_a_file?(str); end

  def pry_method?(code_object); end

  def reload?(file_name=T.unsafe(nil)); end

  def reloadable?(); end

  def repl_edit(); end

  def repl_edit?(); end

  def runtime_patch?(); end
end

class Pry::Command::Edit::ExceptionPatcher
  def file_and_line(); end

  def file_and_line=(file_and_line); end

  def initialize(pry_instance, state, exception_file_and_line); end

  def perform_patch(); end

  def pry_instance(); end

  def pry_instance=(pry_instance); end

  def state(); end

  def state=(state); end
end

class Pry::Command::Edit::ExceptionPatcher
end

module Pry::Command::Edit::FileAndLineLocator
end

module Pry::Command::Edit::FileAndLineLocator
  def self.from_binding(target); end

  def self.from_code_object(code_object, filename_argument); end

  def self.from_exception(exception, backtrace_level); end

  def self.from_filename_argument(filename_argument); end
end

class Pry::Command::Edit
end

class Pry::Command::Exit
  def process_pop_and_return(); end
end

class Pry::Command::Exit
end

class Pry::Command::ExitAll
end

class Pry::Command::ExitAll
end

class Pry::Command::ExitProgram
end

class Pry::Command::ExitProgram
end

class Pry::Command::FindMethod
end

class Pry::Command::FindMethod
  extend ::Pry::Helpers::BaseHelpers
end

class Pry::Command::FixIndent
end

class Pry::Command::FixIndent
end

class Pry::Command::Help
  def command_groups(); end

  def display_command(command); end

  def display_filtered_commands(search); end

  def display_filtered_search_results(search); end

  def display_index(groups); end

  def display_search(search); end

  def group_sort_key(group_name); end

  def help_text_for_commands(name, commands); end

  def normalize(key); end

  def search_hash(search, hash); end

  def sorted_commands(commands); end

  def sorted_group_names(groups); end

  def visible_commands(); end
end

class Pry::Command::Help
end

class Pry::Command::Hist
end

class Pry::Command::Hist
end

class Pry::Command::ImportSet
  def process(_command_set_name); end
end

class Pry::Command::ImportSet
end

class Pry::Command::JumpTo
  def process(break_level); end
end

class Pry::Command::JumpTo
end

class Pry::Command::ListInspectors
end

class Pry::Command::ListInspectors
end

class Pry::Command::Ls
  def no_user_opts?(); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls::Constants
  include ::Pry::Command::Ls::Interrogatable
  def initialize(interrogatee, no_user_opts, opts, pry_instance); end
  DEPRECATED_CONSTANTS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls::Constants
end

class Pry::Command::Ls::Formatter
  def grep=(grep); end

  def initialize(pry_instance); end

  def pry_instance(); end

  def write_out(); end
end

class Pry::Command::Ls::Formatter
end

class Pry::Command::Ls::Globals
  def initialize(opts, pry_instance); end
  BUILTIN_GLOBALS = ::T.let(nil, ::T.untyped)
  PSEUDO_GLOBALS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls::Globals
end

class Pry::Command::Ls::Grep
  def initialize(grep_regexp); end

  def regexp(); end
end

class Pry::Command::Ls::Grep
end

class Pry::Command::Ls::InstanceVars
  include ::Pry::Command::Ls::Interrogatable
  def initialize(interrogatee, no_user_opts, opts, pry_instance); end
end

class Pry::Command::Ls::InstanceVars
end

module Pry::Command::Ls::Interrogatable
end

module Pry::Command::Ls::Interrogatable
end

module Pry::Command::Ls::JRubyHacks
end

module Pry::Command::Ls::JRubyHacks
end

class Pry::Command::Ls::LocalNames
  def initialize(no_user_opts, args, pry_instance); end
end

class Pry::Command::Ls::LocalNames
end

class Pry::Command::Ls::LocalVars
  def initialize(opts, pry_instance); end
end

class Pry::Command::Ls::LocalVars
end

class Pry::Command::Ls::LsEntity
  def entities_table(); end

  def initialize(opts); end

  def pry_instance(); end
end

class Pry::Command::Ls::LsEntity
end

class Pry::Command::Ls::Methods
  include ::Pry::Command::Ls::Interrogatable
  include ::Pry::Command::Ls::MethodsHelper
  include ::Pry::Command::Ls::JRubyHacks
  def initialize(interrogatee, no_user_opts, opts, pry_instance); end
end

class Pry::Command::Ls::Methods
end

module Pry::Command::Ls::MethodsHelper
  include ::Pry::Command::Ls::JRubyHacks
end

module Pry::Command::Ls::MethodsHelper
end

class Pry::Command::Ls::SelfMethods
  include ::Pry::Command::Ls::Interrogatable
  include ::Pry::Command::Ls::MethodsHelper
  include ::Pry::Command::Ls::JRubyHacks
  def initialize(interrogatee, no_user_opts, opts, pry_instance); end
end

class Pry::Command::Ls::SelfMethods
end

class Pry::Command::Ls
end

class Pry::Command::Nesting
end

class Pry::Command::Nesting
end

class Pry::Command::Play
  def code_object(); end

  def content(); end

  def content_after_options(); end

  def content_at_expression(); end

  def default_file(); end

  def file_content(); end

  def perform_play(); end

  def should_use_default_file?(); end

  def show_input(); end
end

class Pry::Command::Play
end

class Pry::Command::PryBacktrace
end

class Pry::Command::PryBacktrace
end

class Pry::Command::RaiseUp
end

class Pry::Command::RaiseUp
end

class Pry::Command::ReloadCode
end

class Pry::Command::ReloadCode
end

class Pry::Command::Reset
end

class Pry::Command::Reset
end

class Pry::Command::Ri
  def process(spec); end
end

class Pry::Command::Ri
end

class Pry::Command::SaveFile
  def display_content(); end

  def file_name(); end

  def mode(); end

  def save_file(); end
end

class Pry::Command::SaveFile
end

class Pry::Command::ShellCommand
  def process(cmd); end
end

class Pry::Command::ShellCommand
end

class Pry::Command::ShellMode
end

class Pry::Command::ShellMode
end

class Pry::Command::ShowDoc
  include ::Pry::Helpers::DocumentationHelpers
  def content_for(code_object); end

  def docs_for(code_object); end

  def render_doc_markup_for(code_object); end
end

class Pry::Command::ShowDoc
end

class Pry::Command::ShowInfo
  def code_object_header(code_object, line_num); end

  def code_object_with_accessible_source(code_object); end

  def complete(input); end

  def content_and_header_for_code_object(code_object); end

  def content_and_headers_for_all_module_candidates(mod); end

  def file_and_line_for(code_object); end

  def header(code_object); end

  def header_options(); end

  def initialize(*_); end

  def method_header(code_object, line_num); end

  def method_sections(code_object); end

  def module_header(code_object, line_num); end

  def no_definition_message(); end

  def obj_name(); end

  def show_all_modules?(code_object); end

  def start_line_for(code_object); end

  def use_line_numbers?(); end

  def valid_superclass?(code_object); end
end

class Pry::Command::ShowInfo
  extend ::Pry::Helpers::BaseHelpers
end

class Pry::Command::ShowInput
end

class Pry::Command::ShowInput
end

class Pry::Command::ShowSource
  include ::Pry::Helpers::DocumentationHelpers
  def content_for(code_object); end

  def docs_for(code_object); end

  def render_doc_markup_for(code_object); end
end

class Pry::Command::ShowSource
end

class Pry::Command::Stat
end

class Pry::Command::Stat
end

class Pry::Command::SwitchTo
  def process(selection); end
end

class Pry::Command::SwitchTo
end

class Pry::Command::ToggleColor
  def color_toggle(); end
end

class Pry::Command::ToggleColor
end

class Pry::Command::Version
end

class Pry::Command::Version
end

class Pry::Command::WatchExpression
end

class Pry::Command::WatchExpression::Expression
  def changed?(); end

  def eval!(); end

  def initialize(pry_instance, target, source); end

  def previous_value(); end

  def pry_instance(); end

  def source(); end

  def target(); end

  def value(); end
end

class Pry::Command::WatchExpression::Expression
end

class Pry::Command::WatchExpression
end

class Pry::Command::Whereami
  def bad_option_combination?(); end

  def code(); end

  def code?(); end

  def initialize(*_); end

  def location(); end
end

class Pry::Command::Whereami
  def self.method_size_cutoff(); end

  def self.method_size_cutoff=(method_size_cutoff); end
end

class Pry::Command::Wtf
  RUBY_FRAME_PATTERN = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Wtf
end

class Pry::Command
  extend ::Pry::Helpers::DocumentationHelpers
  extend ::Pry::CodeObject::Helpers
  def self.banner(arg=T.unsafe(nil)); end

  def self.block(); end

  def self.block=(block); end

  def self.command_name(); end

  def self.command_options(arg=T.unsafe(nil)); end

  def self.command_options=(command_options); end

  def self.command_regex(); end

  def self.convert_to_regex(obj); end

  def self.default_options(match); end

  def self.description(arg=T.unsafe(nil)); end

  def self.description=(description); end

  def self.doc(); end

  def self.file(); end

  def self.group(name=T.unsafe(nil)); end

  def self.line(); end

  def self.match(arg=T.unsafe(nil)); end

  def self.match=(match); end

  def self.match_score(val); end

  def self.matches?(val); end

  def self.options(arg=T.unsafe(nil)); end

  def self.options=(options); end

  def self.source(); end

  def self.source_file(); end

  def self.source_line(); end

  def self.state(); end

  def self.subclass(match, description, options, helpers, &block); end
end

class Pry::CommandError
end

class Pry::CommandError
end

class Pry::CommandSet
  include ::Enumerable
  include ::Pry::Helpers::BaseHelpers
  def [](pattern); end

  def []=(pattern, command); end

  def add_command(command); end

  def alias_command(match, action, options=T.unsafe(nil)); end

  def block_command(match, description=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def command(match, description=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def complete(search, context=T.unsafe(nil)); end

  def create_command(match, description=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def delete(*searches); end

  def desc(search, description=T.unsafe(nil)); end

  def each(&block); end

  def find_command(pattern); end

  def find_command_by_match_or_listing(match_or_listing); end

  def find_command_for_help(search); end

  def helper_module(); end

  def import(*sets); end

  def import_from(set, *matches); end

  def initialize(*imported_sets, &block); end

  def keys(); end

  def list_commands(); end

  def process_line(val, context=T.unsafe(nil)); end

  def rename_command(new_match, search, options=T.unsafe(nil)); end

  def to_h(); end

  def to_hash(); end

  def valid_command?(val); end
end

class Pry::CommandSet
end

class Pry::CommandState
  def reset(command_name); end

  def state_for(command_name); end
end

class Pry::CommandState
  def self.default(); end
end

class Pry::Config
  def [](attr); end

  def []=(attr, value); end

  def auto_indent(); end

  def auto_indent=(auto_indent); end

  def collision_warning(); end

  def collision_warning=(collision_warning); end

  def color(); end

  def color=(color); end

  def command_completions(); end

  def command_completions=(command_completions); end

  def command_prefix(); end

  def command_prefix=(command_prefix); end

  def commands(); end

  def commands=(commands); end

  def completer(); end

  def completer=(completer); end

  def control_d_handler(); end

  def control_d_handler=(value); end

  def correct_indent(); end

  def correct_indent=(correct_indent); end

  def default_window_size(); end

  def default_window_size=(default_window_size); end

  def disable_auto_reload(); end

  def disable_auto_reload=(disable_auto_reload); end

  def editor(); end

  def editor=(editor); end

  def exception_handler(); end

  def exception_handler=(exception_handler); end

  def exception_whitelist(); end

  def exception_whitelist=(exception_whitelist); end

  def exec_string(); end

  def exec_string=(exec_string); end

  def extra_sticky_locals(); end

  def extra_sticky_locals=(extra_sticky_locals); end

  def file_completions(); end

  def file_completions=(file_completions); end

  def history(); end

  def history=(history); end

  def history_file(); end

  def history_file=(history_file); end

  def history_ignorelist(); end

  def history_ignorelist=(history_ignorelist); end

  def history_load(); end

  def history_load=(history_load); end

  def history_save(); end

  def history_save=(history_save); end

  def hooks(); end

  def hooks=(hooks); end

  def input(); end

  def input=(input); end

  def ls(); end

  def ls=(ls); end

  def memory_size(); end

  def memory_size=(memory_size); end

  def merge(config_hash); end

  def merge!(config_hash); end

  def method_missing(method_name, *args, &_block); end

  def output(); end

  def output=(output); end

  def output_prefix(); end

  def output_prefix=(output_prefix); end

  def pager(); end

  def pager=(pager); end

  def print(); end

  def print=(print); end

  def prompt(); end

  def prompt=(prompt); end

  def prompt_name(); end

  def prompt_name=(prompt_name); end

  def prompt_safe_contexts(); end

  def prompt_safe_contexts=(prompt_safe_contexts); end

  def quiet(); end

  def quiet=(quiet); end

  def rc_file(); end

  def rc_file=(rc_file); end

  def requires(); end

  def requires=(requires); end

  def should_load_local_rc(); end

  def should_load_local_rc=(should_load_local_rc); end

  def should_load_plugins(); end

  def should_load_plugins=(should_load_plugins); end

  def should_load_rc(); end

  def should_load_rc=(should_load_rc); end

  def should_load_requires(); end

  def should_load_requires=(should_load_requires); end

  def should_trap_interrupts(); end

  def should_trap_interrupts=(should_trap_interrupts); end

  def system(); end

  def system=(system); end

  def unrescued_exceptions(); end

  def unrescued_exceptions=(unrescued_exceptions); end

  def windows_console_warning(); end

  def windows_console_warning=(windows_console_warning); end
end

module Pry::Config::Attributable
  def attribute(attr_name); end
end

module Pry::Config::Attributable
end

class Pry::Config::LazyValue
  def call(); end

  def initialize(&block); end
end

class Pry::Config::LazyValue
end

class Pry::Config::MemoizedValue
  def call(); end

  def initialize(&block); end
end

class Pry::Config::MemoizedValue
end

class Pry::Config::Value
  def call(); end

  def initialize(value); end
end

class Pry::Config::Value
end

class Pry::Config
  extend ::Pry::Config::Attributable
end

module Pry::ControlDHandler
end

module Pry::ControlDHandler
  def self.default(pry_instance); end
end

class Pry::Editor
  include ::Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
  def build_editor_invocation_string(file, line, blocking); end

  def edit_tempfile_with_content(initial_content, line=T.unsafe(nil)); end

  def initialize(pry_instance); end

  def invoke_editor(file, line, blocking=T.unsafe(nil)); end

  def pry_instance(); end
end

class Pry::Editor
  def self.default(); end
end

module Pry::Env
end

module Pry::Env
  def self.[](key); end
end

module Pry::ExceptionHandler
end

module Pry::ExceptionHandler
  def self.handle_exception(output, exception, _pry_instance); end
end

module Pry::Forwardable
  include ::Forwardable
  def def_private_delegators(target, *private_delegates); end
end

module Pry::Forwardable
end

module Pry::FrozenObjectException
end

module Pry::FrozenObjectException
  def self.===(exception); end
end

module Pry::Helpers
end

module Pry::Helpers::BaseHelpers
  def colorize_code(code); end

  def find_command(name, set=T.unsafe(nil)); end

  def heading(text); end

  def highlight(string, regexp, highlight_color=T.unsafe(nil)); end

  def not_a_real_file?(file); end

  def safe_send(obj, method, *args, &block); end

  def silence_warnings(); end

  def stagger_output(text, _out=T.unsafe(nil)); end

  def use_ansi_codes?(); end
end

module Pry::Helpers::BaseHelpers
  extend ::Pry::Helpers::BaseHelpers
end

module Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
  def absolute_index_number(line_number, array_length); end

  def absolute_index_range(range_or_number, array_length); end

  def get_method_or_raise(method_name, context, opts=T.unsafe(nil)); end

  def internal_binding?(context); end

  def one_index_number(line_number); end

  def one_index_range(range); end

  def one_index_range_or_number(range_or_number); end

  def restrict_to_lines(content, lines); end

  def set_file_and_dir_locals(file_name, pry=T.unsafe(nil), ctx=T.unsafe(nil)); end

  def temp_file(ext=T.unsafe(nil)); end

  def unindent(dirty_text, left_padding=T.unsafe(nil)); end
end

module Pry::Helpers::CommandHelpers
  extend ::Pry::Helpers::CommandHelpers
  extend ::Pry::Helpers::OptionsHelpers
end

module Pry::Helpers::DocumentationHelpers
  YARD_TAGS = ::T.let(nil, ::T.untyped)
end

module Pry::Helpers::DocumentationHelpers
  def self.get_comment_content(comment); end

  def self.process_comment_markup(comment); end

  def self.process_rdoc(comment); end

  def self.process_yardoc(comment); end

  def self.process_yardoc_tag(comment, tag); end

  def self.strip_comments_from_c_code(code); end

  def self.strip_leading_whitespace(text); end
end

module Pry::Helpers::OptionsHelpers
end

module Pry::Helpers::OptionsHelpers
  def self.method_object(); end

  def self.method_options(opt); end
end

module Pry::Helpers::Platform
end

module Pry::Helpers::Platform
  def self.jruby?(); end

  def self.jruby_19?(); end

  def self.linux?(); end

  def self.mac_osx?(); end

  def self.mri?(); end

  def self.mri_19?(); end

  def self.mri_2?(); end

  def self.windows?(); end

  def self.windows_ansi?(); end
end

class Pry::Helpers::Table
  def ==(other); end

  def column_count(); end

  def column_count=(count); end

  def columns(); end

  def fits_on_line?(line_length); end

  def initialize(items, args, pry_instance=T.unsafe(nil)); end

  def items(); end

  def items=(items); end

  def rows_to_s(style=T.unsafe(nil)); end

  def to_a(); end
end

class Pry::Helpers::Table
end

module Pry::Helpers::Text
  def black(text); end

  def black_on_black(text); end

  def black_on_blue(text); end

  def black_on_cyan(text); end

  def black_on_green(text); end

  def black_on_magenta(text); end

  def black_on_purple(text); end

  def black_on_red(text); end

  def black_on_white(text); end

  def black_on_yellow(text); end

  def blue(text); end

  def blue_on_black(text); end

  def blue_on_blue(text); end

  def blue_on_cyan(text); end

  def blue_on_green(text); end

  def blue_on_magenta(text); end

  def blue_on_purple(text); end

  def blue_on_red(text); end

  def blue_on_white(text); end

  def blue_on_yellow(text); end

  def bold(text); end

  def bright_black(text); end

  def bright_black_on_black(text); end

  def bright_black_on_blue(text); end

  def bright_black_on_cyan(text); end

  def bright_black_on_green(text); end

  def bright_black_on_magenta(text); end

  def bright_black_on_purple(text); end

  def bright_black_on_red(text); end

  def bright_black_on_white(text); end

  def bright_black_on_yellow(text); end

  def bright_blue(text); end

  def bright_blue_on_black(text); end

  def bright_blue_on_blue(text); end

  def bright_blue_on_cyan(text); end

  def bright_blue_on_green(text); end

  def bright_blue_on_magenta(text); end

  def bright_blue_on_purple(text); end

  def bright_blue_on_red(text); end

  def bright_blue_on_white(text); end

  def bright_blue_on_yellow(text); end

  def bright_cyan(text); end

  def bright_cyan_on_black(text); end

  def bright_cyan_on_blue(text); end

  def bright_cyan_on_cyan(text); end

  def bright_cyan_on_green(text); end

  def bright_cyan_on_magenta(text); end

  def bright_cyan_on_purple(text); end

  def bright_cyan_on_red(text); end

  def bright_cyan_on_white(text); end

  def bright_cyan_on_yellow(text); end

  def bright_green(text); end

  def bright_green_on_black(text); end

  def bright_green_on_blue(text); end

  def bright_green_on_cyan(text); end

  def bright_green_on_green(text); end

  def bright_green_on_magenta(text); end

  def bright_green_on_purple(text); end

  def bright_green_on_red(text); end

  def bright_green_on_white(text); end

  def bright_green_on_yellow(text); end

  def bright_magenta(text); end

  def bright_magenta_on_black(text); end

  def bright_magenta_on_blue(text); end

  def bright_magenta_on_cyan(text); end

  def bright_magenta_on_green(text); end

  def bright_magenta_on_magenta(text); end

  def bright_magenta_on_purple(text); end

  def bright_magenta_on_red(text); end

  def bright_magenta_on_white(text); end

  def bright_magenta_on_yellow(text); end

  def bright_purple(text); end

  def bright_purple_on_black(text); end

  def bright_purple_on_blue(text); end

  def bright_purple_on_cyan(text); end

  def bright_purple_on_green(text); end

  def bright_purple_on_magenta(text); end

  def bright_purple_on_purple(text); end

  def bright_purple_on_red(text); end

  def bright_purple_on_white(text); end

  def bright_purple_on_yellow(text); end

  def bright_red(text); end

  def bright_red_on_black(text); end

  def bright_red_on_blue(text); end

  def bright_red_on_cyan(text); end

  def bright_red_on_green(text); end

  def bright_red_on_magenta(text); end

  def bright_red_on_purple(text); end

  def bright_red_on_red(text); end

  def bright_red_on_white(text); end

  def bright_red_on_yellow(text); end

  def bright_white(text); end

  def bright_white_on_black(text); end

  def bright_white_on_blue(text); end

  def bright_white_on_cyan(text); end

  def bright_white_on_green(text); end

  def bright_white_on_magenta(text); end

  def bright_white_on_purple(text); end

  def bright_white_on_red(text); end

  def bright_white_on_white(text); end

  def bright_white_on_yellow(text); end

  def bright_yellow(text); end

  def bright_yellow_on_black(text); end

  def bright_yellow_on_blue(text); end

  def bright_yellow_on_cyan(text); end

  def bright_yellow_on_green(text); end

  def bright_yellow_on_magenta(text); end

  def bright_yellow_on_purple(text); end

  def bright_yellow_on_red(text); end

  def bright_yellow_on_white(text); end

  def bright_yellow_on_yellow(text); end

  def cyan(text); end

  def cyan_on_black(text); end

  def cyan_on_blue(text); end

  def cyan_on_cyan(text); end

  def cyan_on_green(text); end

  def cyan_on_magenta(text); end

  def cyan_on_purple(text); end

  def cyan_on_red(text); end

  def cyan_on_white(text); end

  def cyan_on_yellow(text); end

  def default(text); end

  def green(text); end

  def green_on_black(text); end

  def green_on_blue(text); end

  def green_on_cyan(text); end

  def green_on_green(text); end

  def green_on_magenta(text); end

  def green_on_purple(text); end

  def green_on_red(text); end

  def green_on_white(text); end

  def green_on_yellow(text); end

  def indent(text, chars); end

  def magenta(text); end

  def magenta_on_black(text); end

  def magenta_on_blue(text); end

  def magenta_on_cyan(text); end

  def magenta_on_green(text); end

  def magenta_on_magenta(text); end

  def magenta_on_purple(text); end

  def magenta_on_red(text); end

  def magenta_on_white(text); end

  def magenta_on_yellow(text); end

  def no_color(); end

  def no_pager(); end

  def purple(text); end

  def purple_on_black(text); end

  def purple_on_blue(text); end

  def purple_on_cyan(text); end

  def purple_on_green(text); end

  def purple_on_magenta(text); end

  def purple_on_purple(text); end

  def purple_on_red(text); end

  def purple_on_white(text); end

  def purple_on_yellow(text); end

  def red(text); end

  def red_on_black(text); end

  def red_on_blue(text); end

  def red_on_cyan(text); end

  def red_on_green(text); end

  def red_on_magenta(text); end

  def red_on_purple(text); end

  def red_on_red(text); end

  def red_on_white(text); end

  def red_on_yellow(text); end

  def strip_color(text); end

  def white(text); end

  def white_on_black(text); end

  def white_on_blue(text); end

  def white_on_cyan(text); end

  def white_on_green(text); end

  def white_on_magenta(text); end

  def white_on_purple(text); end

  def white_on_red(text); end

  def white_on_white(text); end

  def white_on_yellow(text); end

  def with_line_numbers(text, offset, color=T.unsafe(nil)); end

  def yellow(text); end

  def yellow_on_black(text); end

  def yellow_on_blue(text); end

  def yellow_on_cyan(text); end

  def yellow_on_green(text); end

  def yellow_on_magenta(text); end

  def yellow_on_purple(text); end

  def yellow_on_red(text); end

  def yellow_on_white(text); end

  def yellow_on_yellow(text); end
  COLORS = ::T.let(nil, ::T.untyped)
end

module Pry::Helpers::Text
  extend ::Pry::Helpers::Text
end

module Pry::Helpers
  def self.tablify(things, line_length, pry_instance=T.unsafe(nil)); end

  def self.tablify_or_one_line(heading, things, pry_instance=T.unsafe(nil)); end

  def self.tablify_to_screen_width(things, options, pry_instance=T.unsafe(nil)); end
end

class Pry::History
  def <<(line); end

  def clear(); end

  def filter(history); end

  def history_line_count(); end

  def initialize(options=T.unsafe(nil)); end

  def load(); end

  def loader(); end

  def loader=(loader); end

  def original_lines(); end

  def push(line); end

  def saver(); end

  def saver=(saver); end

  def session_line_count(); end

  def to_a(); end
end

class Pry::History
  def self.default_file(); end
end

class Pry::Hooks
  def add_hook(event_name, hook_name, callable=T.unsafe(nil), &block); end

  def clear_event_hooks(event_name); end

  def delete_hook(event_name, hook_name); end

  def errors(); end

  def exec_hook(event_name, *args, &block); end

  def get_hook(event_name, hook_name); end

  def get_hooks(event_name); end

  def hook_count(event_name); end

  def hook_exists?(event_name, hook_name); end

  def hooks(); end

  def merge(other); end

  def merge!(other); end
end

class Pry::Hooks
  def self.default(); end
end

class Pry::Indent
  include ::Pry::Helpers::BaseHelpers
  def correct_indentation(prompt, code, overhang=T.unsafe(nil)); end

  def current_prefix(); end

  def end_of_statement?(last_token, last_kind); end

  def in_string?(); end

  def indent(input); end

  def indent_level(); end

  def indentation_delta(tokens); end

  def initialize(pry_instance=T.unsafe(nil)); end

  def module_nesting(); end

  def open_delimiters(); end

  def open_delimiters_line(); end

  def reset(); end

  def stack(); end

  def tokenize(string); end

  def track_delimiter(token); end

  def track_module_nesting(token, kind); end

  def track_module_nesting_end(token, kind=T.unsafe(nil)); end
  IGNORE_TOKENS = ::T.let(nil, ::T.untyped)
  MIDWAY_TOKENS = ::T.let(nil, ::T.untyped)
  OPEN_TOKENS = ::T.let(nil, ::T.untyped)
  OPTIONAL_DO_TOKENS = ::T.let(nil, ::T.untyped)
  SINGLELINE_TOKENS = ::T.let(nil, ::T.untyped)
  SPACES = ::T.let(nil, ::T.untyped)
  STATEMENT_END_TOKENS = ::T.let(nil, ::T.untyped)
end

class Pry::Indent::UnparseableNestingError
end

class Pry::Indent::UnparseableNestingError
end

class Pry::Indent
  def self.indent(str); end

  def self.nesting_at(str, line_number); end
end

class Pry::InputCompleter
  def build_path(input); end

  def call(str, options=T.unsafe(nil)); end

  def ignored_modules(); end

  def initialize(input, pry=T.unsafe(nil)); end

  def select_message(path, receiver, message, candidates); end
  ARRAY_REGEXP = ::T.let(nil, ::T.untyped)
  CONSTANT_OR_METHOD_REGEXP = ::T.let(nil, ::T.untyped)
  CONSTANT_REGEXP = ::T.let(nil, ::T.untyped)
  GLOBALVARIABLE_REGEXP = ::T.let(nil, ::T.untyped)
  HEX_REGEXP = ::T.let(nil, ::T.untyped)
  NUMERIC_REGEXP = ::T.let(nil, ::T.untyped)
  PROC_OR_HASH_REGEXP = ::T.let(nil, ::T.untyped)
  REGEX_REGEXP = ::T.let(nil, ::T.untyped)
  RESERVED_WORDS = ::T.let(nil, ::T.untyped)
  SYMBOL_METHOD_CALL_REGEXP = ::T.let(nil, ::T.untyped)
  SYMBOL_REGEXP = ::T.let(nil, ::T.untyped)
  TOPLEVEL_LOOKUP_REGEXP = ::T.let(nil, ::T.untyped)
  VARIABLE_REGEXP = ::T.let(nil, ::T.untyped)
  WORD_ESCAPE_STR = ::T.let(nil, ::T.untyped)
end

class Pry::InputCompleter
end

class Pry::InputLock
  def __with_ownership(); end

  def enter_interruptible_region(); end

  def interruptible_region(); end

  def leave_interruptible_region(); end

  def with_ownership(&block); end
end

class Pry::InputLock::Interrupt
end

class Pry::InputLock::Interrupt
end

class Pry::InputLock
  def self.for(input); end

  def self.global_lock(); end

  def self.global_lock=(global_lock); end

  def self.input_locks(); end

  def self.input_locks=(input_locks); end
end

class Pry::Inspector
  MAP = ::T.let(nil, ::T.untyped)
end

class Pry::Inspector
end

class Pry::LastException
  def bt_index(); end

  def bt_index=(bt_index); end

  def bt_source_location_for(index); end

  def file(); end

  def inc_bt_index(); end

  def initialize(exception); end

  def line(); end

  def method_missing(name, *args, &block); end

  def wrapped_exception(); end
end

class Pry::LastException
end

class Pry::Method
  include ::Pry::Helpers::BaseHelpers
  include ::Pry::Helpers::DocumentationHelpers
  include ::Pry::CodeObject::Helpers
  def ==(other); end

  def alias?(); end

  def aliases(); end

  def bound_method?(); end

  def comment(); end

  def doc(); end

  def dynamically_defined?(); end

  def initialize(method, known_info=T.unsafe(nil)); end

  def is_a?(klass); end

  def kind_of?(klass); end

  def method_missing(method_name, *args, &block); end

  def name(); end

  def name_with_owner(); end

  def original_name(); end

  def owner(*args, &block); end

  def parameters(*args, &block); end

  def pry_method?(); end

  def receiver(*args, &block); end

  def redefine(source); end

  def respond_to?(method_name, include_all=T.unsafe(nil)); end

  def signature(); end

  def singleton_method?(); end

  def source(); end

  def source?(); end

  def source_file(); end

  def source_line(); end

  def source_range(); end

  def source_type(); end

  def super(times=T.unsafe(nil)); end

  def unbound_method?(); end

  def undefined?(); end

  def visibility(); end

  def wrapped(); end

  def wrapped_owner(); end
end

class Pry::Method::Disowned
  def initialize(receiver, method_name); end

  def owner(); end

  def receiver(); end
end

class Pry::Method::Disowned
end

class Pry::Method::Patcher
  def initialize(method); end

  def method(); end

  def method=(method); end

  def patch_in_ram(source); end
end

class Pry::Method::Patcher
  def self.code_for(filename); end
end

class Pry::Method::WeirdMethodLocator
  def find_method(); end

  def initialize(method, target); end

  def lost_method?(); end

  def method(); end

  def method=(method); end

  def target(); end

  def target=(target); end
end

class Pry::Method::WeirdMethodLocator
  def self.normal_method?(method, binding); end

  def self.weird_method?(method, binding); end
end

class Pry::Method
  extend ::Pry::Helpers::BaseHelpers
  extend ::Pry::Forwardable
  extend ::Forwardable
  def self.all_from_class(klass, include_super=T.unsafe(nil)); end

  def self.all_from_obj(obj, include_super=T.unsafe(nil)); end

  def self.from_binding(binding); end

  def self.from_class(klass, name, target=T.unsafe(nil)); end

  def self.from_module(klass, name, target=T.unsafe(nil)); end

  def self.from_obj(obj, name, target=T.unsafe(nil)); end

  def self.from_str(name, target=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.instance_method_definition?(name, definition_line); end

  def self.instance_resolution_order(klass); end

  def self.lookup_method_via_binding(obj, method_name, method_type, target=T.unsafe(nil)); end

  def self.method_definition?(name, definition_line); end

  def self.resolution_order(obj); end

  def self.singleton_class_of(obj); end

  def self.singleton_class_resolution_order(klass); end

  def self.singleton_method_definition?(name, definition_line); end
end

class Pry::MethodNotFound
end

class Pry::MethodNotFound
end

class Pry::NoCommandError
  def initialize(match, owner); end
end

class Pry::NoCommandError
end

class Pry::ObjectPath
  def initialize(path_string, current_stack); end

  def resolve(); end
  SPECIAL_TERMS = ::T.let(nil, ::T.untyped)
end

class Pry::ObjectPath
end

class Pry::ObsoleteError
end

class Pry::ObsoleteError
end

class Pry::Output
  def <<(*objs); end

  def decolorize_maybe(str); end

  def height(); end

  def initialize(pry_instance); end

  def method_missing(method_name, *args, &block); end

  def print(*objs); end

  def pry_instance(); end

  def puts(*objs); end

  def size(); end

  def tty?(); end

  def width(); end

  def write(*objs); end
  DEFAULT_SIZE = ::T.let(nil, ::T.untyped)
end

class Pry::Output
end

class Pry::Pager
  def initialize(pry_instance); end

  def open(); end

  def page(text); end

  def pry_instance(); end
end

class Pry::Pager::NullPager
  def <<(str); end

  def close(); end

  def initialize(out); end

  def print(str); end

  def puts(str); end

  def write(str); end
end

class Pry::Pager::NullPager
end

class Pry::Pager::PageTracker
  def initialize(rows, cols); end

  def page?(); end

  def record(str); end

  def reset(); end
end

class Pry::Pager::PageTracker
end

class Pry::Pager::SimplePager
  def initialize(*_); end
end

class Pry::Pager::SimplePager
end

class Pry::Pager::StopPaging
end

class Pry::Pager::StopPaging
end

class Pry::Pager::SystemPager
  def initialize(*_); end
end

class Pry::Pager::SystemPager
  def self.available?(); end

  def self.default_pager(); end
end

class Pry::Pager
end

class Pry::PluginManager
  def load_plugins(); end

  def locate_plugins(); end

  def plugins(); end
  PRY_PLUGIN_PREFIX = ::T.let(nil, ::T.untyped)
end

class Pry::PluginManager::NoPlugin
  def initialize(name); end
end

class Pry::PluginManager::NoPlugin
end

class Pry::PluginManager::Plugin
  def activate!(); end

  def active(); end

  def active=(active); end

  def active?(); end

  def disable!(); end

  def enable!(); end

  def enabled(); end

  def enabled=(enabled); end

  def enabled?(); end

  def gem_name(); end

  def gem_name=(gem_name); end

  def initialize(name, gem_name, spec, enabled); end

  def load_cli_options(); end

  def name(); end

  def name=(name); end

  def spec(); end

  def spec=(spec); end

  def supported?(); end
end

class Pry::PluginManager::Plugin
end

class Pry::PluginManager
end

class Pry::Prompt
  def [](key); end

  def description(); end

  def incomplete_proc(); end

  def initialize(name, description, prompt_procs); end

  def name(); end

  def prompt_procs(); end

  def wait_proc(); end
end

class Pry::Prompt
  def self.[](name); end

  def self.add(name, description=T.unsafe(nil), separators=T.unsafe(nil)); end

  def self.all(); end
end

class Pry::REPL
  def initialize(pry, options=T.unsafe(nil)); end

  def input(*args, &block); end

  def output(*args, &block); end

  def pry(); end

  def pry=(pry); end

  def start(); end
end

class Pry::REPL
  extend ::Pry::Forwardable
  extend ::Forwardable
  def self.start(options); end
end

class Pry::REPLFileLoader
  def define_additional_commands(); end

  def initialize(file_name); end

  def interactive_mode(pry_instance); end

  def load(); end

  def non_interactive_mode(pry_instance, content); end
end

class Pry::REPLFileLoader
end

module Pry::RescuableException
end

module Pry::RescuableException
  def self.===(exception); end
end

class Pry::Result
  def command?(); end

  def initialize(is_command, retval=T.unsafe(nil)); end

  def retval(); end

  def void_command?(); end
end

class Pry::Result
end

class Pry::Ring
  def <<(value); end

  def [](index); end

  def clear(); end

  def count(); end

  def initialize(max_size); end

  def max_size(); end

  def size(); end

  def to_a(); end
end

class Pry::Ring
end

class Pry::Slop
  include ::Enumerable
  def [](key); end

  def add_callback(label, &block); end

  def banner(banner=T.unsafe(nil)); end

  def banner=(banner); end

  def command(command, options=T.unsafe(nil), &block); end

  def config(); end

  def description(desc=T.unsafe(nil)); end

  def description=(desc); end

  def each(&block); end

  def fetch_command(command); end

  def fetch_option(key); end

  def get(key); end

  def help(); end

  def initialize(config=T.unsafe(nil), &block); end

  def missing(); end

  def on(*objects, &block); end

  def opt(*objects, &block); end

  def option(*objects, &block); end

  def options(); end

  def parse(items=T.unsafe(nil), &block); end

  def parse!(items=T.unsafe(nil), &block); end

  def present?(*keys); end

  def run(callable=T.unsafe(nil), &block); end

  def separator(text); end

  def strict?(); end

  def to_h(include_commands=T.unsafe(nil)); end

  def to_hash(include_commands=T.unsafe(nil)); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Pry::Slop::Commands
  include ::Enumerable
  def [](key); end

  def arguments(); end

  def banner(banner=T.unsafe(nil)); end

  def banner=(banner); end

  def commands(); end

  def config(); end

  def default(config=T.unsafe(nil), &block); end

  def each(&block); end

  def get(key); end

  def global(config=T.unsafe(nil), &block); end

  def help(); end

  def initialize(config=T.unsafe(nil), &block); end

  def on(command, config=T.unsafe(nil), &block); end

  def parse(items=T.unsafe(nil)); end

  def parse!(items=T.unsafe(nil)); end

  def present?(key); end

  def to_hash(); end
end

class Pry::Slop::Commands
end

class Pry::Slop::Error
end

class Pry::Slop::Error
end

class Pry::Slop::InvalidArgumentError
end

class Pry::Slop::InvalidArgumentError
end

class Pry::Slop::InvalidCommandError
end

class Pry::Slop::InvalidCommandError
end

class Pry::Slop::InvalidOptionError
end

class Pry::Slop::InvalidOptionError
end

class Pry::Slop::MissingArgumentError
end

class Pry::Slop::MissingArgumentError
end

class Pry::Slop::MissingOptionError
end

class Pry::Slop::MissingOptionError
end

class Pry::Slop::Option
  def accepts_optional_argument?(); end

  def argument?(); end

  def argument_in_value(); end

  def argument_in_value=(argument_in_value); end

  def as?(); end

  def autocreated?(); end

  def call(*objects); end

  def callback?(); end

  def config(); end

  def count(); end

  def count=(count); end

  def default?(); end

  def delimiter?(); end

  def description(); end

  def expects_argument?(); end

  def help(); end

  def initialize(slop, short, long, description, config=T.unsafe(nil), &block); end

  def key(); end

  def limit?(); end

  def long(); end

  def match?(); end

  def optional?(); end

  def optional_argument?(); end

  def required?(); end

  def short(); end

  def tail?(); end

  def types(); end

  def value(); end

  def value=(new_value); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Pry::Slop::Option
end

class Pry::Slop
  def self.optspec(string, config=T.unsafe(nil)); end

  def self.parse(items=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def self.parse!(items=T.unsafe(nil), config=T.unsafe(nil), &block); end
end

class Pry::SyntaxHighlighter
end

class Pry::SyntaxHighlighter
  def self.highlight(code, language=T.unsafe(nil)); end

  def self.keyword_token_color(); end

  def self.overwrite_coderay_comment_token!(); end

  def self.tokenize(code, language=T.unsafe(nil)); end
end

module Pry::SystemCommandHandler
end

module Pry::SystemCommandHandler
  def self.default(output, command, _pry_instance); end
end

module Pry::TooSafeException
end

module Pry::TooSafeException
  def self.===(exception); end
end

module Pry::UserError
end

module Pry::UserError
end

module Pry::Warning
end

module Pry::Warning
  def self.warn(message); end
end

class Pry::WrappedModule
  include ::Pry::Helpers::BaseHelpers
  include ::Pry::CodeObject::Helpers
  def candidate(rank); end

  def candidates(); end

  def class?(); end

  def constants(inherit=T.unsafe(nil)); end

  def doc(); end

  def file(); end

  def initialize(mod); end

  def line(); end

  def method_missing(method_name, *args, &block); end

  def method_prefix(); end

  def module?(); end

  def nonblank_name(); end

  def number_of_candidates(); end

  def singleton_class?(); end

  def singleton_instance(); end

  def source(); end

  def source_file(); end

  def source_line(); end

  def source_location(); end

  def super(times=T.unsafe(nil)); end

  def wrapped(); end

  def yard_doc(); end

  def yard_docs?(); end

  def yard_file(); end

  def yard_line(); end
end

class Pry::WrappedModule::Candidate
  include ::Pry::Helpers::DocumentationHelpers
  include ::Pry::CodeObject::Helpers
  def class?(*args, &block); end

  def doc(); end

  def file(); end

  def initialize(wrapper, rank); end

  def line(); end

  def module?(*args, &block); end

  def nonblank_name(*args, &block); end

  def number_of_candidates(*args, &block); end

  def source(); end

  def source_file(); end

  def source_line(); end

  def source_location(); end

  def wrapped(*args, &block); end
end

class Pry::WrappedModule::Candidate
  extend ::Pry::Forwardable
  extend ::Forwardable
end

class Pry::WrappedModule
  def self.from_str(mod_name, target=T.unsafe(nil)); end
end

class Pry
  extend ::Pry::Forwardable
  extend ::Forwardable
  def self.Code(obj); end

  def self.Method(obj); end

  def self.WrappedModule(obj); end

  def self.auto_resize!(); end

  def self.binding_for(target); end

  def self.cli(); end

  def self.cli=(cli); end

  def self.color(*args, &block); end

  def self.color=(*args, &block); end

  def self.commands(*args, &block); end

  def self.commands=(*args, &block); end

  def self.config(); end

  def self.config=(config); end

  def self.configure(); end

  def self.critical_section(); end

  def self.current(); end

  def self.current_line(); end

  def self.current_line=(current_line); end

  def self.custom_completions(); end

  def self.custom_completions=(custom_completions); end

  def self.editor(*args, &block); end

  def self.editor=(*args, &block); end

  def self.eval_path(); end

  def self.eval_path=(eval_path); end

  def self.exception_handler(*args, &block); end

  def self.exception_handler=(*args, &block); end

  def self.extra_sticky_locals(*args, &block); end

  def self.extra_sticky_locals=(*args, &block); end

  def self.final_session_setup(); end

  def self.history(*args, &block); end

  def self.history=(*args, &block); end

  def self.hooks(*args, &block); end

  def self.hooks=(*args, &block); end

  def self.in_critical_section?(); end

  def self.init(); end

  def self.initial_session?(); end

  def self.initial_session_setup(); end

  def self.input(*args, &block); end

  def self.input=(*args, &block); end

  def self.last_internal_error(); end

  def self.last_internal_error=(last_internal_error); end

  def self.line_buffer(); end

  def self.line_buffer=(line_buffer); end

  def self.load_file_at_toplevel(file); end

  def self.load_file_through_repl(file_name); end

  def self.load_history(); end

  def self.load_plugins(*args, &block); end

  def self.load_rc_files(); end

  def self.load_requires(); end

  def self.load_traps(); end

  def self.load_win32console(); end

  def self.locate_plugins(*args, &block); end

  def self.main(); end

  def self.memory_size(*args, &block); end

  def self.memory_size=(*args, &block); end

  def self.output(*args, &block); end

  def self.output=(*args, &block); end

  def self.pager(*args, &block); end

  def self.pager=(*args, &block); end

  def self.plugins(*args, &block); end

  def self.print(*args, &block); end

  def self.print=(*args, &block); end

  def self.prompt(*args, &block); end

  def self.prompt=(*args, &block); end

  def self.quiet(); end

  def self.quiet=(quiet); end

  def self.rc_files_to_load(); end

  def self.real_path_to(file); end

  def self.reset_defaults(); end

  def self.run_command(command_string, options=T.unsafe(nil)); end

  def self.start(target=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.toplevel_binding(); end

  def self.toplevel_binding=(toplevel_binding); end

  def self.view_clip(obj, options=T.unsafe(nil)); end
end

module Psych
  VERSION = ::T.let(nil, ::T.untyped)
end

module Psych
  extend ::Bootsnap::CompileCache::YAML::Patch
  def self.add_builtin_type(type_tag, &block); end

  def self.add_domain_type(domain, type_tag, &block); end

  def self.add_tag(tag, klass); end

  def self.domain_types(); end

  def self.domain_types=(domain_types); end

  def self.dump_tags(); end

  def self.dump_tags=(dump_tags); end

  def self.libyaml_version(); end

  def self.load_tags(); end

  def self.load_tags=(load_tags); end

  def self.remove_type(type_tag); end
end

module Puma
  IS_JRUBY = ::T.let(nil, ::T.untyped)
  IS_WINDOWS = ::T.let(nil, ::T.untyped)
end

module Puma::ConfigDefault
  DefaultRackup = ::T.let(nil, ::T.untyped)
  DefaultTCPHost = ::T.let(nil, ::T.untyped)
  DefaultTCPPort = ::T.let(nil, ::T.untyped)
  DefaultWorkerShutdownTimeout = ::T.let(nil, ::T.untyped)
  DefaultWorkerTimeout = ::T.let(nil, ::T.untyped)
end

module Puma::ConfigDefault
end

class Puma::Configuration
  include ::Puma::ConfigDefault
  def app(); end

  def app_configured?(); end

  def clamp(); end

  def config_files(); end

  def configure(); end

  def environment(); end

  def environment_str(); end

  def flatten(); end

  def flatten!(); end

  def initialize(user_options=T.unsafe(nil), default_options=T.unsafe(nil), &block); end

  def load(); end

  def load_plugin(name); end

  def options(); end

  def plugins(); end

  def puma_default_options(); end

  def rackup(); end

  def run_hooks(key, arg); end
end

class Puma::Configuration::ConfigMiddleware
  def call(env); end

  def initialize(config, app); end
end

class Puma::Configuration::ConfigMiddleware
end

class Puma::Configuration
  def self.random_token(); end

  def self.temp_path(); end
end

class Puma::DSL
  include ::Puma::ConfigDefault
  def _load_from(path); end

  def _offer_plugins(); end

  def activate_control_app(url=T.unsafe(nil), opts=T.unsafe(nil)); end

  def after_worker_boot(&block); end

  def after_worker_fork(&block); end

  def app(obj=T.unsafe(nil), &block); end

  def before_fork(&block); end

  def bind(url); end

  def clean_thread_locals(which=T.unsafe(nil)); end

  def clear_binds!(); end

  def daemonize(which=T.unsafe(nil)); end

  def debug(); end

  def default_host(); end

  def directory(dir); end

  def drain_on_shutdown(which=T.unsafe(nil)); end

  def early_hints(answer=T.unsafe(nil)); end

  def environment(environment); end

  def first_data_timeout(seconds); end

  def force_shutdown_after(val=T.unsafe(nil)); end

  def get(key, default=T.unsafe(nil)); end

  def initialize(options, config); end

  def inject(&blk); end

  def load(file); end

  def log_requests(which=T.unsafe(nil)); end

  def lowlevel_error_handler(obj=T.unsafe(nil), &block); end

  def on_restart(&block); end

  def on_worker_boot(&block); end

  def on_worker_fork(&block); end

  def on_worker_shutdown(&block); end

  def persistent_timeout(seconds); end

  def pidfile(path); end

  def plugin(name); end

  def port(port, host=T.unsafe(nil)); end

  def preload_app!(answer=T.unsafe(nil)); end

  def prune_bundler(answer=T.unsafe(nil)); end

  def queue_requests(answer=T.unsafe(nil)); end

  def quiet(which=T.unsafe(nil)); end

  def rackup(path); end

  def restart_command(cmd); end

  def set_default_host(host); end

  def set_remote_address(val=T.unsafe(nil)); end

  def shutdown_debug(val=T.unsafe(nil)); end

  def ssl_bind(host, port, opts); end

  def state_path(path); end

  def stdout_redirect(stdout=T.unsafe(nil), stderr=T.unsafe(nil), append=T.unsafe(nil)); end

  def tag(string); end

  def tcp_mode(); end

  def tcp_mode!(); end

  def threads(min, max); end

  def worker_boot_timeout(timeout); end

  def worker_directory(dir); end

  def worker_shutdown_timeout(timeout); end

  def worker_timeout(timeout); end

  def workers(count); end
end

class Puma::DSL
end

class Puma::HttpParser
  def body(); end

  def error?(); end

  def execute(_, _1, _2); end

  def finish(); end

  def finished?(); end

  def nread(); end

  def reset(); end
end

class Puma::HttpParser
end

class Puma::HttpParserError
end

class Puma::HttpParserError
end

module Puma::Rack
end

class Puma::Rack::Builder
  def call(env); end

  def initialize(default_app=T.unsafe(nil), &block); end

  def map(path, &block); end

  def run(app); end

  def to_app(); end

  def use(middleware, *args, &block); end

  def warmup(prc=T.unsafe(nil), &block); end
end

class Puma::Rack::Builder
  def self.app(default_app=T.unsafe(nil), &block); end

  def self.new_from_string(builder_script, file=T.unsafe(nil)); end

  def self.parse_file(config, opts=T.unsafe(nil)); end
end

class Puma::Rack::Options
  def handler_opts(options); end

  def parse!(args); end
end

class Puma::Rack::Options
end

module Puma::Rack
end

class Puma::UserFileDefaultOptions
  def [](key); end

  def []=(key, value); end

  def all_of(key); end

  def default_options(); end

  def fetch(key, default_value=T.unsafe(nil)); end

  def file_options(); end

  def finalize_values(); end

  def initialize(user_options, default_options); end

  def user_options(); end
end

class Puma::UserFileDefaultOptions
end

module Puma
  def self.jruby?(); end

  def self.windows?(); end
end

class REXML::AttlistDecl
  def initialize(source); end
end

class REXML::Attribute
  def initialize(first, second=T.unsafe(nil), parent=T.unsafe(nil)); end
end

class REXML::Attributes
  def initialize(element); end
end

class REXML::CData
  def initialize(first, whitespace=T.unsafe(nil), parent=T.unsafe(nil)); end
end

class REXML::Child
  def initialize(parent=T.unsafe(nil)); end
end

class REXML::Comment
  def initialize(first, second=T.unsafe(nil)); end
end

class REXML::Declaration
  def initialize(src); end
end

class REXML::DocType
  def initialize(first, parent=T.unsafe(nil)); end
end

class REXML::Document
  def initialize(source=T.unsafe(nil), context=T.unsafe(nil)); end
end

class REXML::Element
  def initialize(arg=T.unsafe(nil), parent=T.unsafe(nil), context=T.unsafe(nil)); end
end

class REXML::Elements
  def initialize(parent); end
end

class REXML::Entity
  def initialize(stream, value=T.unsafe(nil), parent=T.unsafe(nil), reference=T.unsafe(nil)); end
end

class REXML::ExternalEntity
  def initialize(src); end
end

class REXML::Formatters::Default
  def initialize(ie_hack=T.unsafe(nil)); end
end

class REXML::Formatters::Pretty
  def initialize(indentation=T.unsafe(nil), ie_hack=T.unsafe(nil)); end
end

class REXML::IOSource
  def initialize(arg, block_size=T.unsafe(nil), encoding=T.unsafe(nil)); end
end

class REXML::Instruction
  def initialize(target, content=T.unsafe(nil)); end
end

class REXML::NotationDecl
  def initialize(name, middle, pub, sys); end
end

class REXML::Output
  def initialize(real_IO, encd=T.unsafe(nil)); end
end

class REXML::ParseException
  def initialize(message, source=T.unsafe(nil), parser=T.unsafe(nil), exception=T.unsafe(nil)); end
end

class REXML::Parsers::BaseParser
  def initialize(source); end
  QNAME = ::T.let(nil, ::T.untyped)
  QNAME_STR = ::T.let(nil, ::T.untyped)
end

class REXML::Parsers::StreamParser
  def initialize(source, listener); end
end

class REXML::Parsers::TreeParser
  def initialize(source, build_context=T.unsafe(nil)); end
end

class REXML::Parsers::XPathParser
  LOCAL_NAME_WILDCARD = ::T.let(nil, ::T.untyped)
  PREFIX_WILDCARD = ::T.let(nil, ::T.untyped)
end

class REXML::Source
  def initialize(arg, encoding=T.unsafe(nil)); end
end

class REXML::Text
  def initialize(arg, respect_whitespace=T.unsafe(nil), parent=T.unsafe(nil), raw=T.unsafe(nil), entity_filter=T.unsafe(nil), illegal=T.unsafe(nil)); end
end

class REXML::UndefinedNamespaceException
  def initialize(prefix, source, parser); end
end

class REXML::Validation::ValidationException
  def initialize(msg); end
end

class REXML::XMLDecl
  def initialize(version=T.unsafe(nil), encoding=T.unsafe(nil), standalone=T.unsafe(nil)); end
end

class REXML::XPath
  def self.match(element, path=T.unsafe(nil), namespaces=T.unsafe(nil), variables=T.unsafe(nil), options=T.unsafe(nil)); end
end

class REXML::XPathNode
  def context(); end

  def initialize(node, context=T.unsafe(nil)); end

  def position(); end

  def raw_node(); end
end

class REXML::XPathNode
end

class REXML::XPathParser
  def initialize(strict: T.unsafe(nil)); end
  DEBUG = ::T.let(nil, ::T.untyped)
end

module Racc
  Racc_No_Extensions = ::T.let(nil, ::T.untyped)
end

class Racc::CparseParams
end

class Racc::CparseParams
end

class Racc::Parser
  Racc_Main_Parsing_Routine = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Id_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Type = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Version = ::T.let(nil, ::T.untyped)
  Racc_YY_Parse_Method = ::T.let(nil, ::T.untyped)
end

class Rack::Request
  def query(); end

  def version_supplied(); end

  def version_supplied=(version_supplied); end
end

class Rake::TaskLib
  include ::Rake::Cloneable
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

class Random
  def self.bytes(_); end
end

class Range
  def %(_); end

  def entries(); end

  def to_a(); end
end

module RbConfig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.fire_update!(key, val, mkconf=T.unsafe(nil), conf=T.unsafe(nil)); end

  def self.ruby(); end
end

module Readline
  def self.completion_quote_character(); end
end

class Regexp
  def bson_type(); end
  TOKEN_KEYS = ::T.let(nil, ::T.untyped)
end

module Regexp::Expression
end

class Regexp::Expression::Alternation
  def alternatives(); end
end

Regexp::Expression::Alternation::OPERAND = Regexp::Expression::Alternative

class Regexp::Expression::Alternation
end

class Regexp::Expression::Alternative
end

class Regexp::Expression::Alternative
end

module Regexp::Expression::Anchor
end

Regexp::Expression::Anchor::BOL = Regexp::Expression::Anchor::BeginningOfLine

Regexp::Expression::Anchor::BOS = Regexp::Expression::Anchor::BeginningOfString

class Regexp::Expression::Anchor::Base
  def match_length(); end
end

class Regexp::Expression::Anchor::Base
end

class Regexp::Expression::Anchor::BeginningOfLine
end

class Regexp::Expression::Anchor::BeginningOfLine
end

class Regexp::Expression::Anchor::BeginningOfString
end

class Regexp::Expression::Anchor::BeginningOfString
end

Regexp::Expression::Anchor::EOL = Regexp::Expression::Anchor::EndOfLine

Regexp::Expression::Anchor::EOS = Regexp::Expression::Anchor::EndOfString

Regexp::Expression::Anchor::EOSobEOL = Regexp::Expression::Anchor::EndOfStringOrBeforeEndOfLine

class Regexp::Expression::Anchor::EndOfLine
end

class Regexp::Expression::Anchor::EndOfLine
end

class Regexp::Expression::Anchor::EndOfString
end

class Regexp::Expression::Anchor::EndOfString
end

class Regexp::Expression::Anchor::EndOfStringOrBeforeEndOfLine
end

class Regexp::Expression::Anchor::EndOfStringOrBeforeEndOfLine
end

class Regexp::Expression::Anchor::MatchStart
end

class Regexp::Expression::Anchor::MatchStart
end

class Regexp::Expression::Anchor::NonWordBoundary
end

class Regexp::Expression::Anchor::NonWordBoundary
end

class Regexp::Expression::Anchor::WordBoundary
end

class Regexp::Expression::Anchor::WordBoundary
end

module Regexp::Expression::Anchor
end

module Regexp::Expression::Assertion
end

class Regexp::Expression::Assertion::Base
end

class Regexp::Expression::Assertion::Base
end

class Regexp::Expression::Assertion::Lookahead
end

class Regexp::Expression::Assertion::Lookahead
end

class Regexp::Expression::Assertion::Lookbehind
end

class Regexp::Expression::Assertion::Lookbehind
end

class Regexp::Expression::Assertion::NegativeLookahead
end

class Regexp::Expression::Assertion::NegativeLookahead
end

class Regexp::Expression::Assertion::NegativeLookbehind
end

class Regexp::Expression::Assertion::NegativeLookbehind
end

module Regexp::Expression::Assertion
end

module Regexp::Expression::Backreference
end

class Regexp::Expression::Backreference::Base
  def match_length(); end

  def referenced_expression(); end

  def referenced_expression=(referenced_expression); end
end

class Regexp::Expression::Backreference::Base
end

class Regexp::Expression::Backreference::Name
  def name(); end

  def reference(); end
end

class Regexp::Expression::Backreference::Name
end

class Regexp::Expression::Backreference::NameCall
end

class Regexp::Expression::Backreference::NameCall
end

class Regexp::Expression::Backreference::NameRecursionLevel
  def recursion_level(); end
end

class Regexp::Expression::Backreference::NameRecursionLevel
end

class Regexp::Expression::Backreference::Number
  def number(); end

  def reference(); end
end

class Regexp::Expression::Backreference::Number
end

class Regexp::Expression::Backreference::NumberCall
end

class Regexp::Expression::Backreference::NumberCall
end

class Regexp::Expression::Backreference::NumberCallRelative
end

class Regexp::Expression::Backreference::NumberCallRelative
end

class Regexp::Expression::Backreference::NumberRecursionLevel
  def recursion_level(); end
end

class Regexp::Expression::Backreference::NumberRecursionLevel
end

class Regexp::Expression::Backreference::NumberRelative
  def effective_number(); end

  def effective_number=(effective_number); end
end

class Regexp::Expression::Backreference::NumberRelative
end

module Regexp::Expression::Backreference
end

class Regexp::Expression::Base
  include ::RuboCop::Ext::RegexpParser::Expression::Base
  def =~(string, offset=T.unsafe(nil)); end

  def a?(); end

  def ascii_classes?(); end

  def attributes(); end

  def base_length(); end

  def case_insensitive?(); end

  def coded_offset(); end

  def conditional_level(); end

  def conditional_level=(conditional_level); end

  def d?(); end

  def default_classes?(); end

  def extended?(); end

  def free_spacing?(); end

  def full_length(); end

  def greedy?(); end

  def i?(); end

  def ignore_case?(); end

  def initialize(token, options=T.unsafe(nil)); end

  def is?(test_token, test_type=T.unsafe(nil)); end

  def lazy?(); end

  def level(); end

  def level=(level); end

  def m?(); end

  def match(string, offset=T.unsafe(nil)); end

  def match?(string); end

  def matches?(string); end

  def multiline?(); end

  def nesting_level(); end

  def nesting_level=(nesting_level); end

  def offset(); end

  def one_of?(scope, top=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def possessive?(); end

  def quantified?(); end

  def quantifier(); end

  def quantifier=(quantifier); end

  def quantifier_affix(expression_format); end

  def quantify(token, text, min=T.unsafe(nil), max=T.unsafe(nil), mode=T.unsafe(nil)); end

  def quantity(); end

  def reluctant?(); end

  def repetitions(); end

  def set_level(); end

  def set_level=(set_level); end

  def starts_at(); end

  def strfre(format=T.unsafe(nil), indent_offset=T.unsafe(nil), index=T.unsafe(nil)); end

  def strfregexp(format=T.unsafe(nil), indent_offset=T.unsafe(nil), index=T.unsafe(nil)); end

  def terminal?(); end

  def text(); end

  def text=(text); end

  def to_h(); end

  def to_re(format=T.unsafe(nil)); end

  def to_s(format=T.unsafe(nil)); end

  def token(); end

  def token=(token); end

  def ts(); end

  def ts=(ts); end

  def type(); end

  def type=(type); end

  def type?(test_type); end

  def u?(); end

  def unicode_classes?(); end

  def unquantified_clone(); end

  def x?(); end
end

class Regexp::Expression::Base
end

class Regexp::Expression::CharacterSet
  include ::RuboCop::Ext::RegexpParser::Expression::CharacterSet
  def close(); end

  def closed(); end

  def closed=(closed); end

  def closed?(); end

  def negate(); end

  def negated?(); end

  def negative(); end

  def negative=(negative); end

  def negative?(); end
end

class Regexp::Expression::CharacterSet::IntersectedSequence
end

class Regexp::Expression::CharacterSet::IntersectedSequence
end

class Regexp::Expression::CharacterSet::Intersection
end

Regexp::Expression::CharacterSet::Intersection::OPERAND = Regexp::Expression::CharacterSet::IntersectedSequence

class Regexp::Expression::CharacterSet::Intersection
end

class Regexp::Expression::CharacterSet::Range
  def complete?(); end

  def to_s(_format=T.unsafe(nil)); end
end

class Regexp::Expression::CharacterSet::Range
end

class Regexp::Expression::CharacterSet
end

module Regexp::Expression::CharacterType
end

class Regexp::Expression::CharacterType::Any
end

class Regexp::Expression::CharacterType::Any
end

class Regexp::Expression::CharacterType::Base
  def match_length(); end
end

class Regexp::Expression::CharacterType::Base
end

class Regexp::Expression::CharacterType::Digit
end

class Regexp::Expression::CharacterType::Digit
end

class Regexp::Expression::CharacterType::ExtendedGrapheme
end

class Regexp::Expression::CharacterType::ExtendedGrapheme
end

class Regexp::Expression::CharacterType::Hex
end

class Regexp::Expression::CharacterType::Hex
end

class Regexp::Expression::CharacterType::Linebreak
end

class Regexp::Expression::CharacterType::Linebreak
end

class Regexp::Expression::CharacterType::NonDigit
end

class Regexp::Expression::CharacterType::NonDigit
end

class Regexp::Expression::CharacterType::NonHex
end

class Regexp::Expression::CharacterType::NonHex
end

class Regexp::Expression::CharacterType::NonSpace
end

class Regexp::Expression::CharacterType::NonSpace
end

class Regexp::Expression::CharacterType::NonWord
end

class Regexp::Expression::CharacterType::NonWord
end

class Regexp::Expression::CharacterType::Space
end

class Regexp::Expression::CharacterType::Space
end

class Regexp::Expression::CharacterType::Word
end

class Regexp::Expression::CharacterType::Word
end

module Regexp::Expression::CharacterType
end

class Regexp::Expression::Comment
end

class Regexp::Expression::Comment
end

module Regexp::Expression::Conditional
end

class Regexp::Expression::Conditional::Branch
end

class Regexp::Expression::Conditional::Branch
end

class Regexp::Expression::Conditional::Condition
  def match_length(); end

  def reference(); end

  def referenced_expression(); end

  def referenced_expression=(referenced_expression); end
end

class Regexp::Expression::Conditional::Condition
end

class Regexp::Expression::Conditional::Expression
  def add_sequence(active_opts=T.unsafe(nil)); end

  def branch(active_opts=T.unsafe(nil)); end

  def branches(); end

  def condition(); end

  def condition=(exp); end

  def reference(); end

  def referenced_expression(); end

  def referenced_expression=(referenced_expression); end
end

class Regexp::Expression::Conditional::Expression
end

class Regexp::Expression::Conditional::TooManyBranches
  def initialize(); end
end

class Regexp::Expression::Conditional::TooManyBranches
end

module Regexp::Expression::Conditional
end

module Regexp::Expression::EscapeSequence
end

class Regexp::Expression::EscapeSequence::AbstractMetaControlSequence
end

class Regexp::Expression::EscapeSequence::AbstractMetaControlSequence
end

class Regexp::Expression::EscapeSequence::AsciiEscape
end

class Regexp::Expression::EscapeSequence::AsciiEscape
end

class Regexp::Expression::EscapeSequence::Backspace
end

class Regexp::Expression::EscapeSequence::Backspace
end

class Regexp::Expression::EscapeSequence::Base
  def char(); end

  def codepoint(); end

  def match_length(); end
end

class Regexp::Expression::EscapeSequence::Base
end

class Regexp::Expression::EscapeSequence::Bell
end

class Regexp::Expression::EscapeSequence::Bell
end

class Regexp::Expression::EscapeSequence::Codepoint
end

class Regexp::Expression::EscapeSequence::Codepoint
end

class Regexp::Expression::EscapeSequence::CodepointList
  def chars(); end

  def codepoints(); end
end

class Regexp::Expression::EscapeSequence::CodepointList
end

class Regexp::Expression::EscapeSequence::Control
end

class Regexp::Expression::EscapeSequence::Control
end

class Regexp::Expression::EscapeSequence::FormFeed
end

class Regexp::Expression::EscapeSequence::FormFeed
end

class Regexp::Expression::EscapeSequence::Hex
end

class Regexp::Expression::EscapeSequence::Hex
end

class Regexp::Expression::EscapeSequence::Literal
end

class Regexp::Expression::EscapeSequence::Literal
end

class Regexp::Expression::EscapeSequence::Meta
end

class Regexp::Expression::EscapeSequence::Meta
end

class Regexp::Expression::EscapeSequence::MetaControl
end

class Regexp::Expression::EscapeSequence::MetaControl
end

class Regexp::Expression::EscapeSequence::Newline
end

class Regexp::Expression::EscapeSequence::Newline
end

class Regexp::Expression::EscapeSequence::Octal
end

class Regexp::Expression::EscapeSequence::Octal
end

class Regexp::Expression::EscapeSequence::Return
end

class Regexp::Expression::EscapeSequence::Return
end

class Regexp::Expression::EscapeSequence::Tab
end

class Regexp::Expression::EscapeSequence::Tab
end

class Regexp::Expression::EscapeSequence::VerticalTab
end

class Regexp::Expression::EscapeSequence::VerticalTab
end

module Regexp::Expression::EscapeSequence
end

class Regexp::Expression::FreeSpace
  def match_length(); end
end

class Regexp::Expression::FreeSpace
end

module Regexp::Expression::Group
end

class Regexp::Expression::Group::Absence
end

class Regexp::Expression::Group::Absence
end

class Regexp::Expression::Group::Atomic
end

class Regexp::Expression::Group::Atomic
end

class Regexp::Expression::Group::Base
  def capturing?(); end

  def comment?(); end
end

class Regexp::Expression::Group::Base
end

class Regexp::Expression::Group::Capture
  def identifier(); end

  def number(); end

  def number=(number); end

  def number_at_level(); end

  def number_at_level=(number_at_level); end
end

class Regexp::Expression::Group::Capture
end

class Regexp::Expression::Group::Comment
  def to_s(_format=T.unsafe(nil)); end
end

class Regexp::Expression::Group::Comment
end

class Regexp::Expression::Group::Named
  def name(); end
end

class Regexp::Expression::Group::Named
end

class Regexp::Expression::Group::Options
  def option_changes(); end

  def option_changes=(option_changes); end
end

class Regexp::Expression::Group::Options
end

class Regexp::Expression::Group::Passive
  def implicit=(implicit); end

  def implicit?(); end
end

class Regexp::Expression::Group::Passive
end

module Regexp::Expression::Group
end

module Regexp::Expression::Keep
end

class Regexp::Expression::Keep::Mark
  def match_length(); end
end

class Regexp::Expression::Keep::Mark
end

module Regexp::Expression::Keep
end

class Regexp::Expression::Literal
  def match_length(); end
end

class Regexp::Expression::Literal
end

Regexp::Expression::MatchLength = Regexp::MatchLength

class Regexp::Expression::PosixClass
  def match_length(); end

  def name(); end

  def negative?(); end
end

class Regexp::Expression::PosixClass
end

class Regexp::Expression::Quantifier
  def ==(other); end

  def eq(other); end

  def greedy?(); end

  def initialize(token, text, min, max, mode); end

  def lazy?(); end

  def max(); end

  def min(); end

  def mode(); end

  def possessive?(); end

  def reluctant?(); end

  def text(); end

  def to_h(); end

  def to_str(); end

  def token(); end
  MODES = ::T.let(nil, ::T.untyped)
end

class Regexp::Expression::Quantifier
end

class Regexp::Expression::Root
end

class Regexp::Expression::Root
  def self.build(options=T.unsafe(nil)); end

  def self.build_token(); end
end

class Regexp::Expression::Sequence
end

class Regexp::Expression::Sequence
  def self.add_to(subexpression, params=T.unsafe(nil), active_opts=T.unsafe(nil)); end

  def self.at_levels(level, set_level, conditional_level); end
end

class Regexp::Expression::SequenceOperation
  def add_sequence(active_opts=T.unsafe(nil)); end

  def operands(); end

  def operator(); end

  def sequences(); end
end

class Regexp::Expression::SequenceOperation
end

class Regexp::Expression::Subexpression
  include ::Enumerable
  def <<(exp); end

  def [](*args, &block); end

  def at(*args, &block); end

  def dig(*indices); end

  def each(*args, &block); end

  def each_expression(include_self=T.unsafe(nil), &block); end

  def empty?(*args, &block); end

  def expressions(); end

  def expressions=(expressions); end

  def fetch(*args, &block); end

  def flat_map(include_self=T.unsafe(nil), &block); end

  def index(*args, &block); end

  def inner_match_length(); end

  def join(*args, &block); end

  def last(*args, &block); end

  def length(*args, &block); end

  def match_length(); end

  def strfre_tree(format=T.unsafe(nil), include_self=T.unsafe(nil), separator=T.unsafe(nil)); end

  def strfregexp_tree(format=T.unsafe(nil), include_self=T.unsafe(nil), separator=T.unsafe(nil)); end

  def te(); end

  def to_h(); end

  def traverse(include_self=T.unsafe(nil), &block); end

  def values_at(*args, &block); end

  def walk(include_self=T.unsafe(nil), &block); end
end

class Regexp::Expression::Subexpression
end

module Regexp::Expression::UnicodeProperty
end

class Regexp::Expression::UnicodeProperty::Age
end

class Regexp::Expression::UnicodeProperty::Age
end

class Regexp::Expression::UnicodeProperty::Alnum
end

class Regexp::Expression::UnicodeProperty::Alnum
end

class Regexp::Expression::UnicodeProperty::Alpha
end

class Regexp::Expression::UnicodeProperty::Alpha
end

class Regexp::Expression::UnicodeProperty::Any
end

class Regexp::Expression::UnicodeProperty::Any
end

class Regexp::Expression::UnicodeProperty::Ascii
end

class Regexp::Expression::UnicodeProperty::Ascii
end

class Regexp::Expression::UnicodeProperty::Assigned
end

class Regexp::Expression::UnicodeProperty::Assigned
end

class Regexp::Expression::UnicodeProperty::Base
  def match_length(); end

  def name(); end

  def negative?(); end

  def shortcut(); end
end

class Regexp::Expression::UnicodeProperty::Base
end

class Regexp::Expression::UnicodeProperty::Blank
end

class Regexp::Expression::UnicodeProperty::Blank
end

class Regexp::Expression::UnicodeProperty::Block
end

class Regexp::Expression::UnicodeProperty::Block
end

class Regexp::Expression::UnicodeProperty::Cntrl
end

class Regexp::Expression::UnicodeProperty::Cntrl
end

module Regexp::Expression::UnicodeProperty::Codepoint
end

class Regexp::Expression::UnicodeProperty::Codepoint::Any
end

class Regexp::Expression::UnicodeProperty::Codepoint::Any
end

class Regexp::Expression::UnicodeProperty::Codepoint::Base
end

class Regexp::Expression::UnicodeProperty::Codepoint::Base
end

class Regexp::Expression::UnicodeProperty::Codepoint::Control
end

class Regexp::Expression::UnicodeProperty::Codepoint::Control
end

class Regexp::Expression::UnicodeProperty::Codepoint::Format
end

class Regexp::Expression::UnicodeProperty::Codepoint::Format
end

class Regexp::Expression::UnicodeProperty::Codepoint::PrivateUse
end

class Regexp::Expression::UnicodeProperty::Codepoint::PrivateUse
end

class Regexp::Expression::UnicodeProperty::Codepoint::Surrogate
end

class Regexp::Expression::UnicodeProperty::Codepoint::Surrogate
end

class Regexp::Expression::UnicodeProperty::Codepoint::Unassigned
end

class Regexp::Expression::UnicodeProperty::Codepoint::Unassigned
end

module Regexp::Expression::UnicodeProperty::Codepoint
end

class Regexp::Expression::UnicodeProperty::Derived
end

class Regexp::Expression::UnicodeProperty::Derived
end

class Regexp::Expression::UnicodeProperty::Digit
end

class Regexp::Expression::UnicodeProperty::Digit
end

class Regexp::Expression::UnicodeProperty::Emoji
end

class Regexp::Expression::UnicodeProperty::Emoji
end

class Regexp::Expression::UnicodeProperty::Graph
end

class Regexp::Expression::UnicodeProperty::Graph
end

module Regexp::Expression::UnicodeProperty::Letter
end

class Regexp::Expression::UnicodeProperty::Letter::Any
end

class Regexp::Expression::UnicodeProperty::Letter::Any
end

class Regexp::Expression::UnicodeProperty::Letter::Base
end

class Regexp::Expression::UnicodeProperty::Letter::Base
end

class Regexp::Expression::UnicodeProperty::Letter::Cased
end

class Regexp::Expression::UnicodeProperty::Letter::Cased
end

class Regexp::Expression::UnicodeProperty::Letter::Lowercase
end

class Regexp::Expression::UnicodeProperty::Letter::Lowercase
end

class Regexp::Expression::UnicodeProperty::Letter::Modifier
end

class Regexp::Expression::UnicodeProperty::Letter::Modifier
end

class Regexp::Expression::UnicodeProperty::Letter::Other
end

class Regexp::Expression::UnicodeProperty::Letter::Other
end

class Regexp::Expression::UnicodeProperty::Letter::Titlecase
end

class Regexp::Expression::UnicodeProperty::Letter::Titlecase
end

class Regexp::Expression::UnicodeProperty::Letter::Uppercase
end

class Regexp::Expression::UnicodeProperty::Letter::Uppercase
end

module Regexp::Expression::UnicodeProperty::Letter
end

class Regexp::Expression::UnicodeProperty::Lower
end

class Regexp::Expression::UnicodeProperty::Lower
end

module Regexp::Expression::UnicodeProperty::Mark
end

class Regexp::Expression::UnicodeProperty::Mark::Any
end

class Regexp::Expression::UnicodeProperty::Mark::Any
end

class Regexp::Expression::UnicodeProperty::Mark::Base
end

class Regexp::Expression::UnicodeProperty::Mark::Base
end

class Regexp::Expression::UnicodeProperty::Mark::Combining
end

class Regexp::Expression::UnicodeProperty::Mark::Combining
end

class Regexp::Expression::UnicodeProperty::Mark::Enclosing
end

class Regexp::Expression::UnicodeProperty::Mark::Enclosing
end

class Regexp::Expression::UnicodeProperty::Mark::Nonspacing
end

class Regexp::Expression::UnicodeProperty::Mark::Nonspacing
end

class Regexp::Expression::UnicodeProperty::Mark::Spacing
end

class Regexp::Expression::UnicodeProperty::Mark::Spacing
end

module Regexp::Expression::UnicodeProperty::Mark
end

class Regexp::Expression::UnicodeProperty::Newline
end

class Regexp::Expression::UnicodeProperty::Newline
end

module Regexp::Expression::UnicodeProperty::Number
end

class Regexp::Expression::UnicodeProperty::Number::Any
end

class Regexp::Expression::UnicodeProperty::Number::Any
end

class Regexp::Expression::UnicodeProperty::Number::Base
end

class Regexp::Expression::UnicodeProperty::Number::Base
end

class Regexp::Expression::UnicodeProperty::Number::Decimal
end

class Regexp::Expression::UnicodeProperty::Number::Decimal
end

class Regexp::Expression::UnicodeProperty::Number::Letter
end

class Regexp::Expression::UnicodeProperty::Number::Letter
end

class Regexp::Expression::UnicodeProperty::Number::Other
end

class Regexp::Expression::UnicodeProperty::Number::Other
end

module Regexp::Expression::UnicodeProperty::Number
end

class Regexp::Expression::UnicodeProperty::Print
end

class Regexp::Expression::UnicodeProperty::Print
end

class Regexp::Expression::UnicodeProperty::Punct
end

class Regexp::Expression::UnicodeProperty::Punct
end

module Regexp::Expression::UnicodeProperty::Punctuation
end

class Regexp::Expression::UnicodeProperty::Punctuation::Any
end

class Regexp::Expression::UnicodeProperty::Punctuation::Any
end

class Regexp::Expression::UnicodeProperty::Punctuation::Base
end

class Regexp::Expression::UnicodeProperty::Punctuation::Base
end

class Regexp::Expression::UnicodeProperty::Punctuation::Close
end

class Regexp::Expression::UnicodeProperty::Punctuation::Close
end

class Regexp::Expression::UnicodeProperty::Punctuation::Connector
end

class Regexp::Expression::UnicodeProperty::Punctuation::Connector
end

class Regexp::Expression::UnicodeProperty::Punctuation::Dash
end

class Regexp::Expression::UnicodeProperty::Punctuation::Dash
end

class Regexp::Expression::UnicodeProperty::Punctuation::Final
end

class Regexp::Expression::UnicodeProperty::Punctuation::Final
end

class Regexp::Expression::UnicodeProperty::Punctuation::Initial
end

class Regexp::Expression::UnicodeProperty::Punctuation::Initial
end

class Regexp::Expression::UnicodeProperty::Punctuation::Open
end

class Regexp::Expression::UnicodeProperty::Punctuation::Open
end

class Regexp::Expression::UnicodeProperty::Punctuation::Other
end

class Regexp::Expression::UnicodeProperty::Punctuation::Other
end

module Regexp::Expression::UnicodeProperty::Punctuation
end

class Regexp::Expression::UnicodeProperty::Script
end

class Regexp::Expression::UnicodeProperty::Script
end

module Regexp::Expression::UnicodeProperty::Separator
end

class Regexp::Expression::UnicodeProperty::Separator::Any
end

class Regexp::Expression::UnicodeProperty::Separator::Any
end

class Regexp::Expression::UnicodeProperty::Separator::Base
end

class Regexp::Expression::UnicodeProperty::Separator::Base
end

class Regexp::Expression::UnicodeProperty::Separator::Line
end

class Regexp::Expression::UnicodeProperty::Separator::Line
end

class Regexp::Expression::UnicodeProperty::Separator::Paragraph
end

class Regexp::Expression::UnicodeProperty::Separator::Paragraph
end

class Regexp::Expression::UnicodeProperty::Separator::Space
end

class Regexp::Expression::UnicodeProperty::Separator::Space
end

module Regexp::Expression::UnicodeProperty::Separator
end

class Regexp::Expression::UnicodeProperty::Space
end

class Regexp::Expression::UnicodeProperty::Space
end

module Regexp::Expression::UnicodeProperty::Symbol
end

class Regexp::Expression::UnicodeProperty::Symbol::Any
end

class Regexp::Expression::UnicodeProperty::Symbol::Any
end

class Regexp::Expression::UnicodeProperty::Symbol::Base
end

class Regexp::Expression::UnicodeProperty::Symbol::Base
end

class Regexp::Expression::UnicodeProperty::Symbol::Currency
end

class Regexp::Expression::UnicodeProperty::Symbol::Currency
end

class Regexp::Expression::UnicodeProperty::Symbol::Math
end

class Regexp::Expression::UnicodeProperty::Symbol::Math
end

class Regexp::Expression::UnicodeProperty::Symbol::Modifier
end

class Regexp::Expression::UnicodeProperty::Symbol::Modifier
end

class Regexp::Expression::UnicodeProperty::Symbol::Other
end

class Regexp::Expression::UnicodeProperty::Symbol::Other
end

module Regexp::Expression::UnicodeProperty::Symbol
end

class Regexp::Expression::UnicodeProperty::Upper
end

class Regexp::Expression::UnicodeProperty::Upper
end

class Regexp::Expression::UnicodeProperty::Word
end

class Regexp::Expression::UnicodeProperty::Word
end

class Regexp::Expression::UnicodeProperty::XPosixPunct
end

class Regexp::Expression::UnicodeProperty::XPosixPunct
end

class Regexp::Expression::UnicodeProperty::Xdigit
end

class Regexp::Expression::UnicodeProperty::Xdigit
end

module Regexp::Expression::UnicodeProperty
end

class Regexp::Expression::WhiteSpace
  def merge(exp); end
end

class Regexp::Expression::WhiteSpace
end

module Regexp::Expression
end

class Regexp::Lexer
  def lex(input, syntax=T.unsafe(nil), options: T.unsafe(nil), &block); end
  CLOSING_TOKENS = ::T.let(nil, ::T.untyped)
  OPENING_TOKENS = ::T.let(nil, ::T.untyped)
end

class Regexp::Lexer
  def self.lex(input, syntax=T.unsafe(nil), options: T.unsafe(nil), &block); end

  def self.scan(input, syntax=T.unsafe(nil), options: T.unsafe(nil), &block); end
end

class Regexp::MatchLength
  include ::Enumerable
  def each(opts=T.unsafe(nil), &blk); end

  def endless_each(&block); end

  def fixed?(); end

  def include?(length); end

  def initialize(exp, opts=T.unsafe(nil)); end

  def max(); end

  def min(); end

  def to_re(); end
end

class Regexp::MatchLength
  def self.of(obj); end
end

class Regexp::Parser
  include ::Regexp::Expression
  include ::Regexp::Syntax
  include ::Regexp::Expression::UnicodeProperty
  def parse(input, syntax=T.unsafe(nil), options: T.unsafe(nil), &block); end
  ENC_FLAGS = ::T.let(nil, ::T.untyped)
  MOD_FLAGS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Regexp::Parser::ParserError
end

class Regexp::Parser::ParserError
end

class Regexp::Parser::UnknownTokenError
  def initialize(type, token); end
end

class Regexp::Parser::UnknownTokenError
end

class Regexp::Parser::UnknownTokenTypeError
  def initialize(type, token); end
end

class Regexp::Parser::UnknownTokenTypeError
end

class Regexp::Parser
  def self.parse(input, syntax=T.unsafe(nil), options: T.unsafe(nil), &block); end
end

class Regexp::Scanner
  def emit(type, token, text); end

  def scan(input_object, options: T.unsafe(nil), &block); end
  PROP_MAPS_DIR = ::T.let(nil, ::T.untyped)
end

class Regexp::Scanner::InvalidBackrefError
  def initialize(what, reason); end
end

class Regexp::Scanner::InvalidBackrefError
end

class Regexp::Scanner::InvalidGroupError
  def initialize(what, reason); end
end

class Regexp::Scanner::InvalidGroupError
end

class Regexp::Scanner::InvalidGroupOption
  def initialize(option, text); end
end

class Regexp::Scanner::InvalidGroupOption
end

class Regexp::Scanner::InvalidSequenceError
  def initialize(what=T.unsafe(nil), where=T.unsafe(nil)); end
end

class Regexp::Scanner::InvalidSequenceError
end

class Regexp::Scanner::PrematureEndError
  def initialize(where=T.unsafe(nil)); end
end

class Regexp::Scanner::PrematureEndError
end

class Regexp::Scanner::ScannerError
end

class Regexp::Scanner::ScannerError
end

class Regexp::Scanner::UnknownUnicodePropertyError
  def initialize(name); end
end

class Regexp::Scanner::UnknownUnicodePropertyError
end

class Regexp::Scanner::ValidationError
  def initialize(reason); end
end

class Regexp::Scanner::ValidationError
end

class Regexp::Scanner
  def self.long_prop_map(); end

  def self.scan(input_object, options: T.unsafe(nil), &block); end

  def self.short_prop_map(); end
end

module Regexp::Syntax
  VERSION_CONST_REGEXP = ::T.let(nil, ::T.untyped)
  VERSION_FORMAT = ::T.let(nil, ::T.untyped)
  VERSION_REGEXP = ::T.let(nil, ::T.untyped)
end

class Regexp::Syntax::Any
end

class Regexp::Syntax::Any
end

class Regexp::Syntax::Base
  include ::Regexp::Syntax::Token
  def check!(type, token); end

  def check?(type, token); end

  def excludes(type, tokens); end

  def features(); end

  def implementations(type); end

  def implements(type, tokens); end

  def implements!(type, token); end

  def implements?(type, token); end

  def normalize(type, token); end

  def normalize_backref(type, token); end

  def normalize_group(type, token); end
end

class Regexp::Syntax::Base
end

class Regexp::Syntax::InvalidVersionNameError
  def initialize(name); end
end

class Regexp::Syntax::InvalidVersionNameError
end

class Regexp::Syntax::NotImplementedError
  def initialize(syntax, type, token); end
end

class Regexp::Syntax::NotImplementedError
end

class Regexp::Syntax::SyntaxError
end

class Regexp::Syntax::SyntaxError
end

module Regexp::Syntax::Token
  All = ::T.let(nil, ::T.untyped)
  Map = ::T.let(nil, ::T.untyped)
  Types = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Anchor
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  MatchStart = ::T.let(nil, ::T.untyped)
  String = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Anchor
end

module Regexp::Syntax::Token::Assertion
  All = ::T.let(nil, ::T.untyped)
  Lookahead = ::T.let(nil, ::T.untyped)
  Lookbehind = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Assertion
end

module Regexp::Syntax::Token::Backreference
  All = ::T.let(nil, ::T.untyped)
  Name = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
  RecursionLevel = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Backreference
end

module Regexp::Syntax::Token::CharacterSet
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::CharacterSet
end

module Regexp::Syntax::Token::CharacterType
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Clustered = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Hex = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::CharacterType
end

module Regexp::Syntax::Token::Conditional
  All = ::T.let(nil, ::T.untyped)
  Condition = ::T.let(nil, ::T.untyped)
  Delimiters = ::T.let(nil, ::T.untyped)
  Separator = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Conditional
end

module Regexp::Syntax::Token::Escape
  ASCII = ::T.let(nil, ::T.untyped)
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Control = ::T.let(nil, ::T.untyped)
  Hex = ::T.let(nil, ::T.untyped)
  Meta = ::T.let(nil, ::T.untyped)
  Octal = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  Unicode = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Escape
end

module Regexp::Syntax::Token::FreeSpace
  All = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::FreeSpace
end

module Regexp::Syntax::Token::Group
  All = ::T.let(nil, ::T.untyped)
  Atomic = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Comment = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Named = ::T.let(nil, ::T.untyped)
  Passive = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  V1_8_6 = ::T.let(nil, ::T.untyped)
  V2_4_1 = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Group
end

module Regexp::Syntax::Token::Keep
  All = ::T.let(nil, ::T.untyped)
  Mark = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Keep
end

module Regexp::Syntax::Token::Literal
  All = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Literal
end

module Regexp::Syntax::Token::Meta
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Meta
end

module Regexp::Syntax::Token::PosixClass
  All = ::T.let(nil, ::T.untyped)
  Extensions = ::T.let(nil, ::T.untyped)
  NonType = ::T.let(nil, ::T.untyped)
  Standard = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::PosixClass
end

module Regexp::Syntax::Token::Quantifier
  All = ::T.let(nil, ::T.untyped)
  Greedy = ::T.let(nil, ::T.untyped)
  Interval = ::T.let(nil, ::T.untyped)
  IntervalAll = ::T.let(nil, ::T.untyped)
  IntervalPossessive = ::T.let(nil, ::T.untyped)
  IntervalReluctant = ::T.let(nil, ::T.untyped)
  Possessive = ::T.let(nil, ::T.untyped)
  Reluctant = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Quantifier
end

module Regexp::Syntax::Token::SubexpressionCall
  All = ::T.let(nil, ::T.untyped)
  Name = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::SubexpressionCall
end

module Regexp::Syntax::Token::UnicodeProperty
  Age = ::T.let(nil, ::T.untyped)
  Age_V1_9_3 = ::T.let(nil, ::T.untyped)
  Age_V2_0_0 = ::T.let(nil, ::T.untyped)
  Age_V2_2_0 = ::T.let(nil, ::T.untyped)
  Age_V2_3_0 = ::T.let(nil, ::T.untyped)
  Age_V2_4_0 = ::T.let(nil, ::T.untyped)
  Age_V2_5_0 = ::T.let(nil, ::T.untyped)
  Age_V2_6_0 = ::T.let(nil, ::T.untyped)
  Age_V2_6_2 = ::T.let(nil, ::T.untyped)
  Age_V2_6_3 = ::T.let(nil, ::T.untyped)
  All = ::T.let(nil, ::T.untyped)
  CharType_V1_9_0 = ::T.let(nil, ::T.untyped)
  CharType_V2_5_0 = ::T.let(nil, ::T.untyped)
  Derived = ::T.let(nil, ::T.untyped)
  Derived_V1_9_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_0_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_4_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_5_0 = ::T.let(nil, ::T.untyped)
  Emoji = ::T.let(nil, ::T.untyped)
  Emoji_V2_5_0 = ::T.let(nil, ::T.untyped)
  NonType = ::T.let(nil, ::T.untyped)
  POSIX = ::T.let(nil, ::T.untyped)
  Script = ::T.let(nil, ::T.untyped)
  Script_V1_9_0 = ::T.let(nil, ::T.untyped)
  Script_V1_9_3 = ::T.let(nil, ::T.untyped)
  Script_V2_0_0 = ::T.let(nil, ::T.untyped)
  Script_V2_2_0 = ::T.let(nil, ::T.untyped)
  Script_V2_3_0 = ::T.let(nil, ::T.untyped)
  Script_V2_4_0 = ::T.let(nil, ::T.untyped)
  Script_V2_5_0 = ::T.let(nil, ::T.untyped)
  Script_V2_6_0 = ::T.let(nil, ::T.untyped)
  Script_V2_6_2 = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  UnicodeBlock = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V1_9_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_0_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_2_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_3_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_4_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_5_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_6_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_6_2 = ::T.let(nil, ::T.untyped)
  V1_9_0 = ::T.let(nil, ::T.untyped)
  V1_9_3 = ::T.let(nil, ::T.untyped)
  V2_0_0 = ::T.let(nil, ::T.untyped)
  V2_2_0 = ::T.let(nil, ::T.untyped)
  V2_3_0 = ::T.let(nil, ::T.untyped)
  V2_4_0 = ::T.let(nil, ::T.untyped)
  V2_5_0 = ::T.let(nil, ::T.untyped)
  V2_6_0 = ::T.let(nil, ::T.untyped)
  V2_6_2 = ::T.let(nil, ::T.untyped)
  V2_6_3 = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::UnicodeProperty::Category
  All = ::T.let(nil, ::T.untyped)
  Codepoint = ::T.let(nil, ::T.untyped)
  Letter = ::T.let(nil, ::T.untyped)
  Mark = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
  Punctuation = ::T.let(nil, ::T.untyped)
  Separator = ::T.let(nil, ::T.untyped)
  Symbol = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::UnicodeProperty::Category
end

module Regexp::Syntax::Token::UnicodeProperty
end

module Regexp::Syntax::Token
end

class Regexp::Syntax::UnknownSyntaxNameError
  def initialize(name); end
end

class Regexp::Syntax::UnknownSyntaxNameError
end

class Regexp::Syntax::V1_8_6
end

class Regexp::Syntax::V1_8_6
end

class Regexp::Syntax::V1_9
end

class Regexp::Syntax::V1_9
end

class Regexp::Syntax::V1_9_1
end

class Regexp::Syntax::V1_9_1
end

class Regexp::Syntax::V1_9_3
end

class Regexp::Syntax::V1_9_3
end

class Regexp::Syntax::V2_0_0
end

class Regexp::Syntax::V2_0_0
end

class Regexp::Syntax::V2_1
end

class Regexp::Syntax::V2_1
end

class Regexp::Syntax::V2_2
end

class Regexp::Syntax::V2_2
end

class Regexp::Syntax::V2_2_0
end

class Regexp::Syntax::V2_2_0
end

class Regexp::Syntax::V2_3
end

class Regexp::Syntax::V2_3
end

class Regexp::Syntax::V2_3_0
end

class Regexp::Syntax::V2_3_0
end

class Regexp::Syntax::V2_4
end

class Regexp::Syntax::V2_4
end

class Regexp::Syntax::V2_4_0
end

class Regexp::Syntax::V2_4_0
end

class Regexp::Syntax::V2_4_1
end

class Regexp::Syntax::V2_4_1
end

class Regexp::Syntax::V2_5
end

class Regexp::Syntax::V2_5
end

class Regexp::Syntax::V2_5_0
end

class Regexp::Syntax::V2_5_0
end

class Regexp::Syntax::V2_6_0
end

class Regexp::Syntax::V2_6_0
end

class Regexp::Syntax::V2_6_2
end

class Regexp::Syntax::V2_6_2
end

class Regexp::Syntax::V2_6_3
end

class Regexp::Syntax::V2_6_3
end

module Regexp::Syntax
  def self.comparable_version(name); end

  def self.const_missing(const_name); end

  def self.fallback_version_class(version); end

  def self.inherit_from_version(parent_version, new_version); end

  def self.new(name); end

  def self.specified_versions(); end

  def self.supported?(name); end

  def self.version_class(version); end

  def self.version_const_name(version_string); end

  def self.warn_if_future_version(const_name); end
end

class Regexp::Token
  def conditional_level(); end

  def conditional_level=(_); end

  def level(); end

  def level=(_); end

  def next(); end

  def next=(_); end

  def offset(); end

  def previous(); end

  def previous=(previous); end

  def set_level(); end

  def set_level=(_); end

  def te(); end

  def te=(_); end

  def text(); end

  def text=(_); end

  def token(); end

  def token=(_); end

  def ts(); end

  def ts=(_); end

  def type(); end

  def type=(_); end
end

class Regexp::Token
  def self.[](*_); end

  def self.members(); end
end

class Resolv::DNS
  def extract_resources(msg, name, typeclass); end
  RequestID = ::T.let(nil, ::T.untyped)
  RequestIDMutex = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Config
  def initialize(config_info=T.unsafe(nil)); end
end

class Resolv::DNS::Label::Str
  def initialize(string); end
end

class Resolv::DNS::Message
  def initialize(id=T.unsafe(nil)); end
end

class Resolv::DNS::Message::MessageDecoder
  def initialize(data); end
end

class Resolv::DNS::Requester::ConnectedUDP
  def initialize(host, port=T.unsafe(nil)); end

  def lazy_initialize(); end
end

class Resolv::DNS::Requester::Sender
  def initialize(msg, data, sock); end
end

class Resolv::DNS::Requester::TCP
  def initialize(host, port=T.unsafe(nil)); end
end

class Resolv::DNS::Requester::UnconnectedUDP
  def initialize(*nameserver_port); end

  def lazy_initialize(); end
end

class Resolv::DNS::Requester::UnconnectedUDP::Sender
  def initialize(msg, data, sock, host, port); end
end

class Resolv::DNS::Resource
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::LOC
  def initialize(version, ssize, hprecision, vprecision, latitude, longitude, altitude); end
end

class Resolv::DNS
  def self.allocate_request_id(host, port); end

  def self.bind_random_port(udpsock, bind_host=T.unsafe(nil)); end

  def self.free_request_id(host, port, id); end

  def self.random(arg); end
end

module ReverseMarkdown
  VERSION = ::T.let(nil, ::T.untyped)
end

class ReverseMarkdown::Cleaner
  def clean_punctuation_characters(string); end

  def clean_tag_borders(string); end

  def force_encoding(string); end

  def remove_inner_whitespaces(string); end

  def remove_leading_newlines(string); end

  def remove_newlines(string); end

  def tidy(string); end
end

class ReverseMarkdown::Cleaner
end

class ReverseMarkdown::Config
  def force_encoding(); end

  def force_encoding=(force_encoding); end

  def github_flavored(); end

  def github_flavored=(github_flavored); end

  def tag_border(); end

  def tag_border=(tag_border); end

  def unknown_tags(); end

  def unknown_tags=(unknown_tags); end

  def with(options=T.unsafe(nil)); end
end

class ReverseMarkdown::Config
end

module ReverseMarkdown::Converters
end

class ReverseMarkdown::Converters::A
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::A
end

class ReverseMarkdown::Converters::Base
  def escape_keychars(string); end

  def extract_title(node); end

  def treat(node, state); end

  def treat_children(node, state); end
end

class ReverseMarkdown::Converters::Base
end

class ReverseMarkdown::Converters::Blockquote
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Blockquote
end

class ReverseMarkdown::Converters::Br
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Br
end

class ReverseMarkdown::Converters::Bypass
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Bypass
end

class ReverseMarkdown::Converters::Code
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Code
end

class ReverseMarkdown::Converters::Del
  def convert(node, state=T.unsafe(nil)); end

  def disabled?(); end

  def enabled?(); end
end

class ReverseMarkdown::Converters::Del
end

class ReverseMarkdown::Converters::Details
  def convert(node, state=T.unsafe(nil)); end

  def disabled?(); end

  def enabled?(); end
end

class ReverseMarkdown::Converters::Details
end

class ReverseMarkdown::Converters::Div
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Div
end

class ReverseMarkdown::Converters::Drop
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Drop
end

class ReverseMarkdown::Converters::Em
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Em
end

class ReverseMarkdown::Converters::H
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::H
end

class ReverseMarkdown::Converters::Hr
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Hr
end

class ReverseMarkdown::Converters::Ignore
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Ignore
end

class ReverseMarkdown::Converters::Img
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Img
end

class ReverseMarkdown::Converters::Li
  def convert(node, state=T.unsafe(nil)); end

  def indentation_from(state); end

  def prefix_for(node); end
end

class ReverseMarkdown::Converters::Li
end

class ReverseMarkdown::Converters::Ol
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Ol
end

class ReverseMarkdown::Converters::P
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::P
end

class ReverseMarkdown::Converters::PassThrough
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::PassThrough
end

class ReverseMarkdown::Converters::Pre
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Pre
end

class ReverseMarkdown::Converters::Strong
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Strong
end

class ReverseMarkdown::Converters::Table
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Table
end

class ReverseMarkdown::Converters::Td
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Td
end

class ReverseMarkdown::Converters::Text
  def convert(node, options=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Text
end

class ReverseMarkdown::Converters::Tr
  def convert(node, state=T.unsafe(nil)); end

  def table_header_row?(node); end

  def underline_for(node); end
end

class ReverseMarkdown::Converters::Tr
end

module ReverseMarkdown::Converters
  def self.default_converter(tag_name); end

  def self.lookup(tag_name); end

  def self.register(tag_name, converter); end

  def self.unregister(tag_name); end
end

class ReverseMarkdown::Error
end

class ReverseMarkdown::Error
end

class ReverseMarkdown::InvalidConfigurationError
end

class ReverseMarkdown::InvalidConfigurationError
end

class ReverseMarkdown::UnknownTagError
end

class ReverseMarkdown::UnknownTagError
end

module ReverseMarkdown
  def self.cleaner(); end

  def self.config(); end

  def self.convert(input, options=T.unsafe(nil)); end
end

class Ripper
  def column(); end

  def encoding(); end

  def end_seen?(); end

  def error?(); end

  def filename(); end

  def initialize(*_); end

  def lineno(); end

  def parse(); end

  def state(); end

  def yydebug(); end

  def yydebug=(yydebug); end
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_ARG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_BEG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_CMDARG = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_ENDARG = ::T.let(nil, ::T.untyped)
  EXPR_ENDFN = ::T.let(nil, ::T.untyped)
  EXPR_END_ANY = ::T.let(nil, ::T.untyped)
  EXPR_FITEM = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_LABEL = ::T.let(nil, ::T.untyped)
  EXPR_LABELED = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  EXPR_NONE = ::T.let(nil, ::T.untyped)
  EXPR_VALUE = ::T.let(nil, ::T.untyped)
  PARSER_EVENT_TABLE = ::T.let(nil, ::T.untyped)
  SCANNER_EVENT_TABLE = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Ripper::Filter
  def initialize(src, filename=T.unsafe(nil), lineno=T.unsafe(nil)); end
end

class Ripper::Lexer
  def lex(); end

  def tokenize(); end
end

class Ripper::Lexer::Elem
  def event(); end

  def event=(_); end

  def initialize(pos, event, tok, state); end

  def pos(); end

  def pos=(_); end

  def state(); end

  def state=(_); end

  def tok(); end

  def tok=(_); end
end

class Ripper::Lexer::Elem
  def self.[](*_); end

  def self.members(); end
end

class Ripper::Lexer::State
  def &(i); end

  def ==(i); end

  def allbits?(i); end

  def anybits?(i); end

  def initialize(i); end

  def nobits?(i); end

  def to_i(); end

  def to_int(); end

  def to_int=(_); end

  def to_s=(_); end

  def |(i); end
end

class Ripper::Lexer::State
  def self.[](*_); end

  def self.members(); end
end

class Ripper::Lexer
end

class Ripper::SexpBuilder
  def on_BEGIN(*args); end

  def on_CHAR(tok); end

  def on_END(*args); end

  def on___end__(tok); end

  def on_alias(*args); end

  def on_alias_error(*args); end

  def on_aref(*args); end

  def on_aref_field(*args); end

  def on_arg_ambiguous(*args); end

  def on_arg_paren(*args); end

  def on_args_add(*args); end

  def on_args_add_block(*args); end

  def on_args_add_star(*args); end

  def on_args_new(*args); end

  def on_array(*args); end

  def on_assign(*args); end

  def on_assign_error(*args); end

  def on_assoc_new(*args); end

  def on_assoc_splat(*args); end

  def on_assoclist_from_args(*args); end

  def on_backref(tok); end

  def on_backtick(tok); end

  def on_bare_assoc_hash(*args); end

  def on_begin(*args); end

  def on_binary(*args); end

  def on_block_var(*args); end

  def on_blockarg(*args); end

  def on_bodystmt(*args); end

  def on_brace_block(*args); end

  def on_break(*args); end

  def on_call(*args); end

  def on_case(*args); end

  def on_class(*args); end

  def on_class_name_error(*args); end

  def on_comma(tok); end

  def on_command(*args); end

  def on_command_call(*args); end

  def on_comment(tok); end

  def on_const(tok); end

  def on_const_path_field(*args); end

  def on_const_path_ref(*args); end

  def on_const_ref(*args); end

  def on_cvar(tok); end

  def on_def(*args); end

  def on_defined(*args); end

  def on_defs(*args); end

  def on_do_block(*args); end

  def on_dot2(*args); end

  def on_dot3(*args); end

  def on_dyna_symbol(*args); end

  def on_else(*args); end

  def on_elsif(*args); end

  def on_embdoc(tok); end

  def on_embdoc_beg(tok); end

  def on_embdoc_end(tok); end

  def on_embexpr_beg(tok); end

  def on_embexpr_end(tok); end

  def on_embvar(tok); end

  def on_ensure(*args); end

  def on_excessed_comma(*args); end

  def on_fcall(*args); end

  def on_field(*args); end

  def on_float(tok); end

  def on_for(*args); end

  def on_gvar(tok); end

  def on_hash(*args); end

  def on_heredoc_beg(tok); end

  def on_heredoc_end(tok); end

  def on_ident(tok); end

  def on_if(*args); end

  def on_if_mod(*args); end

  def on_ifop(*args); end

  def on_ignored_nl(tok); end

  def on_ignored_sp(tok); end

  def on_imaginary(tok); end

  def on_int(tok); end

  def on_ivar(tok); end

  def on_kw(tok); end

  def on_kwrest_param(*args); end

  def on_label(tok); end

  def on_label_end(tok); end

  def on_lambda(*args); end

  def on_lbrace(tok); end

  def on_lbracket(tok); end

  def on_lparen(tok); end

  def on_magic_comment(*args); end

  def on_massign(*args); end

  def on_method_add_arg(*args); end

  def on_method_add_block(*args); end

  def on_mlhs_add(*args); end

  def on_mlhs_add_post(*args); end

  def on_mlhs_add_star(*args); end

  def on_mlhs_new(*args); end

  def on_mlhs_paren(*args); end

  def on_module(*args); end

  def on_mrhs_add(*args); end

  def on_mrhs_add_star(*args); end

  def on_mrhs_new(*args); end

  def on_mrhs_new_from_args(*args); end

  def on_next(*args); end

  def on_nl(tok); end

  def on_op(tok); end

  def on_opassign(*args); end

  def on_operator_ambiguous(*args); end

  def on_param_error(*args); end

  def on_params(*args); end

  def on_paren(*args); end

  def on_parse_error(*args); end

  def on_period(tok); end

  def on_program(*args); end

  def on_qsymbols_add(*args); end

  def on_qsymbols_beg(tok); end

  def on_qsymbols_new(*args); end

  def on_qwords_add(*args); end

  def on_qwords_beg(tok); end

  def on_qwords_new(*args); end

  def on_rational(tok); end

  def on_rbrace(tok); end

  def on_rbracket(tok); end

  def on_redo(*args); end

  def on_regexp_add(*args); end

  def on_regexp_beg(tok); end

  def on_regexp_end(tok); end

  def on_regexp_literal(*args); end

  def on_regexp_new(*args); end

  def on_rescue(*args); end

  def on_rescue_mod(*args); end

  def on_rest_param(*args); end

  def on_retry(*args); end

  def on_return(*args); end

  def on_return0(*args); end

  def on_rparen(tok); end

  def on_sclass(*args); end

  def on_semicolon(tok); end

  def on_sp(tok); end

  def on_stmts_add(*args); end

  def on_stmts_new(*args); end

  def on_string_add(*args); end

  def on_string_concat(*args); end

  def on_string_content(*args); end

  def on_string_dvar(*args); end

  def on_string_embexpr(*args); end

  def on_string_literal(*args); end

  def on_super(*args); end

  def on_symbeg(tok); end

  def on_symbol(*args); end

  def on_symbol_literal(*args); end

  def on_symbols_add(*args); end

  def on_symbols_beg(tok); end

  def on_symbols_new(*args); end

  def on_tlambda(tok); end

  def on_tlambeg(tok); end

  def on_top_const_field(*args); end

  def on_top_const_ref(*args); end

  def on_tstring_beg(tok); end

  def on_tstring_content(tok); end

  def on_tstring_end(tok); end

  def on_unary(*args); end

  def on_undef(*args); end

  def on_unless(*args); end

  def on_unless_mod(*args); end

  def on_until(*args); end

  def on_until_mod(*args); end

  def on_var_alias(*args); end

  def on_var_field(*args); end

  def on_var_ref(*args); end

  def on_vcall(*args); end

  def on_void_stmt(*args); end

  def on_when(*args); end

  def on_while(*args); end

  def on_while_mod(*args); end

  def on_word_add(*args); end

  def on_word_new(*args); end

  def on_words_add(*args); end

  def on_words_beg(tok); end

  def on_words_new(*args); end

  def on_words_sep(tok); end

  def on_xstring_add(*args); end

  def on_xstring_literal(*args); end

  def on_xstring_new(*args); end

  def on_yield(*args); end

  def on_yield0(*args); end

  def on_zsuper(*args); end
end

class Ripper::SexpBuilderPP
end

class Ripper::SexpBuilderPP
end

class Ripper::TokenPattern
  def initialize(pattern); end

  def match(str); end

  def match_list(tokens); end
  MAP = ::T.let(nil, ::T.untyped)
end

class Ripper::TokenPattern::CompileError
end

class Ripper::TokenPattern::CompileError
end

class Ripper::TokenPattern::Error
end

class Ripper::TokenPattern::Error
end

class Ripper::TokenPattern::MatchData
  def initialize(tokens, match); end

  def string(n=T.unsafe(nil)); end
end

class Ripper::TokenPattern::MatchData
end

class Ripper::TokenPattern::MatchError
end

class Ripper::TokenPattern::MatchError
end

class Ripper::TokenPattern
  def self.compile(*_); end
end

class Ripper
  def self.dedent_string(_, _1); end

  def self.lex_state_name(_); end

  def self.token_match(src, pattern); end
end

module RuboCop
end

module RuboCop::AST
end

class RuboCop::AST::AliasNode
  def new_identifier(); end

  def old_identifier(); end
end

class RuboCop::AST::AliasNode
end

class RuboCop::AST::AndNode
  include ::RuboCop::AST::BinaryOperatorNode
  include ::RuboCop::AST::PredicateOperatorNode
  def alternate_operator(); end

  def inverse_operator(); end
end

class RuboCop::AST::AndNode
end

class RuboCop::AST::ArgNode
  def default?(); end

  def default_value(); end

  def name(); end
end

class RuboCop::AST::ArgNode
end

class RuboCop::AST::ArgsNode
  include ::RuboCop::AST::CollectionNode
  def argument_list(); end

  def empty_and_without_delimiters?(); end
end

class RuboCop::AST::ArgsNode
end

class RuboCop::AST::ArrayNode
  def bracketed?(); end

  def each_value(&block); end

  def percent_literal?(type=T.unsafe(nil)); end

  def square_brackets?(); end

  def values(); end
end

class RuboCop::AST::ArrayNode
end

module RuboCop::AST::BasicLiteralNode
  def value(); end
end

module RuboCop::AST::BasicLiteralNode
end

module RuboCop::AST::BinaryOperatorNode
  def conditions(); end

  def lhs(); end

  def rhs(); end
end

module RuboCop::AST::BinaryOperatorNode
end

class RuboCop::AST::BlockNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def argument_list(); end

  def arguments(); end

  def arguments?(); end

  def body(); end

  def braces?(); end

  def closing_delimiter(); end

  def delimiters(); end

  def keywords?(); end

  def lambda?(); end

  def method_name(); end

  def opening_delimiter(); end

  def send_node(); end

  def void_context?(); end
end

class RuboCop::AST::BlockNode
end

class RuboCop::AST::BreakNode
  include ::RuboCop::AST::ParameterizedNode::WrappedArguments
  include ::RuboCop::AST::ParameterizedNode
end

class RuboCop::AST::BreakNode
end

class RuboCop::AST::Builder
  NODE_MAP = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::Builder
end

class RuboCop::AST::CaseMatchNode
  include ::RuboCop::AST::ConditionalNode
  def each_in_pattern(&block); end

  def else?(); end

  def else_branch(); end

  def in_pattern_branches(); end

  def keyword(); end
end

class RuboCop::AST::CaseMatchNode
end

class RuboCop::AST::CaseNode
  include ::RuboCop::AST::ConditionalNode
  def branches(); end

  def each_when(&block); end

  def else?(); end

  def else_branch(); end

  def keyword(); end

  def when_branches(); end
end

class RuboCop::AST::CaseNode
end

class RuboCop::AST::ClassNode
  def body(); end

  def identifier(); end

  def parent_class(); end
end

class RuboCop::AST::ClassNode
end

module RuboCop::AST::CollectionNode
  def &(*args, &block); end

  def *(*args, &block); end

  def +(*args, &block); end

  def -(*args, &block); end

  def <<(*args, &block); end

  def [](*args, &block); end

  def []=(*args, &block); end

  def __evolve_date__(*args, &block); end

  def __evolve_time__(*args, &block); end

  def __sort_option__(*args, &block); end

  def __sort_pair__(*args, &block); end

  def all?(*args, &block); end

  def any?(*args, &block); end

  def append(*args, &block); end

  def assoc(*args, &block); end

  def at(*args, &block); end

  def bsearch(*args, &block); end

  def bsearch_index(*args, &block); end

  def bson_type(*args, &block); end

  def chain(*args, &block); end

  def chunk(*args, &block); end

  def chunk_while(*args, &block); end

  def clear(*args, &block); end

  def collect(*args, &block); end

  def collect!(*args, &block); end

  def collect_concat(*args, &block); end

  def combination(*args, &block); end

  def compact(*args, &block); end

  def compact!(*args, &block); end

  def concat(*args, &block); end

  def count(*args, &block); end

  def cycle(*args, &block); end

  def delete(*args, &block); end

  def delete_at(*args, &block); end

  def delete_if(*args, &block); end

  def delete_one(*args, &block); end

  def detect(*args, &block); end

  def difference(*args, &block); end

  def dig(*args, &block); end

  def drop(*args, &block); end

  def drop_while(*args, &block); end

  def each(*args, &block); end

  def each_cons(*args, &block); end

  def each_entry(*args, &block); end

  def each_index(*args, &block); end

  def each_slice(*args, &block); end

  def each_with_index(*args, &block); end

  def each_with_object(*args, &block); end

  def empty?(*args, &block); end

  def entries(*args, &block); end

  def exclude?(*args, &block); end

  def excluding(*args, &block); end

  def extract!(*args, &block); end

  def extract_options!(*args, &block); end

  def fetch(*args, &block); end

  def fifth(*args, &block); end

  def fill(*args, &block); end

  def filter(*args, &block); end

  def filter!(*args, &block); end

  def find(*args, &block); end

  def find_all(*args, &block); end

  def find_index(*args, &block); end

  def first(*args, &block); end

  def flat_map(*args, &block); end

  def flatten(*args, &block); end

  def flatten!(*args, &block); end

  def forty_two(*args, &block); end

  def fourth(*args, &block); end

  def from(*args, &block); end

  def grep(*args, &block); end

  def grep_v(*args, &block); end

  def group_by(*args, &block); end

  def in_groups(*args, &block); end

  def in_groups_of(*args, &block); end

  def include?(*args, &block); end

  def including(*args, &block); end

  def index(*args, &block); end

  def index_by(*args, &block); end

  def index_with(*args, &block); end

  def inject(*args, &block); end

  def inquiry(*args, &block); end

  def insert(*args, &block); end

  def join(*args, &block); end

  def keep_if(*args, &block); end

  def last(*args, &block); end

  def lazy(*args, &block); end

  def length(*args, &block); end

  def many?(*args, &block); end

  def map(*args, &block); end

  def map!(*args, &block); end

  def max(*args, &block); end

  def max_by(*args, &block); end

  def member?(*args, &block); end

  def min(*args, &block); end

  def min_by(*args, &block); end

  def minmax(*args, &block); end

  def minmax_by(*args, &block); end

  def none?(*args, &block); end

  def one?(*args, &block); end

  def pack(*args, &block); end

  def partition(*args, &block); end

  def permutation(*args, &block); end

  def place(*args, &block); end

  def pluck(*args, &block); end

  def pop(*args, &block); end

  def prepend(*args, &block); end

  def product(*args, &block); end

  def push(*args, &block); end

  def rassoc(*args, &block); end

  def reduce(*args, &block); end

  def reject(*args, &block); end

  def reject!(*args, &block); end

  def repeated_combination(*args, &block); end

  def repeated_permutation(*args, &block); end

  def replace(*args, &block); end

  def reverse(*args, &block); end

  def reverse!(*args, &block); end

  def reverse_each(*args, &block); end

  def rindex(*args, &block); end

  def rotate(*args, &block); end

  def rotate!(*args, &block); end

  def sample(*args, &block); end

  def second(*args, &block); end

  def second_to_last(*args, &block); end

  def select(*args, &block); end

  def select!(*args, &block); end

  def shelljoin(*args, &block); end

  def shift(*args, &block); end

  def shuffle(*args, &block); end

  def shuffle!(*args, &block); end

  def size(*args, &block); end

  def slice(*args, &block); end

  def slice!(*args, &block); end

  def slice_after(*args, &block); end

  def slice_before(*args, &block); end

  def slice_when(*args, &block); end

  def sort(*args, &block); end

  def sort!(*args, &block); end

  def sort_by(*args, &block); end

  def sort_by!(*args, &block); end

  def split(*args, &block); end

  def sum(*args, &block); end

  def take(*args, &block); end

  def take_while(*args, &block); end

  def third(*args, &block); end

  def third_to_last(*args, &block); end

  def to(*args, &block); end

  def to_ary(*args, &block); end

  def to_bson(*args, &block); end

  def to_bson_object_id(*args, &block); end

  def to_default_s(*args, &block); end

  def to_formatted_s(*args, &block); end

  def to_h(*args, &block); end

  def to_msgpack(*args, &block); end

  def to_sentence(*args, &block); end

  def to_set(*args, &block); end

  def to_xml(*args, &block); end

  def transpose(*args, &block); end

  def union(*args, &block); end

  def uniq(*args, &block); end

  def uniq!(*args, &block); end

  def unshift(*args, &block); end

  def update_values(*args, &block); end

  def values_at(*args, &block); end

  def without(*args, &block); end

  def zip(*args, &block); end

  def |(*args, &block); end
end

module RuboCop::AST::CollectionNode
  extend ::Forwardable
end

module RuboCop::AST::ConditionalNode
  def body(); end

  def condition(); end

  def multiline_condition?(); end

  def single_line_condition?(); end
end

module RuboCop::AST::ConditionalNode
end

class RuboCop::AST::ConstNode
  def absolute?(); end

  def class_name?(); end

  def each_path(&block); end

  def module_name?(); end

  def namespace(); end

  def relative?(); end

  def short_name(); end
end

class RuboCop::AST::ConstNode
end

class RuboCop::AST::DefNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def argument_forwarding?(); end

  def arguments(); end

  def body(); end

  def endless?(); end

  def method_name(); end

  def receiver(); end

  def void_context?(); end
end

class RuboCop::AST::DefNode
end

class RuboCop::AST::DefinedNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def arguments(); end
end

class RuboCop::AST::DefinedNode
end

module RuboCop::AST::Descendence
  def child_nodes(); end

  def descendants(); end

  def each_child_node(*types); end

  def each_descendant(*types, &block); end

  def each_node(*types, &block); end

  def visit_descendants(types, &block); end
end

module RuboCop::AST::Descendence
end

class RuboCop::AST::EnsureNode
  def body(); end
end

class RuboCop::AST::EnsureNode
end

module RuboCop::AST::Ext
end

module RuboCop::AST::Ext::Range
  def line_span(exclude_end: T.unsafe(nil)); end
end

module RuboCop::AST::Ext::Range
end

module RuboCop::AST::Ext::RangeMinMax
end

module RuboCop::AST::Ext::RangeMinMax
end

module RuboCop::AST::Ext
end

class RuboCop::AST::FloatNode
  include ::RuboCop::AST::BasicLiteralNode
  include ::RuboCop::AST::NumericNode
end

class RuboCop::AST::FloatNode
end

class RuboCop::AST::ForNode
  def body(); end

  def collection(); end

  def do?(); end

  def keyword(); end

  def variable(); end

  def void_context?(); end
end

class RuboCop::AST::ForNode
end

class RuboCop::AST::ForwardArgsNode
  include ::RuboCop::AST::CollectionNode
end

class RuboCop::AST::ForwardArgsNode
end

module RuboCop::AST::HashElementNode
  def delimiter_delta(other); end

  def key(); end

  def key_delta(other, alignment=T.unsafe(nil)); end

  def same_line?(other); end

  def value(); end

  def value_delta(other); end
end

module RuboCop::AST::HashElementNode
end

class RuboCop::AST::HashNode
  def braces?(); end

  def each_key(&block); end

  def each_pair(); end

  def each_value(&block); end

  def empty?(); end

  def keys(); end

  def mixed_delimiters?(); end

  def pairs(); end

  def pairs_on_same_line?(); end

  def values(); end
end

class RuboCop::AST::HashNode
end

class RuboCop::AST::IfNode
  include ::RuboCop::AST::ConditionalNode
  include ::RuboCop::AST::ModifierNode
  def branches(); end

  def each_branch(&block); end

  def else?(); end

  def else_branch(); end

  def elsif?(); end

  def elsif_conditional?(); end

  def if?(); end

  def if_branch(); end

  def inverse_keyword(); end

  def keyword(); end

  def nested_conditional?(); end

  def ternary?(); end

  def unless?(); end
end

class RuboCop::AST::IfNode
end

class RuboCop::AST::IndexNode
  include ::RuboCop::AST::ParameterizedNode::RestArguments
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def attribute_accessor?(); end
end

class RuboCop::AST::IndexNode
end

class RuboCop::AST::IndexasgnNode
  include ::RuboCop::AST::ParameterizedNode::RestArguments
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def attribute_accessor?(); end
end

class RuboCop::AST::IndexasgnNode
end

class RuboCop::AST::IntNode
  include ::RuboCop::AST::BasicLiteralNode
  include ::RuboCop::AST::NumericNode
end

class RuboCop::AST::IntNode
end

class RuboCop::AST::KeywordSplatNode
  include ::RuboCop::AST::HashElementNode
  def colon?(); end

  def hash_rocket?(); end

  def operator(); end
end

class RuboCop::AST::KeywordSplatNode
end

class RuboCop::AST::LambdaNode
  include ::RuboCop::AST::ParameterizedNode::RestArguments
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def attribute_accessor?(); end
end

class RuboCop::AST::LambdaNode
end

module RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def access_modifier?(); end

  def adjacent_def_modifier?(param0=T.unsafe(nil)); end

  def arithmetic_operation?(); end

  def assignment?(); end

  def bare_access_modifier?(); end

  def bare_access_modifier_declaration?(param0=T.unsafe(nil)); end

  def binary_operation?(); end

  def block_literal?(); end

  def block_node(); end

  def command?(name); end

  def const_receiver?(); end

  def def_modifier?(); end

  def dot?(); end

  def double_colon?(); end

  def implicit_call?(); end

  def in_macro_scope?(param0=T.unsafe(nil)); end

  def lambda?(); end

  def lambda_literal?(); end

  def macro?(); end

  def method_name(); end

  def non_bare_access_modifier?(); end

  def non_bare_access_modifier_declaration?(param0=T.unsafe(nil)); end

  def receiver(); end

  def safe_navigation?(); end

  def self_receiver?(); end

  def setter_method?(); end

  def special_modifier?(); end

  def unary_operation?(); end
end

module RuboCop::AST::MethodDispatchNode
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::AST::MethodIdentifierPredicates
  def assignment_method?(); end

  def bang_method?(); end

  def camel_case_method?(); end

  def comparison_method?(); end

  def const_receiver?(); end

  def enumerable_method?(); end

  def enumerator_method?(); end

  def method?(name); end

  def negation_method?(); end

  def nonmutating_array_method?(); end

  def nonmutating_binary_operator_method?(); end

  def nonmutating_hash_method?(); end

  def nonmutating_operator_method?(); end

  def nonmutating_string_method?(); end

  def nonmutating_unary_operator_method?(); end

  def operator_method?(); end

  def predicate_method?(); end

  def prefix_bang?(); end

  def prefix_not?(); end

  def self_receiver?(); end
end

module RuboCop::AST::MethodIdentifierPredicates
end

module RuboCop::AST::ModifierNode
  def modifier_form?(); end
end

module RuboCop::AST::ModifierNode
end

class RuboCop::AST::ModuleNode
  def body(); end

  def identifier(); end
end

class RuboCop::AST::ModuleNode
end

class RuboCop::AST::NextNode
  include ::RuboCop::AST::ParameterizedNode::WrappedArguments
  include ::RuboCop::AST::ParameterizedNode
end

class RuboCop::AST::NextNode
end

class RuboCop::AST::Node
  include ::RuboCop::AST::Sexp
  include ::RuboCop::AST::Descendence
  def __ENCODING___type?(); end

  def __FILE___type?(); end

  def __LINE___type?(); end

  def alias_type?(); end

  def ancestors(); end

  def and_asgn_type?(); end

  def and_type?(); end

  def arg_expr_type?(); end

  def arg_type?(); end

  def args_type?(); end

  def argument?(); end

  def argument_type?(); end

  def array_pattern_type?(); end

  def array_pattern_with_tail_type?(); end

  def array_type?(); end

  def assignment?(); end

  def assignment_or_similar?(param0=T.unsafe(nil)); end

  def back_ref_type?(); end

  def basic_conditional?(); end

  def basic_literal?(); end

  def begin_type?(); end

  def block_pass_type?(); end

  def block_type?(); end

  def blockarg_expr_type?(); end

  def blockarg_type?(); end

  def boolean_type?(); end

  def break_type?(); end

  def call_type?(); end

  def case_match_type?(); end

  def case_type?(); end

  def casgn_type?(); end

  def cbase_type?(); end

  def chained?(); end

  def class_constructor?(param0=T.unsafe(nil)); end

  def class_definition?(param0=T.unsafe(nil)); end

  def class_type?(); end

  def complete!(); end

  def complete?(); end

  def complex_type?(); end

  def conditional?(); end

  def const_name(); end

  def const_pattern_type?(); end

  def const_type?(); end

  def csend_type?(); end

  def cvar_type?(); end

  def cvasgn_type?(); end

  def def_type?(); end

  def defined_module(); end

  def defined_module_name(); end

  def defined_type?(); end

  def defs_type?(); end

  def dstr_type?(); end

  def dsym_type?(); end

  def each_ancestor(*types, &block); end

  def eflipflop_type?(); end

  def empty_else_type?(); end

  def empty_source?(); end

  def ensure_type?(); end

  def equals_asgn?(); end

  def erange_type?(); end

  def false_type?(); end

  def falsey_literal?(); end

  def find_pattern_type?(); end

  def first_line(); end

  def float_type?(); end

  def for_type?(); end

  def forward_arg_type?(); end

  def forward_args_type?(); end

  def forwarded_args_type?(); end

  def global_const?(param0=T.unsafe(nil), param1); end

  def guard_clause?(); end

  def gvar_type?(); end

  def gvasgn_type?(); end

  def hash_pattern_type?(); end

  def hash_type?(); end

  def ident_type?(); end

  def if_guard_type?(); end

  def if_type?(); end

  def iflipflop_type?(); end

  def immutable_literal?(); end

  def in_match_type?(); end

  def in_pattern_type?(); end

  def index_type?(); end

  def indexasgn_type?(); end

  def int_type?(); end

  def irange_type?(); end

  def ivar_type?(); end

  def ivasgn_type?(); end

  def keyword?(); end

  def kwarg_type?(); end

  def kwbegin_type?(); end

  def kwnilarg_type?(); end

  def kwoptarg_type?(); end

  def kwrestarg_type?(); end

  def kwsplat_type?(); end

  def lambda?(param0=T.unsafe(nil)); end

  def lambda_or_proc?(param0=T.unsafe(nil)); end

  def lambda_type?(); end

  def last_line(); end

  def left_sibling(); end

  def left_siblings(); end

  def line_count(); end

  def literal?(); end

  def loop_keyword?(); end

  def lvar_type?(); end

  def lvasgn_type?(); end

  def masgn_type?(); end

  def match_alt_type?(); end

  def match_as_type?(); end

  def match_current_line_type?(); end

  def match_guard_clause?(param0=T.unsafe(nil)); end

  def match_nil_pattern_type?(); end

  def match_rest_type?(); end

  def match_var_type?(); end

  def match_with_lvasgn_type?(); end

  def match_with_trailing_comma_type?(); end

  def mlhs_type?(); end

  def module_definition?(param0=T.unsafe(nil)); end

  def module_type?(); end

  def multiline?(); end

  def mutable_literal?(); end

  def new_class_or_module_block?(param0=T.unsafe(nil)); end

  def next_type?(); end

  def nil_type?(); end

  def node_parts(); end

  def nonempty_line_count(); end

  def not_type?(); end

  def nth_ref_type?(); end

  def numargs_type?(); end

  def numblock_type?(); end

  def numeric_type?(); end

  def objc_kwarg_type?(); end

  def objc_restarg_type?(); end

  def objc_varargs_type?(); end

  def op_asgn_type?(); end

  def operator_keyword?(); end

  def optarg_type?(); end

  def or_asgn_type?(); end

  def or_type?(); end

  def pair_type?(); end

  def parent(); end

  def parent=(node); end

  def parent?(); end

  def parent_module_name(); end

  def parenthesized_call?(); end

  def pin_type?(); end

  def post_condition_loop?(); end

  def postexe_type?(); end

  def preexe_type?(); end

  def proc?(param0=T.unsafe(nil)); end

  def procarg0_type?(); end

  def pure?(); end

  def range_type?(); end

  def rational_type?(); end

  def receiver(param0=T.unsafe(nil)); end

  def recursive_basic_literal?(); end

  def recursive_literal?(); end

  def redo_type?(); end

  def reference?(); end

  def regexp_type?(); end

  def regopt_type?(); end

  def resbody_type?(); end

  def rescue_type?(); end

  def restarg_expr_type?(); end

  def restarg_type?(); end

  def retry_type?(); end

  def return_type?(); end

  def right_sibling(); end

  def right_siblings(); end

  def root?(); end

  def sclass_type?(); end

  def self_type?(); end

  def send_type?(); end

  def shadowarg_type?(); end

  def shorthand_asgn?(); end

  def sibling_index(); end

  def single_line?(); end

  def source(); end

  def source_length(); end

  def source_range(); end

  def special_keyword?(); end

  def splat_type?(); end

  def str_content(param0=T.unsafe(nil)); end

  def str_type?(); end

  def struct_constructor?(param0=T.unsafe(nil)); end

  def super_type?(); end

  def sym_type?(); end

  def true_type?(); end

  def truthy_literal?(); end

  def undef_type?(); end

  def unless_guard_type?(); end

  def until_post_type?(); end

  def until_type?(); end

  def value_used?(); end

  def variable?(); end

  def when_type?(); end

  def while_post_type?(); end

  def while_type?(); end

  def xstr_type?(); end

  def yield_type?(); end

  def zsuper_type?(); end
  ARGUMENT_TYPES = ::T.let(nil, ::T.untyped)
  ASSIGNMENTS = ::T.let(nil, ::T.untyped)
  BASIC_CONDITIONALS = ::T.let(nil, ::T.untyped)
  BASIC_LITERALS = ::T.let(nil, ::T.untyped)
  COMPARISON_OPERATORS = ::T.let(nil, ::T.untyped)
  COMPOSITE_LITERALS = ::T.let(nil, ::T.untyped)
  CONDITIONALS = ::T.let(nil, ::T.untyped)
  EQUALS_ASSIGNMENTS = ::T.let(nil, ::T.untyped)
  FALSEY_LITERALS = ::T.let(nil, ::T.untyped)
  IMMUTABLE_LITERALS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  LITERALS = ::T.let(nil, ::T.untyped)
  LOOP_TYPES = ::T.let(nil, ::T.untyped)
  MUTABLE_LITERALS = ::T.let(nil, ::T.untyped)
  OPERATOR_KEYWORDS = ::T.let(nil, ::T.untyped)
  POST_CONDITION_LOOP_TYPES = ::T.let(nil, ::T.untyped)
  REFERENCES = ::T.let(nil, ::T.untyped)
  SHORTHAND_ASSIGNMENTS = ::T.let(nil, ::T.untyped)
  SPECIAL_KEYWORDS = ::T.let(nil, ::T.untyped)
  TRUTHY_LITERALS = ::T.let(nil, ::T.untyped)
  VARIABLES = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::Node
  extend ::RuboCop::AST::NodePattern::Macros
end

class RuboCop::AST::NodePattern
  include ::RuboCop::AST::NodePattern::MethodDefiner
  def ==(other); end

  def as_json(_options=T.unsafe(nil)); end

  def ast(); end

  def captures(*args, &block); end

  def encode_with(coder); end

  def eql?(other); end

  def init_with(coder); end

  def initialize(str, compiler: T.unsafe(nil)); end

  def marshal_dump(); end

  def marshal_load(pattern); end

  def match(*args, **rest, &block); end

  def match_code(); end

  def named_parameters(*args, &block); end

  def pattern(); end

  def positional_parameters(*args, &block); end
  VAR = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Builder
  def emit_atom(type, value); end

  def emit_call(type, selector, args=T.unsafe(nil)); end

  def emit_capture(capture_token, node); end

  def emit_list(type, _begin, children, _end); end

  def emit_subsequence(node_list); end

  def emit_unary_op(type, _operator=T.unsafe(nil), *children); end

  def emit_union(begin_t, pattern_lists, end_t); end
end

class RuboCop::AST::NodePattern::Builder
end

class RuboCop::AST::NodePattern::Comment
  def ==(other); end

  def initialize(range); end

  def loc(); end

  def location(); end

  def text(); end
end

class RuboCop::AST::NodePattern::Comment
end

class RuboCop::AST::NodePattern::Compiler
  def bind(*args, &block); end

  def captures(); end

  def compile_as_atom(node); end

  def compile_as_node_pattern(node, **options); end

  def compile_sequence(sequence, var:); end

  def each_union(enum, &block); end

  def named_parameter(name); end

  def named_parameters(); end

  def next_capture(); end

  def parser(); end

  def positional_parameter(number); end

  def positional_parameters(); end

  def with_temp_variables(*names, &block); end
end

class RuboCop::AST::NodePattern::Compiler::AtomSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::AtomSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Binding
  def bind(name); end

  def union_bind(enum); end
end

class RuboCop::AST::NodePattern::Compiler::Binding
end

class RuboCop::AST::NodePattern::Compiler::Debug
  def comments(*args, &block); end

  def node_ids(); end

  def tokens(*args, &block); end
end

class RuboCop::AST::NodePattern::Compiler::Debug::Colorizer
  def compiler(); end

  def initialize(pattern, compiler: T.unsafe(nil)); end

  def node_pattern(); end

  def pattern(); end

  def test(ruby, trace: T.unsafe(nil)); end
  COLOR_SCHEME = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Compiler::Debug::Colorizer::Result
  def color_map(color_scheme=T.unsafe(nil)); end

  def colorize(color_scheme=T.unsafe(nil)); end

  def colorizer(); end

  def colorizer=(_); end

  def match_map(); end

  def matched?(node); end

  def returned(); end

  def returned=(_); end

  def ruby_ast(); end

  def ruby_ast=(_); end

  def trace(); end

  def trace=(_); end
end

class RuboCop::AST::NodePattern::Compiler::Debug::Colorizer::Result
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::AST::NodePattern::Compiler::Debug::Colorizer
end

module RuboCop::AST::NodePattern::Compiler::Debug::InstrumentationSubcompiler
  def do_compile(); end
end

module RuboCop::AST::NodePattern::Compiler::Debug::InstrumentationSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::NodePatternSubcompiler
  include ::RuboCop::AST::NodePattern::Compiler::Debug::InstrumentationSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::NodePatternSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::SequenceSubcompiler
  include ::RuboCop::AST::NodePattern::Compiler::Debug::InstrumentationSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::SequenceSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::Trace
  def enter(node_id); end

  def matched?(node_id); end

  def success(node_id); end
end

class RuboCop::AST::NodePattern::Compiler::Debug::Trace
end

class RuboCop::AST::NodePattern::Compiler::Debug
end

class RuboCop::AST::NodePattern::Compiler::NodePatternSubcompiler
  def access(); end

  def initialize(compiler, var: T.unsafe(nil), access: T.unsafe(nil), seq_head: T.unsafe(nil)); end

  def seq_head(); end
end

class RuboCop::AST::NodePattern::Compiler::NodePatternSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::SequenceSubcompiler
  def compile_sequence(); end

  def compile_terms(children=T.unsafe(nil), last_arity=T.unsafe(nil)); end

  def cur_index(); end

  def in_sync(); end

  def initialize(compiler, sequence:, var:); end

  def sync(); end
  DELTA = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Compiler::SequenceSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Subcompiler
  def compile(node); end

  def compiler(); end

  def initialize(compiler); end
end

class RuboCop::AST::NodePattern::Compiler::Subcompiler
  def self.inherited(base); end

  def self.method_added(method); end

  def self.registry(); end
end

class RuboCop::AST::NodePattern::Compiler
  extend ::Forwardable
end

class RuboCop::AST::NodePattern::Invalid
end

class RuboCop::AST::NodePattern::Invalid
end

class RuboCop::AST::NodePattern::Lexer
  def comments(); end

  def initialize(source); end

  def source_buffer(); end

  def tokens(); end
end

class RuboCop::AST::NodePattern::Lexer
end

class RuboCop::AST::NodePattern::LexerRex
  def action(); end

  def filename(); end

  def filename=(filename); end

  def location(); end

  def match(); end

  def matches(); end

  def next_token(); end

  def parse(str); end

  def parse_file(path); end

  def scanner_class(); end

  def ss(); end

  def ss=(ss); end

  def state(); end

  def state=(state); end
  CALL = ::T.let(nil, ::T.untyped)
  CONST_NAME = ::T.let(nil, ::T.untyped)
  IDENTIFIER = ::T.let(nil, ::T.untyped)
  NODE_TYPE = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
  REGEXP_BODY = ::T.let(nil, ::T.untyped)
  SYMBOL_NAME = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::LexerRex::LexerError
end

class RuboCop::AST::NodePattern::LexerRex::LexerError
end

class RuboCop::AST::NodePattern::LexerRex::ScanError
end

class RuboCop::AST::NodePattern::LexerRex::ScanError
end

class RuboCop::AST::NodePattern::LexerRex
end

module RuboCop::AST::NodePattern::Macros
  def def_node_matcher(method_name, pattern_str, **keyword_defaults); end

  def def_node_search(method_name, pattern_str, **keyword_defaults); end
end

module RuboCop::AST::NodePattern::Macros
end

module RuboCop::AST::NodePattern::MethodDefiner
  def as_lambda(); end

  def compile_as_lambda(); end

  def def_node_matcher(base, method_name, **defaults); end

  def def_node_search(base, method_name, **defaults); end
end

module RuboCop::AST::NodePattern::MethodDefiner
end

class RuboCop::AST::NodePattern::Node
  include ::RuboCop::AST::Descendence
  def arity(); end

  def arity_range(); end

  def capture?(); end

  def child(); end

  def children_nodes(); end

  def in_sequence_head(); end

  def matches_within_set?(); end

  def nb_captures(); end

  def rest?(); end

  def variadic?(); end

  def with(type: T.unsafe(nil), children: T.unsafe(nil), location: T.unsafe(nil)); end
  MAP = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Node::AnyOrder
  include ::RuboCop::AST::NodePattern::Node::ForbidInSeqHead
  def ends_with_rest?(); end

  def rest_node(); end

  def term_nodes(); end
end

class RuboCop::AST::NodePattern::Node::AnyOrder
end

class RuboCop::AST::NodePattern::Node::Capture
  def arity(*args, &block); end

  def rest?(*args, &block); end
end

class RuboCop::AST::NodePattern::Node::Capture
end

module RuboCop::AST::NodePattern::Node::ForbidInSeqHead
  def in_sequence_head(); end
end

module RuboCop::AST::NodePattern::Node::ForbidInSeqHead
end

class RuboCop::AST::NodePattern::Node::Predicate
  def arg_list(); end

  def method_name(); end
end

class RuboCop::AST::NodePattern::Node::Predicate
end

class RuboCop::AST::NodePattern::Node::Repetition
  include ::RuboCop::AST::NodePattern::Node::ForbidInSeqHead
  def operator(); end
  ARITIES = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Node::Repetition
end

class RuboCop::AST::NodePattern::Node::Rest
end

class RuboCop::AST::NodePattern::Node::Rest
end

class RuboCop::AST::NodePattern::Node::Sequence
  include ::RuboCop::AST::NodePattern::Node::ForbidInSeqHead
end

class RuboCop::AST::NodePattern::Node::Sequence
end

class RuboCop::AST::NodePattern::Node::Subsequence
  include ::RuboCop::AST::NodePattern::Node::ForbidInSeqHead
end

class RuboCop::AST::NodePattern::Node::Subsequence
end

class RuboCop::AST::NodePattern::Node::Union
end

class RuboCop::AST::NodePattern::Node::Union
end

class RuboCop::AST::NodePattern::Node
  extend ::Forwardable
end

class RuboCop::AST::NodePattern::Parser
  def _reduce_10(val, _values); end

  def _reduce_11(val, _values); end

  def _reduce_13(val, _values); end

  def _reduce_14(val, _values); end

  def _reduce_15(val, _values); end

  def _reduce_16(val, _values); end

  def _reduce_17(val, _values); end

  def _reduce_18(val, _values); end

  def _reduce_19(val, _values); end

  def _reduce_2(val, _values); end

  def _reduce_20(val, _values); end

  def _reduce_21(val, _values); end

  def _reduce_22(val, _values); end

  def _reduce_25(val, _values); end

  def _reduce_26(val, _values); end

  def _reduce_3(val, _values); end

  def _reduce_33(val, _values); end

  def _reduce_37(val, _values); end

  def _reduce_38(val, _values); end

  def _reduce_39(val, _values); end

  def _reduce_4(val, _values); end

  def _reduce_40(val, _values); end

  def _reduce_41(val, _values); end

  def _reduce_42(val, _values); end

  def _reduce_43(val, _values); end

  def _reduce_44(val, _values); end

  def _reduce_45(val, _values); end

  def _reduce_46(val, _values); end

  def _reduce_5(val, _values); end

  def _reduce_6(val, _values); end

  def _reduce_7(val, _values); end

  def _reduce_8(val, _values); end

  def _reduce_9(val, _values); end

  def _reduce_none(val, _values); end

  def emit_atom(*args, &block); end

  def emit_call(*args, &block); end

  def emit_capture(*args, &block); end

  def emit_list(*args, &block); end

  def emit_unary_op(*args, &block); end

  def emit_union(*args, &block); end

  def initialize(builder=T.unsafe(nil)); end

  def next_token(*args, &block); end

  def parse(source); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Parser::WithMeta
  def comments(); end

  def tokens(); end
end

class RuboCop::AST::NodePattern::Parser::WithMeta::Builder
  def emit_atom(type, token); end

  def emit_call(type, selector_t, args=T.unsafe(nil)); end

  def emit_list(type, begin_t, children, end_t); end

  def emit_unary_op(type, operator_t=T.unsafe(nil), *children); end
end

class RuboCop::AST::NodePattern::Parser::WithMeta::Builder
end

class RuboCop::AST::NodePattern::Parser::WithMeta::Lexer
  def initialize(str_or_buffer); end

  def pos(); end
end

class RuboCop::AST::NodePattern::Parser::WithMeta::Lexer
end

class RuboCop::AST::NodePattern::Parser::WithMeta
end

class RuboCop::AST::NodePattern::Parser
  extend ::Forwardable
end

module RuboCop::AST::NodePattern::Sets
  MAX = ::T.let(nil, ::T.untyped)
  REGISTRY = ::T.let(nil, ::T.untyped)
  SET_0_1 = ::T.let(nil, ::T.untyped)
  SET_10_10 = ::T.let(nil, ::T.untyped)
  SET_1_1 = ::T.let(nil, ::T.untyped)
  SET_ADD_DEPENDENCY_ADD_RUNTIME_DEPENDENCY_ADD_DEVELOPMENT_DEPENDENCY = ::T.let(nil, ::T.untyped)
  SET_ATTR_READER_ATTR_WRITER_ATTR_ACCESSOR_ATTR = ::T.let(nil, ::T.untyped)
  SET_CAPTURE2_CAPTURE2E_CAPTURE3_ETC = ::T.let(nil, ::T.untyped)
  SET_CIPHER_DIGEST = ::T.let(nil, ::T.untyped)
  SET_CLASS_EVAL_INSTANCE_EVAL = ::T.let(nil, ::T.untyped)
  SET_CLASS_EVAL_MODULE_EVAL = ::T.let(nil, ::T.untyped)
  SET_CLASS_MODULE = ::T.let(nil, ::T.untyped)
  SET_CLASS_MODULE_STRUCT = ::T.let(nil, ::T.untyped)
  SET_COUNT_LENGTH_SIZE = ::T.let(nil, ::T.untyped)
  SET_DEFINE_METHOD_DEFINE_SINGLETON_METHOD = ::T.let(nil, ::T.untyped)
  SET_EACH_WITH_INDEX_WITH_INDEX = ::T.let(nil, ::T.untyped)
  SET_EACH_WITH_OBJECT_WITH_OBJECT = ::T.let(nil, ::T.untyped)
  SET_ENUMERATOR_RATIONAL_COMPLEX_THREAD = ::T.let(nil, ::T.untyped)
  SET_ESCAPE_ENCODE_UNESCAPE_DECODE = ::T.let(nil, ::T.untyped)
  SET_FIRST_LAST__ETC = ::T.let(nil, ::T.untyped)
  SET_FIXNUM_BIGNUM = ::T.let(nil, ::T.untyped)
  SET_FORMAT_SPRINTF_PRINTF = ::T.let(nil, ::T.untyped)
  SET_GEMCUTTER_RUBYGEMS_RUBYFORGE = ::T.let(nil, ::T.untyped)
  SET_GSUB_GSUB = ::T.let(nil, ::T.untyped)
  SET_INCLUDE_EXTEND_PREPEND = ::T.let(nil, ::T.untyped)
  SET_INSTANCE_EVAL_CLASS_EVAL_MODULE_EVAL = ::T.let(nil, ::T.untyped)
  SET_INSTANCE_EXEC_CLASS_EXEC_MODULE_EXEC = ::T.let(nil, ::T.untyped)
  SET_KEYS_VALUES = ::T.let(nil, ::T.untyped)
  SET_KEY_HAS_KEY_FETCH_ETC = ::T.let(nil, ::T.untyped)
  SET_LAST_FIRST = ::T.let(nil, ::T.untyped)
  SET_LENGTH_SIZE = ::T.let(nil, ::T.untyped)
  SET_LOAD_RESTORE = ::T.let(nil, ::T.untyped)
  SET_MAP_COLLECT = ::T.let(nil, ::T.untyped)
  SET_NEW_OPEN = ::T.let(nil, ::T.untyped)
  SET_NIL_ = ::T.let(nil, ::T.untyped)
  SET_PIPELINE_PIPELINE_R_PIPELINE_RW_ETC = ::T.let(nil, ::T.untyped)
  SET_PRIVATE_PROTECTED = ::T.let(nil, ::T.untyped)
  SET_PRIVATE_PROTECTED_PUBLIC = ::T.let(nil, ::T.untyped)
  SET_PUBLIC_CONSTANT_PRIVATE_CONSTANT = ::T.let(nil, ::T.untyped)
  SET_PUBLIC_PROTECTED_PRIVATE_MODULE_FUNCTION = ::T.let(nil, ::T.untyped)
  SET_RAISE_FAIL = ::T.let(nil, ::T.untyped)
  SET_RAISE_FAIL_THROW_ETC = ::T.let(nil, ::T.untyped)
  SET_REDUCE_INJECT = ::T.let(nil, ::T.untyped)
  SET_REJECT_REJECT = ::T.let(nil, ::T.untyped)
  SET_REQUIRE_REQUIRE_RELATIVE = ::T.let(nil, ::T.untyped)
  SET_SELECT_SELECT = ::T.let(nil, ::T.untyped)
  SET_SEND_PUBLIC_SEND___SEND__ = ::T.let(nil, ::T.untyped)
  SET_SORT_BY_SORT = ::T.let(nil, ::T.untyped)
  SET_SPAWN_SYSTEM = ::T.let(nil, ::T.untyped)
  SET_SPRINTF_FORMAT = ::T.let(nil, ::T.untyped)
  SET_STRUCT_CLASS = ::T.let(nil, ::T.untyped)
  SET_SUCC_PRED_NEXT = ::T.let(nil, ::T.untyped)
  SET_TEMPFILE_STRINGIO = ::T.let(nil, ::T.untyped)
  SET_TO_ENUM_ENUM_FOR = ::T.let(nil, ::T.untyped)
  SET_TO_I_TO_F_TO_C = ::T.let(nil, ::T.untyped)
  SET_TRUE_FALSE = ::T.let(nil, ::T.untyped)
  SET_ZERO_POSITIVE_NEGATIVE = ::T.let(nil, ::T.untyped)
  SET__ = ::T.let(nil, ::T.untyped)
  SET__AT_SLICE = ::T.let(nil, ::T.untyped)
  SET__EQUAL_EQL = ::T.let(nil, ::T.untyped)
  SET__GLOB = ::T.let(nil, ::T.untyped)
  SET___ = ::T.let(nil, ::T.untyped)
  SET___2 = ::T.let(nil, ::T.untyped)
  SET___3 = ::T.let(nil, ::T.untyped)
  SET___4 = ::T.let(nil, ::T.untyped)
  SET___5 = ::T.let(nil, ::T.untyped)
  SET___6 = ::T.let(nil, ::T.untyped)
  SET___7 = ::T.let(nil, ::T.untyped)
  SET___METHOD_____CALLEE__ = ::T.let(nil, ::T.untyped)
  SET____ = ::T.let(nil, ::T.untyped)
  SET____ETC = ::T.let(nil, ::T.untyped)
  SET____ETC_2 = ::T.let(nil, ::T.untyped)
  SET____ETC_3 = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::NodePattern::Sets
  def self.[](set); end

  def self.name(set); end

  def self.uniq(name); end
end

class RuboCop::AST::NodePattern
  extend ::Forwardable
  def self.descend(element, &block); end
end

module RuboCop::AST::NumericNode
  def sign?(); end
end

module RuboCop::AST::NumericNode
end

class RuboCop::AST::OrNode
  include ::RuboCop::AST::BinaryOperatorNode
  include ::RuboCop::AST::PredicateOperatorNode
  def alternate_operator(); end

  def inverse_operator(); end
end

class RuboCop::AST::OrNode
end

class RuboCop::AST::PairNode
  include ::RuboCop::AST::HashElementNode
  def colon?(); end

  def delimiter(*deprecated, with_spacing: T.unsafe(nil)); end

  def hash_rocket?(); end

  def inverse_delimiter(*deprecated, with_spacing: T.unsafe(nil)); end

  def value_on_new_line?(); end
end

class RuboCop::AST::PairNode
end

module RuboCop::AST::ParameterizedNode
  def arguments?(); end

  def block_argument?(); end

  def first_argument(); end

  def last_argument(); end

  def parenthesized?(); end

  def rest_argument?(); end

  def splat_argument?(); end
end

module RuboCop::AST::ParameterizedNode::RestArguments
  include ::RuboCop::AST::ParameterizedNode
  def arguments(); end

  def arguments?(); end

  def first_argument(); end

  def last_argument(); end
end

module RuboCop::AST::ParameterizedNode::RestArguments
end

module RuboCop::AST::ParameterizedNode::WrappedArguments
  include ::RuboCop::AST::ParameterizedNode
  def arguments(); end
end

module RuboCop::AST::ParameterizedNode::WrappedArguments
end

module RuboCop::AST::ParameterizedNode
end

module RuboCop::AST::PredicateOperatorNode
  def logical_operator?(); end

  def operator(); end

  def semantic_operator?(); end
end

module RuboCop::AST::PredicateOperatorNode
end

class RuboCop::AST::Procarg0Node
end

class RuboCop::AST::Procarg0Node
end

class RuboCop::AST::ProcessedSource
  include ::RuboCop::Ext::ProcessedSource
  def [](*args); end

  def ast(); end

  def ast_with_comments(); end

  def buffer(); end

  def checksum(); end

  def comment_at_line(line); end

  def commented?(source_range); end

  def comments(); end

  def comments_before_line(line); end

  def contains_comment?(source_range); end

  def current_line(token); end

  def diagnostics(); end

  def each_comment(&block); end

  def each_comment_in_lines(line_range); end

  def each_token(&block); end

  def file_path(); end

  def find_comment(&block); end

  def find_token(&block); end

  def first_token_of(range_or_node); end

  def following_line(token); end

  def initialize(source, ruby_version, path=T.unsafe(nil)); end

  def last_token_of(range_or_node); end

  def line_indentation(line_number); end

  def line_with_comment?(line); end

  def lines(); end

  def parser_error(); end

  def path(); end

  def preceding_line(token); end

  def raw_source(); end

  def ruby_version(); end

  def start_with?(string); end

  def tokens(); end

  def tokens_within(range_or_node); end

  def valid_syntax?(); end
  STRING_SOURCE_NAME = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::ProcessedSource
  def self.from_file(path, ruby_version); end
end

class RuboCop::AST::RangeNode
  def begin(); end

  def end(); end
end

class RuboCop::AST::RangeNode
end

class RuboCop::AST::RegexpNode
  include ::RuboCop::Ext::RegexpNode
  def content(); end

  def delimiter?(char); end

  def delimiters(); end

  def extended?(); end

  def ignore_case?(); end

  def interpolation?(); end

  def multiline_mode?(); end

  def no_encoding?(); end

  def options(); end

  def percent_r_literal?(); end

  def regopt(); end

  def single_interpolation?(); end

  def slash_literal?(); end

  def to_regexp(); end
end

class RuboCop::AST::RegexpNode
end

class RuboCop::AST::ResbodyNode
  def body(); end

  def branch_index(); end

  def exception_variable(); end

  def exceptions(); end
end

class RuboCop::AST::ResbodyNode
end

class RuboCop::AST::RescueNode
  def body(); end

  def branches(); end

  def else?(); end

  def else_branch(); end

  def resbody_branches(); end
end

class RuboCop::AST::RescueNode
end

class RuboCop::AST::ReturnNode
  include ::RuboCop::AST::ParameterizedNode::WrappedArguments
  include ::RuboCop::AST::ParameterizedNode
end

class RuboCop::AST::ReturnNode
end

module RuboCop::AST::RuboCopCompatibility
  def rubocop_loaded(); end
  INCOMPATIBLE_COPS = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::RuboCopCompatibility
end

class RuboCop::AST::SelfClassNode
  def body(); end

  def identifier(); end
end

class RuboCop::AST::SelfClassNode
end

class RuboCop::AST::SendNode
  include ::RuboCop::AST::ParameterizedNode::RestArguments
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def attribute_accessor?(param0=T.unsafe(nil)); end
end

class RuboCop::AST::SendNode
end

module RuboCop::AST::Sexp
  def s(type, *children); end
end

module RuboCop::AST::Sexp
end

class RuboCop::AST::StrNode
  include ::RuboCop::AST::BasicLiteralNode
  def heredoc?(); end
end

class RuboCop::AST::StrNode
end

class RuboCop::AST::SuperNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def arguments(); end
end

class RuboCop::AST::SuperNode
end

class RuboCop::AST::SymbolNode
  include ::RuboCop::AST::BasicLiteralNode
end

class RuboCop::AST::SymbolNode
end

class RuboCop::AST::Token
  def begin_pos(); end

  def column(); end

  def comma?(); end

  def comment?(); end

  def end?(); end

  def end_pos(); end

  def equal_sign?(); end

  def initialize(pos, type, text); end

  def left_array_bracket?(); end

  def left_brace?(); end

  def left_bracket?(); end

  def left_curly_brace?(); end

  def left_parens?(); end

  def left_ref_bracket?(); end

  def line(); end

  def pos(); end

  def rescue_modifier?(); end

  def right_bracket?(); end

  def right_curly_brace?(); end

  def right_parens?(); end

  def semicolon?(); end

  def space_after?(); end

  def space_before?(); end

  def text(); end

  def type(); end
end

class RuboCop::AST::Token
  def self.from_parser_token(parser_token); end
end

module RuboCop::AST::Traversal
  def on_(node); end

  def on___ENCODING__(node); end

  def on___FILE__(node); end

  def on___LINE__(node); end

  def on_alias(node); end

  def on_and(node); end

  def on_and_asgn(node); end

  def on_arg(node); end

  def on_arg_expr(node); end

  def on_args(node); end

  def on_array(node); end

  def on_array_pattern(node); end

  def on_array_pattern_with_tail(node); end

  def on_back_ref(node); end

  def on_begin(node); end

  def on_block(node); end

  def on_block_pass(node); end

  def on_blockarg(node); end

  def on_break(node); end

  def on_case(node); end

  def on_case_match(node); end

  def on_casgn(node); end

  def on_cbase(node); end

  def on_class(node); end

  def on_complex(node); end

  def on_const(node); end

  def on_const_pattern(node); end

  def on_csend(node); end

  def on_cvar(node); end

  def on_cvasgn(node); end

  def on_def(node); end

  def on_defined?(node); end

  def on_defs(node); end

  def on_dstr(node); end

  def on_dsym(node); end

  def on_eflipflop(node); end

  def on_empty_else(node); end

  def on_ensure(node); end

  def on_erange(node); end

  def on_false(node); end

  def on_find_pattern(node); end

  def on_float(node); end

  def on_for(node); end

  def on_forward_arg(node); end

  def on_forward_args(node); end

  def on_forwarded_args(node); end

  def on_gvar(node); end

  def on_gvasgn(node); end

  def on_hash(node); end

  def on_hash_pattern(node); end

  def on_if(node); end

  def on_if_guard(node); end

  def on_iflipflop(node); end

  def on_in_match(node); end

  def on_in_pattern(node); end

  def on_index(node); end

  def on_indexasgn(node); end

  def on_int(node); end

  def on_irange(node); end

  def on_ivar(node); end

  def on_ivasgn(node); end

  def on_kwarg(node); end

  def on_kwbegin(node); end

  def on_kwnilarg(node); end

  def on_kwoptarg(node); end

  def on_kwrestarg(node); end

  def on_kwsplat(node); end

  def on_lambda(node); end

  def on_lvar(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_match_alt(node); end

  def on_match_as(node); end

  def on_match_current_line(node); end

  def on_match_nil_pattern(node); end

  def on_match_rest(node); end

  def on_match_var(node); end

  def on_match_with_lvasgn(node); end

  def on_match_with_trailing_comma(node); end

  def on_mlhs(node); end

  def on_module(node); end

  def on_mrasgn(node); end

  def on_next(node); end

  def on_nil(node); end

  def on_not(node); end

  def on_nth_ref(node); end

  def on_numblock(node); end

  def on_op_asgn(node); end

  def on_optarg(node); end

  def on_or(node); end

  def on_or_asgn(node); end

  def on_pair(node); end

  def on_pin(node); end

  def on_postexe(node); end

  def on_preexe(node); end

  def on_procarg0(node); end

  def on_rasgn(node); end

  def on_rational(node); end

  def on_redo(node); end

  def on_regexp(node); end

  def on_regopt(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_restarg(node); end

  def on_retry(node); end

  def on_return(node); end

  def on_sclass(node); end

  def on_self(node); end

  def on_send(node); end

  def on_shadowarg(node); end

  def on_splat(node); end

  def on_str(node); end

  def on_super(node); end

  def on_sym(node); end

  def on_true(node); end

  def on_undef(node); end

  def on_unless_guard(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_when(node); end

  def on_while(node); end

  def on_while_post(node); end

  def on_xstr(node); end

  def on_yield(node); end

  def on_zsuper(node); end

  def walk(node); end
  TYPE_TO_METHOD = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::Traversal::DebugError
end

class RuboCop::AST::Traversal::DebugError
end

module RuboCop::AST::Traversal
end

class RuboCop::AST::UntilNode
  include ::RuboCop::AST::ConditionalNode
  include ::RuboCop::AST::ModifierNode
  def do?(); end

  def inverse_keyword(); end

  def keyword(); end
end

class RuboCop::AST::UntilNode
end

module RuboCop::AST::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::Version
end

class RuboCop::AST::WhenNode
  def body(); end

  def branch_index(); end

  def conditions(); end

  def each_condition(&block); end

  def then?(); end
end

class RuboCop::AST::WhenNode
end

class RuboCop::AST::WhileNode
  include ::RuboCop::AST::ConditionalNode
  include ::RuboCop::AST::ModifierNode
  def do?(); end

  def inverse_keyword(); end

  def keyword(); end
end

class RuboCop::AST::WhileNode
end

class RuboCop::AST::YieldNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def arguments(); end
end

class RuboCop::AST::YieldNode
end

module RuboCop::AST
  extend ::RuboCop::AST::RuboCopCompatibility
end

class RuboCop::CLI
  def config_store(); end

  def options(); end

  def run(args=T.unsafe(nil)); end
  STATUS_ERROR = ::T.let(nil, ::T.untyped)
  STATUS_INTERRUPTED = ::T.let(nil, ::T.untyped)
  STATUS_OFFENSES = ::T.let(nil, ::T.untyped)
  STATUS_SUCCESS = ::T.let(nil, ::T.untyped)
end

module RuboCop::CLI::Command
end

class RuboCop::CLI::Command::AutoGenerateConfig
  def run(); end
  AUTO_GENERATED_FILE = ::T.let(nil, ::T.untyped)
  PHASE_1 = ::T.let(nil, ::T.untyped)
  PHASE_1_DISABLED = ::T.let(nil, ::T.untyped)
  PHASE_1_OVERRIDDEN = ::T.let(nil, ::T.untyped)
  PHASE_2 = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Command::AutoGenerateConfig
end

class RuboCop::CLI::Command::Base
  def env(); end

  def initialize(env); end
end

class RuboCop::CLI::Command::Base
  def self.by_command_name(name); end

  def self.command_name(); end

  def self.command_name=(command_name); end

  def self.inherited(subclass); end
end

class RuboCop::CLI::Command::ExecuteRunner
  include ::RuboCop::Formatter::TextUtil
  def run(); end
  INTEGRATION_FORMATTERS = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Command::ExecuteRunner
end

class RuboCop::CLI::Command::InitDotfile
  def run(); end
  DOTFILE = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Command::InitDotfile
end

class RuboCop::CLI::Command::ShowCops
  def run(); end
end

class RuboCop::CLI::Command::ShowCops
end

class RuboCop::CLI::Command::SuggestExtensions
  def run(); end
  INCLUDED_FORMATTERS = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Command::SuggestExtensions
end

class RuboCop::CLI::Command::Version
  def run(); end
end

class RuboCop::CLI::Command::Version
end

module RuboCop::CLI::Command
  def self.run(env, name); end
end

class RuboCop::CLI::Environment
  def config_store(); end

  def initialize(options, config_store, paths); end

  def options(); end

  def paths(); end

  def run(name); end
end

class RuboCop::CLI::Environment
end

class RuboCop::CLI::Finished
end

class RuboCop::CLI::Finished
end

class RuboCop::CLI
end

class RuboCop::CachedData
  def from_json(text); end

  def initialize(filename); end

  def to_json(offenses); end
end

class RuboCop::CachedData
end

class RuboCop::CommentConfig
  def cop_disabled_line_ranges(); end

  def cop_enabled_at_line?(cop, line_number); end

  def extra_enabled_comments(); end

  def initialize(processed_source); end

  def processed_source(); end
  COMMENT_DIRECTIVE_REGEXP = ::T.let(nil, ::T.untyped)
  COPS_PATTERN = ::T.let(nil, ::T.untyped)
  COP_NAMES_PATTERN = ::T.let(nil, ::T.untyped)
  COP_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  REDUNDANT_DISABLE = ::T.let(nil, ::T.untyped)
end

class RuboCop::CommentConfig::CopAnalysis
  def line_ranges(); end

  def line_ranges=(_); end

  def start_line_number(); end

  def start_line_number=(_); end
end

class RuboCop::CommentConfig::CopAnalysis
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::CommentConfig
end

class RuboCop::Config
  include ::RuboCop::PathUtil
  include ::RuboCop::FileFinder
  def [](*args, &block); end

  def []=(*args, &block); end

  def add_excludes_from_higher_level(highest_config); end

  def allowed_camel_case_file?(file); end

  def base_dir_for_path_parameters(); end

  def bundler_lock_file_path(); end

  def check(); end

  def delete(*args, &block); end

  def deprecation_check(); end

  def disabled_new_cops?(); end

  def each(*args, &block); end

  def each_key(*args, &block); end

  def enabled_new_cops?(); end

  def fetch(*args, &block); end

  def file_to_exclude?(file); end

  def file_to_include?(file); end

  def for_all_cops(); end

  def for_badge(badge); end

  def for_cop(cop); end

  def for_department(department_name); end

  def initialize(hash=T.unsafe(nil), loaded_path=T.unsafe(nil)); end

  def internal?(); end

  def key?(*args, &block); end

  def keys(*args, &block); end

  def loaded_features(); end

  def loaded_path(); end

  def make_excludes_absolute(); end

  def map(*args, &block); end

  def merge(*args, &block); end

  def path_relative_to_config(path); end

  def patterns_to_exclude(); end

  def patterns_to_include(); end

  def pending_cops(); end

  def possibly_include_hidden?(); end

  def signature(); end

  def smart_loaded_path(); end

  def target_rails_version(); end

  def target_ruby_version(*args, &block); end

  def to_h(*args, &block); end

  def to_hash(*args, &block); end

  def transform_values(*args, &block); end

  def validate(*args, &block); end
  DEFAULT_RAILS_VERSION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Config::CopConfig
  def metadata(); end

  def metadata=(_); end

  def name(); end

  def name=(_); end
end

class RuboCop::Config::CopConfig
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Config
  extend ::Forwardable
  def self.create(hash, path); end
end

class RuboCop::ConfigLoader
  DEFAULT_FILE = ::T.let(nil, ::T.untyped)
  DOTFILE = ::T.let(nil, ::T.untyped)
  RUBOCOP_HOME = ::T.let(nil, ::T.untyped)
  XDG_CONFIG = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigLoader
  extend ::RuboCop::FileFinder
  def self.add_excludes_from_files(config, config_file); end

  def self.add_missing_namespaces(path, hash); end

  def self.clear_options(); end

  def self.configuration_file_for(target_dir); end

  def self.configuration_from_file(config_file); end

  def self.debug(); end

  def self.debug=(debug); end

  def self.debug?(); end

  def self.default_configuration(); end

  def self.default_configuration=(default_configuration); end

  def self.disable_pending_cops(); end

  def self.disable_pending_cops=(disable_pending_cops); end

  def self.enable_pending_cops(); end

  def self.enable_pending_cops=(enable_pending_cops); end

  def self.ignore_parent_exclusion(); end

  def self.ignore_parent_exclusion=(ignore_parent_exclusion); end

  def self.ignore_parent_exclusion?(); end

  def self.load_file(file); end

  def self.load_yaml_configuration(absolute_path); end

  def self.loaded_features(); end

  def self.merge(base_hash, derived_hash); end

  def self.merge_with_default(config, config_file, unset_nil: T.unsafe(nil)); end

  def self.possible_new_cops?(config); end

  def self.project_root(); end

  def self.project_root=(project_root); end

  def self.warn_on_pending_cops(pending_cops); end

  def self.warn_pending_cop(cop); end
end

class RuboCop::ConfigLoaderResolver
  def merge(base_hash, derived_hash, **opts); end

  def merge_with_default(config, config_file, unset_nil:); end

  def override_department_setting_for_cops(base_hash, derived_hash); end

  def resolve_inheritance(path, hash, file, debug); end

  def resolve_inheritance_from_gems(hash); end

  def resolve_requires(path, hash); end
end

class RuboCop::ConfigLoaderResolver
end

class RuboCop::ConfigNotFoundError
end

class RuboCop::ConfigNotFoundError
end

class RuboCop::ConfigObsoletion
  def initialize(config); end

  def reject_obsolete!(); end

  def rules(); end

  def warnings(); end
  COP_RULE_CLASSES = ::T.let(nil, ::T.untyped)
  DEFAULT_RULES_FILE = ::T.let(nil, ::T.untyped)
  PARAMETER_RULE_CLASSES = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigObsoletion::ChangedEnforcedStyles
  def message(); end
  BASE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigObsoletion::ChangedEnforcedStyles
end

class RuboCop::ConfigObsoletion::ChangedParameter
  def message(); end
  BASE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigObsoletion::ChangedParameter
end

class RuboCop::ConfigObsoletion::CopRule
  def initialize(config, old_name); end

  def message(); end

  def old_name(); end

  def warning?(); end
end

class RuboCop::ConfigObsoletion::CopRule
end

class RuboCop::ConfigObsoletion::ExtractedCop
  def department(); end

  def gem(); end

  def initialize(config, old_name, gem); end

  def rule_message(); end
end

class RuboCop::ConfigObsoletion::ExtractedCop
end

class RuboCop::ConfigObsoletion::ParameterRule
  def cop(); end

  def initialize(config, cop, parameter, metadata); end

  def metadata(); end

  def parameter(); end

  def warning?(); end
end

class RuboCop::ConfigObsoletion::ParameterRule
end

class RuboCop::ConfigObsoletion::RemovedCop
  def initialize(config, old_name, metadata); end

  def metadata(); end

  def rule_message(); end
  BASE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigObsoletion::RemovedCop
end

class RuboCop::ConfigObsoletion::RenamedCop
  def initialize(config, old_name, new_name); end

  def new_name(); end

  def rule_message(); end
end

class RuboCop::ConfigObsoletion::RenamedCop
end

class RuboCop::ConfigObsoletion::Rule
  def cop_rule?(); end

  def initialize(config); end

  def parameter_rule?(); end

  def violated?(); end
end

class RuboCop::ConfigObsoletion::Rule
end

class RuboCop::ConfigObsoletion::SplitCop
  def initialize(config, old_name, metadata); end

  def metadata(); end

  def rule_message(); end
end

class RuboCop::ConfigObsoletion::SplitCop
end

class RuboCop::ConfigObsoletion
  def self.files(); end

  def self.files=(files); end

  def self.legacy_cop_names(); end
end

class RuboCop::ConfigRegeneration
  def options(); end
  AUTO_GENERATED_FILE = ::T.let(nil, ::T.untyped)
  COMMAND_REGEX = ::T.let(nil, ::T.untyped)
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigRegeneration
end

class RuboCop::ConfigStore
  def for(file_or_dir); end

  def for_dir(dir); end

  def for_file(file); end

  def for_pwd(); end

  def force_default_config!(); end

  def options_config=(options_config); end
end

class RuboCop::ConfigStore
end

class RuboCop::ConfigValidator
  def for_all_cops(*args, &block); end

  def initialize(config); end

  def smart_loaded_path(*args, &block); end

  def target_ruby_version(); end

  def validate(); end

  def validate_section_presence(name); end
  COMMON_PARAMS = ::T.let(nil, ::T.untyped)
  INTERNAL_PARAMS = ::T.let(nil, ::T.untyped)
  NEW_COPS_VALUES = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigValidator
  extend ::Forwardable
end

module RuboCop::Cop
end

module RuboCop::Cop::Alignment
  SPACE = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Alignment
end

class RuboCop::Cop::AlignmentCorrector
end

class RuboCop::Cop::AlignmentCorrector
  extend ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::Alignment
  def self.align_end(corrector, processed_source, node, align_to); end

  def self.correct(processed_source, node, column_delta); end

  def self.processed_source(); end
end

module RuboCop::Cop::AllowedMethods
end

module RuboCop::Cop::AllowedMethods
end

class RuboCop::Cop::AmbiguousCopName
  def initialize(name, origin, badges); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::AmbiguousCopName
end

module RuboCop::Cop::ArrayMinSize
end

module RuboCop::Cop::ArrayMinSize
end

module RuboCop::Cop::ArraySyntax
end

module RuboCop::Cop::ArraySyntax
end

module RuboCop::Cop::AutoCorrector
  def support_autocorrect?(); end
end

module RuboCop::Cop::AutoCorrector
end

module RuboCop::Cop::AutocorrectLogic
  def autocorrect?(); end

  def autocorrect_enabled?(); end

  def autocorrect_requested?(); end

  def correctable?(); end

  def disable_uncorrectable?(); end

  def safe_autocorrect?(); end
end

module RuboCop::Cop::AutocorrectLogic
end

class RuboCop::Cop::Badge
  def ==(other); end

  def cop_name(); end

  def department(); end

  def eql?(other); end

  def initialize(class_name_parts); end

  def match?(other); end

  def qualified?(); end

  def with_department(department); end
end

class RuboCop::Cop::Badge
  def self.for(class_name); end

  def self.parse(identifier); end
end

class RuboCop::Cop::Base
  include ::RuboCop::AST::Sexp
  include ::RuboCop::Cop::Util
  include ::RuboCop::PathUtil
  include ::RuboCop::Cop::IgnoredNode
  include ::RuboCop::Cop::AutocorrectLogic
  def add_global_offense(message=T.unsafe(nil), severity: T.unsafe(nil)); end

  def add_offense(node_or_range, message: T.unsafe(nil), severity: T.unsafe(nil), &block); end

  def callbacks_needed(); end

  def config(); end

  def config_to_allow_offenses(); end

  def config_to_allow_offenses=(hash); end

  def cop_config(); end

  def cop_name(); end

  def excluded_file?(file); end

  def external_dependency_checksum(); end

  def initialize(config=T.unsafe(nil), options=T.unsafe(nil)); end

  def message(_range=T.unsafe(nil)); end

  def name(); end

  def offenses(); end

  def on_investigation_end(); end

  def on_new_investigation(); end

  def on_other_file(); end

  def processed_source(); end

  def ready(); end

  def relevant_file?(file); end

  def target_rails_version(); end

  def target_ruby_version(); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Base::InvestigationReport
  def cop(); end

  def cop=(_); end

  def corrector(); end

  def corrector=(_); end

  def offenses(); end

  def offenses=(_); end

  def processed_source(); end

  def processed_source=(_); end
end

class RuboCop::Cop::Base::InvestigationReport
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Cop::Base
  extend ::RuboCop::AST::Sexp
  extend ::RuboCop::AST::NodePattern::Macros
  def self.autocorrect_incompatible_with(); end

  def self.badge(); end

  def self.callbacks_needed(); end

  def self.cop_name(); end

  def self.department(); end

  def self.documentation_url(); end

  def self.exclude_from_registry(); end

  def self.inherited(subclass); end

  def self.joining_forces(); end

  def self.lint?(); end

  def self.match?(given_names); end

  def self.support_autocorrect?(); end

  def self.support_multiple_source?(); end
end

module RuboCop::Cop::Bundler
end

class RuboCop::Cop::Bundler::DuplicatedGem
  include ::RuboCop::Cop::RangeHelp
  def gem_declarations(param0); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::DuplicatedGem
end

class RuboCop::Cop::Bundler::GemComment
  include ::RuboCop::Cop::DefNode
  def gem_declaration?(param0=T.unsafe(nil)); end

  def on_send(node); end
  CHECKED_OPTIONS_CONFIG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  VERSION_SPECIFIERS_OPTION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::GemComment
end

class RuboCop::Cop::Bundler::InsecureProtocolSource
  include ::RuboCop::Cop::RangeHelp
  def insecure_protocol_source?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::InsecureProtocolSource
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Bundler::OrderedGems
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::OrderedGemNode
  def autocorrect(node); end

  def gem_declarations(param0); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::OrderedGems
end

module RuboCop::Cop::Bundler
end

module RuboCop::Cop::CheckAssignment
  def on_and_asgn(node); end

  def on_casgn(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_op_asgn(node); end

  def on_or_asgn(node); end

  def on_send(node); end
end

module RuboCop::Cop::CheckAssignment
  def self.extract_rhs(node); end
end

module RuboCop::Cop::CheckLineBreakable
  def extract_breakable_node(node, max); end
end

module RuboCop::Cop::CheckLineBreakable
end

module RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::CodeLength
end

module RuboCop::Cop::CommentsHelp
  include ::RuboCop::Cop::VisibilityHelp
  def source_range_with_comment(node); end
end

module RuboCop::Cop::CommentsHelp
end

class RuboCop::Cop::Commissioner
  include ::RuboCop::AST::Traversal
  def errors(); end

  def initialize(cops, forces=T.unsafe(nil), options=T.unsafe(nil)); end

  def investigate(processed_source); end
end

class RuboCop::Cop::Commissioner::InvestigationReport
  def cop_reports(); end

  def cop_reports=(_); end

  def cops(); end

  def correctors(); end

  def errors(); end

  def errors=(_); end

  def merge(investigation); end

  def offenses(); end

  def offenses_per_cop(); end

  def processed_source(); end

  def processed_source=(_); end
end

class RuboCop::Cop::Commissioner::InvestigationReport
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Cop::Commissioner
end

class RuboCop::Cop::ConditionCorrector
end

class RuboCop::Cop::ConditionCorrector
  def self.correct_negative_condition(corrector, node); end
end

module RuboCop::Cop::ConfigurableEnforcedStyle
  def alternative_style(); end

  def alternative_styles(); end

  def ambiguous_style_detected(*possibilities); end

  def conflicting_styles_detected(); end

  def correct_style_detected(); end

  def detected_style(); end

  def detected_style=(style); end

  def no_acceptable_style!(); end

  def no_acceptable_style?(); end

  def opposite_style_detected(); end

  def style(); end

  def style_configured?(); end

  def style_detected(detected); end

  def style_parameter_name(); end

  def supported_styles(); end

  def unexpected_style_detected(unexpected); end

  def unrecognized_style_detected(); end
end

module RuboCop::Cop::ConfigurableEnforcedStyle
end

module RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def check_name(node, name, name_range); end

  def class_emitter_method?(node, name); end

  def report_opposing_styles(node, name); end

  def valid_name?(node, name, given_style=T.unsafe(nil)); end
end

module RuboCop::Cop::ConfigurableFormatting
end

module RuboCop::Cop::ConfigurableMax
end

module RuboCop::Cop::ConfigurableMax
end

module RuboCop::Cop::ConfigurableNaming
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  FORMATS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::ConfigurableNaming
end

module RuboCop::Cop::ConfigurableNumbering
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  FORMATS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::ConfigurableNumbering
end

class RuboCop::Cop::Cop
  def add_offense(node_or_range, location: T.unsafe(nil), message: T.unsafe(nil), severity: T.unsafe(nil), &block); end

  def corrections(); end

  def find_location(node, loc); end

  def parse(source, path=T.unsafe(nil)); end

  def support_autocorrect?(); end
end

class RuboCop::Cop::Cop::Correction
  def call(corrector); end

  def cop(); end

  def cop=(_); end

  def lambda=(_); end

  def node(); end

  def node=(_); end
end

class RuboCop::Cop::Cop::Correction
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Cop::Cop
  def self.all(); end

  def self.qualified_cop_name(name, origin); end

  def self.registry(); end
end

class RuboCop::Cop::Corrector
  def initialize(source); end

  def remove_leading(node_or_range, size); end

  def remove_preceding(node_or_range, size); end

  def remove_trailing(node_or_range, size); end

  def rewrite(); end
  NOOP_CONSUMER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Corrector
  def self.source_buffer(source); end
end

module RuboCop::Cop::DefNode
  def non_public_modifier?(param0=T.unsafe(nil)); end
  NON_PUBLIC_MODIFIERS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::DefNode
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::Cop::Documentation
end

module RuboCop::Cop::Documentation
  def self.department_to_basename(department); end

  def self.url_for(cop_class); end
end

module RuboCop::Cop::DocumentationComment
  include ::RuboCop::Cop::Style::AnnotationComment
end

module RuboCop::Cop::DocumentationComment
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::Cop::Duplication
end

module RuboCop::Cop::Duplication
end

class RuboCop::Cop::EachToForCorrector
  def call(corrector); end

  def initialize(block_node); end
  CORRECTION_WITHOUT_ARGUMENTS = ::T.let(nil, ::T.untyped)
  CORRECTION_WITH_ARGUMENTS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::EachToForCorrector
  extend ::RuboCop::AST::NodePattern::Macros
end

class RuboCop::Cop::EmptyLineCorrector
end

class RuboCop::Cop::EmptyLineCorrector
  def self.correct(corrector, node); end

  def self.insert_before(corrector, node); end
end

module RuboCop::Cop::EmptyParameter
  def empty_arguments?(param0=T.unsafe(nil)); end
end

module RuboCop::Cop::EmptyParameter
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::EndKeywordAlignment
end

module RuboCop::Cop::EnforceSuperclass
  def on_class(node); end

  def on_send(node); end
end

module RuboCop::Cop::EnforceSuperclass
  def self.included(base); end
end

module RuboCop::Cop::FirstElementLineBreak
end

module RuboCop::Cop::FirstElementLineBreak
end

class RuboCop::Cop::ForToEachCorrector
  def call(corrector); end

  def initialize(for_node); end
  CORRECTION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::ForToEachCorrector
  extend ::RuboCop::AST::NodePattern::Macros
end

class RuboCop::Cop::Force
  def cops(); end

  def initialize(cops); end

  def investigate(_processed_source); end

  def name(); end

  def run_hook(method_name, *args); end
end

class RuboCop::Cop::Force
  def self.all(); end

  def self.force_name(); end

  def self.inherited(subclass); end
end

module RuboCop::Cop::FrozenStringLiteral
  FROZEN_STRING_LITERAL = ::T.let(nil, ::T.untyped)
  FROZEN_STRING_LITERAL_ENABLED = ::T.let(nil, ::T.untyped)
  FROZEN_STRING_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::FrozenStringLiteral
  def self.frozen_string_literal_comment_exists?(); end
end

module RuboCop::Cop::Gemspec
end

class RuboCop::Cop::Gemspec::DuplicatedAssignment
  include ::RuboCop::Cop::RangeHelp
  def assignment_method_declarations(param0); end

  def gem_specification(param0); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::DuplicatedAssignment
end

class RuboCop::Cop::Gemspec::OrderedDependencies
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::OrderedGemNode
  def autocorrect(node); end

  def dependency_declarations(param0); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::OrderedDependencies
end

class RuboCop::Cop::Gemspec::RequiredRubyVersion
  include ::RuboCop::Cop::RangeHelp
  def defined_ruby_version(param0=T.unsafe(nil)); end

  def required_ruby_version(param0); end
  MISSING_MSG = ::T.let(nil, ::T.untyped)
  NOT_EQUAL_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::RequiredRubyVersion
end

class RuboCop::Cop::Gemspec::RubyVersionGlobalsUsage
  def gem_specification?(param0); end

  def on_const(node); end

  def ruby_version?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::RubyVersionGlobalsUsage
end

module RuboCop::Cop::Gemspec
end

class RuboCop::Cop::Generator
  def initialize(name, github_user, output: T.unsafe(nil)); end

  def inject_config(config_file_path: T.unsafe(nil), version_added: T.unsafe(nil)); end

  def inject_require(root_file_path: T.unsafe(nil)); end

  def todo(); end

  def write_source(); end

  def write_spec(); end
  CONFIGURATION_ADDED_MESSAGE = ::T.let(nil, ::T.untyped)
  SOURCE_TEMPLATE = ::T.let(nil, ::T.untyped)
  SPEC_TEMPLATE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Generator::ConfigurationInjector
  def initialize(configuration_file_path:, badge:, version_added: T.unsafe(nil)); end

  def inject(); end
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Generator::ConfigurationInjector
end

class RuboCop::Cop::Generator::RequireFileInjector
  def initialize(source_path:, root_file_path:, output: T.unsafe(nil)); end

  def inject(); end
  REQUIRE_PATH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Generator::RequireFileInjector
end

class RuboCop::Cop::Generator
end

module RuboCop::Cop::HashAlignmentStyles
end

class RuboCop::Cop::HashAlignmentStyles::KeyAlignment
  def checkable_layout?(_node); end

  def deltas(first_pair, current_pair); end

  def deltas_for_first_pair(first_pair, _node); end
end

class RuboCop::Cop::HashAlignmentStyles::KeyAlignment
end

class RuboCop::Cop::HashAlignmentStyles::SeparatorAlignment
  include ::RuboCop::Cop::HashAlignmentStyles::ValueAlignment
  def deltas_for_first_pair(*_nodes); end
end

class RuboCop::Cop::HashAlignmentStyles::SeparatorAlignment
end

class RuboCop::Cop::HashAlignmentStyles::TableAlignment
  include ::RuboCop::Cop::HashAlignmentStyles::ValueAlignment
  def deltas_for_first_pair(first_pair, node); end
end

class RuboCop::Cop::HashAlignmentStyles::TableAlignment
end

module RuboCop::Cop::HashAlignmentStyles::ValueAlignment
  def checkable_layout?(node); end

  def deltas(first_pair, current_pair); end
end

module RuboCop::Cop::HashAlignmentStyles::ValueAlignment
end

module RuboCop::Cop::HashAlignmentStyles
end

module RuboCop::Cop::HashTransformMethod
  def array_receiver?(param0=T.unsafe(nil)); end

  def on_block(node); end

  def on_csend(node); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::HashTransformMethod::Autocorrection
  def block_node(); end

  def block_node=(_); end

  def leading(); end

  def leading=(_); end

  def match(); end

  def match=(_); end

  def set_new_arg_name(transformed_argname, corrector); end

  def set_new_body_expression(transforming_body_expr, corrector); end

  def set_new_method_name(new_method_name, corrector); end

  def strip_prefix_and_suffix(node, corrector); end

  def trailing(); end

  def trailing=(_); end
end

class RuboCop::Cop::HashTransformMethod::Autocorrection
  def self.[](*_); end

  def self.from_each_with_object(node, match); end

  def self.from_hash_brackets_map(node, match); end

  def self.from_map_to_h(node, match); end

  def self.from_to_h(node, match); end

  def self.members(); end
end

class RuboCop::Cop::HashTransformMethod::Captures
  def noop_transformation?(); end

  def transformation_uses_both_args?(); end

  def transformed_argname(); end

  def transformed_argname=(_); end

  def transforming_body_expr(); end

  def transforming_body_expr=(_); end

  def unchanged_body_expr(); end

  def unchanged_body_expr=(_); end
end

class RuboCop::Cop::HashTransformMethod::Captures
  def self.[](*_); end

  def self.members(); end
end

module RuboCop::Cop::HashTransformMethod
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::Cop::Heredoc
  def on_dstr(node); end

  def on_heredoc(_node); end

  def on_str(node); end

  def on_xstr(node); end
  OPENING_DELIMITER = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Heredoc
end

module RuboCop::Cop::IgnoredMethods
  def ignored_method?(name); end

  def ignored_methods(); end
end

module RuboCop::Cop::IgnoredMethods::Config
  def deprecated_key(); end

  def deprecated_key=(deprecated_key); end

  def ignored_methods(**config); end
end

module RuboCop::Cop::IgnoredMethods::Config
end

module RuboCop::Cop::IgnoredMethods
  def self.included(base); end
end

module RuboCop::Cop::IgnoredNode
  def ignore_node(node); end

  def ignored_node?(node); end

  def part_of_ignored_node?(node); end
end

module RuboCop::Cop::IgnoredNode
end

module RuboCop::Cop::IgnoredPattern
end

module RuboCop::Cop::IgnoredPattern
end

module RuboCop::Cop::IntegerNode
end

module RuboCop::Cop::IntegerNode
end

module RuboCop::Cop::Interpolation
  def on_dstr(node); end

  def on_dsym(node); end

  def on_node_with_interpolations(node); end

  def on_regexp(node); end

  def on_xstr(node); end
end

module RuboCop::Cop::Interpolation
end

class RuboCop::Cop::LambdaLiteralToMethodCorrector
  def call(corrector); end

  def initialize(block_node); end
end

class RuboCop::Cop::LambdaLiteralToMethodCorrector
end

module RuboCop::Cop::Layout
end

class RuboCop::Cop::Layout::AccessModifierIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end

  def on_class(node); end

  def on_module(node); end

  def on_sclass(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::AccessModifierIndentation
end

class RuboCop::Cop::Layout::ArgumentAlignment
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_csend(node); end

  def on_send(node); end
  ALIGN_PARAMS_MSG = ::T.let(nil, ::T.untyped)
  FIXED_INDENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ArgumentAlignment
end

class RuboCop::Cop::Layout::ArrayAlignment
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_array(node); end
  ALIGN_ELEMENTS_MSG = ::T.let(nil, ::T.untyped)
  FIXED_INDENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ArrayAlignment
end

class RuboCop::Cop::Layout::AssignmentIndentation
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def check_assignment(node, rhs); end

  def leftmost_multiple_assignment(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::AssignmentIndentation
end

class RuboCop::Cop::Layout::BeginEndAlignment
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_kwbegin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::BeginEndAlignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::BlockAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def block_end_align_target?(param0=T.unsafe(nil), param1); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::BlockAlignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::BlockEndNewline
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::BlockEndNewline
end

class RuboCop::Cop::Layout::CaseIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_case(case_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::CaseIndentation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::ClassStructure
  include ::RuboCop::Cop::VisibilityHelp
  def dynamic_constant?(param0=T.unsafe(nil)); end

  def on_class(class_node); end
  HUMANIZED_NODE_TYPE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ClassStructure
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::ClosingHeredocIndentation
  include ::RuboCop::Cop::Heredoc
  def on_heredoc(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_ARG = ::T.let(nil, ::T.untyped)
  SIMPLE_HEREDOC = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ClosingHeredocIndentation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::ClosingParenthesisIndentation
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_begin(node); end

  def on_csend(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end
  MSG_ALIGN = ::T.let(nil, ::T.untyped)
  MSG_INDENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ClosingParenthesisIndentation
end

class RuboCop::Cop::Layout::CommentIndentation
  include ::RuboCop::Cop::Alignment
  def autocorrect(comment); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::CommentIndentation
end

class RuboCop::Cop::Layout::ConditionPosition
  include ::RuboCop::Cop::RangeHelp
  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ConditionPosition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::DefEndAlignment
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::DefEndAlignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::DotPosition
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Layout::DotPosition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::ElseAlignment
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::CheckAssignment
  def autocorrect(node); end

  def on_case(node); end

  def on_case_match(node); end

  def on_if(node, base=T.unsafe(nil)); end

  def on_rescue(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ElseAlignment
end

class RuboCop::Cop::Layout::EmptyComment
  include ::RuboCop::Cop::RangeHelp
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyComment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLineAfterGuardClause
  include ::RuboCop::Cop::RangeHelp
  def on_if(node); end
  END_OF_HEREDOC_LINE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineAfterGuardClause
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLineAfterMagicComment
  include ::RuboCop::Cop::RangeHelp
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineAfterMagicComment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLineAfterMultilineCondition
  include ::RuboCop::Cop::RangeHelp
  def on_case(node); end

  def on_if(node); end

  def on_rescue(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineAfterMultilineCondition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLineBetweenDefs
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(corrector, prev_def, node); end

  def check_defs(nodes); end

  def on_begin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineBetweenDefs
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLines
  include ::RuboCop::Cop::RangeHelp
  LINE_OFFSET = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLines
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end

  def on_class(node); end

  def on_module(node); end

  def on_sclass(node); end

  def on_send(node); end
  MSG_AFTER = ::T.let(nil, ::T.untyped)
  MSG_AFTER_FOR_ONLY_BEFORE = ::T.let(nil, ::T.untyped)
  MSG_BEFORE_AND_AFTER = ::T.let(nil, ::T.untyped)
  MSG_BEFORE_FOR_ONLY_BEFORE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLinesAroundArguments
  include ::RuboCop::Cop::RangeHelp
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundArguments
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLinesAroundAttributeAccessor
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::AllowedMethods
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundAttributeAccessor
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLinesAroundBeginBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_kwbegin(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundBeginBody
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLinesAroundBlockBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundBlockBody
  extend ::RuboCop::Cop::AutoCorrector
end

module RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def constant_definition?(param0=T.unsafe(nil)); end

  def empty_line_required?(param0=T.unsafe(nil)); end
  MSG_DEFERRED = ::T.let(nil, ::T.untyped)
  MSG_EXTRA = ::T.let(nil, ::T.untyped)
  MSG_MISSING = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Layout::EmptyLinesAroundBody
  extend ::RuboCop::AST::NodePattern::Macros
end

class RuboCop::Cop::Layout::EmptyLinesAroundClassBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_class(node); end

  def on_sclass(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundClassBody
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLinesAroundExceptionHandlingKeywords
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_def(node); end

  def on_defs(node); end

  def on_kwbegin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundExceptionHandlingKeywords
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLinesAroundMethodBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_def(node); end

  def on_defs(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundMethodBody
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLinesAroundModuleBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_module(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundModuleBody
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EndAlignment
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_case(node); end

  def on_class(node); end

  def on_if(node); end

  def on_module(node); end

  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Layout::EndAlignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EndOfLine
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def offense_message(line); end

  def unimportant_missing_cr?(index, last_line, line); end
  MSG_DETECTED = ::T.let(nil, ::T.untyped)
  MSG_MISSING = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EndOfLine
end

class RuboCop::Cop::Layout::ExtraSpacing
  include ::RuboCop::Cop::PrecedingFollowingAlignment
  include ::RuboCop::Cop::RangeHelp
  MSG_UNALIGNED_ASGN = ::T.let(nil, ::T.untyped)
  MSG_UNNECESSARY = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ExtraSpacing
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::FirstArgumentIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def eligible_method_call?(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstArgumentIndentation
end

class RuboCop::Cop::Layout::FirstArrayElementIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineElementIndentation
  def autocorrect(node); end

  def on_array(node); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstArrayElementIndentation
end

class RuboCop::Cop::Layout::FirstArrayElementLineBreak
  include ::RuboCop::Cop::FirstElementLineBreak
  def on_array(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstArrayElementLineBreak
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::FirstHashElementIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineElementIndentation
  def autocorrect(node); end

  def on_csend(node); end

  def on_hash(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstHashElementIndentation
end

class RuboCop::Cop::Layout::FirstHashElementLineBreak
  include ::RuboCop::Cop::FirstElementLineBreak
  def on_hash(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstHashElementLineBreak
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::FirstMethodArgumentLineBreak
  include ::RuboCop::Cop::FirstElementLineBreak
  def on_csend(node); end

  def on_send(node); end

  def on_super(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstMethodArgumentLineBreak
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::FirstMethodParameterLineBreak
  include ::RuboCop::Cop::FirstElementLineBreak
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstMethodParameterLineBreak
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::FirstParameterIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineElementIndentation
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstParameterIndentation
end

class RuboCop::Cop::Layout::HashAlignment
  include ::RuboCop::Cop::HashAlignmentStyles
  include ::RuboCop::Cop::RangeHelp
  def column_deltas(); end

  def column_deltas=(column_deltas); end

  def offences_by(); end

  def offences_by=(offences_by); end

  def on_hash(node); end

  def on_send(node); end

  def on_super(node); end

  def on_yield(node); end
  MESSAGES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::HashAlignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::HeredocArgumentClosingParenthesis
  include ::RuboCop::Cop::RangeHelp
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::HeredocArgumentClosingParenthesis
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::HeredocIndentation
  include ::RuboCop::Cop::Heredoc
  def on_heredoc(node); end
  TYPE_MSG = ::T.let(nil, ::T.untyped)
  WIDTH_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::HeredocIndentation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::IndentationConsistency
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_begin(node); end

  def on_kwbegin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentationConsistency
end

class RuboCop::Cop::Layout::IndentationStyle
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentationStyle
end

class RuboCop::Cop::Layout::IndentationWidth
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::IgnoredPattern
  def access_modifier?(param0=T.unsafe(nil)); end

  def autocorrect(node); end

  def on_block(node); end

  def on_case(case_node); end

  def on_class(node); end

  def on_csend(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_ensure(node); end

  def on_for(node); end

  def on_if(node, base=T.unsafe(nil)); end

  def on_kwbegin(node); end

  def on_module(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_sclass(node); end

  def on_until(node, base=T.unsafe(nil)); end

  def on_while(node, base=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentationWidth
end

class RuboCop::Cop::Layout::InitialIndentation
  include ::RuboCop::Cop::RangeHelp
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::InitialIndentation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::LeadingCommentSpace
  include ::RuboCop::Cop::RangeHelp
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::LeadingCommentSpace
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::LeadingEmptyLines
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::LeadingEmptyLines
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::LineLength
  include ::RuboCop::Cop::CheckLineBreakable
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::IgnoredPattern
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::LineLengthHelp
  def on_array(node); end

  def on_block(node); end

  def on_hash(node); end

  def on_potential_breakable_node(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::LineLength
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::MultilineArrayBraceLayout
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_array(node); end
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineArrayBraceLayout
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::MultilineArrayLineBreaks
  include ::RuboCop::Cop::MultilineElementLineBreaks
  def on_array(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineArrayLineBreaks
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::MultilineAssignmentLayout
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def check_assignment(node, rhs); end

  def check_by_enforced_style(node, rhs); end

  def check_new_line_offense(node, rhs); end

  def check_same_line_offense(node, rhs); end
  NEW_LINE_OFFENSE = ::T.let(nil, ::T.untyped)
  SAME_LINE_OFFENSE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineAssignmentLayout
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::MultilineBlockLayout
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end
  ARG_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PIPE_SIZE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineBlockLayout
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::MultilineHashBraceLayout
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_hash(node); end
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineHashBraceLayout
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::MultilineHashKeyLineBreaks
  include ::RuboCop::Cop::MultilineElementLineBreaks
  def on_hash(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineHashKeyLineBreaks
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::MultilineMethodArgumentLineBreaks
  include ::RuboCop::Cop::MultilineElementLineBreaks
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodArgumentLineBreaks
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::MultilineMethodCallBraceLayout
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_send(node); end
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodCallBraceLayout
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::MultilineMethodCallIndentation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::MultilineExpressionIndentation
  def autocorrect(node); end

  def validate_config(); end
end

class RuboCop::Cop::Layout::MultilineMethodCallIndentation
end

class RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_def(node); end

  def on_defs(node); end
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::MultilineOperationIndentation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::MultilineExpressionIndentation
  def autocorrect(node); end

  def on_and(node); end

  def on_or(node); end

  def validate_config(); end
end

class RuboCop::Cop::Layout::MultilineOperationIndentation
end

class RuboCop::Cop::Layout::ParameterAlignment
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  ALIGN_PARAMS_MSG = ::T.let(nil, ::T.untyped)
  FIXED_INDENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ParameterAlignment
end

class RuboCop::Cop::Layout::RescueEnsureAlignment
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_ensure(node); end

  def on_resbody(node); end
  ALTERNATIVE_ACCESS_MODIFIERS = ::T.let(nil, ::T.untyped)
  ANCESTOR_TYPES = ::T.let(nil, ::T.untyped)
  ANCESTOR_TYPES_WITH_ACCESS_MODIFIERS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RUBY_2_5_ANCESTOR_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::RescueEnsureAlignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceAfterColon
  def on_kwoptarg(node); end

  def on_pair(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterColon
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceAfterComma
  include ::RuboCop::Cop::SpaceAfterPunctuation
  def kind(token); end

  def space_style_before_rcurly(); end
end

class RuboCop::Cop::Layout::SpaceAfterComma
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceAfterMethodName
  include ::RuboCop::Cop::RangeHelp
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterMethodName
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceAfterNot
  include ::RuboCop::Cop::RangeHelp
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterNot
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceAfterSemicolon
  include ::RuboCop::Cop::SpaceAfterPunctuation
  def kind(token); end

  def space_style_before_rcurly(); end
end

class RuboCop::Cop::Layout::SpaceAfterSemicolon
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceAroundBlockParameters
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end
end

class RuboCop::Cop::Layout::SpaceAroundBlockParameters
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceAroundEqualsInParameterDefault
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_optarg(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundEqualsInParameterDefault
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceAroundKeyword
  def on_and(node); end

  def on_block(node); end

  def on_break(node); end

  def on_case(node); end

  def on_defined?(node); end

  def on_ensure(node); end

  def on_for(node); end

  def on_if(node); end

  def on_kwbegin(node); end

  def on_next(node); end

  def on_or(node); end

  def on_postexe(node); end

  def on_preexe(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_return(node); end

  def on_send(node); end

  def on_super(node); end

  def on_until(node); end

  def on_when(node); end

  def on_while(node); end

  def on_yield(node); end

  def on_zsuper(node); end
  ACCEPT_LEFT_PAREN = ::T.let(nil, ::T.untyped)
  ACCEPT_LEFT_SQUARE_BRACKET = ::T.let(nil, ::T.untyped)
  ACCEPT_NAMESPACE_OPERATOR = ::T.let(nil, ::T.untyped)
  DO = ::T.let(nil, ::T.untyped)
  MSG_AFTER = ::T.let(nil, ::T.untyped)
  MSG_BEFORE = ::T.let(nil, ::T.untyped)
  NAMESPACE_OPERATOR = ::T.let(nil, ::T.untyped)
  SAFE_NAVIGATION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundKeyword
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceAroundMethodCallOperator
  include ::RuboCop::Cop::RangeHelp
  def on_const(node); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  SPACES_REGEXP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundMethodCallOperator
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceAroundOperators
  include ::RuboCop::Cop::PrecedingFollowingAlignment
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::RationalLiteral
  def on_and(node); end

  def on_and_asgn(node); end

  def on_assignment(node); end

  def on_binary(node); end

  def on_casgn(node); end

  def on_class(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_if(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_op_asgn(node); end

  def on_or(node); end

  def on_or_asgn(node); end

  def on_pair(node); end

  def on_resbody(node); end

  def on_send(node); end

  def on_special_asgn(node); end
  EXCESSIVE_SPACE = ::T.let(nil, ::T.untyped)
  IRREGULAR_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundOperators
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceBeforeBlockBraces
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end
  DETECTED_MSG = ::T.let(nil, ::T.untyped)
  MISSING_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeBlockBraces
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceBeforeComma
  include ::RuboCop::Cop::SpaceBeforePunctuation
  include ::RuboCop::Cop::RangeHelp
  def kind(token); end
end

class RuboCop::Cop::Layout::SpaceBeforeComma
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceBeforeComment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeComment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceBeforeFirstArg
  include ::RuboCop::Cop::PrecedingFollowingAlignment
  include ::RuboCop::Cop::RangeHelp
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeFirstArg
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceBeforeSemicolon
  include ::RuboCop::Cop::SpaceBeforePunctuation
  include ::RuboCop::Cop::RangeHelp
  def kind(token); end
end

class RuboCop::Cop::Layout::SpaceBeforeSemicolon
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceInLambdaLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_send(node); end
  MSG_REQUIRE_NO_SPACE = ::T.let(nil, ::T.untyped)
  MSG_REQUIRE_SPACE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInLambdaLiteral
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceInsideArrayLiteralBrackets
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_array(node); end
  EMPTY_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideArrayLiteralBrackets
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceInsideArrayPercentLiteral
  include ::RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_array(node); end

  def on_percent_literal(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MULTIPLE_SPACES_BETWEEN_ITEMS_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideArrayPercentLiteral
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceInsideBlockBraces
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end
end

class RuboCop::Cop::Layout::SpaceInsideBlockBraces
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceInsideHashLiteralBraces
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_hash(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideHashLiteralBraces
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceInsideParens
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  MSG = ::T.let(nil, ::T.untyped)
  MSG_SPACE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideParens
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters
  include ::RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_array(node); end

  def on_percent_literal(node); end

  def on_xstr(node); end
  BEGIN_REGEX = ::T.let(nil, ::T.untyped)
  END_REGEX = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceInsideRangeLiteral
  def on_erange(node); end

  def on_irange(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideRangeLiteral
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceInsideReferenceBrackets
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_send(node); end
  EMPTY_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideReferenceBrackets
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceInsideStringInterpolation
  include ::RuboCop::Cop::Interpolation
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_interpolation(begin_node); end
  NO_SPACE_MSG = ::T.let(nil, ::T.untyped)
  SPACE_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideStringInterpolation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::TrailingEmptyLines
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Layout::TrailingEmptyLines
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::TrailingWhitespace
  include ::RuboCop::Cop::RangeHelp
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::TrailingWhitespace
  extend ::RuboCop::Cop::AutoCorrector
end

module RuboCop::Cop::Layout
end

module RuboCop::Cop::Legacy
end

class RuboCop::Cop::Legacy::CorrectionsProxy
  def <<(callable); end

  def concat(corrections); end

  def corrector(); end

  def empty?(); end

  def initialize(corrector); end
end

class RuboCop::Cop::Legacy::CorrectionsProxy
end

module RuboCop::Cop::Legacy
end

class RuboCop::Cop::LineBreakCorrector
end

class RuboCop::Cop::LineBreakCorrector
  extend ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::TrailingBody
  extend ::RuboCop::Cop::Util
  extend ::RuboCop::PathUtil
  def self.break_line_before(range:, node:, corrector:, configured_width:, indent_steps: T.unsafe(nil)); end

  def self.correct_trailing_body(configured_width:, corrector:, node:, processed_source:); end

  def self.move_comment(eol_comment:, node:, corrector:); end

  def self.processed_source(); end
end

module RuboCop::Cop::LineLengthHelp
end

module RuboCop::Cop::LineLengthHelp
end

module RuboCop::Cop::Lint
end

class RuboCop::Cop::Lint::AmbiguousBlockAssociation
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousBlockAssociation
end

class RuboCop::Cop::Lint::AmbiguousOperator
  AMBIGUITIES = ::T.let(nil, ::T.untyped)
  MSG_FORMAT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousOperator
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::AmbiguousRegexpLiteral
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousRegexpLiteral
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::AssignmentInCondition
  include ::RuboCop::Cop::SafeAssignment
  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
  ASGN_TYPES = ::T.let(nil, ::T.untyped)
  MSG_WITHOUT_SAFE_ASSIGNMENT_ALLOWED = ::T.let(nil, ::T.untyped)
  MSG_WITH_SAFE_ASSIGNMENT_ALLOWED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AssignmentInCondition
end

class RuboCop::Cop::Lint::BigDecimalNew
  def big_decimal_new(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::BigDecimalNew
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::BinaryOperatorWithIdenticalOperands
  def on_and(node); end

  def on_or(node); end

  def on_send(node); end
  MATH_OPERATORS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::BinaryOperatorWithIdenticalOperands
end

class RuboCop::Cop::Lint::BooleanSymbol
  def boolean_symbol?(param0=T.unsafe(nil)); end

  def on_sym(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::BooleanSymbol
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::CircularArgumentReference
  def on_kwoptarg(node); end

  def on_optarg(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::CircularArgumentReference
end

class RuboCop::Cop::Lint::ConstantDefinitionInBlock
  include ::RuboCop::Cop::AllowedMethods
  def constant_assigned_in_block?(param0=T.unsafe(nil)); end

  def module_defined_in_block?(param0=T.unsafe(nil)); end

  def on_casgn(node); end

  def on_class(node); end

  def on_module(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ConstantDefinitionInBlock
end

class RuboCop::Cop::Lint::ConstantResolution
  def on_const(node); end

  def unqualified_const?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ConstantResolution
end

class RuboCop::Cop::Lint::Debugger
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Debugger
end

class RuboCop::Cop::Lint::DeprecatedClassMethods
  def on_send(node); end
  DEPRECATED_METHODS_OBJECT = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DeprecatedClassMethods::DeprecatedClassMethod
  include ::RuboCop::AST::Sexp
  def class_constant(); end

  def class_nodes(); end

  def deprecated_method(); end

  def initialize(deprecated:, replacement:, class_constant: T.unsafe(nil)); end

  def replacement_method(); end
end

class RuboCop::Cop::Lint::DeprecatedClassMethods::DeprecatedClassMethod
end

class RuboCop::Cop::Lint::DeprecatedClassMethods
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::DeprecatedOpenSSLConstant
  include ::RuboCop::Cop::RangeHelp
  def algorithm_const(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DeprecatedOpenSSLConstant
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::DisjunctiveAssignmentInConstructor
  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DisjunctiveAssignmentInConstructor
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::DuplicateBranch
  include ::RuboCop::Cop::RescueNode
  def on_branching_statement(node); end

  def on_case(node); end

  def on_if(node); end

  def on_rescue(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateBranch
end

class RuboCop::Cop::Lint::DuplicateCaseCondition
  def on_case(case_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateCaseCondition
end

class RuboCop::Cop::Lint::DuplicateElsifCondition
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateElsifCondition
end

class RuboCop::Cop::Lint::DuplicateHashKey
  include ::RuboCop::Cop::Duplication
  def on_hash(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateHashKey
end

class RuboCop::Cop::Lint::DuplicateMethods
  def alias_method?(param0=T.unsafe(nil)); end

  def method_alias?(param0=T.unsafe(nil)); end

  def on_alias(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end

  def sym_name(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateMethods
end

class RuboCop::Cop::Lint::DuplicateRegexpCharacterClassElement
  include ::RuboCop::Cop::RangeHelp
  def each_repeated_character_class_element_loc(node); end

  def on_regexp(node); end
  MSG_REPEATED_ELEMENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateRegexpCharacterClassElement
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::DuplicateRequire
  def on_send(node); end

  def require_call?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  REQUIRE_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateRequire
end

class RuboCop::Cop::Lint::DuplicateRescueException
  include ::RuboCop::Cop::RescueNode
  def on_rescue(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateRescueException
end

class RuboCop::Cop::Lint::EachWithObjectArgument
  def each_with_object?(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EachWithObjectArgument
end

class RuboCop::Cop::Lint::ElseLayout
  include ::RuboCop::Cop::RangeHelp
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ElseLayout
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::EmptyBlock
  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyBlock
end

class RuboCop::Cop::Lint::EmptyClass
  def on_class(node); end

  def on_sclass(node); end
  CLASS_MSG = ::T.let(nil, ::T.untyped)
  METACLASS_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyClass
end

class RuboCop::Cop::Lint::EmptyConditionalBody
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyConditionalBody
end

class RuboCop::Cop::Lint::EmptyEnsure
  def on_ensure(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyEnsure
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::EmptyExpression
  def on_begin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyExpression
end

class RuboCop::Cop::Lint::EmptyFile
  include ::RuboCop::Cop::RangeHelp
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyFile
end

class RuboCop::Cop::Lint::EmptyInterpolation
  include ::RuboCop::Cop::Interpolation
  def on_interpolation(begin_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyInterpolation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::EmptyWhen
  def on_case(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyWhen
end

class RuboCop::Cop::Lint::EnsureReturn
  include ::RuboCop::Cop::RangeHelp
  def on_ensure(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EnsureReturn
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::ErbNewArguments
  include ::RuboCop::Cop::RangeHelp
  def erb_new_with_non_keyword_arguments(param0=T.unsafe(nil)); end

  def on_send(node); end
  MESSAGES = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ErbNewArguments
  extend ::RuboCop::Cop::TargetRubyVersion
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::FlipFlop
  def on_eflipflop(node); end

  def on_iflipflop(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FlipFlop
end

class RuboCop::Cop::Lint::FloatComparison
  def on_send(node); end
  EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
  FLOAT_INSTANCE_METHODS = ::T.let(nil, ::T.untyped)
  FLOAT_RETURNING_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FloatComparison
end

class RuboCop::Cop::Lint::FloatOutOfRange
  def on_float(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FloatOutOfRange
end

class RuboCop::Cop::Lint::FormatParameterMismatch
  def called_on_string?(param0=T.unsafe(nil)); end

  def on_send(node); end
  KERNEL = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  MSG_INVALID = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  SHOVEL = ::T.let(nil, ::T.untyped)
  STRING_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FormatParameterMismatch
end

class RuboCop::Cop::Lint::HashCompareByIdentity
  def id_as_hash_key?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::HashCompareByIdentity
end

class RuboCop::Cop::Lint::HeredocMethodCallPosition
  include ::RuboCop::Cop::RangeHelp
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::HeredocMethodCallPosition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::IdentityComparison
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::IdentityComparison
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::ImplicitStringConcatenation
  def on_dstr(node); end
  FOR_ARRAY = ::T.let(nil, ::T.untyped)
  FOR_METHOD = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ImplicitStringConcatenation
end

class RuboCop::Cop::Lint::IneffectiveAccessModifier
  def on_class(node); end

  def on_module(node); end

  def private_class_methods(param0); end
  ALTERNATIVE_PRIVATE = ::T.let(nil, ::T.untyped)
  ALTERNATIVE_PROTECTED = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::IneffectiveAccessModifier
end

class RuboCop::Cop::Lint::InheritException
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def class_new_call?(param0=T.unsafe(nil)); end

  def on_class(node); end

  def on_send(node); end
  ILLEGAL_CLASSES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PREFERRED_BASE_CLASS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::InheritException
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::InterpolationCheck
  def on_str(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::InterpolationCheck
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::LiteralAsCondition
  include ::RuboCop::Cop::RangeHelp
  def message(node); end

  def on_case(case_node); end

  def on_if(node); end

  def on_send(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::LiteralAsCondition
end

class RuboCop::Cop::Lint::LiteralInInterpolation
  include ::RuboCop::Cop::Interpolation
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_interpolation(begin_node); end
  COMPOSITE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::LiteralInInterpolation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::Loop
  def on_until_post(node); end

  def on_while_post(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Loop
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::MissingCopEnableDirective
  include ::RuboCop::Cop::RangeHelp
  MSG = ::T.let(nil, ::T.untyped)
  MSG_BOUND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MissingCopEnableDirective
end

class RuboCop::Cop::Lint::MissingSuper
  def on_def(node); end

  def on_defs(node); end
  CALLBACKS = ::T.let(nil, ::T.untyped)
  CALLBACK_MSG = ::T.let(nil, ::T.untyped)
  CLASS_LIFECYCLE_CALLBACKS = ::T.let(nil, ::T.untyped)
  CONSTRUCTOR_MSG = ::T.let(nil, ::T.untyped)
  METHOD_LIFECYCLE_CALLBACKS = ::T.let(nil, ::T.untyped)
  STATELESS_CLASSES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MissingSuper
end

class RuboCop::Cop::Lint::MixedRegexpCaptureTypes
  def on_regexp(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MixedRegexpCaptureTypes
end

class RuboCop::Cop::Lint::MultipleComparison
  def multiple_compare?(param0=T.unsafe(nil)); end

  def on_send(node); end
  COMPARISON_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MultipleComparison
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::NestedMethodDefinition
  def class_or_module_or_struct_new_call?(param0=T.unsafe(nil)); end

  def eval_call?(param0=T.unsafe(nil)); end

  def exec_call?(param0=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NestedMethodDefinition
end

class RuboCop::Cop::Lint::NestedPercentLiteral
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_array(node); end

  def on_percent_literal(node); end
  MSG = ::T.let(nil, ::T.untyped)
  PERCENT_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
  REGEXES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NestedPercentLiteral
end

class RuboCop::Cop::Lint::NextWithoutAccumulator
  def on_block(node); end

  def on_body_of_reduce(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NextWithoutAccumulator
end

class RuboCop::Cop::Lint::NoReturnInBeginEndBlocks
  def on_lvasgn(node); end

  def on_op_asgn(node); end

  def on_or_asgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NoReturnInBeginEndBlocks
end

class RuboCop::Cop::Lint::NonDeterministicRequireOrder
  def loop_variable(param0=T.unsafe(nil)); end

  def method_require?(param0=T.unsafe(nil)); end

  def on_block(node); end

  def on_block_pass(node); end

  def unsorted_dir_block?(param0=T.unsafe(nil)); end

  def unsorted_dir_each?(param0=T.unsafe(nil)); end

  def unsorted_dir_each_pass?(param0=T.unsafe(nil)); end

  def unsorted_dir_glob_pass?(param0=T.unsafe(nil)); end

  def var_is_required?(param0, param1); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NonDeterministicRequireOrder
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::NonLocalExitFromIterator
  def chained_send?(param0=T.unsafe(nil)); end

  def define_method?(param0=T.unsafe(nil)); end

  def on_return(return_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NonLocalExitFromIterator
end

class RuboCop::Cop::Lint::NumberConversion
  include ::RuboCop::Cop::IgnoredMethods
  def on_send(node); end

  def to_method(param0=T.unsafe(nil)); end
  CONVERSION_METHOD_CLASS_MAPPING = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NumberConversion
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::IgnoredMethods::Config
end

class RuboCop::Cop::Lint::OrderedMagicComments
  include ::RuboCop::Cop::FrozenStringLiteral
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::OrderedMagicComments
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::OutOfRangeRegexpRef
  def after_send(node); end

  def on_match_with_lvasgn(node); end

  def on_nth_ref(node); end

  def on_when(node); end
  MSG = ::T.let(nil, ::T.untyped)
  REGEXP_ARGUMENT_METHODS = ::T.let(nil, ::T.untyped)
  REGEXP_CAPTURE_METHODS = ::T.let(nil, ::T.untyped)
  REGEXP_RECEIVER_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::OutOfRangeRegexpRef
end

class RuboCop::Cop::Lint::ParenthesesAsGroupedExpression
  include ::RuboCop::Cop::RangeHelp
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ParenthesesAsGroupedExpression
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::PercentStringArray
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_array(node); end

  def on_percent_literal(node); end
  LEADING_QUOTE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  QUOTES_AND_COMMAS = ::T.let(nil, ::T.untyped)
  TRAILING_QUOTE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::PercentStringArray
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::PercentSymbolArray
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_array(node); end

  def on_percent_literal(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::PercentSymbolArray
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RaiseException
  def exception?(param0=T.unsafe(nil)); end

  def exception_new_with_message?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RaiseException
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RandOne
  def on_send(node); end

  def rand_one?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RandOne
end

class RuboCop::Cop::Lint::RedundantCopDisableDirective
  include ::RuboCop::Cop::RangeHelp
  def initialize(config=T.unsafe(nil), options=T.unsafe(nil), offenses=T.unsafe(nil)); end

  def offenses_to_check(); end

  def offenses_to_check=(offenses_to_check); end
  COP_NAME = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantCopDisableDirective
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RedundantCopEnableDirective
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantCopEnableDirective
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RedundantRequireStatement
  include ::RuboCop::Cop::RangeHelp
  def on_send(node); end

  def unnecessary_require_statement?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantRequireStatement
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RedundantSafeNavigation
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::RangeHelp
  def on_csend(node); end

  def respond_to_nil_specific_method?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  NIL_SPECIFIC_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantSafeNavigation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RedundantSplatExpansion
  def array_new?(param0=T.unsafe(nil)); end

  def literal_expansion(param0=T.unsafe(nil)); end

  def on_splat(node); end
  ARRAY_PARAM_MSG = ::T.let(nil, ::T.untyped)
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PERCENT_CAPITAL_I = ::T.let(nil, ::T.untyped)
  PERCENT_CAPITAL_W = ::T.let(nil, ::T.untyped)
  PERCENT_I = ::T.let(nil, ::T.untyped)
  PERCENT_W = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantSplatExpansion
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RedundantStringCoercion
  include ::RuboCop::Cop::Interpolation
  def on_interpolation(begin_node); end

  def to_s_without_args?(param0=T.unsafe(nil)); end
  MSG_DEFAULT = ::T.let(nil, ::T.untyped)
  MSG_SELF = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantStringCoercion
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RedundantWithIndex
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end

  def redundant_with_index?(param0=T.unsafe(nil)); end
  MSG_EACH_WITH_INDEX = ::T.let(nil, ::T.untyped)
  MSG_WITH_INDEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantWithIndex
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RedundantWithObject
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end

  def redundant_with_object?(param0=T.unsafe(nil)); end
  MSG_EACH_WITH_OBJECT = ::T.let(nil, ::T.untyped)
  MSG_WITH_OBJECT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantWithObject
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RegexpAsCondition
  def on_match_current_line(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RegexpAsCondition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RequireParentheses
  include ::RuboCop::Cop::RangeHelp
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RequireParentheses
end

class RuboCop::Cop::Lint::RescueException
  def on_resbody(node); end

  def targets_exception?(rescue_arg_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RescueException
end

class RuboCop::Cop::Lint::RescueType
  def autocorrect(corrector, node); end

  def on_resbody(node); end
  INVALID_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RescueType
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::ReturnInVoidContext
  def on_return(return_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ReturnInVoidContext
end

class RuboCop::Cop::Lint::SafeNavigationChain
  include ::RuboCop::Cop::NilMethods
  include ::RuboCop::Cop::AllowedMethods
  def bad_method?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SafeNavigationChain
end

class RuboCop::Cop::Lint::SafeNavigationConsistency
  include ::RuboCop::Cop::NilMethods
  include ::RuboCop::Cop::AllowedMethods
  def check(node); end

  def on_csend(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SafeNavigationConsistency
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::SafeNavigationWithEmpty
  def on_if(node); end

  def safe_navigation_empty_in_conditional?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SafeNavigationWithEmpty
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::ScriptPermission
  MSG = ::T.let(nil, ::T.untyped)
  SHEBANG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ScriptPermission
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::SelfAssignment
  def on_and_asgn(node); end

  def on_casgn(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_or_asgn(node); end
  ASSIGNMENT_TYPE_TO_RHS_TYPE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SelfAssignment
end

class RuboCop::Cop::Lint::SendWithMixinArgument
  include ::RuboCop::Cop::RangeHelp
  def on_send(node); end

  def send_with_mixin_argument?(param0=T.unsafe(nil)); end
  MIXIN_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  SEND_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SendWithMixinArgument
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::ShadowedArgument
  def after_leaving_scope(scope, _variable_table); end

  def uses_var?(param0, param1); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ShadowedArgument
end

class RuboCop::Cop::Lint::ShadowedException
  include ::RuboCop::Cop::RescueNode
  include ::RuboCop::Cop::RangeHelp
  def on_rescue(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ShadowedException
end

class RuboCop::Cop::Lint::ShadowingOuterLocalVariable
  def before_declaring_variable(variable, variable_table); end

  def ractor_block?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ShadowingOuterLocalVariable
end

class RuboCop::Cop::Lint::StructNewOverride
  def on_send(node); end

  def struct_new(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  STRUCT_MEMBER_NAME_TYPES = ::T.let(nil, ::T.untyped)
  STRUCT_METHOD_NAMES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::StructNewOverride
end

class RuboCop::Cop::Lint::SuppressedException
  def on_resbody(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SuppressedException
end

class RuboCop::Cop::Lint::Syntax
end

class RuboCop::Cop::Lint::Syntax
end

class RuboCop::Cop::Lint::ToEnumArguments
  def enum_conversion_call?(param0=T.unsafe(nil)); end

  def method_name?(param0=T.unsafe(nil), param1); end

  def on_send(node); end

  def passing_keyword_arg?(param0=T.unsafe(nil), param1); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ToEnumArguments
end

class RuboCop::Cop::Lint::ToJSON
  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ToJSON
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::TopLevelReturnWithArgument
  def on_return(return_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::TopLevelReturnWithArgument
end

class RuboCop::Cop::Lint::TrailingCommaInAttributeDeclaration
  include ::RuboCop::Cop::RangeHelp
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::TrailingCommaInAttributeDeclaration
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::UnderscorePrefixedVariableName
  def after_leaving_scope(scope, _variable_table); end

  def check_variable(variable); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnderscorePrefixedVariableName
end

class RuboCop::Cop::Lint::UnexpectedBlockArity
  def on_block(node); end

  def on_numblock(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnexpectedBlockArity
end

class RuboCop::Cop::Lint::UnifiedInteger
  def fixnum_or_bignum_const(param0=T.unsafe(nil)); end

  def on_const(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnifiedInteger
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::UnmodifiedReduceAccumulator
  def accumulator_index?(param0=T.unsafe(nil), param1); end

  def element_modified?(param0, param1); end

  def expression_values(param0); end

  def lvar_used?(param0=T.unsafe(nil), param1); end

  def on_block(node); end

  def on_numblock(node); end

  def reduce_with_block?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_INDEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnmodifiedReduceAccumulator
end

class RuboCop::Cop::Lint::UnreachableCode
  def flow_command?(param0=T.unsafe(nil)); end

  def on_begin(node); end

  def on_kwbegin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnreachableCode
end

class RuboCop::Cop::Lint::UnreachableLoop
  def break_command?(param0=T.unsafe(nil)); end

  def on_block(node); end

  def on_for(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnreachableLoop
end

module RuboCop::Cop::Lint::UnusedArgument
  def after_leaving_scope(scope, _variable_table); end
end

module RuboCop::Cop::Lint::UnusedArgument
  extend ::RuboCop::AST::NodePattern::Macros
end

class RuboCop::Cop::Lint::UnusedBlockArgument
  include ::RuboCop::Cop::Lint::UnusedArgument
end

class RuboCop::Cop::Lint::UnusedBlockArgument
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::UnusedMethodArgument
  include ::RuboCop::Cop::Lint::UnusedArgument
  def not_implemented?(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::UnusedMethodArgument
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::UriEscapeUnescape
  def on_send(node); end

  def uri_escape_unescape?(param0=T.unsafe(nil)); end
  ALTERNATE_METHODS_OF_URI_ESCAPE = ::T.let(nil, ::T.untyped)
  ALTERNATE_METHODS_OF_URI_UNESCAPE = ::T.let(nil, ::T.untyped)
  METHOD_NAMES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UriEscapeUnescape
end

class RuboCop::Cop::Lint::UriRegexp
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  URI_CONSTANTS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UriRegexp
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::UselessAccessModifier
  include ::RuboCop::Cop::RangeHelp
  def class_or_instance_eval?(param0=T.unsafe(nil)); end

  def class_or_module_or_struct_new_call?(param0=T.unsafe(nil)); end

  def dynamic_method_definition?(param0=T.unsafe(nil)); end

  def on_block(node); end

  def on_class(node); end

  def on_module(node); end

  def on_sclass(node); end

  def static_method_definition?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessAccessModifier
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::UselessAssignment
  def after_leaving_scope(scope, _variable_table); end

  def check_for_unused_assignments(variable); end

  def collect_variable_like_names(scope); end

  def message_for_useless_assignment(assignment); end

  def message_specification(assignment, variable); end

  def multiple_assignment_message(variable_name); end

  def operator_assignment_message(scope, assignment); end

  def return_value_node_of_scope(scope); end

  def similar_name_message(variable); end

  def variable_like_method_invocation?(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessAssignment
end

class RuboCop::Cop::Lint::UselessElseWithoutRescue
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessElseWithoutRescue
end

class RuboCop::Cop::Lint::UselessMethodDefinition
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessMethodDefinition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::UselessSetterCall
  def on_def(node); end

  def on_defs(node); end

  def setter_call_to_local_variable?(param0=T.unsafe(nil)); end
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessSetterCall::MethodVariableTracker
  def constructor?(node); end

  def contain_local_object?(variable_name); end

  def initialize(body_node); end

  def process_assignment(asgn_node, rhs_node); end

  def process_assignment_node(node); end

  def process_binary_operator_assignment(op_asgn_node); end

  def process_logical_operator_assignment(asgn_node); end

  def process_multiple_assignment(masgn_node); end

  def scan(node, &block); end
end

class RuboCop::Cop::Lint::UselessSetterCall::MethodVariableTracker
end

class RuboCop::Cop::Lint::UselessSetterCall
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::UselessTimes
  include ::RuboCop::Cop::RangeHelp
  def block_arg(param0=T.unsafe(nil)); end

  def block_reassigns_arg?(param0, param1); end

  def on_send(node); end

  def times_call?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessTimes
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::Void
  def on_begin(node); end

  def on_block(node); end

  def on_kwbegin(node); end
  BINARY_OPERATORS = ::T.let(nil, ::T.untyped)
  DEFINED_MSG = ::T.let(nil, ::T.untyped)
  LIT_MSG = ::T.let(nil, ::T.untyped)
  NONMUTATING_METHODS = ::T.let(nil, ::T.untyped)
  NONMUTATING_MSG = ::T.let(nil, ::T.untyped)
  OPERATORS = ::T.let(nil, ::T.untyped)
  OP_MSG = ::T.let(nil, ::T.untyped)
  SELF_MSG = ::T.let(nil, ::T.untyped)
  UNARY_OPERATORS = ::T.let(nil, ::T.untyped)
  VAR_MSG = ::T.let(nil, ::T.untyped)
  VOID_CONTEXT_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Void
end

module RuboCop::Cop::Lint
end

module RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::RangeHelp
end

module RuboCop::Cop::MatchRange
end

class RuboCop::Cop::MessageAnnotator
  def annotate(message); end

  def config(); end

  def cop_config(); end

  def cop_name(); end

  def initialize(config, cop_name, cop_config, options); end

  def options(); end

  def urls(); end
end

class RuboCop::Cop::MessageAnnotator
  def self.style_guide_urls(); end
end

module RuboCop::Cop::MethodComplexity
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::IgnoredMethods
  include ::RuboCop::Cop::Metrics::Utils::RepeatedCsendDiscount
  def define_method?(param0=T.unsafe(nil)); end

  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end
end

module RuboCop::Cop::MethodComplexity
  extend ::RuboCop::Cop::IgnoredMethods::Config
  extend ::RuboCop::AST::NodePattern::Macros
  def self.included(base); end
end

module RuboCop::Cop::MethodPreference
end

module RuboCop::Cop::MethodPreference
end

module RuboCop::Cop::Metrics
end

class RuboCop::Cop::Metrics::AbcSize
  include ::RuboCop::Cop::MethodComplexity
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::IgnoredMethods
  include ::RuboCop::Cop::Metrics::Utils::RepeatedCsendDiscount
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::AbcSize
  extend ::RuboCop::Cop::IgnoredMethods::Config
end

class RuboCop::Cop::Metrics::BlockLength
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::IgnoredMethods
  def on_block(node); end
  LABEL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::BlockLength
  extend ::RuboCop::Cop::IgnoredMethods::Config
end

class RuboCop::Cop::Metrics::BlockNesting
  include ::RuboCop::Cop::ConfigurableMax
  NESTING_BLOCKS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::BlockNesting
end

class RuboCop::Cop::Metrics::ClassLength
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  def on_casgn(node); end

  def on_class(node); end
end

class RuboCop::Cop::Metrics::ClassLength
end

class RuboCop::Cop::Metrics::CyclomaticComplexity
  include ::RuboCop::Cop::MethodComplexity
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::IgnoredMethods
  include ::RuboCop::Cop::Metrics::Utils::RepeatedCsendDiscount
  include ::RuboCop::Cop::Metrics::Utils::IteratingBlock
  COUNTED_NODES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::CyclomaticComplexity
  extend ::RuboCop::Cop::IgnoredMethods::Config
end

class RuboCop::Cop::Metrics::MethodLength
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::IgnoredMethods
  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end
  LABEL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::MethodLength
  extend ::RuboCop::Cop::IgnoredMethods::Config
end

class RuboCop::Cop::Metrics::ModuleLength
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  def module_definition?(param0=T.unsafe(nil)); end

  def on_casgn(node); end

  def on_module(node); end
end

class RuboCop::Cop::Metrics::ModuleLength
end

class RuboCop::Cop::Metrics::ParameterLists
  include ::RuboCop::Cop::ConfigurableMax
  def argument_to_lambda_or_proc?(param0=T.unsafe(nil)); end

  def on_args(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
  OPTIONAL_PARAMETERS_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::ParameterLists
end

class RuboCop::Cop::Metrics::PerceivedComplexity
  COUNTED_NODES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::PerceivedComplexity
end

module RuboCop::Cop::Metrics::Utils
end

class RuboCop::Cop::Metrics::Utils::AbcSizeCalculator
  include ::RuboCop::Cop::Metrics::Utils::IteratingBlock
  include ::RuboCop::Cop::Metrics::Utils::RepeatedCsendDiscount
  include ::RuboCop::Cop::Metrics::Utils::RepeatedAttributeDiscount
  include ::RuboCop::AST::Sexp
  def calculate(); end

  def else_branch?(node); end

  def evaluate_condition_node(node); end
end

class RuboCop::Cop::Metrics::Utils::AbcSizeCalculator
  def self.calculate(node, discount_repeated_attributes: T.unsafe(nil)); end
end

class RuboCop::Cop::Metrics::Utils::CodeLengthCalculator
  include ::RuboCop::Cop::Util
  include ::RuboCop::PathUtil
  def calculate(); end

  def initialize(node, processed_source, count_comments: T.unsafe(nil), foldable_types: T.unsafe(nil)); end
end

class RuboCop::Cop::Metrics::Utils::CodeLengthCalculator
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::Cop::Metrics::Utils::IteratingBlock
  def block_method_name(node); end

  def iterating_block?(node); end

  def iterating_method?(name); end
  KNOWN_ITERATING_METHODS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Metrics::Utils::IteratingBlock
end

module RuboCop::Cop::Metrics::Utils::RepeatedAttributeDiscount
  include ::RuboCop::AST::Sexp
  def attribute_call?(param0=T.unsafe(nil)); end

  def calculate_node(node); end

  def discount_repeated_attributes?(); end

  def evaluate_branch_nodes(node); end

  def initialize(node, discount_repeated_attributes: T.unsafe(nil)); end

  def root_node?(param0=T.unsafe(nil)); end
  VAR_SETTER_TO_GETTER = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Metrics::Utils::RepeatedAttributeDiscount
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::Cop::Metrics::Utils::RepeatedCsendDiscount
  def discount_for_repeated_csend?(csend_node); end

  def reset_on_lvasgn(node); end

  def reset_repeated_csend(); end
end

module RuboCop::Cop::Metrics::Utils::RepeatedCsendDiscount
end

module RuboCop::Cop::Metrics::Utils
end

module RuboCop::Cop::Metrics
end

module RuboCop::Cop::Migration
end

class RuboCop::Cop::Migration::DepartmentName
  include ::RuboCop::Cop::RangeHelp
  DISABLE_COMMENT_FORMAT = ::T.let(nil, ::T.untyped)
  DISABLING_COPS_CONTENT_TOKEN = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Migration::DepartmentName
  extend ::RuboCop::Cop::AutoCorrector
end

module RuboCop::Cop::Migration
end

module RuboCop::Cop::MinBodyLength
end

module RuboCop::Cop::MinBodyLength
end

module RuboCop::Cop::MultilineElementIndentation
end

module RuboCop::Cop::MultilineElementIndentation
end

module RuboCop::Cop::MultilineElementLineBreaks
end

module RuboCop::Cop::MultilineElementLineBreaks
end

module RuboCop::Cop::MultilineExpressionIndentation
  def on_send(node); end
  ASSIGNMENT_MESSAGE_TAIL = ::T.let(nil, ::T.untyped)
  DEFAULT_MESSAGE_TAIL = ::T.let(nil, ::T.untyped)
  KEYWORD_ANCESTOR_TYPES = ::T.let(nil, ::T.untyped)
  KEYWORD_MESSAGE_TAIL = ::T.let(nil, ::T.untyped)
  UNALIGNED_RHS_TYPES = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::MultilineExpressionIndentation
end

class RuboCop::Cop::MultilineLiteralBraceCorrector
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def call(); end

  def initialize(corrector, node, processed_source); end
end

class RuboCop::Cop::MultilineLiteralBraceCorrector
  def self.correct(corrector, node, processed_source); end
end

module RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
end

module RuboCop::Cop::MultilineLiteralBraceLayout
end

module RuboCop::Cop::Naming
end

class RuboCop::Cop::Naming::AccessorMethodName
  def on_def(node); end

  def on_defs(node); end
  MSG_READER = ::T.let(nil, ::T.untyped)
  MSG_WRITER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::AccessorMethodName
end

class RuboCop::Cop::Naming::AsciiIdentifiers
  include ::RuboCop::Cop::RangeHelp
  CONSTANT_MSG = ::T.let(nil, ::T.untyped)
  IDENTIFIER_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::AsciiIdentifiers
end

class RuboCop::Cop::Naming::BinaryOperatorParameterName
  def on_def(node); end

  def op_method_candidate?(param0=T.unsafe(nil)); end
  EXCLUDED = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  OP_LIKE_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::BinaryOperatorParameterName
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Naming::BlockParameterName
  include ::RuboCop::Cop::UncommunicativeName
  def on_block(node); end
end

class RuboCop::Cop::Naming::BlockParameterName
end

class RuboCop::Cop::Naming::ClassAndModuleCamelCase
  def on_class(node); end

  def on_module(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::ClassAndModuleCamelCase
end

class RuboCop::Cop::Naming::ConstantName
  def class_or_struct_return_method?(param0=T.unsafe(nil)); end

  def literal_receiver?(param0=T.unsafe(nil)); end

  def on_casgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
  SNAKE_CASE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::ConstantName
end

class RuboCop::Cop::Naming::FileName
  include ::RuboCop::Cop::RangeHelp
  MSG_NO_DEFINITION = ::T.let(nil, ::T.untyped)
  MSG_REGEX = ::T.let(nil, ::T.untyped)
  MSG_SNAKE_CASE = ::T.let(nil, ::T.untyped)
  SNAKE_CASE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::FileName
end

class RuboCop::Cop::Naming::HeredocDelimiterCase
  include ::RuboCop::Cop::Heredoc
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_heredoc(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::HeredocDelimiterCase
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Naming::HeredocDelimiterNaming
  include ::RuboCop::Cop::Heredoc
  def on_heredoc(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::HeredocDelimiterNaming
end

class RuboCop::Cop::Naming::MemoizedInstanceVariableName
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def defined_memoized?(param0=T.unsafe(nil), param1); end

  def on_defined?(node); end

  def on_or_asgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
  UNDERSCORE_REQUIRED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::MemoizedInstanceVariableName
end

class RuboCop::Cop::Naming::MethodName
  include ::RuboCop::Cop::ConfigurableNaming
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::IgnoredPattern
  include ::RuboCop::Cop::RangeHelp
  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end

  def str_name(param0=T.unsafe(nil)); end

  def sym_name(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::MethodName
end

class RuboCop::Cop::Naming::MethodParameterName
  include ::RuboCop::Cop::UncommunicativeName
  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Naming::MethodParameterName
end

class RuboCop::Cop::Naming::PredicateName
  include ::RuboCop::Cop::AllowedMethods
  def dynamic_method_define(param0=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end
end

class RuboCop::Cop::Naming::PredicateName
end

class RuboCop::Cop::Naming::RescuedExceptionsVariableName
  def on_resbody(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::RescuedExceptionsVariableName
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Naming::VariableName
  include ::RuboCop::Cop::ConfigurableNaming
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_arg(node); end

  def on_blockarg(node); end

  def on_cvasgn(node); end

  def on_ivasgn(node); end

  def on_kwarg(node); end

  def on_kwoptarg(node); end

  def on_kwrestarg(node); end

  def on_lvar(node); end

  def on_lvasgn(node); end

  def on_optarg(node); end

  def on_restarg(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::VariableName
end

class RuboCop::Cop::Naming::VariableNumber
  include ::RuboCop::Cop::ConfigurableNumbering
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_arg(node); end

  def on_cvasgn(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_sym(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::VariableNumber
end

module RuboCop::Cop::Naming
end

module RuboCop::Cop::NegativeConditional
  def empty_condition?(param0=T.unsafe(nil)); end

  def single_negative?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::NegativeConditional
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::Cop::NilMethods
  include ::RuboCop::Cop::AllowedMethods
end

module RuboCop::Cop::NilMethods
end

class RuboCop::Cop::Offense
  include ::Comparable
  def ==(other); end

  def column(); end

  def column_length(); end

  def column_range(); end

  def cop_name(); end

  def correctable?(); end

  def corrected?(); end

  def corrected_with_todo?(); end

  def corrector(); end

  def disabled?(); end

  def eql?(other); end

  def first_line(); end

  def highlighted_area(); end

  def initialize(severity, location, message, cop_name, status=T.unsafe(nil), corrector=T.unsafe(nil)); end

  def last_column(); end

  def last_line(); end

  def line(); end

  def location(); end

  def message(); end

  def real_column(); end

  def severity(); end

  def source_line(); end

  def status(); end
  COMPARISON_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  NO_LOCATION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Offense
end

module RuboCop::Cop::OnNormalIfUnless
  def on_if(node); end
end

module RuboCop::Cop::OnNormalIfUnless
end

class RuboCop::Cop::OrderedGemCorrector
end

class RuboCop::Cop::OrderedGemCorrector
  extend ::RuboCop::Cop::OrderedGemNode
  def self.comments_as_separators(); end

  def self.correct(processed_source, node, previous_declaration, comments_as_separators); end

  def self.processed_source(); end
end

module RuboCop::Cop::OrderedGemNode
end

module RuboCop::Cop::OrderedGemNode
end

module RuboCop::Cop::Parentheses
end

module RuboCop::Cop::Parentheses
end

class RuboCop::Cop::ParenthesesCorrector
end

class RuboCop::Cop::ParenthesesCorrector
  def self.correct(corrector, node); end
end

module RuboCop::Cop::PercentArray
end

module RuboCop::Cop::PercentArray
end

module RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
end

module RuboCop::Cop::PercentLiteral
end

class RuboCop::Cop::PercentLiteralCorrector
  include ::RuboCop::Cop::Util
  include ::RuboCop::PathUtil
  def config(); end

  def correct(corrector, node, char); end

  def initialize(config, preferred_delimiters); end

  def preferred_delimiters(); end
end

class RuboCop::Cop::PercentLiteralCorrector
end

module RuboCop::Cop::PrecedingFollowingAlignment
end

module RuboCop::Cop::PrecedingFollowingAlignment
end

class RuboCop::Cop::PreferredDelimiters
  def config(); end

  def delimiters(); end

  def initialize(type, config, preferred_delimiters); end

  def type(); end
  PERCENT_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::PreferredDelimiters
end

class RuboCop::Cop::PunctuationCorrector
end

class RuboCop::Cop::PunctuationCorrector
  def self.add_space(corrector, token); end

  def self.remove_space(corrector, space_before); end

  def self.swap_comma(corrector, range); end
end

module RuboCop::Cop::RangeHelp
  BYTE_ORDER_MARK = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::RangeHelp
end

module RuboCop::Cop::RationalLiteral
  def rational_literal?(param0=T.unsafe(nil)); end
end

module RuboCop::Cop::RationalLiteral
  extend ::RuboCop::AST::NodePattern::Macros
end

class RuboCop::Cop::Registry
  include ::Enumerable
  def ==(other); end

  def contains_cop_matching?(names); end

  def cops(); end

  def department_missing?(badge, name); end

  def departments(); end

  def dismiss(cop); end

  def each(&block); end

  def enabled(config, only=T.unsafe(nil), only_safe: T.unsafe(nil)); end

  def enabled?(cop, config, only_safe); end

  def enabled_pending_cop?(cop_cfg, config); end

  def enlist(cop); end

  def find_by_cop_name(cop_name); end

  def initialize(cops=T.unsafe(nil), options=T.unsafe(nil)); end

  def length(); end

  def names(); end

  def options(); end

  def print_warning(name, path); end

  def qualified_cop_name(name, path, warn: T.unsafe(nil)); end

  def select(&block); end

  def sort!(); end

  def to_h(); end

  def unqualified_cop_names(); end

  def with_department(department); end

  def without_department(department); end
end

class RuboCop::Cop::Registry
  def self.all(); end

  def self.global(); end

  def self.qualified_cop_name(name, origin); end

  def self.with_temporary_global(temp_global=T.unsafe(nil)); end
end

module RuboCop::Cop::RescueNode
  def on_new_investigation(); end
end

module RuboCop::Cop::RescueNode
end

module RuboCop::Cop::SafeAssignment
  def empty_condition?(param0=T.unsafe(nil)); end

  def safe_assignment?(param0=T.unsafe(nil)); end

  def setter_method?(param0=T.unsafe(nil)); end
end

module RuboCop::Cop::SafeAssignment
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::Cop::Security
end

class RuboCop::Cop::Security::Eval
  def eval?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::Eval
end

class RuboCop::Cop::Security::JSONLoad
  def json_load(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::JSONLoad
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Security::MarshalLoad
  def marshal_load(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::MarshalLoad
end

class RuboCop::Cop::Security::Open
  def on_send(node); end

  def open?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::Open
end

class RuboCop::Cop::Security::YAMLLoad
  def on_send(node); end

  def yaml_load(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::YAMLLoad
  extend ::RuboCop::Cop::AutoCorrector
end

module RuboCop::Cop::Security
end

class RuboCop::Cop::Severity
  include ::Comparable
  def ==(other); end

  def code(); end

  def initialize(name_or_code); end

  def level(); end

  def name(); end
  CODE_TABLE = ::T.let(nil, ::T.untyped)
  NAMES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Severity
  def self.name_from_code(code); end
end

module RuboCop::Cop::SpaceAfterPunctuation
  def on_new_investigation(); end
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::SpaceAfterPunctuation
end

module RuboCop::Cop::SpaceBeforePunctuation
  include ::RuboCop::Cop::RangeHelp
  def on_new_investigation(); end
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::SpaceBeforePunctuation
end

class RuboCop::Cop::SpaceCorrector
end

class RuboCop::Cop::SpaceCorrector
  extend ::RuboCop::Cop::SurroundingSpace
  extend ::RuboCop::Cop::RangeHelp
  def self.add_space(processed_source, corrector, left_token, right_token); end

  def self.empty_corrections(processed_source, corrector, empty_config, left_token, right_token); end

  def self.processed_source(); end

  def self.remove_space(processed_source, corrector, left_token, right_token); end
end

module RuboCop::Cop::StatementModifier
  include ::RuboCop::Cop::LineLengthHelp
end

module RuboCop::Cop::StatementModifier
end

module RuboCop::Cop::StringHelp
  def on_regexp(node); end

  def on_str(node); end
end

module RuboCop::Cop::StringHelp
end

class RuboCop::Cop::StringLiteralCorrector
end

class RuboCop::Cop::StringLiteralCorrector
  extend ::RuboCop::Cop::Util
  extend ::RuboCop::PathUtil
  def self.correct(corrector, node, style); end
end

module RuboCop::Cop::StringLiteralsHelp
  include ::RuboCop::Cop::StringHelp
end

module RuboCop::Cop::StringLiteralsHelp
end

module RuboCop::Cop::Style
end

class RuboCop::Cop::Style::AccessModifierDeclarations
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def access_modifier_with_symbol?(param0=T.unsafe(nil)); end

  def on_send(node); end
  GROUP_STYLE_MESSAGE = ::T.let(nil, ::T.untyped)
  INLINE_STYLE_MESSAGE = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AccessModifierDeclarations
end

class RuboCop::Cop::Style::AccessorGrouping
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::VisibilityHelp
  def on_class(node); end

  def on_module(node); end

  def on_sclass(node); end
  ACCESSOR_METHODS = ::T.let(nil, ::T.untyped)
  GROUPED_MSG = ::T.let(nil, ::T.untyped)
  SEPARATED_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AccessorGrouping
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Alias
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def identifier(param0=T.unsafe(nil)); end

  def on_alias(node); end

  def on_send(node); end
  MSG_ALIAS = ::T.let(nil, ::T.untyped)
  MSG_ALIAS_METHOD = ::T.let(nil, ::T.untyped)
  MSG_SYMBOL_ARGS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Alias
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::AndOr
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_and(node); end

  def on_if(node); end

  def on_or(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AndOr
  extend ::RuboCop::Cop::AutoCorrector
end

module RuboCop::Cop::Style::AnnotationComment
end

module RuboCop::Cop::Style::AnnotationComment
end

class RuboCop::Cop::Style::ArgumentsForwarding
  include ::RuboCop::Cop::RangeHelp
  def forwarding_method_arguments?(param0=T.unsafe(nil), param1, param2, param3); end

  def on_def(node); end

  def on_defs(node); end

  def only_rest_arguments?(param0=T.unsafe(nil), param1); end

  def use_rest_arguments?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ArgumentsForwarding
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Style::ArrayCoercion
  def array_splat?(param0=T.unsafe(nil)); end

  def on_array(node); end

  def on_if(node); end

  def unless_array?(param0=T.unsafe(nil)); end
  CHECK_MSG = ::T.let(nil, ::T.untyped)
  SPLAT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ArrayCoercion
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ArrayJoin
  def join_candidate?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ArrayJoin
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::AsciiComments
  include ::RuboCop::Cop::RangeHelp
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AsciiComments
end

class RuboCop::Cop::Style::Attr
  include ::RuboCop::Cop::RangeHelp
  def class_eval?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Attr
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::AutoResourceCleanup
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  TARGET_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AutoResourceCleanup
end

class RuboCop::Cop::Style::BarePercentLiterals
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_dstr(node); end

  def on_str(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BarePercentLiterals
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::BeginBlock
  def on_preexe(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BeginBlock
end

class RuboCop::Cop::Style::BisectedAttrAccessor
  include ::RuboCop::Cop::VisibilityHelp
  def on_class(class_node); end

  def on_module(class_node); end

  def on_sclass(class_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BisectedAttrAccessor
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::BlockComments
  include ::RuboCop::Cop::RangeHelp
  BEGIN_LENGTH = ::T.let(nil, ::T.untyped)
  END_LENGTH = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BlockComments
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::BlockDelimiters
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::IgnoredMethods
  def on_block(node); end

  def on_send(node); end
  ALWAYS_BRACES_MESSAGE = ::T.let(nil, ::T.untyped)
  BRACES_REQUIRED_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BlockDelimiters
  extend ::RuboCop::Cop::IgnoredMethods::Config
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::CaseCorrector
end

class RuboCop::Cop::Style::CaseCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
  def self.correct(corrector, cop, node); end

  def self.move_assignment_inside_condition(corrector, node); end
end

class RuboCop::Cop::Style::CaseEquality
  def case_equality?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CaseEquality
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::CaseLikeIf
  include ::RuboCop::Cop::RangeHelp
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CaseLikeIf
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::CharacterLiteral
  include ::RuboCop::Cop::StringHelp
  def autocorrect(corrector, node); end

  def correct_style_detected(); end

  def offense?(node); end

  def opposite_style_detected(); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CharacterLiteral
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ClassAndModuleChildren
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_class(node); end

  def on_module(node); end
  COMPACT_MSG = ::T.let(nil, ::T.untyped)
  NESTED_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassAndModuleChildren
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ClassCheck
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def message(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassCheck
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ClassEqualityComparison
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::IgnoredMethods
  def class_comparison_candidate?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassEqualityComparison
  extend ::RuboCop::Cop::IgnoredMethods::Config
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ClassMethods
  def on_class(node); end

  def on_module(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassMethods
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ClassMethodsDefinitions
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::CommentsHelp
  include ::RuboCop::Cop::VisibilityHelp
  include ::RuboCop::Cop::RangeHelp
  def on_defs(node); end

  def on_sclass(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_SCLASS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassMethodsDefinitions
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ClassVars
  def on_cvasgn(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassVars
end

class RuboCop::Cop::Style::CollectionCompact
  include ::RuboCop::Cop::RangeHelp
  def on_send(node); end

  def reject_method?(param0=T.unsafe(nil)); end

  def select_method?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CollectionCompact
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::CollectionMethods
  include ::RuboCop::Cop::MethodPreference
  def on_block(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CollectionMethods
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ColonMethodCall
  def java_type_node?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ColonMethodCall
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ColonMethodDefinition
  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ColonMethodDefinition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::CombinableLoops
  def on_block(node); end

  def on_for(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CombinableLoops
end

class RuboCop::Cop::Style::CommandLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_xstr(node); end
  MSG_USE_BACKTICKS = ::T.let(nil, ::T.untyped)
  MSG_USE_PERCENT_X = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CommandLiteral
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::CommentAnnotation
  include ::RuboCop::Cop::Style::AnnotationComment
  include ::RuboCop::Cop::RangeHelp
  MISSING_NOTE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CommentAnnotation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::CommentedKeyword
  ALLOWED_COMMENTS = ::T.let(nil, ::T.untyped)
  ALLOWED_COMMENT_REGEXES = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  KEYWORD_REGEXES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CommentedKeyword
end

class RuboCop::Cop::Style::ConditionalAssignment
  include ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def assignment_type?(param0=T.unsafe(nil)); end

  def candidate_condition?(param0=T.unsafe(nil)); end

  def on_and_asgn(node); end

  def on_case(node); end

  def on_casgn(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_if(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_op_asgn(node); end

  def on_or_asgn(node); end

  def on_send(node); end
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  ASSIGN_TO_CONDITION_MSG = ::T.let(nil, ::T.untyped)
  ENABLED = ::T.let(nil, ::T.untyped)
  INDENTATION_WIDTH = ::T.let(nil, ::T.untyped)
  LINE_LENGTH = ::T.let(nil, ::T.untyped)
  MAX = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SINGLE_LINE_CONDITIONS_ONLY = ::T.let(nil, ::T.untyped)
  VARIABLE_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  WIDTH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ConditionalAssignment
  extend ::RuboCop::Cop::AutoCorrector
end

module RuboCop::Cop::Style::ConditionalAssignmentHelper
  def end_with_eq?(sym); end

  def expand_elses(branch); end

  def expand_when_branches(when_branches); end

  def indent(cop, source); end

  def lhs(node); end

  def tail(branch); end
  ALIGN_WITH = ::T.let(nil, ::T.untyped)
  END_ALIGNMENT = ::T.let(nil, ::T.untyped)
  EQUAL = ::T.let(nil, ::T.untyped)
  KEYWORD = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::Cop::Style::ConditionalCorrectorHelper
  def assignment(node); end

  def correct_branches(corrector, branches); end

  def correct_if_branches(corrector, cop, node); end

  def remove_whitespace_in_branches(corrector, branch, condition, column); end

  def replace_branch_assignment(corrector, branch); end

  def white_space_range(node, column); end
end

module RuboCop::Cop::Style::ConditionalCorrectorHelper
end

class RuboCop::Cop::Style::ConstantVisibility
  def on_casgn(node); end

  def visibility_declaration_for?(param0=T.unsafe(nil), param1); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ConstantVisibility
end

class RuboCop::Cop::Style::Copyright
  include ::RuboCop::Cop::RangeHelp
  AUTOCORRECT_EMPTY_WARNING = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Copyright
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::DateTime
  def date_time?(param0=T.unsafe(nil)); end

  def historic_date?(param0=T.unsafe(nil)); end

  def on_send(node); end

  def to_datetime?(param0=T.unsafe(nil)); end
  CLASS_MSG = ::T.let(nil, ::T.untyped)
  COERCION_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DateTime
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::DefWithParentheses
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DefWithParentheses
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Dir
  def dir_replacement?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Dir
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::DisableCopsWithinSourceCodeDirective
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DisableCopsWithinSourceCodeDirective
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::DocumentDynamicEvalDefinition
  def on_send(node); end
  BLOCK_COMMENT_REGEXP = ::T.let(nil, ::T.untyped)
  COMMENT_REGEXP = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DocumentDynamicEvalDefinition
end

class RuboCop::Cop::Style::Documentation
  include ::RuboCop::Cop::DocumentationComment
  include ::RuboCop::Cop::Style::AnnotationComment
  def constant_definition?(param0=T.unsafe(nil)); end

  def constant_visibility_declaration?(param0=T.unsafe(nil)); end

  def on_class(node); end

  def on_module(node); end

  def outer_module(param0); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Documentation
end

class RuboCop::Cop::Style::DocumentationMethod
  include ::RuboCop::Cop::DocumentationComment
  include ::RuboCop::Cop::Style::AnnotationComment
  include ::RuboCop::Cop::DefNode
  def module_function_node?(param0=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DocumentationMethod
end

class RuboCop::Cop::Style::DoubleCopDisableDirective
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DoubleCopDisableDirective
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::DoubleNegation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def double_negative?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DoubleNegation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::EachForSimpleLoop
  def offending_each_range(param0=T.unsafe(nil)); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EachForSimpleLoop
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::EachWithObject
  include ::RuboCop::Cop::RangeHelp
  def each_with_object_candidate?(param0=T.unsafe(nil)); end

  def on_block(node); end
  METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EachWithObject
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::EmptyBlockParameter
  include ::RuboCop::Cop::EmptyParameter
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyBlockParameter
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::EmptyCaseCondition
  include ::RuboCop::Cop::RangeHelp
  def on_case(case_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyCaseCondition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::EmptyElse
  include ::RuboCop::Cop::OnNormalIfUnless
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_case(node); end

  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyElse
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::EmptyLambdaParameter
  include ::RuboCop::Cop::EmptyParameter
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyLambdaParameter
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::EmptyLiteral
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::RangeHelp
  def array_node(param0=T.unsafe(nil)); end

  def array_with_block(param0=T.unsafe(nil)); end

  def hash_node(param0=T.unsafe(nil)); end

  def hash_with_block(param0=T.unsafe(nil)); end

  def on_send(node); end

  def str_node(param0=T.unsafe(nil)); end
  ARR_MSG = ::T.let(nil, ::T.untyped)
  HASH_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  STR_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyLiteral
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::EmptyMethod
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_def(node); end

  def on_defs(node); end
  MSG_COMPACT = ::T.let(nil, ::T.untyped)
  MSG_EXPANDED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyMethod
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Encoding
  include ::RuboCop::Cop::RangeHelp
  ENCODING_PATTERN = ::T.let(nil, ::T.untyped)
  MSG_UNNECESSARY = ::T.let(nil, ::T.untyped)
  SHEBANG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Encoding
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::EndBlock
  def on_postexe(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EndBlock
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::EvalWithLocation
  def eval_without_location?(param0=T.unsafe(nil)); end

  def line_with_offset?(param0=T.unsafe(nil), param1, param2); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_INCORRECT_LINE = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EvalWithLocation
end

class RuboCop::Cop::Style::EvenOdd
  def even_odd_candidate?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EvenOdd
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ExpandPathArguments
  include ::RuboCop::Cop::RangeHelp
  def file_expand_path(param0=T.unsafe(nil)); end

  def on_send(node); end

  def pathname_new_parent_expand_path(param0=T.unsafe(nil)); end

  def pathname_parent_expand_path(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  PATHNAME_MSG = ::T.let(nil, ::T.untyped)
  PATHNAME_NEW_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ExpandPathArguments
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ExplicitBlockArgument
  include ::RuboCop::Cop::RangeHelp
  def on_yield(node); end

  def yielding_block?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ExplicitBlockArgument
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ExponentialNotation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_float(node); end
  MESSAGES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ExponentialNotation
end

class RuboCop::Cop::Style::FloatDivision
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def any_coerce?(param0=T.unsafe(nil)); end

  def both_coerce?(param0=T.unsafe(nil)); end

  def left_coerce?(param0=T.unsafe(nil)); end

  def on_send(node); end

  def right_coerce?(param0=T.unsafe(nil)); end
  MESSAGES = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FloatDivision
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::For
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end

  def on_for(node); end
  EACH_LENGTH = ::T.let(nil, ::T.untyped)
  PREFER_EACH = ::T.let(nil, ::T.untyped)
  PREFER_FOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::For
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::FormatString
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def formatter(param0=T.unsafe(nil)); end

  def on_send(node); end

  def variable_argument?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FormatString
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::FormatStringToken
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def format_string_in_typical_context?(param0=T.unsafe(nil)); end

  def on_str(node); end
end

class RuboCop::Cop::Style::FormatStringToken
end

class RuboCop::Cop::Style::FrozenStringLiteralComment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::RangeHelp
  MSG_DISABLED = ::T.let(nil, ::T.untyped)
  MSG_MISSING = ::T.let(nil, ::T.untyped)
  MSG_MISSING_TRUE = ::T.let(nil, ::T.untyped)
  MSG_UNNECESSARY = ::T.let(nil, ::T.untyped)
  SHEBANG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FrozenStringLiteralComment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::GlobalStdStream
  def const_to_gvar_assignment?(param0=T.unsafe(nil), param1); end

  def on_const(node); end
  MSG = ::T.let(nil, ::T.untyped)
  STD_STREAMS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::GlobalStdStream
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::GlobalVars
  def allowed_var?(global_var); end

  def check(node); end

  def on_gvar(node); end

  def on_gvasgn(node); end

  def user_vars(); end
  BUILT_IN_VARS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::GlobalVars
end

class RuboCop::Cop::Style::GuardClause
  include ::RuboCop::Cop::MinBodyLength
  include ::RuboCop::Cop::StatementModifier
  include ::RuboCop::Cop::LineLengthHelp
  def on_def(node); end

  def on_defs(node); end

  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::GuardClause
end

class RuboCop::Cop::Style::HashAsLastArrayItem
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_hash(node); end
end

class RuboCop::Cop::Style::HashAsLastArrayItem
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::HashEachMethods
  include ::RuboCop::Cop::Lint::UnusedArgument
  def kv_each(param0=T.unsafe(nil)); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashEachMethods
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::HashLikeCase
  def hash_like_case?(param0=T.unsafe(nil)); end

  def on_case(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashLikeCase
end

class RuboCop::Cop::Style::HashSyntax
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def hash_rockets_check(pairs); end

  def no_mixed_keys_check(pairs); end

  def on_hash(node); end

  def ruby19_check(pairs); end

  def ruby19_no_mixed_keys_check(pairs); end
  MSG_19 = ::T.let(nil, ::T.untyped)
  MSG_HASH_ROCKETS = ::T.let(nil, ::T.untyped)
  MSG_NO_MIXED_KEYS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashSyntax
end

class RuboCop::Cop::Style::HashTransformKeys
  include ::RuboCop::Cop::HashTransformMethod
  def on_bad_each_with_object(param0=T.unsafe(nil)); end

  def on_bad_hash_brackets_map(param0=T.unsafe(nil)); end

  def on_bad_map_to_h(param0=T.unsafe(nil)); end

  def on_bad_to_h(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::HashTransformKeys
  extend ::RuboCop::Cop::TargetRubyVersion
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::HashTransformValues
  include ::RuboCop::Cop::HashTransformMethod
  def on_bad_each_with_object(param0=T.unsafe(nil)); end

  def on_bad_hash_brackets_map(param0=T.unsafe(nil)); end

  def on_bad_map_to_h(param0=T.unsafe(nil)); end

  def on_bad_to_h(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::HashTransformValues
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::IdenticalConditionalBranches
  def on_case(node); end

  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IdenticalConditionalBranches
end

class RuboCop::Cop::Style::IfCorrector
end

class RuboCop::Cop::Style::IfCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
  def self.correct(corrector, cop, node); end

  def self.move_assignment_inside_condition(corrector, node); end
end

class RuboCop::Cop::Style::IfInsideElse
  include ::RuboCop::Cop::RangeHelp
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfInsideElse
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::IfUnlessModifier
  include ::RuboCop::Cop::StatementModifier
  include ::RuboCop::Cop::LineLengthHelp
  include ::RuboCop::Cop::IgnoredPattern
  def on_if(node); end
  MSG_USE_MODIFIER = ::T.let(nil, ::T.untyped)
  MSG_USE_NORMAL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfUnlessModifier
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::IfUnlessModifierOfIfUnless
  include ::RuboCop::Cop::StatementModifier
  include ::RuboCop::Cop::LineLengthHelp
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfUnlessModifierOfIfUnless
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::IfWithSemicolon
  include ::RuboCop::Cop::OnNormalIfUnless
  def on_normal_if_unless(node); end
  MSG_IF_ELSE = ::T.let(nil, ::T.untyped)
  MSG_TERNARY = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfWithSemicolon
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ImplicitRuntimeError
  def implicit_runtime_error_raise_or_fail(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ImplicitRuntimeError
end

class RuboCop::Cop::Style::InfiniteLoop
  def after_leaving_scope(scope, _variable_table); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
  LEADING_SPACE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InfiniteLoop
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::InlineComment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InlineComment
end

class RuboCop::Cop::Style::InverseMethods
  include ::RuboCop::Cop::RangeHelp
  def inverse_block?(param0=T.unsafe(nil)); end

  def inverse_candidate?(param0=T.unsafe(nil)); end

  def on_block(node); end

  def on_send(node); end
  CAMEL_CASE = ::T.let(nil, ::T.untyped)
  CLASS_COMPARISON_METHODS = ::T.let(nil, ::T.untyped)
  EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  NEGATED_EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InverseMethods
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::IpAddresses
  include ::RuboCop::Cop::StringHelp
  def correct_style_detected(); end

  def offense?(node); end

  def opposite_style_detected(); end
  IPV6_MAX_SIZE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IpAddresses
end

class RuboCop::Cop::Style::KeywordParametersOrder
  include ::RuboCop::Cop::RangeHelp
  def on_kwoptarg(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::KeywordParametersOrder
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Lambda
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_block(node); end

  def on_numblock(node); end
  LITERAL_MESSAGE = ::T.let(nil, ::T.untyped)
  METHOD_MESSAGE = ::T.let(nil, ::T.untyped)
  OFFENDING_SELECTORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Lambda
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::LambdaCall
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(corrector, node); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::LambdaCall
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::LineEndConcatenation
  include ::RuboCop::Cop::RangeHelp
  COMPLEX_STRING_BEGIN_TOKEN = ::T.let(nil, ::T.untyped)
  COMPLEX_STRING_END_TOKEN = ::T.let(nil, ::T.untyped)
  CONCAT_TOKEN_TYPES = ::T.let(nil, ::T.untyped)
  HIGH_PRECEDENCE_OP_TOKEN_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  QUOTE_DELIMITERS = ::T.let(nil, ::T.untyped)
  SIMPLE_STRING_TOKEN_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::LineEndConcatenation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MethodCallWithArgsParentheses
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::IgnoredMethods
  include ::RuboCop::Cop::IgnoredPattern
  include ::RuboCop::Cop::Style::MethodCallWithArgsParentheses::RequireParentheses
  include ::RuboCop::Cop::Style::MethodCallWithArgsParentheses::OmitParentheses
  def on_csend(node); end

  def on_send(node); end

  def on_super(node); end

  def on_yield(node); end
end

module RuboCop::Cop::Style::MethodCallWithArgsParentheses::OmitParentheses
  TRAILING_WHITESPACE_REGEX = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Style::MethodCallWithArgsParentheses::OmitParentheses
end

module RuboCop::Cop::Style::MethodCallWithArgsParentheses::RequireParentheses
end

module RuboCop::Cop::Style::MethodCallWithArgsParentheses::RequireParentheses
end

class RuboCop::Cop::Style::MethodCallWithArgsParentheses
  extend ::RuboCop::Cop::IgnoredMethods::Config
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MethodCallWithoutArgsParentheses
  include ::RuboCop::Cop::IgnoredMethods
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodCallWithoutArgsParentheses
  extend ::RuboCop::Cop::IgnoredMethods::Config
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MethodCalledOnDoEndBlock
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodCalledOnDoEndBlock
end

class RuboCop::Cop::Style::MethodDefParentheses
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_def(node); end

  def on_defs(node); end
  MSG_MISSING = ::T.let(nil, ::T.untyped)
  MSG_PRESENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodDefParentheses
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MinMax
  def min_max_candidate(param0=T.unsafe(nil)); end

  def on_array(node); end

  def on_return(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MinMax
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MissingElse
  include ::RuboCop::Cop::OnNormalIfUnless
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_case(node); end

  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_EMPTY = ::T.let(nil, ::T.untyped)
  MSG_NIL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MissingElse
end

class RuboCop::Cop::Style::MissingRespondToMissing
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MissingRespondToMissing
end

class RuboCop::Cop::Style::MixinGrouping
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_class(node); end

  def on_module(node); end
  MIXIN_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MixinGrouping
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MixinUsage
  def in_top_level_scope?(param0=T.unsafe(nil)); end

  def include_statement(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MixinUsage
end

class RuboCop::Cop::Style::ModuleFunction
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def extend_self_node?(param0=T.unsafe(nil)); end

  def module_function_node?(param0=T.unsafe(nil)); end

  def on_module(node); end

  def private_directive?(param0=T.unsafe(nil)); end
  EXTEND_SELF_MSG = ::T.let(nil, ::T.untyped)
  FORBIDDEN_MSG = ::T.let(nil, ::T.untyped)
  MODULE_FUNCTION_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ModuleFunction
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MultilineBlockChain
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineBlockChain
end

class RuboCop::Cop::Style::MultilineIfModifier
  include ::RuboCop::Cop::StatementModifier
  include ::RuboCop::Cop::LineLengthHelp
  include ::RuboCop::Cop::Alignment
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineIfModifier
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MultilineIfThen
  include ::RuboCop::Cop::OnNormalIfUnless
  include ::RuboCop::Cop::RangeHelp
  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
  NON_MODIFIER_THEN = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineIfThen
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MultilineMemoization
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def message(_node); end

  def on_or_asgn(node); end
  BRACES_MSG = ::T.let(nil, ::T.untyped)
  KEYWORD_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineMemoization
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MultilineMethodSignature
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineMethodSignature
end

class RuboCop::Cop::Style::MultilineTernaryOperator
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineTernaryOperator
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MultilineWhenThen
  include ::RuboCop::Cop::RangeHelp
  def on_when(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineWhenThen
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MultipleComparison
  def on_or(node); end

  def simple_comparison_lhs?(param0=T.unsafe(nil)); end

  def simple_comparison_rhs?(param0=T.unsafe(nil)); end

  def simple_double_comparison?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultipleComparison
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MutableConstant
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_casgn(node); end

  def on_or_asgn(node); end

  def operation_produces_immutable_object?(param0=T.unsafe(nil)); end

  def range_enclosed_in_parentheses?(param0=T.unsafe(nil)); end

  def splat_value(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MutableConstant
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NegatedIf
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::NegativeConditional
  def on_if(node); end
end

class RuboCop::Cop::Style::NegatedIf
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NegatedIfElseCondition
  include ::RuboCop::Cop::RangeHelp
  def double_negation?(param0=T.unsafe(nil)); end

  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
  NEGATED_EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NegatedIfElseCondition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NegatedUnless
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::NegativeConditional
  def on_if(node); end
end

class RuboCop::Cop::Style::NegatedUnless
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NegatedWhile
  include ::RuboCop::Cop::NegativeConditional
  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Style::NegatedWhile
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NestedModifier
  include ::RuboCop::Cop::RangeHelp
  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedModifier
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NestedParenthesizedCalls
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::AllowedMethods
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedParenthesizedCalls
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NestedTernaryOperator
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedTernaryOperator
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Next
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MinBodyLength
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end

  def on_for(node); end

  def on_until(node); end

  def on_while(node); end
  EXIT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Next
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NilComparison
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def nil_check?(param0=T.unsafe(nil)); end

  def nil_comparison?(param0=T.unsafe(nil)); end

  def on_send(node); end
  EXPLICIT_MSG = ::T.let(nil, ::T.untyped)
  PREDICATE_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NilComparison
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NilLambda
  include ::RuboCop::Cop::RangeHelp
  def nil_return?(param0=T.unsafe(nil)); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NilLambda
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NonNilCheck
  def nil_check?(param0=T.unsafe(nil)); end

  def not_and_nil_check?(param0=T.unsafe(nil)); end

  def not_equal_to_nil?(param0=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end

  def unless_check?(param0=T.unsafe(nil)); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NonNilCheck
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Not
  include ::RuboCop::Cop::RangeHelp
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  OPPOSITE_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Not
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NumericLiteralPrefix
  include ::RuboCop::Cop::IntegerNode
  def on_int(node); end
  BINARY_MSG = ::T.let(nil, ::T.untyped)
  BINARY_REGEX = ::T.let(nil, ::T.untyped)
  DECIMAL_MSG = ::T.let(nil, ::T.untyped)
  DECIMAL_REGEX = ::T.let(nil, ::T.untyped)
  HEX_MSG = ::T.let(nil, ::T.untyped)
  HEX_REGEX = ::T.let(nil, ::T.untyped)
  OCTAL_MSG = ::T.let(nil, ::T.untyped)
  OCTAL_REGEX = ::T.let(nil, ::T.untyped)
  OCTAL_ZERO_ONLY_MSG = ::T.let(nil, ::T.untyped)
  OCTAL_ZERO_ONLY_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericLiteralPrefix
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NumericLiterals
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::IntegerNode
  def on_float(node); end

  def on_int(node); end
  DELIMITER_REGEXP = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericLiterals
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NumericPredicate
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::IgnoredMethods
  def comparison(param0=T.unsafe(nil)); end

  def inverted_comparison(param0=T.unsafe(nil)); end

  def on_send(node); end

  def predicate(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  REPLACEMENTS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericPredicate
  extend ::RuboCop::Cop::IgnoredMethods::Config
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::OneLineConditional
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::OnNormalIfUnless
  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OneLineConditional
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::OptionHash
  def on_args(node); end

  def option_hash(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OptionHash
end

class RuboCop::Cop::Style::OptionalArguments
  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OptionalArguments
end

class RuboCop::Cop::Style::OptionalBooleanParameter
  include ::RuboCop::Cop::AllowedMethods
  def on_def(node); end

  def on_defs(node); end
  BOOLEAN_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OptionalBooleanParameter
end

class RuboCop::Cop::Style::OrAssignment
  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_if(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def ternary_assignment?(param0=T.unsafe(nil)); end

  def unless_assignment?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OrAssignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ParallelAssignment
  include ::RuboCop::Cop::RescueNode
  def implicit_self_getter?(param0=T.unsafe(nil)); end

  def on_masgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ParallelAssignment::AssignmentSorter
  include ::TSort
  def accesses?(rhs, lhs); end

  def dependency?(lhs, rhs); end

  def initialize(assignments); end

  def matching_calls(param0, param1, param2); end

  def tsort_each_child(assignment); end

  def tsort_each_node(&block); end

  def uses_var?(param0, param1); end

  def var_name(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::ParallelAssignment::AssignmentSorter
  extend ::RuboCop::AST::NodePattern::Macros
end

class RuboCop::Cop::Style::ParallelAssignment::GenericCorrector
  include ::RuboCop::Cop::Alignment
  def assignment(); end

  def config(); end

  def correction(); end

  def correction_range(); end

  def initialize(node, config, new_elements); end

  def node(); end
end

class RuboCop::Cop::Style::ParallelAssignment::GenericCorrector
end

class RuboCop::Cop::Style::ParallelAssignment::ModifierCorrector
end

class RuboCop::Cop::Style::ParallelAssignment::ModifierCorrector
end

class RuboCop::Cop::Style::ParallelAssignment::RescueCorrector
end

class RuboCop::Cop::Style::ParallelAssignment::RescueCorrector
end

class RuboCop::Cop::Style::ParallelAssignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ParenthesesAroundCondition
  include ::RuboCop::Cop::SafeAssignment
  include ::RuboCop::Cop::Parentheses
  def control_op_condition(param0=T.unsafe(nil)); end

  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Style::ParenthesesAroundCondition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::PercentLiteralDelimiters
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_array(node); end

  def on_dstr(node); end

  def on_regexp(node); end

  def on_str(node); end

  def on_sym(node); end

  def on_xstr(node); end
end

class RuboCop::Cop::Style::PercentLiteralDelimiters
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::PercentQLiterals
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_str(node); end
  LOWER_CASE_Q_MSG = ::T.let(nil, ::T.untyped)
  UPPER_CASE_Q_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::PercentQLiterals
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::PerlBackrefs
  def on_back_ref(node); end

  def on_gvar(node); end

  def on_nth_ref(node); end
  MESSAGE_FORMAT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::PerlBackrefs
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::PreferredHashMethods
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  OFFENDING_SELECTORS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::PreferredHashMethods
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Proc
  def on_block(node); end

  def proc_new?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Proc
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RaiseArgs
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_send(node); end
  COMPACT_MSG = ::T.let(nil, ::T.untyped)
  EXPLODED_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RaiseArgs
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RandomWithOffset
  def integer_op_rand?(param0=T.unsafe(nil)); end

  def on_send(node); end

  def rand_modified?(param0=T.unsafe(nil)); end

  def rand_op_integer?(param0=T.unsafe(nil)); end

  def random_call(param0=T.unsafe(nil)); end

  def to_int(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RandomWithOffset
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantArgument
  include ::RuboCop::Cop::RangeHelp
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantArgument
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantAssignment
  def on_def(node); end

  def on_defs(node); end

  def redundant_assignment?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantAssignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantBegin
  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_kwbegin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantBegin
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantCapitalW
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_array(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantCapitalW
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantCondition
  include ::RuboCop::Cop::RangeHelp
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
  REDUNDANT_CONDITION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantCondition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantConditional
  include ::RuboCop::Cop::Alignment
  def on_if(node); end

  def redundant_condition?(param0=T.unsafe(nil)); end

  def redundant_condition_inverted?(param0=T.unsafe(nil)); end
  COMPARISON_OPERATOR_MATCHER = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantConditional
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantException
  def compact?(param0=T.unsafe(nil)); end

  def exploded?(param0=T.unsafe(nil)); end

  def fix_compact(node); end

  def fix_exploded(node); end

  def on_send(node); end
  MSG_1 = ::T.let(nil, ::T.untyped)
  MSG_2 = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantException
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantFetchBlock
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end

  def rails_cache?(param0=T.unsafe(nil)); end

  def redundant_fetch_block_candidate?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantFetchBlock
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantFileExtensionInRequire
  def on_send(node); end

  def require_call?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantFileExtensionInRequire
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantFreeze
  include ::RuboCop::Cop::FrozenStringLiteral
  def on_send(node); end

  def operation_produces_immutable_object?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantFreeze
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantInterpolation
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_dstr(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantInterpolation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantParentheses
  include ::RuboCop::Cop::Parentheses
  def arg_in_call_with_block?(param0=T.unsafe(nil)); end

  def first_send_argument?(param0=T.unsafe(nil)); end

  def first_super_argument?(param0=T.unsafe(nil)); end

  def first_yield_argument?(param0=T.unsafe(nil)); end

  def interpolation?(param0=T.unsafe(nil)); end

  def method_node_and_args(param0=T.unsafe(nil)); end

  def on_begin(node); end

  def range_end?(param0=T.unsafe(nil)); end

  def rescue?(param0=T.unsafe(nil)); end

  def square_brackets?(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::RedundantParentheses
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantPercentQ
  def on_dstr(node); end

  def on_str(node); end
  DYNAMIC_MSG = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  ESCAPED_NON_BACKSLASH = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PERCENT_CAPITAL_Q = ::T.let(nil, ::T.untyped)
  PERCENT_Q = ::T.let(nil, ::T.untyped)
  QUOTE = ::T.let(nil, ::T.untyped)
  SINGLE_QUOTE = ::T.let(nil, ::T.untyped)
  STRING_INTERPOLATION_REGEXP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantPercentQ
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantRegexpCharacterClass
  def on_regexp(node); end
  MSG_REDUNDANT_CHARACTER_CLASS = ::T.let(nil, ::T.untyped)
  REQUIRES_ESCAPE_OUTSIDE_CHAR_CLASS_CHARS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantRegexpCharacterClass
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantRegexpEscape
  include ::RuboCop::Cop::RangeHelp
  def on_regexp(node); end
  ALLOWED_ALWAYS_ESCAPES = ::T.let(nil, ::T.untyped)
  ALLOWED_OUTSIDE_CHAR_CLASS_METACHAR_ESCAPES = ::T.let(nil, ::T.untyped)
  ALLOWED_WITHIN_CHAR_CLASS_METACHAR_ESCAPES = ::T.let(nil, ::T.untyped)
  MSG_REDUNDANT_ESCAPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantRegexpEscape
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantReturn
  include ::RuboCop::Cop::RangeHelp
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MULTI_RETURN_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantReturn
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantSelf
  def on_and_asgn(node); end

  def on_args(node); end

  def on_block(node); end

  def on_blockarg(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_op_asgn(node); end

  def on_or_asgn(node); end

  def on_send(node); end
  KERNEL_METHODS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSelf
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantSelfAssignment
  include ::RuboCop::Cop::RangeHelp
  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_send(node); end

  def redundant_nonself_assignment?(param0=T.unsafe(nil), param1, param2); end

  def redundant_self_assignment?(param0=T.unsafe(nil), param1); end
  ASSIGNMENT_TYPE_TO_RECEIVER_TYPE = ::T.let(nil, ::T.untyped)
  METHODS_RETURNING_SELF = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSelfAssignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantSort
  include ::RuboCop::Cop::RangeHelp
  def on_send(node); end

  def redundant_sort?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSort
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantSortBy
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end

  def redundant_sort_by(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSortBy
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RegexpLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_regexp(node); end
  MSG_USE_PERCENT_R = ::T.let(nil, ::T.untyped)
  MSG_USE_SLASHES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RegexpLiteral
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RescueModifier
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::RescueNode
  def autocorrect(node); end

  def on_resbody(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RescueModifier
end

class RuboCop::Cop::Style::RescueStandardError
  include ::RuboCop::Cop::RescueNode
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_resbody(node); end

  def rescue_standard_error?(param0=T.unsafe(nil)); end

  def rescue_without_error_class?(param0=T.unsafe(nil)); end
  MSG_EXPLICIT = ::T.let(nil, ::T.untyped)
  MSG_IMPLICIT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RescueStandardError
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ReturnNil
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def chained_send?(param0=T.unsafe(nil)); end

  def define_method?(param0=T.unsafe(nil)); end

  def on_return(node); end

  def return_nil_node?(param0=T.unsafe(nil)); end

  def return_node?(param0=T.unsafe(nil)); end
  RETURN_MSG = ::T.let(nil, ::T.untyped)
  RETURN_NIL_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ReturnNil
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::SafeNavigation
  include ::RuboCop::Cop::NilMethods
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::RangeHelp
  def check_node(node); end

  def modifier_if_safe_navigation_candidate(param0=T.unsafe(nil)); end

  def not_nil_check?(param0=T.unsafe(nil)); end

  def on_and(node); end

  def on_if(node); end

  def use_var_only_in_unless_modifier?(node, variable); end
  LOGIC_JUMP_KEYWORDS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SafeNavigation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Sample
  def on_send(node); end

  def sample_candidate?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Sample
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::SelfAssignment
  def on_cvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
  OPS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SelfAssignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Semicolon
  include ::RuboCop::Cop::RangeHelp
  def on_begin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Semicolon
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Send
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Send
end

class RuboCop::Cop::Style::SignalException
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def custom_fail_methods(param0); end

  def kernel_call?(param0=T.unsafe(nil), param1); end

  def on_rescue(node); end

  def on_send(node); end
  FAIL_MSG = ::T.let(nil, ::T.untyped)
  RAISE_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SignalException
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::SingleArgumentDig
  def on_send(node); end

  def single_argument_dig?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SingleArgumentDig
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::SingleLineBlockParams
  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SingleLineBlockParams
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::SingleLineMethods
  include ::RuboCop::Cop::Alignment
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SingleLineMethods
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::SlicingWithRange
  def on_send(node); end

  def range_till_minus_one?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SlicingWithRange
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Style::SoleNestedConditional
  include ::RuboCop::Cop::RangeHelp
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SoleNestedConditional
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::SpecialGlobalVars
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(corrector, node, global_var); end

  def message(global_var); end

  def on_gvar(node); end
  ENGLISH_VARS = ::T.let(nil, ::T.untyped)
  MSG_BOTH = ::T.let(nil, ::T.untyped)
  MSG_ENGLISH = ::T.let(nil, ::T.untyped)
  MSG_REGULAR = ::T.let(nil, ::T.untyped)
  NON_ENGLISH_VARS = ::T.let(nil, ::T.untyped)
  PERL_VARS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SpecialGlobalVars
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::StabbyLambdaParentheses
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_send(node); end
  MSG_NO_REQUIRE = ::T.let(nil, ::T.untyped)
  MSG_REQUIRE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StabbyLambdaParentheses
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::StaticClass
  include ::RuboCop::Cop::VisibilityHelp
  def on_class(class_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StaticClass
end

class RuboCop::Cop::Style::StderrPuts
  include ::RuboCop::Cop::RangeHelp
  def on_send(node); end

  def stderr_puts?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StderrPuts
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::StringConcatenation
  def on_send(node); end

  def string_concatenation?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringConcatenation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::StringHashKeys
  def on_pair(node); end

  def receive_environments_method?(param0=T.unsafe(nil)); end

  def string_hash_key?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringHashKeys
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::StringLiterals
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::StringLiteralsHelp
  include ::RuboCop::Cop::StringHelp
  def on_dstr(node); end
  MSG_INCONSISTENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringLiterals
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::StringLiteralsInInterpolation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::StringLiteralsHelp
  include ::RuboCop::Cop::StringHelp
  def autocorrect(corrector, node); end
end

class RuboCop::Cop::Style::StringLiteralsInInterpolation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::StringMethods
  include ::RuboCop::Cop::MethodPreference
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringMethods
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Strip
  include ::RuboCop::Cop::RangeHelp
  def lstrip_rstrip(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Strip
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::StructInheritance
  include ::RuboCop::Cop::RangeHelp
  def on_class(node); end

  def struct_constructor?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StructInheritance
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::SwapValues
  include ::RuboCop::Cop::RangeHelp
  def on_asgn(node); end

  def on_casgn(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
  SIMPLE_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SwapValues
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::SymbolArray
  include ::RuboCop::Cop::ArrayMinSize
  include ::RuboCop::Cop::ArraySyntax
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::PercentArray
  def on_array(node); end
  ARRAY_MSG = ::T.let(nil, ::T.untyped)
  PERCENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SymbolArray
  extend ::RuboCop::Cop::AutoCorrector
  def self.largest_brackets(); end

  def self.largest_brackets=(largest_brackets); end
end

class RuboCop::Cop::Style::SymbolLiteral
  def on_sym(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SymbolLiteral
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::SymbolProc
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::IgnoredMethods
  def destructuring_block_argument?(argument_node); end

  def on_block(node); end

  def on_numblock(node); end

  def proc_node?(param0=T.unsafe(nil)); end

  def symbol_proc?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  SUPER_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SymbolProc
  extend ::RuboCop::Cop::IgnoredMethods::Config
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TernaryCorrector
end

class RuboCop::Cop::Style::TernaryCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
  def self.correct(corrector, node); end

  def self.move_assignment_inside_condition(corrector, node); end
end

class RuboCop::Cop::Style::TernaryParentheses
  include ::RuboCop::Cop::SafeAssignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  def method_name(param0=T.unsafe(nil)); end

  def on_if(node); end

  def only_closing_parenthesis_is_last_line?(condition); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_COMPLEX = ::T.let(nil, ::T.untyped)
  NON_COMPLEX_TYPES = ::T.let(nil, ::T.untyped)
  VARIABLE_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TernaryParentheses
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TrailingBodyOnClass
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::TrailingBody
  def on_class(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingBodyOnClass
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TrailingBodyOnMethodDefinition
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::TrailingBody
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingBodyOnMethodDefinition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TrailingBodyOnModule
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::TrailingBody
  def on_module(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingBodyOnModule
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TrailingCommaInArguments
  include ::RuboCop::Cop::TrailingComma
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Style::TrailingCommaInArguments
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TrailingCommaInArrayLiteral
  include ::RuboCop::Cop::TrailingComma
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_array(node); end
end

class RuboCop::Cop::Style::TrailingCommaInArrayLiteral
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TrailingCommaInBlockArgs
  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingCommaInBlockArgs
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TrailingCommaInHashLiteral
  include ::RuboCop::Cop::TrailingComma
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_hash(node); end
end

class RuboCop::Cop::Style::TrailingCommaInHashLiteral
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TrailingMethodEndStatement
  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingMethodEndStatement
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TrailingUnderscoreVariable
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  def on_masgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
  UNDERSCORE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingUnderscoreVariable
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TrivialAccessors
  include ::RuboCop::Cop::AllowedMethods
  def looks_like_trivial_writer?(param0=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrivialAccessors
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::UnlessElse
  include ::RuboCop::Cop::RangeHelp
  def on_if(node); end

  def range_between_condition_and_else(node, condition); end

  def range_between_else_and_end(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnlessElse
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::UnpackFirst
  def on_send(node); end

  def unpack_and_first_element?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnpackFirst
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::VariableInterpolation
  include ::RuboCop::Cop::Interpolation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::VariableInterpolation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::WhenThen
  def on_when(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WhenThen
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::WhileUntilDo
  def on_until(node); end

  def on_while(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WhileUntilDo
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::WhileUntilModifier
  include ::RuboCop::Cop::StatementModifier
  include ::RuboCop::Cop::LineLengthHelp
  def on_until(node); end

  def on_while(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WhileUntilModifier
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::WordArray
  include ::RuboCop::Cop::ArrayMinSize
  include ::RuboCop::Cop::ArraySyntax
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::PercentArray
  def on_array(node); end
  ARRAY_MSG = ::T.let(nil, ::T.untyped)
  PERCENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WordArray
  extend ::RuboCop::Cop::AutoCorrector
  def self.largest_brackets(); end

  def self.largest_brackets=(largest_brackets); end
end

class RuboCop::Cop::Style::YodaCondition
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def file_constant_equal_program_name?(param0=T.unsafe(nil)); end

  def on_send(node); end
  EQUALITY_OPERATORS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  NONCOMMUTATIVE_OPERATORS = ::T.let(nil, ::T.untyped)
  PROGRAM_NAMES = ::T.let(nil, ::T.untyped)
  REVERSE_COMPARISON = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::YodaCondition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ZeroLengthPredicate
  def non_polymorphic_collection?(param0=T.unsafe(nil)); end

  def nonzero_length_predicate(param0=T.unsafe(nil)); end

  def on_send(node); end

  def other_receiver(param0=T.unsafe(nil)); end

  def zero_length_predicate(param0=T.unsafe(nil)); end

  def zero_length_receiver(param0=T.unsafe(nil)); end
  NONZERO_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  ZERO_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ZeroLengthPredicate
  extend ::RuboCop::Cop::AutoCorrector
end

module RuboCop::Cop::Style
end

module RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  NO_SPACE_COMMAND = ::T.let(nil, ::T.untyped)
  SINGLE_SPACE_REGEXP = ::T.let(nil, ::T.untyped)
  SPACE_COMMAND = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::SurroundingSpace
end

module RuboCop::Cop::TargetRubyVersion
  def minimum_target_ruby_version(version); end

  def required_minimum_ruby_version(); end

  def support_target_ruby_version?(version); end
end

module RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Team
  def autocorrect?(); end

  def cops(); end

  def debug?(); end

  def errors(); end

  def external_dependency_checksum(); end

  def forces(); end

  def initialize(cops, config=T.unsafe(nil), options=T.unsafe(nil)); end

  def inspect_file(processed_source); end

  def investigate(processed_source); end

  def updated_source_file(); end

  def updated_source_file?(); end

  def warnings(); end
end

class RuboCop::Cop::Team
  def self.forces_for(cops); end

  def self.mobilize(cop_classes, config, options=T.unsafe(nil)); end

  def self.mobilize_cops(cop_classes, config, options=T.unsafe(nil)); end

  def self.new(cop_or_classes, config, options=T.unsafe(nil)); end
end

module RuboCop::Cop::TrailingBody
  def body_on_first_line?(node, body); end

  def first_part_of(body); end

  def trailing_body?(node); end
end

module RuboCop::Cop::TrailingBody
end

module RuboCop::Cop::TrailingComma
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::TrailingComma
end

module RuboCop::Cop::UncommunicativeName
  def check(node, args); end
  CASE_MSG = ::T.let(nil, ::T.untyped)
  FORBIDDEN_MSG = ::T.let(nil, ::T.untyped)
  LENGTH_MSG = ::T.let(nil, ::T.untyped)
  NUM_MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::UncommunicativeName
end

class RuboCop::Cop::UnusedArgCorrector
end

class RuboCop::Cop::UnusedArgCorrector
  extend ::RuboCop::Cop::RangeHelp
  def self.correct(corrector, processed_source, node); end

  def self.correct_for_blockarg_type(corrector, node); end

  def self.processed_source(); end
end

module RuboCop::Cop::Util
  include ::RuboCop::PathUtil
  LITERAL_REGEX = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Util
  def self.add_parentheses(node, corrector); end

  def self.args_begin(node); end

  def self.args_end(node); end

  def self.begins_its_line?(range); end

  def self.comment_line?(line_source); end

  def self.comment_lines?(node); end

  def self.double_quotes_required?(string); end

  def self.escape_string(string); end

  def self.first_part_of_call_chain(node); end

  def self.indent(node); end

  def self.interpret_string_escapes(string); end

  def self.line_range(node); end

  def self.needs_escaping?(string); end

  def self.on_node(syms, sexp, excludes=T.unsafe(nil), &block); end

  def self.parentheses?(node); end

  def self.same_line?(node1, node2); end

  def self.to_string_literal(string); end

  def self.to_supported_styles(enforced_style); end

  def self.trim_string_interporation_escape_character(str); end
end

module RuboCop::Cop::Utils
end

class RuboCop::Cop::Utils::FormatString
  def format_sequences(); end

  def initialize(string); end

  def max_digit_dollar_num(); end

  def named_interpolation?(); end

  def valid?(); end
  DIGIT_DOLLAR = ::T.let(nil, ::T.untyped)
  FLAG = ::T.let(nil, ::T.untyped)
  NAME = ::T.let(nil, ::T.untyped)
  NUMBER = ::T.let(nil, ::T.untyped)
  NUMBER_ARG = ::T.let(nil, ::T.untyped)
  PRECISION = ::T.let(nil, ::T.untyped)
  SEQUENCE = ::T.let(nil, ::T.untyped)
  TEMPLATE_NAME = ::T.let(nil, ::T.untyped)
  TYPE = ::T.let(nil, ::T.untyped)
  WIDTH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Utils::FormatString::FormatSequence
  def annotated?(); end

  def arity(); end

  def begin_pos(); end

  def end_pos(); end

  def flags(); end

  def initialize(match); end

  def max_digit_dollar_num(); end

  def name(); end

  def percent?(); end

  def precision(); end

  def style(); end

  def template?(); end

  def type(); end

  def width(); end
end

class RuboCop::Cop::Utils::FormatString::FormatSequence
end

class RuboCop::Cop::Utils::FormatString
end

module RuboCop::Cop::Utils
end

class RuboCop::Cop::VariableForce
  def investigate(processed_source); end

  def process_node(node); end

  def variable_table(); end
  ARGUMENT_DECLARATION_TYPES = ::T.let(nil, ::T.untyped)
  LOGICAL_OPERATOR_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  LOOP_TYPES = ::T.let(nil, ::T.untyped)
  MULTIPLE_ASSIGNMENT_TYPE = ::T.let(nil, ::T.untyped)
  OPERATOR_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  POST_CONDITION_LOOP_TYPES = ::T.let(nil, ::T.untyped)
  REGEXP_NAMED_CAPTURE_TYPE = ::T.let(nil, ::T.untyped)
  RESCUE_TYPE = ::T.let(nil, ::T.untyped)
  SCOPE_TYPES = ::T.let(nil, ::T.untyped)
  SEND_TYPE = ::T.let(nil, ::T.untyped)
  TWISTED_SCOPE_TYPES = ::T.let(nil, ::T.untyped)
  VARIABLE_ASSIGNMENT_TYPE = ::T.let(nil, ::T.untyped)
  VARIABLE_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  VARIABLE_REFERENCE_TYPE = ::T.let(nil, ::T.untyped)
  ZERO_ARITY_SUPER_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Assignment
  include ::RuboCop::Cop::VariableForce::Branchable
  def initialize(node, variable); end

  def meta_assignment_node(); end

  def multiple_assignment?(); end

  def name(); end

  def node(); end

  def operator(); end

  def operator_assignment?(); end

  def reference!(node); end

  def referenced(); end

  def referenced?(); end

  def references(); end

  def regexp_named_capture?(); end

  def scope(); end

  def used?(); end

  def variable(); end
  MULTIPLE_LEFT_HAND_SIDE_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Assignment
end

class RuboCop::Cop::VariableForce::AssignmentReference
  def assignment?(); end

  def node(); end

  def node=(_); end
end

class RuboCop::Cop::VariableForce::AssignmentReference
  def self.[](*_); end

  def self.members(); end
end

module RuboCop::Cop::VariableForce::Branch
  CLASSES_BY_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Branch::And
  include ::RuboCop::Cop::VariableForce::Branch::LogicalOperator
  def left_body?(); end

  def right_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::And
end

class RuboCop::Cop::VariableForce::Branch::Base
  def ==(other); end

  def always_run?(); end

  def branched?(); end

  def child_node(); end

  def child_node=(_); end

  def control_node(); end

  def each_ancestor(include_self: T.unsafe(nil), &block); end

  def eql?(other); end

  def exclusive_with?(other); end

  def may_jump_to_other_branch?(); end

  def may_run_incompletely?(); end

  def parent(); end

  def scope(); end

  def scope=(_); end
end

class RuboCop::Cop::VariableForce::Branch::Base
  def self.[](*_); end

  def self.classes(); end

  def self.define_predicate(name, child_index: T.unsafe(nil)); end

  def self.inherited(subclass); end

  def self.members(); end

  def self.type(); end
end

class RuboCop::Cop::VariableForce::Branch::Case
  def else_body?(); end

  def target?(); end

  def when_clause?(); end
end

class RuboCop::Cop::VariableForce::Branch::Case
end

class RuboCop::Cop::VariableForce::Branch::Ensure
  include ::RuboCop::Cop::VariableForce::Branch::ExceptionHandler
  def ensure_body?(); end

  def main_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::Ensure
end

module RuboCop::Cop::VariableForce::Branch::ExceptionHandler
  def may_jump_to_other_branch?(); end

  def may_run_incompletely?(); end
end

module RuboCop::Cop::VariableForce::Branch::ExceptionHandler
end

class RuboCop::Cop::VariableForce::Branch::For
  def collection?(); end

  def element?(); end

  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::For
end

class RuboCop::Cop::VariableForce::Branch::If
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def falsey_body?(); end

  def truthy_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::If
end

module RuboCop::Cop::VariableForce::Branch::LogicalOperator
  def always_run?(); end
end

module RuboCop::Cop::VariableForce::Branch::LogicalOperator
end

class RuboCop::Cop::VariableForce::Branch::Or
  include ::RuboCop::Cop::VariableForce::Branch::LogicalOperator
  def left_body?(); end

  def right_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::Or
end

class RuboCop::Cop::VariableForce::Branch::Rescue
  include ::RuboCop::Cop::VariableForce::Branch::ExceptionHandler
  def else_body?(); end

  def main_body?(); end

  def rescue_clause?(); end
end

class RuboCop::Cop::VariableForce::Branch::Rescue
end

module RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def always_run?(); end

  def conditional_clause?(); end
end

module RuboCop::Cop::VariableForce::Branch::SimpleConditional
end

class RuboCop::Cop::VariableForce::Branch::Until
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::Until
end

class RuboCop::Cop::VariableForce::Branch::UntilPost
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::UntilPost
end

class RuboCop::Cop::VariableForce::Branch::While
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::While
end

class RuboCop::Cop::VariableForce::Branch::WhilePost
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::WhilePost
end

module RuboCop::Cop::VariableForce::Branch
  def self.of(target_node, scope: T.unsafe(nil)); end
end

module RuboCop::Cop::VariableForce::Branchable
  def branch(); end

  def run_exclusively_with?(other); end
end

module RuboCop::Cop::VariableForce::Branchable
end

class RuboCop::Cop::VariableForce::Reference
  include ::RuboCop::Cop::VariableForce::Branchable
  def explicit?(); end

  def initialize(node, scope); end

  def node(); end

  def scope(); end
  VARIABLE_REFERENCE_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Reference
end

class RuboCop::Cop::VariableForce::Scope
  def ==(other); end

  def body_node(); end

  def each_node(&block); end

  def include?(target_node); end

  def initialize(node); end

  def naked_top_level(); end

  def naked_top_level?(); end

  def name(); end

  def node(); end

  def variables(); end
  OUTER_SCOPE_CHILD_INDICES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Scope
end

class RuboCop::Cop::VariableForce::Variable
  def argument?(); end

  def assign(node); end

  def assignments(); end

  def block_argument?(); end

  def capture_with_block!(); end

  def captured_by_block(); end

  def captured_by_block?(); end

  def declaration_node(); end

  def explicit_block_local_variable?(); end

  def in_modifier_if?(assignment); end

  def initialize(name, declaration_node, scope); end

  def keyword_argument?(); end

  def method_argument?(); end

  def name(); end

  def reference!(node); end

  def referenced?(); end

  def references(); end

  def scope(); end

  def should_be_unused?(); end

  def used?(); end
  VARIABLE_DECLARATION_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Variable
end

class RuboCop::Cop::VariableForce::VariableReference
  def assignment?(); end

  def name(); end

  def name=(_); end
end

class RuboCop::Cop::VariableForce::VariableReference
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Cop::VariableForce::VariableTable
  def accessible_variables(); end

  def assign_to_variable(name, node); end

  def current_scope(); end

  def current_scope_level(); end

  def declare_variable(name, node); end

  def find_variable(name); end

  def initialize(hook_receiver=T.unsafe(nil)); end

  def invoke_hook(hook_name, *args); end

  def pop_scope(); end

  def push_scope(scope_node); end

  def reference_variable(name, node); end

  def scope_stack(); end

  def variable_exist?(name); end
end

class RuboCop::Cop::VariableForce::VariableTable
end

class RuboCop::Cop::VariableForce
end

module RuboCop::Cop::VisibilityHelp
  def visibility_block?(param0=T.unsafe(nil)); end
  VISIBILITY_SCOPES = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::VisibilityHelp
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::Cop
end

class RuboCop::DirectiveComment
  def comment(); end

  def cops(); end

  def initialize(comment); end

  def match?(cop_names); end

  def range(); end
end

class RuboCop::DirectiveComment
end

class RuboCop::Error
end

class RuboCop::Error
end

class RuboCop::ErrorWithAnalyzedFileLocation
  def column(); end

  def cop(); end

  def initialize(cause:, node:, cop:); end

  def line(); end
end

class RuboCop::ErrorWithAnalyzedFileLocation
end

module RuboCop::Ext
end

module RuboCop::Ext::ProcessedSource
  def comment_config(); end

  def disabled_line_ranges(); end
end

module RuboCop::Ext::ProcessedSource
end

module RuboCop::Ext::RegexpNode
  def assign_properties(*_); end

  def each_capture(named: T.unsafe(nil)); end

  def parsed_tree(); end
end

module RuboCop::Ext::RegexpNode
end

module RuboCop::Ext::RegexpParser
end

module RuboCop::Ext::RegexpParser::Expression
end

module RuboCop::Ext::RegexpParser::Expression::Base
  def expression(); end

  def loc(); end

  def origin(); end

  def origin=(origin); end
end

module RuboCop::Ext::RegexpParser::Expression::Base
end

module RuboCop::Ext::RegexpParser::Expression::CharacterSet
  def build_location(); end
end

module RuboCop::Ext::RegexpParser::Expression::CharacterSet
end

module RuboCop::Ext::RegexpParser::Expression
end

class RuboCop::Ext::RegexpParser::Map
  def begin(); end

  def body(); end

  def end(); end

  def initialize(expression, body:, quantifier: T.unsafe(nil), begin_l: T.unsafe(nil), end_l: T.unsafe(nil)); end

  def quantifier(); end
end

class RuboCop::Ext::RegexpParser::Map
end

module RuboCop::Ext::RegexpParser
end

module RuboCop::Ext
end

module RuboCop::FileFinder
  def find_file_upwards(filename, start_dir, stop_dir=T.unsafe(nil)); end

  def find_last_file_upwards(filename, start_dir, stop_dir=T.unsafe(nil)); end
end

module RuboCop::FileFinder
  def self.root_level=(level); end

  def self.root_level?(path, stop_dir); end
end

module RuboCop::Formatter
end

class RuboCop::Formatter::AutoGenConfigFormatter
end

class RuboCop::Formatter::AutoGenConfigFormatter
end

class RuboCop::Formatter::BaseFormatter
  def file_finished(file, offenses); end

  def file_started(file, options); end

  def finished(inspected_files); end

  def initialize(output, options=T.unsafe(nil)); end

  def options(); end

  def output(); end

  def started(target_files); end
end

class RuboCop::Formatter::BaseFormatter
end

class RuboCop::Formatter::ClangStyleFormatter
  ELLIPSES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::ClangStyleFormatter
end

module RuboCop::Formatter::Colorizable
  def black(string); end

  def blue(string); end

  def colorize(string, *args); end

  def cyan(string); end

  def green(string); end

  def magenta(string); end

  def rainbow(); end

  def red(string); end

  def white(string); end

  def yellow(string); end
end

module RuboCop::Formatter::Colorizable
end

class RuboCop::Formatter::DisabledConfigFormatter
  include ::RuboCop::PathUtil
  def file_started(_file, _file_info); end

  def finished(_inspected_files); end
  HEADING = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::DisabledConfigFormatter
  def self.config_to_allow_offenses(); end

  def self.config_to_allow_offenses=(config_to_allow_offenses); end

  def self.detected_styles(); end

  def self.detected_styles=(detected_styles); end
end

class RuboCop::Formatter::EmacsStyleFormatter
end

class RuboCop::Formatter::EmacsStyleFormatter
end

class RuboCop::Formatter::FileListFormatter
end

class RuboCop::Formatter::FileListFormatter
end

class RuboCop::Formatter::FormatterSet
  def add_formatter(formatter_type, output_path=T.unsafe(nil)); end

  def close_output_files(); end

  def file_finished(file, offenses); end

  def file_started(file, options); end

  def finished(*args); end

  def initialize(options=T.unsafe(nil)); end

  def started(*args); end
  BUILTIN_FORMATTERS_FOR_KEYS = ::T.let(nil, ::T.untyped)
  FORMATTER_APIS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::FormatterSet
end

class RuboCop::Formatter::FuubarStyleFormatter
  def initialize(*output); end

  def progressbar_color(); end

  def started(target_files); end

  def with_color(); end
  RESET_SEQUENCE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::FuubarStyleFormatter
end

class RuboCop::Formatter::GitHubActionsFormatter
  ESCAPE_MAP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::GitHubActionsFormatter
end

class RuboCop::Formatter::HTMLFormatter
  def files(); end

  def render_html(); end

  def summary(); end
  ELLIPSES = ::T.let(nil, ::T.untyped)
  TEMPLATE_PATH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::HTMLFormatter::Color
  def alpha(); end

  def alpha=(_); end

  def blue(); end

  def blue=(_); end

  def fade_out(amount); end

  def green(); end

  def green=(_); end

  def red(); end

  def red=(_); end
end

class RuboCop::Formatter::HTMLFormatter::Color
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Formatter::HTMLFormatter::ERBContext
  include ::RuboCop::PathUtil
  include ::RuboCop::Formatter::TextUtil
  def base64_encoded_logo_image(); end

  def decorated_message(offense); end

  def escape(string); end

  def files(); end

  def highlighted_source_line(offense); end

  def hightlight_source_tag(offense); end

  def initialize(files, summary); end

  def possible_ellipses(location); end

  def source_after_highlight(offense); end

  def source_before_highlight(offense); end

  def summary(); end
  LOGO_IMAGE_PATH = ::T.let(nil, ::T.untyped)
  SEVERITY_COLORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::HTMLFormatter::ERBContext
end

class RuboCop::Formatter::HTMLFormatter
end

class RuboCop::Formatter::JSONFormatter
  include ::RuboCop::PathUtil
  def hash_for_file(file, offenses); end

  def hash_for_location(offense); end

  def hash_for_offense(offense); end

  def metadata_hash(); end

  def output_hash(); end
end

class RuboCop::Formatter::JSONFormatter
end

class RuboCop::Formatter::JUnitFormatter
  def classname_attribute_value(file); end

  def finished(_inspected_files); end

  def offenses_for_cop(all_offenses, cop); end

  def relevant_for_output?(options, target_offenses); end
end

class RuboCop::Formatter::JUnitFormatter
end

class RuboCop::Formatter::OffenseCountFormatter
  def file_finished(_file, offenses); end

  def finished(_inspected_files); end

  def offense_counts(); end

  def ordered_offense_counts(offense_counts); end

  def report_summary(offense_counts); end

  def total_offense_count(offense_counts); end
end

class RuboCop::Formatter::OffenseCountFormatter
end

class RuboCop::Formatter::PacmanFormatter
  include ::RuboCop::Formatter::TextUtil
  def cols(); end

  def file_started(_file, _options); end

  def next_step(offenses); end

  def pacdots(number); end

  def progress_line(); end

  def progress_line=(progress_line); end

  def started(target_files); end

  def step(character); end

  def update_progress_line(); end
  FALLBACK_TERMINAL_WIDTH = ::T.let(nil, ::T.untyped)
  GHOST = ::T.let(nil, ::T.untyped)
  PACDOT = ::T.let(nil, ::T.untyped)
  PACMAN = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::PacmanFormatter
end

class RuboCop::Formatter::ProgressFormatter
  include ::RuboCop::Formatter::TextUtil
  def report_file_as_mark(offenses); end

  def started(target_files); end
  DOT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::ProgressFormatter
end

class RuboCop::Formatter::QuietFormatter
end

class RuboCop::Formatter::QuietFormatter
end

class RuboCop::Formatter::SimpleTextFormatter
  include ::RuboCop::Formatter::Colorizable
  include ::RuboCop::PathUtil
  def report_file(file, offenses); end

  def report_summary(file_count, offense_count, correction_count, correctable_count); end

  def started(_target_files); end
  COLOR_FOR_SEVERITY = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::SimpleTextFormatter::Report
  include ::RuboCop::Formatter::Colorizable
  include ::RuboCop::Formatter::TextUtil
  def initialize(file_count, offense_count, correction_count, correctable_count, rainbow, safe_auto_correct: T.unsafe(nil)); end

  def summary(); end
end

class RuboCop::Formatter::SimpleTextFormatter::Report
end

class RuboCop::Formatter::SimpleTextFormatter
end

class RuboCop::Formatter::TapFormatter
  def started(target_files); end
end

class RuboCop::Formatter::TapFormatter
end

module RuboCop::Formatter::TextUtil
end

module RuboCop::Formatter::TextUtil
  def self.pluralize(number, thing, options=T.unsafe(nil)); end
end

class RuboCop::Formatter::WorstOffendersFormatter
  def finished(_inspected_files); end

  def offense_counts(); end

  def ordered_offense_counts(offense_counts); end

  def report_summary(offense_counts); end

  def total_offense_count(offense_counts); end
end

class RuboCop::Formatter::WorstOffendersFormatter
end

module RuboCop::Formatter
end

class RuboCop::IncorrectCopNameError
end

class RuboCop::IncorrectCopNameError
end

class RuboCop::Lockfile
  def dependencies(); end

  def gems(); end

  def includes_gem?(name); end
end

class RuboCop::Lockfile
end

class RuboCop::MagicComment
  def any?(); end

  def encoding_specified?(); end

  def frozen_string_literal(); end

  def frozen_string_literal?(); end

  def frozen_string_literal_specified?(); end

  def initialize(comment); end

  def valid_literal_value?(); end
  TOKEN = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment::EditorComment
end

class RuboCop::MagicComment::EditorComment
end

class RuboCop::MagicComment::EmacsComment
  def encoding(); end
  FORMAT = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment::EmacsComment
end

class RuboCop::MagicComment::SimpleComment
  def encoding(); end
end

class RuboCop::MagicComment::SimpleComment
end

class RuboCop::MagicComment::VimComment
  def encoding(); end
  FORMAT = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment::VimComment
end

class RuboCop::MagicComment
  def self.parse(comment); end
end

module RuboCop::NameSimilarity
end

module RuboCop::NameSimilarity
  def self.find_similar_name(target_name, names); end

  def self.find_similar_names(target_name, names); end
end

class RuboCop::AST::NodePattern
end

RuboCop::NodePattern::Builder = RuboCop::AST::NodePattern::Builder

class RuboCop::AST::NodePattern::Compiler
end

RuboCop::NodePattern::Compiler::Debug = RuboCop::AST::NodePattern::Compiler::Debug

class RuboCop::AST::NodePattern::Compiler
end

class RuboCop::AST::NodePattern::Lexer
end

RuboCop::NodePattern::Lexer::Error = RuboCop::AST::NodePattern::LexerRex::ScanError

class RuboCop::AST::NodePattern::Lexer
end

class RuboCop::AST::NodePattern
end

class RuboCop::OptionArgumentError
end

class RuboCop::OptionArgumentError
end

class RuboCop::Options
  def parse(command_line_args); end
  DEFAULT_MAXIMUM_EXCLUSION_ITEMS = ::T.let(nil, ::T.untyped)
  EXITING_OPTIONS = ::T.let(nil, ::T.untyped)
  E_STDIN_NO_PATH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Options
end

module RuboCop::OptionsHelp
  FORMATTER_OPTION_LIST = ::T.let(nil, ::T.untyped)
  MAX_EXCL = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
end

module RuboCop::OptionsHelp
end

class RuboCop::OptionsValidator
  def boolean_or_empty_cache?(); end

  def display_only_fail_level_offenses_with_autocorrect?(); end

  def except_syntax?(); end

  def incompatible_options(); end

  def initialize(options); end

  def only_includes_redundant_disable?(); end

  def validate_auto_correct(); end

  def validate_auto_gen_config(); end

  def validate_cache_enabled_for_cache_root(); end

  def validate_compatibility(); end

  def validate_cop_options(); end

  def validate_display_only_failed(); end

  def validate_exclude_limit_option(); end

  def validate_parallel(); end

  def validate_parallel_with_combo_option(); end
end

class RuboCop::OptionsValidator
  def self.validate_cop_list(names); end
end

module RuboCop::PathUtil
end

module RuboCop::PathUtil
  def self.absolute?(path); end

  def self.hidden_dir?(path); end

  def self.hidden_file?(path); end

  def self.hidden_file_in_not_hidden_dir?(pattern, path); end

  def self.match_path?(pattern, path); end

  def self.maybe_hidden_file?(path); end

  def self.relative_path(path, base_dir=T.unsafe(nil)); end

  def self.smart_path(path); end
end

module RuboCop::Platform
end

module RuboCop::Platform
  def self.windows?(); end
end

RuboCop::ProcessedSource = RuboCop::AST::ProcessedSource

class RuboCop::RemoteConfig
  def file(); end

  def inherit_from_remote(file, path); end

  def initialize(url, base_dir); end

  def uri(); end
  CACHE_LIFETIME = ::T.let(nil, ::T.untyped)
end

class RuboCop::RemoteConfig
end

class RuboCop::ResultCache
  def debug?(); end

  def initialize(file, team, options, config_store, cache_root=T.unsafe(nil)); end

  def load(); end

  def path(); end

  def save(offenses); end

  def valid?(); end
  NON_CHANGING = ::T.let(nil, ::T.untyped)
end

class RuboCop::ResultCache
  def self.allow_symlinks_in_cache_location?(config_store); end

  def self.cache_root(config_store); end

  def self.cleanup(config_store, verbose, cache_root=T.unsafe(nil)); end

  def self.inhibit_cleanup(); end

  def self.inhibit_cleanup=(inhibit_cleanup); end

  def self.rubocop_required_features(); end

  def self.rubocop_required_features=(rubocop_required_features); end

  def self.source_checksum(); end

  def self.source_checksum=(source_checksum); end
end

class RuboCop::Runner
  def aborting=(aborting); end

  def aborting?(); end

  def errors(); end

  def initialize(options, config_store); end

  def run(paths); end

  def warnings(); end
  MAX_ITERATIONS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Runner::InfiniteCorrectionLoop
  def initialize(path, offenses_by_iteration, loop_start: T.unsafe(nil)); end

  def offenses(); end
end

class RuboCop::Runner::InfiniteCorrectionLoop
end

class RuboCop::Runner
end

class RuboCop::StringInterpreter
end

class RuboCop::StringInterpreter
  def self.interpret(string); end
end

class RuboCop::TargetFinder
  def all_cops_include(); end

  def combined_exclude_glob_patterns(base_dir); end

  def configured_include?(file); end

  def debug?(); end

  def fail_fast?(); end

  def find(args, mode); end

  def find_files(base_dir, flags); end

  def force_exclusion?(); end

  def included_file?(file); end

  def initialize(config_store, options=T.unsafe(nil)); end

  def process_explicit_path(path, mode); end

  def ruby_executable?(file); end

  def ruby_extension?(file); end

  def ruby_extensions(); end

  def ruby_file?(file); end

  def ruby_filename?(file); end

  def ruby_filenames(); end

  def ruby_interpreters(file); end

  def stdin?(); end

  def target_files_in_dir(base_dir=T.unsafe(nil)); end

  def to_inspect?(file, hidden_files, base_dir_config); end

  def wanted_dir_patterns(base_dir, exclude_pattern, flags); end
  HIDDEN_PATH_SUBSTRING = ::T.let(nil, ::T.untyped)
end

class RuboCop::TargetFinder
end

class RuboCop::TargetRuby
  def initialize(config); end

  def rubocop_version_with_support(); end

  def source(); end

  def supported?(); end

  def version(); end
  DEFAULT_VERSION = ::T.let(nil, ::T.untyped)
end

class RuboCop::TargetRuby::BundlerLockFile
end

class RuboCop::TargetRuby::BundlerLockFile
end

class RuboCop::TargetRuby::Default
end

class RuboCop::TargetRuby::Default
end

class RuboCop::TargetRuby::GemspecFile
  def gem_requirement?(param0=T.unsafe(nil)); end

  def required_ruby_version(param0); end
  GEMSPEC_EXTENSION = ::T.let(nil, ::T.untyped)
end

class RuboCop::TargetRuby::GemspecFile
  extend ::RuboCop::AST::NodePattern::Macros
end

class RuboCop::TargetRuby::RuboCopConfig
end

class RuboCop::TargetRuby::RuboCopConfig
end

class RuboCop::TargetRuby::RubyVersionFile
  FILENAME = ::T.let(nil, ::T.untyped)
end

class RuboCop::TargetRuby::RubyVersionFile
end

class RuboCop::TargetRuby::Source
  def initialize(config); end

  def name(); end

  def version(); end
end

class RuboCop::TargetRuby::Source
end

class RuboCop::TargetRuby
  def self.supported_versions(); end
end

RuboCop::Token = RuboCop::AST::Token

class RuboCop::ValidationError
end

class RuboCop::ValidationError
end

module RuboCop::Version
  CANONICAL_FEATURE_NAMES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
end

module RuboCop::Version
  def self.document_version(); end

  def self.extension_versions(env); end

  def self.feature_version(feature); end

  def self.version(debug: T.unsafe(nil), env: T.unsafe(nil)); end
end

class RuboCop::Warning
end

class RuboCop::Warning
end

module RuboCop::YAMLDuplicationChecker
end

module RuboCop::YAMLDuplicationChecker
  def self.check(yaml_string, filename, &on_duplicated); end
end

module RuboCop
end

module RubyDep
  VERSION = ::T.let(nil, ::T.untyped)
end

class RubyDep::Travis
  def version_constraint(filename=T.unsafe(nil)); end
end

class RubyDep::Travis::RubyVersion
  def initialize(travis_version_string); end

  def segments(); end
  REGEXP = ::T.let(nil, ::T.untyped)
end

class RubyDep::Travis::RubyVersion::Error
end

class RubyDep::Travis::RubyVersion::Error::Unrecognized
  def initialize(invalid_version_string); end
end

class RubyDep::Travis::RubyVersion::Error::Unrecognized::JRubyVersion
end

class RubyDep::Travis::RubyVersion::Error::Unrecognized::JRubyVersion
end

class RubyDep::Travis::RubyVersion::Error::Unrecognized
end

class RubyDep::Travis::RubyVersion::Error
end

class RubyDep::Travis::RubyVersion
end

class RubyDep::Travis
end

class RubyLex
  include ::RubyToken
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end

  def char_no(); end

  def each_top_level_statement(); end

  def eof?(); end

  def exception_on_syntax_error(); end

  def exception_on_syntax_error=(exception_on_syntax_error); end

  def get_readed(); end

  def getc(); end

  def getc_of_rests(); end

  def gets(); end

  def identify_comment(); end

  def identify_gvar(); end

  def identify_here_document(); end

  def identify_identifier(); end

  def identify_number(); end

  def identify_quotation(); end

  def identify_string(ltype, quoted=T.unsafe(nil)); end

  def identify_string_dvar(); end

  def indent(); end

  def initialize_input(); end

  def lex(); end

  def lex_init(); end

  def lex_int2(); end

  def line_no(); end

  def peek(i=T.unsafe(nil)); end

  def peek_equal?(str); end

  def peek_match?(regexp); end

  def prompt(); end

  def read_escape(); end

  def readed_auto_clean_up(); end

  def readed_auto_clean_up=(readed_auto_clean_up); end

  def seek(); end

  def set_input(io, p=T.unsafe(nil), &block); end

  def set_prompt(p=T.unsafe(nil), &block); end

  def skip_space(); end

  def skip_space=(skip_space); end

  def token(); end

  def ungetc(c=T.unsafe(nil)); end
  DEINDENT_CLAUSE = ::T.let(nil, ::T.untyped)
  DLtype2Token = ::T.let(nil, ::T.untyped)
  ENINDENT_CLAUSE = ::T.let(nil, ::T.untyped)
  Ltype2Token = ::T.let(nil, ::T.untyped)
  PERCENT_LTYPE = ::T.let(nil, ::T.untyped)
  PERCENT_PAREN = ::T.let(nil, ::T.untyped)
end

class RubyLex::AlreadyDefinedToken
end

class RubyLex::AlreadyDefinedToken
end

class RubyLex::SyntaxError
end

class RubyLex::SyntaxError
end

class RubyLex::TerminateLineInput
end

class RubyLex::TerminateLineInput
end

class RubyLex::TkReading2TokenDuplicateError
end

class RubyLex::TkReading2TokenDuplicateError
end

class RubyLex::TkReading2TokenNoKey
end

class RubyLex::TkReading2TokenNoKey
end

class RubyLex::TkSymbol2TokenNoKey
end

class RubyLex::TkSymbol2TokenNoKey
end

class RubyLex
  extend ::Exception2MessageMapper
  def self.debug?(); end

  def self.debug_level(); end

  def self.debug_level=(debug_level); end

  def self.included(mod); end
end

module RubyToken
  def Token(token, value=T.unsafe(nil)); end
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  TkReading2Token = ::T.let(nil, ::T.untyped)
  TkSymbol2Token = ::T.let(nil, ::T.untyped)
  TokenDefinitions = ::T.let(nil, ::T.untyped)
end

class RubyToken::TkALIAS
end

class RubyToken::TkALIAS
end

class RubyToken::TkAMPER
end

class RubyToken::TkAMPER
end

class RubyToken::TkAND
end

class RubyToken::TkAND
end

class RubyToken::TkANDOP
end

class RubyToken::TkANDOP
end

class RubyToken::TkAREF
end

class RubyToken::TkAREF
end

class RubyToken::TkASET
end

class RubyToken::TkASET
end

class RubyToken::TkASSIGN
end

class RubyToken::TkASSIGN
end

class RubyToken::TkASSOC
end

class RubyToken::TkASSOC
end

class RubyToken::TkAT
end

class RubyToken::TkAT
end

class RubyToken::TkBACKQUOTE
end

class RubyToken::TkBACKQUOTE
end

class RubyToken::TkBACKSLASH
end

class RubyToken::TkBACKSLASH
end

class RubyToken::TkBACK_REF
end

class RubyToken::TkBACK_REF
end

class RubyToken::TkBEGIN
end

class RubyToken::TkBEGIN
end

class RubyToken::TkBITAND
end

class RubyToken::TkBITAND
end

class RubyToken::TkBITNOT
end

class RubyToken::TkBITNOT
end

class RubyToken::TkBITOR
end

class RubyToken::TkBITOR
end

class RubyToken::TkBITXOR
end

class RubyToken::TkBITXOR
end

class RubyToken::TkBREAK
end

class RubyToken::TkBREAK
end

class RubyToken::TkCASE
end

class RubyToken::TkCASE
end

class RubyToken::TkCLASS
end

class RubyToken::TkCLASS
end

class RubyToken::TkCMP
end

class RubyToken::TkCMP
end

class RubyToken::TkCOLON
end

class RubyToken::TkCOLON
end

class RubyToken::TkCOLON2
end

class RubyToken::TkCOLON2
end

class RubyToken::TkCOLON3
end

class RubyToken::TkCOLON3
end

class RubyToken::TkCOMMA
end

class RubyToken::TkCOMMA
end

class RubyToken::TkCOMMENT
end

class RubyToken::TkCOMMENT
end

class RubyToken::TkCONSTANT
end

class RubyToken::TkCONSTANT
end

class RubyToken::TkCVAR
end

class RubyToken::TkCVAR
end

class RubyToken::TkDEF
end

class RubyToken::TkDEF
end

class RubyToken::TkDEFINED
end

class RubyToken::TkDEFINED
end

class RubyToken::TkDIV
end

class RubyToken::TkDIV
end

class RubyToken::TkDO
end

class RubyToken::TkDO
end

class RubyToken::TkDOLLAR
end

class RubyToken::TkDOLLAR
end

class RubyToken::TkDOT
end

class RubyToken::TkDOT
end

class RubyToken::TkDOT2
end

class RubyToken::TkDOT2
end

class RubyToken::TkDOT3
end

class RubyToken::TkDOT3
end

class RubyToken::TkDREGEXP
end

class RubyToken::TkDREGEXP
end

class RubyToken::TkDSTRING
end

class RubyToken::TkDSTRING
end

class RubyToken::TkDXSTRING
end

class RubyToken::TkDXSTRING
end

class RubyToken::TkELSE
end

class RubyToken::TkELSE
end

class RubyToken::TkELSIF
end

class RubyToken::TkELSIF
end

class RubyToken::TkEND
end

class RubyToken::TkEND
end

class RubyToken::TkEND_OF_SCRIPT
end

class RubyToken::TkEND_OF_SCRIPT
end

class RubyToken::TkENSURE
end

class RubyToken::TkENSURE
end

class RubyToken::TkEQ
end

class RubyToken::TkEQ
end

class RubyToken::TkEQQ
end

class RubyToken::TkEQQ
end

class RubyToken::TkError
end

class RubyToken::TkError
end

class RubyToken::TkFALSE
end

class RubyToken::TkFALSE
end

class RubyToken::TkFID
end

class RubyToken::TkFID
end

class RubyToken::TkFLOAT
end

class RubyToken::TkFLOAT
end

class RubyToken::TkFOR
end

class RubyToken::TkFOR
end

class RubyToken::TkGEQ
end

class RubyToken::TkGEQ
end

class RubyToken::TkGT
end

class RubyToken::TkGT
end

class RubyToken::TkGVAR
end

class RubyToken::TkGVAR
end

class RubyToken::TkIDENTIFIER
end

class RubyToken::TkIDENTIFIER
end

class RubyToken::TkIF
end

class RubyToken::TkIF
end

class RubyToken::TkIF_MOD
end

class RubyToken::TkIF_MOD
end

class RubyToken::TkIN
end

class RubyToken::TkIN
end

class RubyToken::TkINTEGER
end

class RubyToken::TkINTEGER
end

class RubyToken::TkIVAR
end

class RubyToken::TkIVAR
end

class RubyToken::TkId
  def initialize(seek, line_no, char_no, name); end

  def name(); end
end

class RubyToken::TkId
end

class RubyToken::TkLBRACE
end

class RubyToken::TkLBRACE
end

class RubyToken::TkLBRACK
end

class RubyToken::TkLBRACK
end

class RubyToken::TkLEQ
end

class RubyToken::TkLEQ
end

class RubyToken::TkLPAREN
end

class RubyToken::TkLPAREN
end

class RubyToken::TkLSHFT
end

class RubyToken::TkLSHFT
end

class RubyToken::TkLT
end

class RubyToken::TkLT
end

class RubyToken::TkMATCH
end

class RubyToken::TkMATCH
end

class RubyToken::TkMINUS
end

class RubyToken::TkMINUS
end

class RubyToken::TkMOD
end

class RubyToken::TkMOD
end

class RubyToken::TkMODULE
end

class RubyToken::TkMODULE
end

class RubyToken::TkMULT
end

class RubyToken::TkMULT
end

class RubyToken::TkNEQ
end

class RubyToken::TkNEQ
end

class RubyToken::TkNEXT
end

class RubyToken::TkNEXT
end

class RubyToken::TkNIL
end

class RubyToken::TkNIL
end

class RubyToken::TkNL
end

class RubyToken::TkNL
end

class RubyToken::TkNMATCH
end

class RubyToken::TkNMATCH
end

class RubyToken::TkNOT
end

class RubyToken::TkNOT
end

class RubyToken::TkNOTOP
end

class RubyToken::TkNOTOP
end

class RubyToken::TkNTH_REF
end

class RubyToken::TkNTH_REF
end

class RubyToken::TkNode
  def node(); end
end

class RubyToken::TkNode
end

class RubyToken::TkOPASGN
  def initialize(seek, line_no, char_no, op); end

  def op(); end
end

class RubyToken::TkOPASGN
end

class RubyToken::TkOR
end

class RubyToken::TkOR
end

class RubyToken::TkOROP
end

class RubyToken::TkOROP
end

class RubyToken::TkOp
  def name(); end

  def name=(name); end
end

class RubyToken::TkOp
end

class RubyToken::TkPLUS
end

class RubyToken::TkPLUS
end

class RubyToken::TkPOW
end

class RubyToken::TkPOW
end

class RubyToken::TkQUESTION
end

class RubyToken::TkQUESTION
end

class RubyToken::TkRBRACE
end

class RubyToken::TkRBRACE
end

class RubyToken::TkRBRACK
end

class RubyToken::TkRBRACK
end

class RubyToken::TkRD_COMMENT
end

class RubyToken::TkRD_COMMENT
end

class RubyToken::TkREDO
end

class RubyToken::TkREDO
end

class RubyToken::TkREGEXP
end

class RubyToken::TkREGEXP
end

class RubyToken::TkRESCUE
end

class RubyToken::TkRESCUE
end

class RubyToken::TkRETRY
end

class RubyToken::TkRETRY
end

class RubyToken::TkRETURN
end

class RubyToken::TkRETURN
end

class RubyToken::TkRPAREN
end

class RubyToken::TkRPAREN
end

class RubyToken::TkRSHFT
end

class RubyToken::TkRSHFT
end

class RubyToken::TkSELF
end

class RubyToken::TkSELF
end

class RubyToken::TkSEMICOLON
end

class RubyToken::TkSEMICOLON
end

class RubyToken::TkSPACE
end

class RubyToken::TkSPACE
end

class RubyToken::TkSTAR
end

class RubyToken::TkSTAR
end

class RubyToken::TkSTRING
end

class RubyToken::TkSTRING
end

class RubyToken::TkSUPER
end

class RubyToken::TkSUPER
end

class RubyToken::TkSYMBEG
end

class RubyToken::TkSYMBEG
end

class RubyToken::TkSYMBOL
end

class RubyToken::TkSYMBOL
end

class RubyToken::TkTHEN
end

class RubyToken::TkTHEN
end

class RubyToken::TkTRUE
end

class RubyToken::TkTRUE
end

class RubyToken::TkUMINUS
end

class RubyToken::TkUMINUS
end

class RubyToken::TkUNDEF
end

class RubyToken::TkUNDEF
end

class RubyToken::TkUNLESS
end

class RubyToken::TkUNLESS
end

class RubyToken::TkUNLESS_MOD
end

class RubyToken::TkUNLESS_MOD
end

class RubyToken::TkUNTIL
end

class RubyToken::TkUNTIL
end

class RubyToken::TkUNTIL_MOD
end

class RubyToken::TkUNTIL_MOD
end

class RubyToken::TkUPLUS
end

class RubyToken::TkUPLUS
end

class RubyToken::TkUnknownChar
  def initialize(seek, line_no, char_no, id); end

  def name(); end
end

class RubyToken::TkUnknownChar
end

class RubyToken::TkVal
  def initialize(seek, line_no, char_no, value=T.unsafe(nil)); end

  def value(); end
end

class RubyToken::TkVal
end

class RubyToken::TkWHEN
end

class RubyToken::TkWHEN
end

class RubyToken::TkWHILE
end

class RubyToken::TkWHILE
end

class RubyToken::TkWHILE_MOD
end

class RubyToken::TkWHILE_MOD
end

class RubyToken::TkXSTRING
end

class RubyToken::TkXSTRING
end

class RubyToken::TkYIELD
end

class RubyToken::TkYIELD
end

class RubyToken::Tk__FILE__
end

class RubyToken::Tk__FILE__
end

class RubyToken::Tk__LINE__
end

class RubyToken::Tk__LINE__
end

class RubyToken::TkfLBRACE
end

class RubyToken::TkfLBRACE
end

class RubyToken::TkfLBRACK
end

class RubyToken::TkfLBRACK
end

class RubyToken::TkfLPAREN
end

class RubyToken::TkfLPAREN
end

class RubyToken::TklBEGIN
end

class RubyToken::TklBEGIN
end

class RubyToken::TklEND
end

class RubyToken::TklEND
end

class RubyToken::Token
  def char_no(); end

  def initialize(seek, line_no, char_no); end

  def line_no(); end

  def seek(); end
end

class RubyToken::Token
end

module RubyToken
  def self.def_token(token_n, super_token=T.unsafe(nil), reading=T.unsafe(nil), *opts); end
end

class RubyVM::AbstractSyntaxTree::Node
  def ==(other); end

  def pretty_print_children(q, names=T.unsafe(nil)); end

  def to_sexp(); end
end

class RubyVM::InstructionSequence
  extend ::Bootsnap::CompileCache::ISeq::InstructionSequenceMixin
end

module RubyVM::MJIT
end

module RubyVM::MJIT
  def self.enabled?(); end

  def self.pause(*_); end

  def self.resume(); end
end

class RubyVM
  def self.resolve_feature_path(_); end
end

ScanError = StringScanner::Error

class Set
  include ::Mongoid::Extensions::Set
  def ==(other); end

  def ===(o); end

  def compare_by_identity(); end

  def compare_by_identity?(); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
end

class Set
  extend ::Mongoid::Criteria::Queryable::Extensions::Set::ClassMethods
end

module Singleton
  def _dump(depth=T.unsafe(nil)); end

  def clone(); end

  def dup(); end
end

module Singleton::SingletonClassMethods
  def _load(str); end

  def clone(); end
end

module Singleton
  def self.__init__(klass); end
end

class Socket
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  SO_BPF_EXTENSIONS = ::T.let(nil, ::T.untyped)
end

module Socket::Constants
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  SO_BPF_EXTENSIONS = ::T.let(nil, ::T.untyped)
end

class SortedSet
  def initialize(*args, &block); end
end

class SortedSet
  def self.setup(); end
end

class Spoom::Cli::Bump
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Spoom::Cli::Helper
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Spoom::Cli::Main
  extend ::T::Sig
end

class Spoom::Coverage::D3::Base
  extend ::T::Sig
  extend ::T::Helpers
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Spoom::Coverage::D3
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Spoom::Coverage::Snapshot
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Spoom::Coverage::Template
  extend ::T::Sig
  extend ::T::Helpers
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Spoom::Coverage
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Spoom::FileTree::Node
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Spoom::FileTree
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Spoom::Git
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Spoom::LSP::Diagnostic
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Spoom::LSP::DocumentSymbol
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Spoom::LSP::Hover
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Spoom::LSP::Location
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Spoom::LSP::Position
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Spoom::LSP::PrintableSymbol
  extend ::T::Sig
  extend ::T::Helpers
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Spoom::LSP::Range
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Spoom::LSP::SignatureHelp
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Spoom::Printer
  extend ::T::Sig
  extend ::T::Helpers
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Spoom::Sorbet::Config
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Spoom::Sorbet::Errors::Error
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Spoom::Sorbet::Errors::Parser
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Spoom::Sorbet::MetricsParser
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Spoom::Sorbet::Sigils
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Spoom::Sorbet
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Spoom::Timeline
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class String
  def black(); end

  def blink(); end

  def blue(); end

  def bold(); end

  def bson_type(); end

  def cyan(); end

  def green(); end

  def hide(); end

  def italic(); end

  def light_black(); end

  def light_blue(); end

  def light_cyan(); end

  def light_green(); end

  def light_magenta(); end

  def light_red(); end

  def light_white(); end

  def light_yellow(); end

  def magenta(); end

  def on_black(); end

  def on_blue(); end

  def on_cyan(); end

  def on_green(); end

  def on_light_black(); end

  def on_light_blue(); end

  def on_light_cyan(); end

  def on_light_green(); end

  def on_light_magenta(); end

  def on_light_red(); end

  def on_light_white(); end

  def on_light_yellow(); end

  def on_magenta(); end

  def on_red(); end

  def on_white(); end

  def on_yellow(); end

  def parse_csv(**options); end

  def red(); end

  def shellescape(); end

  def shellsplit(); end

  def swap(); end

  def underline(); end

  def white(); end

  def yellow(); end
end

class StringScanner
  def bol?(); end

  def initialize(*_); end
  Id = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Struct
  def filter(*_); end
end

class Symbol
  def add_to_set(); end

  def all(); end

  def asc(); end

  def ascending(); end

  def avg(); end

  def desc(); end

  def descending(); end

  def elem_match(); end

  def exists(); end

  def first(); end

  def gt(); end

  def gte(); end

  def in(); end

  def intersects_line(); end

  def intersects_point(); end

  def intersects_polygon(); end

  def last(); end

  def lt(); end

  def lte(); end

  def max(); end

  def min(); end

  def mod(); end

  def ne(); end

  def near(); end

  def near_sphere(); end

  def nin(); end

  def not(); end

  def push(); end

  def sum(); end

  def with_size(); end

  def with_type(); end

  def within_box(); end

  def within_polygon(); end
end

class Tapioca::Compilers::Dsl::Base
  extend ::T::Sig
  extend ::T::Helpers
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Tapioca::Compilers::DslCompiler
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Tapioca::Compilers::RequiresCompiler
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Tapioca::Compilers::Sorbet
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Tapioca::Compilers::SymbolTable::SymbolGenerator
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Tapioca::Compilers::SymbolTable::SymbolLoader
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Tapioca::Compilers::SymbolTableCompiler
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Tapioca::Compilers::TodosCompiler
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Tapioca::Config
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Tapioca::ConfigBuilder
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Tapioca::Gemfile
  Spec = ::T.let(nil, ::T.untyped)
end

class Tapioca::Gemfile::Gem
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Tapioca::Gemfile
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Tapioca::Generator
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Tapioca::Loader
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Tempfile
  def _close(); end

  def inspect(); end
end

class Tempfile::Remover
  def call(*args); end

  def initialize(tmpfile); end
end

class Tempfile::Remover
end

module ThreadSafe::Util::CheapLockable
  def cas_mutex(old_value, new_value); end

  def compare_and_set_mutex(old_value, new_value); end

  def lazy_set_mutex(value); end

  def mutex(); end

  def mutex=(value); end
end

class Tilt::Mapping
  AUTOLOAD_IS_BROKEN = ::T.let(nil, ::T.untyped)
end

class Time
  def bson_type(); end

  def compare_without_coercion(_); end

  def eql_without_coercion(_); end

  def minus_without_duration(_); end

  def plus_without_duration(_); end

  def rfc3339(fraction_digits=T.unsafe(nil)); end

  def to_default_s(); end
end

class Time
  def self.at_without_coercion(*_); end
end

class TracePoint
  def __enable(_, _1); end

  def eval_script(); end

  def instruction_sequence(); end

  def parameters(); end
end

class URI::FTP
  def buffer_open(buf, proxy, options); end
end

class URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::File
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class URI::HTTP
  def buffer_open(buf, proxy, options); end
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::MailTo
  def initialize(*arg); end
end

class URI::RFC2396_Parser
  def initialize(opts=T.unsafe(nil)); end
end

class URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

module URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module URI
  def self.get_encoding(label); end
end

module Warning
  extend ::Warning
end

class WeakRef
  def initialize(orig); end
end

class Zlib::Deflate
  def initialize(*_); end
end

class Zlib::GzipReader
  def initialize(*_); end
end

class Zlib::GzipWriter
  def initialize(*_); end
end

class Zlib::Inflate
  def initialize(*_); end
end
