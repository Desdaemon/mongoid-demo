# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `ast_utils` gem.
# Please instead update this file by running `tapioca sync`.

# typed: true

module ASTUtils
end

class ASTUtils::Labeling
  include(::ASTUtils::NodeHelper)

  def initialize; end

  def counter; end
  def counter=(_arg0); end
  def lookup_env(name:, env:); end
  def next_label!; end
  def replace(array, index); end
  def translate(node, env); end
  def translate_child!(children, index, env); end

  class << self
    def extract_variables(string); end
    def translate(node:); end
  end
end

class ASTUtils::Labeling::LabeledName
  def initialize(name:, label:); end

  def ==(other); end
  def eql?(other); end
  def equal?(other); end
  def hash; end
  def inspect; end
  def label; end
  def name; end
end

class ASTUtils::Navigation
  include(::ASTUtils::NodeHelper)

  def initialize(node:); end

  def construct; end
  def nodes; end
  def parent(node); end
  def parents; end
  def root; end
  def set_parent(node); end

  class << self
    def from(node:); end
  end
end

module ASTUtils::NodeHelper
  def each_child_node(node); end
  def map_child_node(node); end
end

class ASTUtils::NodeSet
  include(::Enumerable)

  def initialize(objects = T.unsafe(nil)); end

  def +(other); end
  def <<(node); end
  def delete(node); end
  def each(&block); end
  def empty?; end
  def set; end
  def size; end
end

class ASTUtils::NodeSet::Item
  def initialize(object); end

  def ==(other); end
  def eql?(other); end
  def hash; end
  def object; end
end

class ASTUtils::PartialMap
  def initialize(enumerable); end

  def apply; end
  def enumerable; end
  def on(index, &block); end
  def on!(index, &block); end
  def on?(index, &block); end
  def updaters; end

  class << self
    def apply(enumerable); end
  end
end

class ASTUtils::Scope
  include(::ASTUtils::NodeHelper)

  def initialize(root:); end

  def add_scope(scope); end
  def all_scopes; end
  def assignment_nodes; end
  def assignments(scope, include_subs: T.unsafe(nil)); end
  def child_scope!(scope, parent_scope); end
  def child_scopes; end
  def children(scope); end
  def construct; end
  def construct_children(node, current_scope); end
  def construct_node(node, current_scope); end
  def each(&block); end
  def nested_scope!(scope, super_scope); end
  def parent(scope); end
  def parent_scopes; end
  def reference_nodes; end
  def references(scope, include_subs: T.unsafe(nil)); end
  def root; end
  def sub_scopes; end
  def subs(scope); end
  def sup(scope); end
  def super_scopes; end
  def valid_scope!(node); end

  class << self
    def from(node:); end
    def scope_node?(node); end
  end
end

class ASTUtils::Scope::Assignment
  def initialize(node:, variable:); end

  def ==(other); end
  def eql?(other); end
  def hash; end
  def node; end
  def variable; end
end

ASTUtils::VERSION = T.let(T.unsafe(nil), String)
