# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/bson/all/bson.rbi
#
# bson-4.11.1

module BSON
  def self.ObjectId(string); end
end
module BSON::Environment
  def jruby?; end
  def ruby_1_9?; end
  extend BSON::Environment
end
module BSON::Config
  def validating_keys=(value); end
  def validating_keys?; end
  extend BSON::Config
end
class BSON::Error < StandardError
end
class BSON::Error::ExtJSONParseError < BSON::Error
end
class BSON::Error::UnsupportedBinarySubtype < BSON::Error
end
class BSON::Error::BSONDecodeError < BSON::Error
end
class BSON::Error::UnserializableClass < BSON::Error
end
module BSON::Registry
  def define_type_reader(type); end
  def get(byte, field = nil); end
  def handle_unsupported_type!(byte, field); end
  def register(byte, type); end
  extend BSON::Registry
end
class BSON::Registry::UnsupportedType < RuntimeError
end
module BSON::Specialized
  def ==(other); end
  def self.included(klass); end
  def to_bson(buffer = nil, validating_keys = nil); end
end
module BSON::Specialized::ClassMethods
  def from_bson(buffer, **options); end
end
module BSON::JSON
  def to_json(*args); end
end
class BSON::Int32
  def ==(other); end
  def ===(other); end
  def as_extended_json(**options); end
  def bson_type; end
  def eql?(other); end
  def initialize(value); end
  def self.from_bson(buffer, **options); end
  def to_bson(buffer = nil, validating_keys = nil); end
  def to_bson_key(validating_keys = nil); end
  def value; end
end
class BSON::Int64
  def ==(other); end
  def ===(other); end
  def as_extended_json(**options); end
  def bson_type; end
  def eql?(other); end
  def initialize(value); end
  def self.from_bson(buffer, **options); end
  def to_bson(buffer = nil, validating_keys = nil); end
  def to_bson_key(validating_keys = nil); end
  def value; end
end
module BSON::Integer
  def append_bson_int32(encoded); end
  def as_extended_json(**options); end
  def bson_int32?; end
  def bson_int64?; end
  def bson_type; end
  def out_of_range!; end
  def to_bson(buffer = nil, validating_keys = nil); end
  def to_bson_int32(encoded); end
  def to_bson_int64(encoded); end
  def to_bson_key(validating_keys = nil); end
end
class Integer < Numeric
  include BSON::Integer
end
module BSON::Array
  def as_extended_json(**options); end
  def to_bson(buffer = nil, validating_keys = nil); end
  def to_bson_normalized_value; end
  def to_bson_object_id; end
end
module BSON::Array::ClassMethods
  def from_bson(buffer, **options); end
end
class Array
  def bson_type; end
  extend BSON::Array::ClassMethods
  include BSON::Array
end
class BSON::Binary
  def ==(other); end
  def as_extended_json(**options); end
  def as_json(*args); end
  def bson_type; end
  def data; end
  def eql?(other); end
  def hash; end
  def initialize(data = nil, type = nil); end
  def inspect; end
  def self.from_bson(buffer, **options); end
  def self.from_uuid(uuid, representation = nil); end
  def to_bson(buffer = nil, validating_keys = nil); end
  def to_uuid(representation = nil); end
  def type; end
  def validate_type!(type); end
  include BSON::JSON
end
class BSON::Binary::InvalidType < RuntimeError
  def initialize(type); end
  def message; end
  def type; end
end
class BSON::Boolean
  def bson_type; end
  def self.from_bson(buffer, **options); end
end
class BSON::Code
  def ==(other); end
  def as_extended_json(**options); end
  def as_json(*args); end
  def bson_type; end
  def initialize(javascript = nil); end
  def javascript; end
  def self.from_bson(buffer, **options); end
  def to_bson(buffer = nil, validating_keys = nil); end
  include BSON::JSON
end
class BSON::CodeWithScope
  def ==(other); end
  def as_extended_json(**options); end
  def as_json(*args); end
  def bson_type; end
  def initialize(javascript = nil, scope = nil); end
  def javascript; end
  def scope; end
  def self.from_bson(buffer, **options); end
  def to_bson(buffer = nil, validating_keys = nil); end
  include BSON::JSON
end
module BSON::Date
  def bson_type; end
  def to_bson(buffer = nil, validating_keys = nil); end
end
class Date
  include BSON::Date
end
module BSON::DateTime
  def to_bson(buffer = nil, validating_keys = nil); end
end
class DateTime < Date
  include BSON::DateTime
end
class BSON::DbPointer
  def ==(other); end
  def as_extended_json(**options); end
  def as_json(*args); end
  def bson_type; end
  def id; end
  def initialize(ref, id); end
  def ref; end
  def self.from_bson(buffer, **options); end
  def to_bson(buffer = nil, validating_keys = nil); end
  include BSON::JSON
end
class BSON::Decimal128
  def ==(other); end
  def as_extended_json(**options); end
  def as_json(*args); end
  def bson_type; end
  def eql?(other); end
  def hash; end
  def initialize(object); end
  def inspect; end
  def self.from_bits(low, high); end
  def self.from_bson(buffer, **options); end
  def self.from_string(string); end
  def set_bits(low, high); end
  def to_big_decimal; end
  def to_bson(buffer = nil, validating_keys = nil); end
  def to_s; end
  def to_str; end
  include BSON::JSON
end
module BSON::Decimal128::Builder
  def parts_to_bits(significand, exponent, is_negative); end
  def valid_exponent?(exponent); end
  def valid_significand?(significand); end
  def validate_range!(exponent, significand); end
  extend BSON::Decimal128::Builder
end
class BSON::Decimal128::Builder::FromString
  def bits; end
  def clamp(exponent, significand); end
  def initialize(string); end
  def round_exact(exponent, significand); end
  def special?; end
  def to_bits; end
  def to_special_bits; end
  def validate_format!; end
end
class BSON::Decimal128::Builder::FromBigDecimal
  def bits; end
  def initialize(big_decimal); end
  def special?; end
  def to_bits; end
  def to_special_bits; end
end
class BSON::Decimal128::Builder::ToString
  def bits_to_significand; end
  def create_string; end
  def exponent; end
  def high_bits; end
  def infinity?; end
  def initialize(decimal128); end
  def low_bits; end
  def nan?; end
  def negative?; end
  def scientific_exponent; end
  def significand; end
  def string; end
  def two_highest_bits_set?; end
  def use_scientific_notation?; end
end
class BSON::Decimal128::InvalidArgument < ArgumentError
  def message; end
end
class BSON::Decimal128::InvalidString < RuntimeError
  def message; end
end
class BSON::Decimal128::InvalidRange < RuntimeError
  def message; end
end
class BSON::Document < Hash
  def [](key); end
  def []=(key, value); end
  def convert_key(key); end
  def convert_value(value); end
  def delete(key, &block); end
  def dig(*keys); end
  def fetch(key, *args, &block); end
  def has_key?(key); end
  def has_value?(value); end
  def include?(key); end
  def initialize(elements = nil); end
  def key?(key); end
  def member?(key); end
  def merge!(other); end
  def merge(other, &block); end
  def slice(*keys); end
  def update(other); end
  def value(value); end
end
module BSON::ExtJSON
  def create_binary(encoded_value, encoded_subtype); end
  def create_regexp(pattern, options); end
  def map_hash(hash, **options); end
  def parse(str, **options); end
  def parse_hash(hash, **options); end
  def parse_obj(value, **options); end
  def self.create_binary(encoded_value, encoded_subtype); end
  def self.create_regexp(pattern, options); end
  def self.map_hash(hash, **options); end
  def self.parse(str, **options); end
  def self.parse_hash(hash, **options); end
  def self.parse_obj(value, **options); end
  def self.verify_no_reserved_keys(hash, **options); end
  def verify_no_reserved_keys(hash, **options); end
end
module BSON::FalseClass
  def bson_type; end
  def to_bson(buffer = nil, validating_keys = nil); end
end
class FalseClass
  include BSON::FalseClass
end
module BSON::Float
  def as_extended_json(**options); end
  def to_bson(buffer = nil, validating_keys = nil); end
end
module BSON::Float::ClassMethods
  def from_bson(buffer, **options); end
end
class Float < Numeric
  def bson_type; end
  extend BSON::Float::ClassMethods
  include BSON::Float
end
module BSON::Hash
  def as_extended_json(**options); end
  def to_bson(buffer = nil, validating_keys = nil); end
  def to_bson_normalized_value; end
end
module BSON::Hash::ClassMethods
  def from_bson(buffer, **options); end
end
class Hash
  def bson_type; end
  extend BSON::Hash::ClassMethods
  include BSON::Hash
end
module BSON::OpenStruct
  def bson_type; end
  def to_bson(buffer = nil, validating_keys = nil); end
end
class OpenStruct
  include BSON::OpenStruct
end
class BSON::MaxKey
  def <=>(other); end
  def as_extended_json(**options); end
  def as_json(*args); end
  def bson_type; end
  extend BSON::Specialized::ClassMethods
  include BSON::JSON
  include BSON::Specialized
  include Comparable
end
class BSON::MinKey
  def <=>(other); end
  def as_extended_json(**options); end
  def as_json(*args); end
  def bson_type; end
  extend BSON::Specialized::ClassMethods
  include BSON::JSON
  include BSON::Specialized
  include Comparable
end
module BSON::NilClass
  extend BSON::Specialized::ClassMethods
  include BSON::Specialized
end
module BSON::NilClass::ClassMethods
  def from_bson(buffer, **options); end
end
class NilClass
  def bson_type; end
  extend BSON::NilClass::ClassMethods
  include BSON::NilClass
end
module BSON::Object
  def as_extended_json(**options); end
  def to_bson_key(validating_keys = nil); end
  def to_bson_normalized_key; end
  def to_bson_normalized_value; end
  def to_extended_json(**options); end
end
class BSON::InvalidKey < RuntimeError
  def initialize(object); end
end
class Object < BasicObject
  include BSON::Object
end
class BSON::ObjectId
  def <=>(other); end
  def ==(other); end
  def ===(other); end
  def as_extended_json(**options); end
  def as_json(options = nil); end
  def bson_type; end
  def eql?(other); end
  def generate_data; end
  def generation_time; end
  def hash; end
  def initialize_copy(other); end
  def inspect; end
  def marshal_dump; end
  def marshal_load(data); end
  def repair; end
  def self.from_bson(buffer, **options); end
  def self.from_data(data); end
  def self.from_string(string); end
  def self.from_time(time, options = nil); end
  def self.legal?(string); end
  def self.repair(object); end
  def to_bson(buffer = nil, validating_keys = nil); end
  def to_s; end
  def to_str; end
  def to_time; end
  include BSON::JSON
  include Comparable
end
class BSON::ObjectId::Invalid < RuntimeError
end
class BSON::ObjectId::Generator
  def generate(time, counter = nil); end
  def initialize; end
  def machine_id; end
  def next_object_id(*arg0); end
  def process_id; end
end
module BSON::Regexp
  def as_json(*args); end
  def bson_dotall; end
  def bson_extended; end
  def bson_ignorecase; end
  def bson_options; end
  def to_bson(buffer = nil, validating_keys = nil); end
  include BSON::JSON
end
class BSON::Regexp::Raw
  def ==(other); end
  def as_extended_json(**opts); end
  def as_json(*args); end
  def compile; end
  def eql?(other); end
  def initialize(pattern, options = nil); end
  def method_missing(method, *arguments); end
  def options; end
  def options_to_int; end
  def pattern; end
  def respond_to?(method, include_private = nil); end
  def to_bson(buffer = nil, validating_keys = nil); end
  include BSON::JSON
end
module BSON::Regexp::ClassMethods
  def from_bson(buffer, **opts); end
end
class Regexp
  def bson_type; end
  extend BSON::Regexp::ClassMethods
  include BSON::Regexp
end
module BSON::String
  def to_bson(buffer = nil, validating_keys = nil); end
  def to_bson_key(validating_keys = nil); end
  def to_bson_object_id; end
  def to_hex_string; end
end
class BSON::String::IllegalKey < RuntimeError
  def initialize(string); end
end
module BSON::String::ClassMethods
  def from_bson(buffer, **options); end
end
class String
  def bson_type; end
  extend BSON::String::ClassMethods
  include BSON::String
end
module BSON::Symbol
  def as_extended_json(**options); end
  def bson_type; end
  def to_bson(buffer = nil, validating_keys = nil); end
  def to_bson_key(validating_keys = nil); end
  def to_bson_normalized_key; end
end
class BSON::Symbol::Raw
  def ==(other); end
  def as_extended_json(**options); end
  def bson_type; end
  def eql?(other); end
  def initialize(str_or_sym); end
  def to_bson(buffer = nil, validating_keys = nil); end
  def to_s; end
  def to_sym; end
end
module BSON::Symbol::ClassMethods
  def from_bson(buffer, **options); end
end
class Symbol
  extend BSON::Symbol::ClassMethods
  include BSON::Symbol
end
module BSON::Time
  def _bson_to_i; end
  def as_extended_json(**options); end
  def to_bson(buffer = nil, validating_keys = nil); end
end
module BSON::Time::ClassMethods
  def from_bson(buffer, **options); end
end
class Time
  def bson_type; end
  extend BSON::Time::ClassMethods
  include BSON::Time
end
class BSON::Timestamp
  def <=>(other); end
  def ==(other); end
  def as_extended_json(**options); end
  def as_json(*args); end
  def bson_type; end
  def increment; end
  def initialize(seconds, increment); end
  def seconds; end
  def self.from_bson(buffer, **options); end
  def to_bson(buffer = nil, validating_keys = nil); end
  include BSON::JSON
  include Comparable
end
module BSON::TrueClass
  def bson_type; end
  def to_bson(buffer = nil, validating_keys = nil); end
end
class TrueClass
  include BSON::TrueClass
end
class BSON::Undefined
  def ==(other); end
  def as_extended_json(**options); end
  def bson_type; end
  extend BSON::Specialized::ClassMethods
  include BSON::Specialized
end
class BSON::ByteBuffer
  def get_array(*arg0); end
  def get_byte; end
  def get_bytes(arg0); end
  def get_cstring; end
  def get_decimal128_bytes; end
  def get_double; end
  def get_hash(*arg0); end
  def get_int32; end
  def get_int64; end
  def get_string; end
  def get_uint32; end
  def initialize(*arg0); end
  def length; end
  def put_array(arg0, arg1); end
  def put_byte(arg0); end
  def put_bytes(arg0); end
  def put_cstring(arg0); end
  def put_decimal128(arg0, arg1); end
  def put_double(arg0); end
  def put_hash(arg0, arg1); end
  def put_int32(arg0); end
  def put_int64(arg0); end
  def put_string(arg0); end
  def put_symbol(arg0); end
  def put_uint32(arg0); end
  def read_position; end
  def replace_int32(arg0, arg1); end
  def rewind!; end
  def to_s; end
  def write_position; end
end
module BSON::TimeWithZone
  def bson_type; end
  def to_bson(buffer = nil, validating_keys = nil); end
end
class ActiveSupport::TimeWithZone
  include BSON::TimeWithZone
end
