# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `steep` gem.
# Please instead update this file by running `tapioca sync`.

# typed: true

module Kernel
  def MethodName(string); end
end

module Steep
  class << self
    def log_error(exn, message: T.unsafe(nil)); end
    def log_output; end
    def log_output=(output); end
    def logger; end
    def measure(message); end
    def new_logger(output, prev_level); end
  end
end

module Steep::AST
end

module Steep::AST::Annotation
end

class Steep::AST::Annotation::BlockType < ::Steep::AST::Annotation::Typed
end

class Steep::AST::Annotation::BreakType < ::Steep::AST::Annotation::Typed
end

class Steep::AST::Annotation::Collection
  def initialize(annotations:, factory:, current_module:); end

  def absolute_type(type); end
  def annotations; end
  def any?(&block); end
  def block_type; end
  def block_type_annotation; end
  def break_type; end
  def break_type_annotation; end
  def const_type_annotations; end
  def const_types; end
  def current_module; end
  def dynamic_annotations; end
  def factory; end
  def implement_module_annotation; end
  def include?(obj); end
  def instance_dynamics; end
  def instance_type; end
  def instance_type_annotation; end
  def ivar_type_annotations; end
  def ivar_types; end
  def lvar_types; end
  def merge_block_annotations(annotations); end
  def method_type(name); end
  def method_type_annotations; end
  def module_dynamics; end
  def module_type; end
  def module_type_annotation; end
  def return_type; end
  def return_type_annotation; end
  def self_type; end
  def self_type_annotation; end
  def size; end
  def var_type(lvar: T.unsafe(nil), ivar: T.unsafe(nil), const: T.unsafe(nil)); end
  def var_type_annotations; end
end

class Steep::AST::Annotation::ConstType < ::Steep::AST::Annotation::Named
end

class Steep::AST::Annotation::Dynamic
  def initialize(names:, location: T.unsafe(nil)); end

  def ==(other); end
  def location; end
  def names; end
end

class Steep::AST::Annotation::Dynamic::Name
  def initialize(name:, kind:, location: T.unsafe(nil)); end

  def ==(other); end
  def instance_method?; end
  def kind; end
  def location; end
  def module_method?; end
  def name; end
end

class Steep::AST::Annotation::Implements
  def initialize(name:, location: T.unsafe(nil)); end

  def ==(other); end
  def location; end
  def name; end
end

class Steep::AST::Annotation::Implements::Module
  def initialize(name:, args:); end

  def ==(other); end
  def args; end
  def eql?(other); end
  def hash; end
  def name; end
end

class Steep::AST::Annotation::InstanceType < ::Steep::AST::Annotation::Typed
end

class Steep::AST::Annotation::IvarType < ::Steep::AST::Annotation::Named
end

class Steep::AST::Annotation::MethodType < ::Steep::AST::Annotation::Named
end

class Steep::AST::Annotation::ModuleType < ::Steep::AST::Annotation::Typed
end

class Steep::AST::Annotation::Named
  def initialize(name:, type:, location: T.unsafe(nil)); end

  def ==(other); end
  def location; end
  def name; end
  def type; end
end

class Steep::AST::Annotation::ReturnType < ::Steep::AST::Annotation::Typed
end

class Steep::AST::Annotation::SelfType < ::Steep::AST::Annotation::Typed
end

class Steep::AST::Annotation::Typed
  def initialize(type:, location: T.unsafe(nil)); end

  def ==(other); end
  def annotation; end
  def location; end
  def type; end
end

class Steep::AST::Annotation::VarType < ::Steep::AST::Annotation::Named
end

module Steep::AST::Builtin
  class << self
    def any_type; end
    def bool_type; end
    def bottom_type; end
    def false_type; end
    def nil_type; end
    def optional(type); end
    def top_type; end
    def true_type; end
  end
end

Steep::AST::Builtin::Array = T.let(T.unsafe(nil), Steep::AST::Builtin::Type)

Steep::AST::Builtin::BasicObject = T.let(T.unsafe(nil), Steep::AST::Builtin::Type)

Steep::AST::Builtin::Class = T.let(T.unsafe(nil), Steep::AST::Builtin::Type)

Steep::AST::Builtin::FalseClass = T.let(T.unsafe(nil), Steep::AST::Builtin::Type)

Steep::AST::Builtin::Float = T.let(T.unsafe(nil), Steep::AST::Builtin::Type)

Steep::AST::Builtin::Hash = T.let(T.unsafe(nil), Steep::AST::Builtin::Type)

Steep::AST::Builtin::Integer = T.let(T.unsafe(nil), Steep::AST::Builtin::Type)

Steep::AST::Builtin::Module = T.let(T.unsafe(nil), Steep::AST::Builtin::Type)

Steep::AST::Builtin::NilClass = T.let(T.unsafe(nil), Steep::AST::Builtin::Type)

Steep::AST::Builtin::Object = T.let(T.unsafe(nil), Steep::AST::Builtin::Type)

Steep::AST::Builtin::Proc = T.let(T.unsafe(nil), Steep::AST::Builtin::Type)

Steep::AST::Builtin::Range = T.let(T.unsafe(nil), Steep::AST::Builtin::Type)

Steep::AST::Builtin::Regexp = T.let(T.unsafe(nil), Steep::AST::Builtin::Type)

Steep::AST::Builtin::String = T.let(T.unsafe(nil), Steep::AST::Builtin::Type)

Steep::AST::Builtin::Symbol = T.let(T.unsafe(nil), Steep::AST::Builtin::Type)

Steep::AST::Builtin::TrueClass = T.let(T.unsafe(nil), Steep::AST::Builtin::Type)

class Steep::AST::Builtin::Type
  def initialize(module_name, arity: T.unsafe(nil)); end

  def arity; end
  def instance_type(*args); end
  def instance_type?(type, args: T.unsafe(nil)); end
  def module_name; end
  def module_type; end
  def module_type?(type); end
end

class Steep::AST::TypeParams
  def initialize(variables:, location: T.unsafe(nil)); end

  def location; end
  def variables; end
end

module Steep::AST::Types
end

class Steep::AST::Types::Any
  include(::Steep::AST::Types::Helper::NoFreeVariables)

  def initialize(location: T.unsafe(nil)); end

  def ==(other); end
  def eql?(other); end
  def hash; end
  def level; end
  def location; end
  def subst(s); end
  def to_s; end
  def with_location(new_location); end
end

class Steep::AST::Types::Boolean
  include(::Steep::AST::Types::Helper::NoFreeVariables)

  def initialize(location: T.unsafe(nil)); end

  def ==(other); end
  def back_type; end
  def eql?(other); end
  def hash; end
  def level; end
  def location; end
  def subst(s); end
  def to_s; end
  def with_location(new_location); end
end

class Steep::AST::Types::Bot
  include(::Steep::AST::Types::Helper::NoFreeVariables)

  def initialize(location: T.unsafe(nil)); end

  def ==(other); end
  def eql?(other); end
  def hash; end
  def level; end
  def location; end
  def subst(s); end
  def to_s; end
  def with_location(new_location); end
end

class Steep::AST::Types::Class
  def initialize(location: T.unsafe(nil)); end

  def ==(other); end
  def eql?(other); end
  def free_variables; end
  def hash; end
  def level; end
  def location; end
  def subst(s); end
  def with_location(new_location); end
end

class Steep::AST::Types::Factory
  def initialize(builder:); end

  def absolute_type(type, namespace:); end
  def absolute_type_name(type_name, namespace:); end
  def class_name?(type_name); end
  def deep_expand_alias(type, recursive: T.unsafe(nil), &block); end
  def definition_builder; end
  def env; end
  def expand_alias(type); end
  def flatten_union(type, acc = T.unsafe(nil)); end
  def function_1(func); end
  def instance_type(type_name, args: T.unsafe(nil), location: T.unsafe(nil)); end
  def interface(type, private:, self_type: T.unsafe(nil)); end
  def method_type(method_type, self_type:, method_decls:, subst2: T.unsafe(nil)); end
  def method_type_1(method_type, self_type:); end
  def module_name?(type_name); end
  def params(type); end
  def setup_primitives(method_name, method_def, method_type); end
  def type(type); end
  def type_1(type); end
  def type_cache; end
  def type_interface_cache; end
  def type_name_cache; end
  def type_name_resolver; end
  def unfold(type_name); end
  def unwrap_optional(type); end
end

class Steep::AST::Types::Factory::InterfaceCalculationError < ::StandardError
  def initialize(type:, message:); end

  def type; end
end

Steep::AST::Types::Factory::NilClassName = T.let(T.unsafe(nil), RBS::TypeName)

module Steep::AST::Types::Helper
end

module Steep::AST::Types::Helper::ChildrenLevel
  def level_of_children(children); end
end

module Steep::AST::Types::Helper::NoFreeVariables
  def free_variables; end
end

class Steep::AST::Types::Instance
  def initialize(location: T.unsafe(nil)); end

  def ==(other); end
  def eql?(other); end
  def free_variables; end
  def hash; end
  def level; end
  def location; end
  def subst(s); end
  def to_s; end
  def with_location(new_location); end
end

class Steep::AST::Types::Intersection
  include(::Steep::AST::Types::Helper::ChildrenLevel)

  def initialize(types:, location: T.unsafe(nil)); end

  def ==(other); end
  def eql?(other); end
  def free_variables; end
  def hash; end
  def level; end
  def location; end
  def subst(s); end
  def to_s; end
  def types; end
  def with_location(new_location); end

  class << self
    def build(types:, location: T.unsafe(nil)); end
  end
end

class Steep::AST::Types::Literal
  include(::Steep::AST::Types::Helper::NoFreeVariables)

  def initialize(value:, location: T.unsafe(nil)); end

  def ==(other); end
  def back_type; end
  def eql?(other); end
  def hash; end
  def level; end
  def location; end
  def subst(s); end
  def to_s; end
  def value; end
  def with_location(new_location); end
end

module Steep::AST::Types::Logic
end

class Steep::AST::Types::Logic::ArgEqualsReceiver < ::Steep::AST::Types::Logic::Base
  def initialize(location: T.unsafe(nil)); end
end

class Steep::AST::Types::Logic::ArgIsReceiver < ::Steep::AST::Types::Logic::Base
  def initialize(location: T.unsafe(nil)); end
end

class Steep::AST::Types::Logic::Base
  def ==(other); end
  def eql?(other); end
  def free_variables; end
  def hash; end
  def location; end
  def subst(s); end
  def to_s; end
end

class Steep::AST::Types::Logic::Env < ::Steep::AST::Types::Logic::Base
  def initialize(truthy:, falsy:, type:, location: T.unsafe(nil)); end

  def ==(other); end
  def eql?(other); end
  def falsy; end
  def hash; end
  def inspect; end
  def to_s; end
  def truthy; end
  def type; end
end

class Steep::AST::Types::Logic::Not < ::Steep::AST::Types::Logic::Base
  def initialize(location: T.unsafe(nil)); end
end

class Steep::AST::Types::Logic::ReceiverIsArg < ::Steep::AST::Types::Logic::Base
  def initialize(location: T.unsafe(nil)); end
end

class Steep::AST::Types::Logic::ReceiverIsNil < ::Steep::AST::Types::Logic::Base
  def initialize(location: T.unsafe(nil)); end
end

class Steep::AST::Types::Logic::ReceiverIsNotNil < ::Steep::AST::Types::Logic::Base
  def initialize(location: T.unsafe(nil)); end
end

class Steep::AST::Types::Masked
  def initialize(type:, mask:, location:); end

  def ==(other); end
  def each_type(&block); end
  def eql?(other); end
  def free_variables; end
  def hash; end
  def location; end
  def mask; end
  def sub(s); end
  def to_json(*a); end
  def to_s(level = T.unsafe(nil)); end
  def type; end
end

module Steep::AST::Types::Name
end

class Steep::AST::Types::Name::Alias < ::Steep::AST::Types::Name::Applying
end

class Steep::AST::Types::Name::Applying < ::Steep::AST::Types::Name::Base
  include(::Steep::AST::Types::Helper::ChildrenLevel)

  def initialize(name:, args:, location: T.unsafe(nil)); end

  def ==(other); end
  def args; end
  def eql?(other); end
  def free_variables; end
  def hash; end
  def level; end
  def subst(s); end
  def to_s; end
  def with_location(new_location); end
end

class Steep::AST::Types::Name::Base
  include(::Steep::AST::Types::Helper::NoFreeVariables)

  def initialize(name:, location: T.unsafe(nil)); end

  def level; end
  def location; end
  def name; end
  def subst(s); end
end

class Steep::AST::Types::Name::Instance < ::Steep::AST::Types::Name::Applying
  def to_module; end
end

class Steep::AST::Types::Name::Interface < ::Steep::AST::Types::Name::Applying
end

class Steep::AST::Types::Name::Singleton < ::Steep::AST::Types::Name::Base
  def ==(other); end
  def eql?(other); end
  def hash; end
  def to_s; end
  def with_location(new_location); end
end

class Steep::AST::Types::Nil
  include(::Steep::AST::Types::Helper::NoFreeVariables)

  def initialize(location: T.unsafe(nil)); end

  def ==(other); end
  def back_type; end
  def eql?(other); end
  def hash; end
  def level; end
  def location; end
  def subst(s); end
  def to_s; end
  def with_location(new_location); end
end

class Steep::AST::Types::Proc
  def initialize(type:, block:, location: T.unsafe(nil)); end

  def ==(other); end
  def back_type; end
  def block; end
  def block_required?; end
  def closed?; end
  def eql?(other); end
  def free_variables; end
  def hash; end
  def level; end
  def location; end
  def map_type(&block); end
  def one_arg?; end
  def subst(s); end
  def to_s; end
  def type; end
  def with_location(new_location); end
end

class Steep::AST::Types::Record
  include(::Steep::AST::Types::Helper::ChildrenLevel)

  def initialize(elements:, location: T.unsafe(nil)); end

  def ==(other); end
  def elements; end
  def eql?(other); end
  def free_variables; end
  def hash; end
  def level; end
  def location; end
  def subst(s); end
  def to_s; end
  def with_location(new_location); end
end

class Steep::AST::Types::Self
  def initialize(location: T.unsafe(nil)); end

  def ==(other); end
  def eql?(other); end
  def free_variables; end
  def hash; end
  def level; end
  def location; end
  def subst(s); end
  def to_s; end
  def with_location(new_location); end
end

class Steep::AST::Types::Top
  include(::Steep::AST::Types::Helper::NoFreeVariables)

  def initialize(location: T.unsafe(nil)); end

  def ==(other); end
  def eql?(other); end
  def hash; end
  def level; end
  def location; end
  def subst(s); end
  def to_s; end
  def with_location(new_location); end
end

class Steep::AST::Types::Tuple
  include(::Steep::AST::Types::Helper::ChildrenLevel)

  def initialize(types:, location: T.unsafe(nil)); end

  def ==(other); end
  def eql?(other); end
  def free_variables; end
  def hash; end
  def level; end
  def location; end
  def subst(s); end
  def to_s; end
  def types; end
  def with_location(new_location); end
end

class Steep::AST::Types::Union
  include(::Steep::AST::Types::Helper::ChildrenLevel)

  def initialize(types:, location: T.unsafe(nil)); end

  def ==(other); end
  def eql?(other); end
  def free_variables; end
  def hash; end
  def level; end
  def location; end
  def subst(s); end
  def to_s; end
  def types; end
  def with_location(new_location); end

  class << self
    def build(types:, location: T.unsafe(nil)); end
  end
end

class Steep::AST::Types::Var
  def initialize(name:, location: T.unsafe(nil)); end

  def ==(other); end
  def eql?(other); end
  def free_variables; end
  def hash; end
  def level; end
  def location; end
  def name; end
  def subst(s); end
  def to_s; end
  def with_location(new_location); end

  class << self
    def fresh(name); end
  end
end

class Steep::AST::Types::Void
  include(::Steep::AST::Types::Helper::NoFreeVariables)

  def initialize(location: T.unsafe(nil)); end

  def ==(other); end
  def eql?(other); end
  def hash; end
  def level; end
  def location; end
  def subst(s); end
  def to_s; end
  def with_location(new_location); end
end

class Steep::AnnotationParser
  def initialize(factory:); end

  def factory; end
  def keyword_and_type(keyword); end
  def keyword_subject_type(keyword, name); end
  def parse(src, location:); end
  def parse_type(string); end
end

Steep::AnnotationParser::COLON = T.let(T.unsafe(nil), Regexp)

Steep::AnnotationParser::CONST_NAME = T.let(T.unsafe(nil), Regexp)

Steep::AnnotationParser::DYNAMIC_NAME = T.let(T.unsafe(nil), Regexp)

Steep::AnnotationParser::IVAR_NAME = T.let(T.unsafe(nil), Regexp)

Steep::AnnotationParser::METHOD_NAME = T.let(T.unsafe(nil), Regexp)

Steep::AnnotationParser::PARAM = T.let(T.unsafe(nil), Regexp)

class Steep::AnnotationParser::SyntaxError < ::StandardError
  def initialize(source:, location:, exn: T.unsafe(nil)); end

  def location; end
  def source; end
end

Steep::AnnotationParser::TYPE = T.let(T.unsafe(nil), Regexp)

Steep::AnnotationParser::TYPE_PARAMS = T.let(T.unsafe(nil), Regexp)

Steep::AnnotationParser::VAR_NAME = T.let(T.unsafe(nil), Regexp)

module Steep::Drivers
end

class Steep::Drivers::Annotations
  include(::Steep::Drivers::Utils::DriverHelper)

  def initialize(stdout:, stderr:); end

  def command_line_patterns; end
  def labeling; end
  def run; end
  def stderr; end
  def stdout; end
end

class Steep::Drivers::Check
  include(::Steep::Drivers::Utils::DriverHelper)

  def initialize(stdout:, stderr:); end

  def command_line_patterns; end
  def dump_all_types; end
  def dump_all_types=(_arg0); end
  def output_types(typing); end
  def run; end
  def stderr; end
  def stdout; end
end

class Steep::Drivers::Init
  include(::Steep::Drivers::Utils::DriverHelper)

  def initialize(stdout:, stderr:); end

  def force_write; end
  def force_write=(_arg0); end
  def run; end
  def stderr; end
  def stdout; end
end

Steep::Drivers::Init::TEMPLATE = T.let(T.unsafe(nil), String)

class Steep::Drivers::Langserver
  include(::Steep::Drivers::Utils::DriverHelper)

  def initialize(stdout:, stderr:, stdin:); end

  def latest_update_version; end
  def project; end
  def reader; end
  def run; end
  def stderr; end
  def stdin; end
  def stdout; end
  def type_check_queue; end
  def type_check_thread; end
  def write_mutex; end
  def writer; end
end

class Steep::Drivers::Langserver::TypeCheckRequest < ::Struct
  def version; end
  def version=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Steep::Drivers::PrintProject
  include(::Steep::Drivers::Utils::DriverHelper)

  def initialize(stdout:, stderr:); end

  def run; end
  def stderr; end
  def stdout; end
end

class Steep::Drivers::SignatureErrorPrinter
  def initialize(stdout:, stderr:); end

  def print_semantic_errors(errors); end
  def print_syntax_errors(errors); end
  def stderr; end
  def stdout; end
end

class Steep::Drivers::Stats
  include(::Steep::Drivers::Utils::DriverHelper)

  def initialize(stdout:, stderr:); end

  def command_line_patterns; end
  def format_stats(target, path, status, typed, untyped, total); end
  def run; end
  def stderr; end
  def stdout; end
end

class Steep::Drivers::TracePrinter
  def initialize(io); end

  def io; end
  def print(trace, level: T.unsafe(nil)); end
end

module Steep::Drivers::Utils
end

module Steep::Drivers::Utils::DriverHelper
  def load_config(path: T.unsafe(nil)); end
  def steepfile; end
  def steepfile=(_arg0); end
  def type_check(project); end
end

class Steep::Drivers::Validate
  include(::Steep::Drivers::Utils::DriverHelper)

  def initialize(stdout:, stderr:); end

  def run; end
  def stderr; end
  def stdout; end
end

class Steep::Drivers::Vendor
  def initialize(stdout:, stderr:, stdin:); end

  def clean_before; end
  def clean_before=(_arg0); end
  def run; end
  def stderr; end
  def stdin; end
  def stdout; end
  def vendor_dir; end
  def vendor_dir=(_arg0); end
end

class Steep::Drivers::Watch
  include(::Steep::Drivers::Utils::DriverHelper)

  def initialize(stdout:, stderr:); end

  def dirs; end
  def queue; end
  def run; end
  def stderr; end
  def stdout; end
end

class Steep::Drivers::Worker
  include(::Steep::Drivers::Utils::DriverHelper)

  def initialize(stdout:, stderr:, stdin:); end

  def run; end
  def stderr; end
  def stdin; end
  def stdout; end
  def steepfile_path; end
  def steepfile_path=(_arg0); end
  def worker_name; end
  def worker_name=(_arg0); end
  def worker_type; end
  def worker_type=(_arg0); end
end

module Steep::Errors
end

class Steep::Errors::ArgumentTypeMismatch < ::Steep::Errors::Base
  def initialize(node:, receiver_type:, expected:, actual:); end

  def actual; end
  def expected; end
  def node; end
  def receiver_type; end
  def to_s; end
end

class Steep::Errors::Base
  def initialize(node:); end

  def format_message(message, class_name: T.unsafe(nil)); end
  def location_to_str; end
  def node; end
  def print_to(io); end
end

class Steep::Errors::BlockBodyTypeMismatch < ::Steep::Errors::Base
  include(::Steep::Errors::ResultPrinter)

  def initialize(node:, expected:, actual:, result:); end

  def actual; end
  def expected; end
  def result; end
  def to_s; end
end

class Steep::Errors::BlockParameterTypeMismatch < ::Steep::Errors::Base
  def initialize(node:, expected:, actual:); end

  def actual; end
  def expected; end
  def to_s; end
end

class Steep::Errors::BlockTypeMismatch < ::Steep::Errors::Base
  include(::Steep::Errors::ResultPrinter)

  def initialize(node:, expected:, actual:, result:); end

  def actual; end
  def expected; end
  def result; end
  def to_s; end
end

class Steep::Errors::BreakTypeMismatch < ::Steep::Errors::Base
  include(::Steep::Errors::ResultPrinter)

  def initialize(node:, expected:, actual:, result:); end

  def actual; end
  def expected; end
  def result; end
  def to_s; end
end

class Steep::Errors::ElseOnExhaustiveCase < ::Steep::Errors::Base
  def initialize(node:, type:); end

  def to_s; end
  def type; end
end

class Steep::Errors::FallbackAny < ::Steep::Errors::Base
  def initialize(node:); end

  def to_s; end
end

class Steep::Errors::IncompatibleAnnotation < ::Steep::Errors::Base
  include(::Steep::Errors::ResultPrinter)

  def initialize(node:, var_name:, result:, relation:); end

  def relation; end
  def result; end
  def to_s; end
  def var_name; end
end

class Steep::Errors::IncompatibleArguments < ::Steep::Errors::Base
  def initialize(node:, receiver_type:, method_type:); end

  def method_type; end
  def node; end
  def receiver_type; end
  def to_s; end
end

class Steep::Errors::IncompatibleAssignment < ::Steep::Errors::Base
  include(::Steep::Errors::ResultPrinter)

  def initialize(node:, lhs_type:, rhs_type:, result:); end

  def lhs_type; end
  def result; end
  def rhs_type; end
  def to_s; end
end

class Steep::Errors::IncompatibleMethodTypeAnnotation < ::Steep::Errors::Base
  include(::Steep::Errors::ResultPrinter)

  def initialize(node:, interface_method:, annotation_method:, result:); end

  def annotation_method; end
  def interface_method; end
  def result; end
  def to_s; end
end

class Steep::Errors::IncompatibleTuple < ::Steep::Errors::Base
  include(::Steep::Errors::ResultPrinter)

  def initialize(node:, expected_tuple:, result:); end

  def expected_tuple; end
  def to_s; end
end

class Steep::Errors::IncompatibleTypeCase < ::Steep::Errors::Base
  include(::Steep::Errors::ResultPrinter)

  def initialize(node:, var_name:, result:, relation:); end

  def relation; end
  def result; end
  def to_s; end
  def var_name; end
end

class Steep::Errors::IncompatibleZuper < ::Steep::Errors::Base
  def initialize(node:, method:); end

  def method; end
  def to_s; end
end

class Steep::Errors::MethodArityMismatch < ::Steep::Errors::Base
  def to_s; end
end

class Steep::Errors::MethodBodyTypeMismatch < ::Steep::Errors::Base
  include(::Steep::Errors::ResultPrinter)

  def initialize(node:, expected:, actual:, result:); end

  def actual; end
  def expected; end
  def result; end
  def to_s; end
end

class Steep::Errors::MethodDefinitionMissing < ::Steep::Errors::Base
  def initialize(node:, module_name:, kind:, missing_method:); end

  def kind; end
  def missing_method; end
  def module_name; end
  def to_s; end
end

class Steep::Errors::MethodDefinitionWithOverloading < ::Steep::Errors::Base
  def initialize(node:, method:); end

  def method; end
  def to_s; end
end

class Steep::Errors::MethodReturnTypeAnnotationMismatch < ::Steep::Errors::Base
  include(::Steep::Errors::ResultPrinter)

  def initialize(node:, method_type:, annotation_type:, result:); end

  def annotation_type; end
  def method_type; end
  def result; end
  def to_s; end
end

class Steep::Errors::MissingKeyword < ::Steep::Errors::Base
  def initialize(node:, missing_keywords:); end

  def missing_keywords; end
  def to_s; end
end

class Steep::Errors::NoMethod < ::Steep::Errors::Base
  def initialize(node:, type:, method:); end

  def method; end
  def to_s; end
  def type; end
end

class Steep::Errors::RequiredBlockMissing < ::Steep::Errors::Base
  def initialize(node:, method_type:); end

  def method_type; end
  def to_s; end
end

module Steep::Errors::ResultPrinter
  def print_result_to(io, level: T.unsafe(nil)); end
  def print_to(io); end
end

class Steep::Errors::ReturnTypeMismatch < ::Steep::Errors::Base
  include(::Steep::Errors::ResultPrinter)

  def initialize(node:, expected:, actual:, result:); end

  def actual; end
  def expected; end
  def result; end
  def to_s; end
end

class Steep::Errors::UnexpectedBlockGiven < ::Steep::Errors::Base
  def initialize(node:, method_type:); end

  def method_type; end
  def to_s; end
end

class Steep::Errors::UnexpectedDynamicMethod < ::Steep::Errors::Base
  def initialize(node:, module_name:, method_name:); end

  def method_name; end
  def module_name; end
  def to_s; end
end

class Steep::Errors::UnexpectedError < ::Steep::Errors::Base
  def initialize(node:, error:); end

  def error; end
  def message; end
  def to_s; end
end

class Steep::Errors::UnexpectedJump < ::Steep::Errors::Base
  def to_s; end
end

class Steep::Errors::UnexpectedJumpValue < ::Steep::Errors::Base
  def to_s; end
end

class Steep::Errors::UnexpectedKeyword < ::Steep::Errors::Base
  def initialize(node:, unexpected_keywords:); end

  def to_s; end
  def unexpected_keywords; end
end

class Steep::Errors::UnexpectedSplat < ::Steep::Errors::Base
  def initialize(node:, type:); end

  def to_s; end
  def type; end
end

class Steep::Errors::UnexpectedSuper < ::Steep::Errors::Base
  def initialize(node:, method:); end

  def method; end
  def to_s; end
end

class Steep::Errors::UnexpectedYield < ::Steep::Errors::Base
  def to_s; end
end

class Steep::Errors::UnknownConstantAssigned < ::Steep::Errors::Base
  def initialize(node:, type:); end

  def to_s; end
  def type; end
end

class Steep::Errors::UnresolvedOverloading < ::Steep::Errors::Base
  def initialize(node:, receiver_type:, method_name:, method_types:); end

  def method_name; end
  def method_types; end
  def node; end
  def receiver_type; end
  def to_s; end
end

class Steep::Errors::UnsatisfiableConstraint < ::Steep::Errors::Base
  include(::Steep::Errors::ResultPrinter)

  def initialize(node:, method_type:, var:, sub_type:, super_type:, result:); end

  def method_type; end
  def result; end
  def sub_type; end
  def super_type; end
  def to_s; end
  def var; end
end

class Steep::Errors::UnsupportedSyntax < ::Steep::Errors::Base
  def initialize(node:, message: T.unsafe(nil)); end

  def message; end
  def to_s; end
end

module Steep::Index
end

class Steep::Index::RBSIndex
  def initialize; end

  def add_constant_declaration(const_name, decl); end
  def add_global_declaration(global_name, decl); end
  def add_method_declaration(method_name, member); end
  def add_type_declaration(type_name, declaration); end
  def add_type_reference(type_name, ref); end
  def const_index; end
  def each_declaration(type_name: T.unsafe(nil), method_name: T.unsafe(nil), const_name: T.unsafe(nil), global_name: T.unsafe(nil), &block); end
  def each_entry(&block); end
  def each_reference(type_name: T.unsafe(nil), &block); end
  def entry(type_name: T.unsafe(nil), method_name: T.unsafe(nil), const_name: T.unsafe(nil), global_name: T.unsafe(nil)); end
  def global_index; end
  def method_index; end
  def type_index; end
end

class Steep::Index::RBSIndex::Builder
  def initialize(index:); end

  def env(env); end
  def index; end
  def member(type_name, member); end
  def type_reference(type, from:); end
end

class Steep::Index::RBSIndex::ConstantEntry
  def initialize(const_name:); end

  def add_declaration(decl); end
  def const_name; end
  def declarations; end
end

class Steep::Index::RBSIndex::GlobalEntry
  def initialize(global_name:); end

  def add_declaration(decl); end
  def declarations; end
  def global_name; end
end

class Steep::Index::RBSIndex::MethodEntry
  def initialize(method_name:); end

  def add_declaration(decl); end
  def declarations; end
  def method_name; end
  def references; end
end

class Steep::Index::RBSIndex::TypeEntry
  def initialize(type_name:); end

  def add_declaration(decl); end
  def add_reference(ref); end
  def declarations; end
  def references; end
  def type_name; end
end

class Steep::Index::SignatureSymbolProvider
  def initialize; end

  def indexes; end
  def query_symbol(query); end

  class << self
    def test_const_name(query, type_name); end
    def test_global_name(query, type_name); end
    def test_method_name(query, method_name); end
    def test_type_name(query, type_name); end
  end
end

Steep::Index::SignatureSymbolProvider::LSP = LanguageServer::Protocol

class Steep::Index::SignatureSymbolProvider::SymbolInformation < ::Struct
  def container_name; end
  def container_name=(_); end
  def kind; end
  def kind=(_); end
  def location; end
  def location=(_); end
  def name; end
  def name=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Steep::Index::SourceIndex
  def initialize(source:, parent: T.unsafe(nil)); end

  def add_definition(constant:, definition:); end
  def add_reference(constant:, ref:); end
  def constant_index; end
  def count; end
  def entry(constant:); end
  def merge!(child); end
  def new_child; end
  def parent; end
  def parent_count; end
  def source; end
end

class Steep::Index::SourceIndex::ConstantEntry
  def initialize(name:); end

  def add_definition(node); end
  def add_reference(node); end
  def definitions; end
  def merge!(other); end
  def name; end
  def references; end
end

class Steep::InstanceMethodName < ::Struct
  def method_name; end
  def method_name=(_); end
  def to_s; end
  def type_name; end
  def type_name=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

module Steep::Interface
end

class Steep::Interface::Block
  def initialize(type:, optional:); end

  def +(other); end
  def ==(other); end
  def closed?; end
  def eql?(other); end
  def free_variables; end
  def hash; end
  def map_type(&block); end
  def optional; end
  def optional?; end
  def subst(s); end
  def to_optional; end
  def to_s; end
  def type; end
end

class Steep::Interface::Function
  def initialize(params:, return_type:, location:); end

  def ==(other); end
  def closed?; end
  def each_type(&block); end
  def eql?(other); end
  def free_variables; end
  def hash; end
  def location; end
  def map_type(&block); end
  def params; end
  def return_type; end
  def subst(s); end
  def to_s; end
  def with(params: T.unsafe(nil), return_type: T.unsafe(nil)); end
end

class Steep::Interface::Function::Params
  def initialize(required:, optional:, rest:, required_keywords:, optional_keywords:, rest_keywords:); end

  def &(other); end
  def +(other); end
  def ==(other); end
  def closed?; end
  def drop_first; end
  def each_extra_argument(args); end
  def each_extra_keyword(args); end
  def each_missing_argument(args); end
  def each_missing_keyword(args); end
  def each_type; end
  def empty?; end
  def eql?(other); end
  def extract_keywords(args); end
  def first_param; end
  def flat_keywords; end
  def flat_unnamed_params; end
  def free_variables; end
  def has_keywords?; end
  def has_positional?; end
  def hash; end
  def map_type(&block); end
  def optional; end
  def optional_keywords; end
  def required; end
  def required_keywords; end
  def rest; end
  def rest_keywords; end
  def size; end
  def subst(s); end
  def to_s; end
  def update(required: T.unsafe(nil), optional: T.unsafe(nil), rest: T.unsafe(nil), required_keywords: T.unsafe(nil), optional_keywords: T.unsafe(nil), rest_keywords: T.unsafe(nil)); end
  def with_first_param(param); end
  def without_keywords; end
  def |(other); end

  class << self
    def empty; end
  end
end

class Steep::Interface::Function::Params::OptionalPositional < ::Struct
  def type; end
  def type=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Steep::Interface::Function::Params::RequiredPositional < ::Struct
  def type; end
  def type=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Steep::Interface::Function::Params::RestPositional < ::Struct
  def type; end
  def type=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Steep::Interface::Interface
  def initialize(type:, private:); end

  def methods; end
  def private?; end
  def public?; end
  def type; end
end

class Steep::Interface::Interface::Entry
  def initialize(method_types:); end

  def method_types; end
  def to_s; end
end

class Steep::Interface::MethodType
  def initialize(type_params:, type:, block:, method_decls:); end

  def &(other); end
  def +(other); end
  def ==(other); end
  def block; end
  def each_type(&block); end
  def eql?(other); end
  def free_variables; end
  def hash; end
  def instantiate(s); end
  def map_type(&block); end
  def method_decls; end
  def subst(s); end
  def to_s; end
  def type; end
  def type_params; end
  def unify_overload(other); end
  def with(type_params: T.unsafe(nil), type: T.unsafe(nil), block: T.unsafe(nil), method_decls: T.unsafe(nil)); end
  def |(other); end
end

class Steep::Interface::Substitution
  def initialize(dictionary:, instance_type:, module_type:, self_type:); end

  def [](key); end
  def add!(v, ty); end
  def dictionary; end
  def domain; end
  def empty?; end
  def except(vars); end
  def except!(vars); end
  def instance_type; end
  def key?(var); end
  def merge(s); end
  def merge!(s, overwrite: T.unsafe(nil)); end
  def module_type; end
  def self_type; end
  def to_s; end

  class << self
    def build(vars, types = T.unsafe(nil), instance_type: T.unsafe(nil), module_type: T.unsafe(nil), self_type: T.unsafe(nil)); end
    def empty; end
  end
end

Steep::Interface::Substitution::CLASS_TYPE = T.let(T.unsafe(nil), Steep::AST::Types::Class)

Steep::Interface::Substitution::INSTANCE_TYPE = T.let(T.unsafe(nil), Steep::AST::Types::Instance)

class Steep::Interface::Substitution::InvalidSubstitutionError < ::StandardError
  def initialize(vars_size:, types_size:); end

  def types_size; end
  def vars_size; end
end

Steep::Interface::Substitution::SELF_TYPE = T.let(T.unsafe(nil), Steep::AST::Types::Self)

module Steep::ModuleHelper
  def module_name_from_node(node); end
  def namespace_from_node(node); end
end

class Steep::Project
  def initialize(steepfile_path:); end

  def absolute_path(path); end
  def all_source_files; end
  def base_dir; end
  def relative_path(path); end
  def steepfile_path; end
  def target_for_source_path(path); end
  def targets; end
  def targets_for_path(path); end
  def type_of_node(path:, line:, column:); end
end

class Steep::Project::CompletionProvider
  def initialize(source_text:, path:, subtyping:); end

  def at_end?(pos, of:); end
  def disallowed_method?(name); end
  def index_for(string, line:, column:); end
  def instance_variable_items_for_context(context, position:, prefix:, items:); end
  def items_for_atmark(position:); end
  def items_for_dot(position:); end
  def items_for_trigger(position:); end
  def local_variable_items_for_context(context, position:, prefix:, items:); end
  def method_items_for_receiver_type(type, include_private:, prefix:, position:, items:); end
  def modified_text; end
  def path; end
  def range_for(position, prefix: T.unsafe(nil)); end
  def range_from_loc(loc); end
  def run(line:, column:); end
  def source; end
  def source_text; end
  def subtyping; end
  def type_check!(text, line:, column:); end
  def typing; end
  def word_name?(name); end
end

class Steep::Project::CompletionProvider::InstanceVariableItem < ::Struct
  def identifier; end
  def identifier=(_); end
  def range; end
  def range=(_); end
  def type; end
  def type=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Steep::Project::CompletionProvider::LocalVariableItem < ::Struct
  def identifier; end
  def identifier=(_); end
  def range; end
  def range=(_); end
  def type; end
  def type=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Steep::Project::CompletionProvider::MethodNameItem < ::Struct
  def comment; end
  def identifier; end
  def identifier=(_); end
  def inherited?; end
  def method_decls; end
  def method_decls=(_); end
  def method_type; end
  def method_type=(_); end
  def range; end
  def range=(_); end
  def receiver_type; end
  def receiver_type=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Steep::Project::CompletionProvider::Position < ::Struct
  def -(size); end
  def column; end
  def column=(_); end
  def line; end
  def line=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Steep::Project::CompletionProvider::Range < ::Struct
  def end; end
  def end=(_); end
  def start; end
  def start=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Steep::Project::DSL
  def initialize(project:); end

  def project; end
  def target(name, template: T.unsafe(nil), &block); end

  class << self
    def parse(project, code, filename: T.unsafe(nil)); end
    def register_template(name, target); end
    def templates; end
  end
end

class Steep::Project::DSL::TargetDSL
  def initialize(name, sources: T.unsafe(nil), libraries: T.unsafe(nil), signatures: T.unsafe(nil), ignored_sources: T.unsafe(nil), repo_paths: T.unsafe(nil)); end

  def check(*args); end
  def ignore(*args); end
  def ignored_sources; end
  def libraries; end
  def library(*args); end
  def name; end
  def no_builtin!(value = T.unsafe(nil)); end
  def repo_path(*paths); end
  def repo_paths; end
  def signature(*args); end
  def signatures; end
  def sources; end
  def strictness_level; end
  def typing_option_hash; end
  def typing_options(level = T.unsafe(nil), **hash); end
  def update(name: T.unsafe(nil), sources: T.unsafe(nil), libraries: T.unsafe(nil), ignored_sources: T.unsafe(nil), signatures: T.unsafe(nil)); end
  def vendor(dir = T.unsafe(nil), stdlib: T.unsafe(nil), gems: T.unsafe(nil)); end
  def vendor_dir; end

  private

  def initialize_copy(other); end
end

class Steep::Project::FileLoader
  def initialize(project:); end

  def each_path_in_patterns(patterns, ext); end
  def load_signatures; end
  def load_sources(command_line_patterns); end
  def project; end
end

class Steep::Project::HoverContent
  def initialize(project:); end

  def content_for(path:, line:, column:); end
  def method_definition_for(factory, type_name, singleton_method: T.unsafe(nil), instance_method: T.unsafe(nil)); end
  def project; end
  def typecheck(target, path:, line:, column:); end
end

class Steep::Project::HoverContent::DefinitionContent < ::Struct
  def comment_string; end
  def definition; end
  def definition=(_); end
  def location; end
  def location=(_); end
  def method_name; end
  def method_name=(_); end
  def method_type; end
  def method_type=(_); end
  def node; end
  def node=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Steep::Project::HoverContent::InstanceMethodName < ::Struct
  def class_name; end
  def class_name=(_); end
  def method_name; end
  def method_name=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Steep::Project::HoverContent::MethodCallContent < ::Struct
  def definition; end
  def definition=(_); end
  def location; end
  def location=(_); end
  def method_name; end
  def method_name=(_); end
  def node; end
  def node=(_); end
  def type; end
  def type=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Steep::Project::HoverContent::SingletonMethodName < ::Struct
  def class_name; end
  def class_name=(_); end
  def method_name; end
  def method_name=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Steep::Project::HoverContent::TypeContent < ::Struct
  def location; end
  def location=(_); end
  def node; end
  def node=(_); end
  def type; end
  def type=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Steep::Project::HoverContent::VariableContent < ::Struct
  def location; end
  def location=(_); end
  def name; end
  def name=(_); end
  def node; end
  def node=(_); end
  def type; end
  def type=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Steep::Project::Options
  def initialize; end

  def allow_fallback_any; end
  def allow_fallback_any=(_arg0); end
  def allow_missing_definitions; end
  def allow_missing_definitions=(_arg0); end
  def allow_unknown_constant_assignment; end
  def allow_unknown_constant_assignment=(_arg0); end
  def allow_unknown_method_calls; end
  def allow_unknown_method_calls=(_arg0); end
  def apply_default_typing_options!; end
  def apply_lenient_typing_options!; end
  def apply_strict_typing_options!; end
  def error_to_report?(error); end
  def libraries; end
  def merge!(hash); end
  def repository_paths; end
  def vendor_path; end
  def vendor_path=(_arg0); end
end

class Steep::Project::SignatureFile
  def initialize(path:); end

  def content; end
  def content=(content); end
  def content_updated_at; end
  def load!; end
  def path; end
  def status; end
end

class Steep::Project::SignatureFile::DeclarationsStatus < ::Struct
  def declarations; end
  def declarations=(_); end
  def timestamp; end
  def timestamp=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Steep::Project::SignatureFile::ParseErrorStatus < ::Struct
  def error; end
  def error=(_); end
  def timestamp; end
  def timestamp=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Steep::Project::SourceFile
  def initialize(path:); end

  def content; end
  def content=(content); end
  def content_updated_at; end
  def errors; end
  def factory; end
  def parse(factory); end
  def path; end
  def status; end
  def status=(_arg0); end
  def type_check(subtyping, env_updated_at); end

  class << self
    def parse(source_code, path:, factory:); end
    def type_check(source, subtyping:); end
  end
end

class Steep::Project::SourceFile::AnnotationSyntaxErrorStatus < ::Struct
  def error; end
  def error=(_); end
  def location; end
  def location=(_); end
  def timestamp; end
  def timestamp=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Steep::Project::SourceFile::ParseErrorStatus < ::Struct
  def error; end
  def error=(_); end
  def timestamp; end
  def timestamp=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Steep::Project::SourceFile::TypeCheckErrorStatus < ::Struct
  def error; end
  def error=(_); end
  def timestamp; end
  def timestamp=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Steep::Project::SourceFile::TypeCheckStatus < ::Struct
  def source; end
  def source=(_); end
  def timestamp; end
  def timestamp=(_); end
  def typing; end
  def typing=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Steep::Project::Target
  def initialize(name:, options:, source_patterns:, ignore_patterns:, signature_patterns:); end

  def add_signature(path, content = T.unsafe(nil)); end
  def add_source(path, content = T.unsafe(nil)); end
  def environment; end
  def errors; end
  def ignore_patterns; end
  def load_signatures(validate:); end
  def name; end
  def no_error?; end
  def options; end
  def possible_signature_file?(path); end
  def possible_source_file?(path); end
  def remove_signature(path); end
  def remove_source(path); end
  def run_type_check(env, check, timestamp, target_sources: T.unsafe(nil)); end
  def signature_file?(path); end
  def signature_files; end
  def signature_patterns; end
  def source_file?(path); end
  def source_files; end
  def source_patterns; end
  def status; end
  def type_check(target_sources: T.unsafe(nil), validate_signatures: T.unsafe(nil)); end
  def update_signature(path, content = T.unsafe(nil)); end
  def update_source(path, content = T.unsafe(nil)); end

  class << self
    def construct_env_loader(options:); end
    def test_pattern(patterns, path, ext:); end
  end
end

class Steep::Project::Target::SignatureOtherErrorStatus < ::Struct
  def error; end
  def error=(_); end
  def timestamp; end
  def timestamp=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Steep::Project::Target::SignatureSyntaxErrorStatus < ::Struct
  def errors; end
  def errors=(_); end
  def timestamp; end
  def timestamp=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Steep::Project::Target::SignatureValidationErrorStatus < ::Struct
  def errors; end
  def errors=(_); end
  def timestamp; end
  def timestamp=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Steep::Project::Target::TypeCheckStatus < ::Struct
  def environment; end
  def environment=(_); end
  def subtyping; end
  def subtyping=(_); end
  def timestamp; end
  def timestamp=(_); end
  def type_check_sources; end
  def type_check_sources=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

module Steep::Server
end

class Steep::Server::BaseWorker
  include(::Steep::Server::Utils)

  def initialize(project:, reader:, writer:); end

  def handle_job(job); end
  def handle_request(request); end
  def project; end
  def reader; end
  def run; end
  def writer; end
end

Steep::Server::BaseWorker::LSP = LanguageServer::Protocol

class Steep::Server::CodeWorker < ::Steep::Server::BaseWorker
  def initialize(project:, reader:, writer:, queue: T.unsafe(nil)); end

  def enqueue_type_check(target:, path:); end
  def handle_job(job); end
  def handle_request(request); end
  def queue; end
  def source_diagnostics(source, options); end
  def typecheck_file(path, target); end
  def typecheck_paths; end
end

Steep::Server::CodeWorker::LSP = LanguageServer::Protocol

class Steep::Server::InteractionWorker < ::Steep::Server::BaseWorker
  def initialize(project:, reader:, writer:, queue: T.unsafe(nil)); end

  def format_completion_item(item); end
  def format_hover(content); end
  def handle_job(job); end
  def handle_request(request); end
  def method_type_to_snippet(method_type); end
  def params_to_snippet(fun); end
  def queue; end
  def response_to_completion(path:, line:, column:, trigger:); end
  def response_to_hover(path:, line:, column:); end
end

class Steep::Server::Master
  include(::Steep::Server::Utils)

  def initialize(project:, reader:, writer:, interaction_worker:, signature_worker:, code_workers:, queue: T.unsafe(nil)); end

  def code_workers; end
  def each_worker(&block); end
  def interaction_worker; end
  def least_busy_worker; end
  def paths_for(worker); end
  def process_message_from_client(message); end
  def process_message_from_worker(message); end
  def project; end
  def queue; end
  def reader; end
  def register_code_to_worker(paths, worker:); end
  def registered_path?(path); end
  def signature_worker; end
  def start; end
  def steepfile; end
  def worker_count; end
  def worker_to_paths; end
  def writer; end
end

Steep::Server::Master::LSP = LanguageServer::Protocol

class Steep::Server::SignatureWorker < ::Steep::Server::BaseWorker
  def initialize(project:, reader:, writer:, queue: T.unsafe(nil)); end

  def active_job?(target, timestamp); end
  def enqueue_symbol(id:, query:); end
  def enqueue_target(target:, timestamp:); end
  def handle_job(job); end
  def handle_request(request); end
  def handle_workspace_symbol(query:, id:); end
  def last_target_validated_at; end
  def queue; end
  def validate_signature(target, timestamp:); end
  def validate_signature_if_required(request); end
end

module Steep::Server::Utils
  def apply_change(change, text); end
  def source_path(uri); end
  def update_source(request); end
end

Steep::Server::Utils::LSP = LanguageServer::Protocol

class Steep::Server::WorkerProcess
  def initialize(reader:, writer:, stderr:, wait_thread:, name:); end

  def <<(message); end
  def name; end
  def read(&block); end
  def reader; end
  def shutdown; end
  def stderr; end
  def wait_thread; end
  def writer; end

  class << self
    def spawn_code_workers(steepfile:, count: T.unsafe(nil)); end
    def spawn_worker(type, name:, steepfile:); end
  end
end

module Steep::Signature
end

module Steep::Signature::Errors
end

class Steep::Signature::Errors::Base
  def loc_to_s; end
  def location; end
  def path; end
  def to_s; end
end

class Steep::Signature::Errors::DuplicatedDeclarationError < ::Steep::Signature::Errors::Base
  def initialize(type_name:, location:); end

  def puts(io); end
  def type_name; end
end

class Steep::Signature::Errors::DuplicatedMethodDefinitionError < ::Steep::Signature::Errors::Base
  def initialize(class_name:, method_name:, location:); end

  def class_name; end
  def method_name; end
  def puts(io); end
end

class Steep::Signature::Errors::InvalidMethodOverloadError < ::Steep::Signature::Errors::Base
  def initialize(class_name:, method_name:, location:); end

  def class_name; end
  def method_name; end
  def puts(io); end
end

class Steep::Signature::Errors::InvalidTypeApplicationError < ::Steep::Signature::Errors::Base
  def initialize(name:, args:, params:, location:); end

  def args; end
  def name; end
  def params; end
  def puts(io); end
end

class Steep::Signature::Errors::RecursiveAliasError < ::Steep::Signature::Errors::Base
  def initialize(class_name:, names:, location:); end

  def class_name; end
  def location; end
  def names; end
  def puts(io); end
end

class Steep::Signature::Errors::UnknownMethodAliasError < ::Steep::Signature::Errors::Base
  def initialize(class_name:, method_name:, location:); end

  def class_name; end
  def method_name; end
  def puts(io); end
end

class Steep::Signature::Errors::UnknownTypeNameError < ::Steep::Signature::Errors::Base
  def initialize(name:, location:); end

  def name; end
  def puts(io); end
end

class Steep::Signature::Validator
  def initialize(checker:); end

  def builder; end
  def checker; end
  def each_error(&block); end
  def env; end
  def factory; end
  def has_error?; end
  def no_error?; end
  def rescue_validation_errors(type_name = T.unsafe(nil)); end
  def type_name_resolver; end
  def validate; end
  def validate_alias; end
  def validate_const; end
  def validate_decl; end
  def validate_global; end
  def validate_one_class(name); end
  def validate_one_interface(name); end
  def validate_type(type); end
  def validator; end
end

Steep::Signature::Validator::Declarations = RBS::AST::Declarations

Steep::Signature::Validator::Location = RBS::Location

class Steep::SingletonMethodName < ::Struct
  def method_name; end
  def method_name=(_); end
  def to_s; end
  def type_name; end
  def type_name=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Steep::Source
  def initialize(path:, node:, mapping:); end

  def annotations(block:, factory:, current_module:); end
  def compact_siblings(node); end
  def each_annotation; end
  def find_nodes(line:, column:, node: T.unsafe(nil), position: T.unsafe(nil), parents: T.unsafe(nil)); end
  def mapping; end
  def node; end
  def path; end
  def without_unrelated_defs(line:, column:); end

  class << self
    def construct_mapping(node:, annotations:, mapping:, line_range: T.unsafe(nil)); end
    def delete_defs(node, allow_list); end
    def each_child_node(node); end
    def map_child_nodes(node); end
    def parse(source_code, path:, factory:, labeling: T.unsafe(nil)); end
    def parser; end
  end
end

class Steep::Source::Builder < ::Parser::Builders::Default
  def string_value(token); end
end

class Steep::Source::LocatedAnnotation
  def initialize(line:, source:, annotation:); end

  def ==(other); end
  def annotation; end
  def line; end
  def source; end
end

module Steep::Subtyping
end

class Steep::Subtyping::Check
  def initialize(factory:); end

  def alias?(type); end
  def arg_type?(type); end
  def cache; end
  def cacheable?(relation); end
  def check(relation, constraints:, self_type:, assumption: T.unsafe(nil), trace: T.unsafe(nil)); end
  def check0(relation, self_type:, assumption:, trace:, constraints:); end
  def check_block_given(name, sub_block, super_block, trace:, constraints:); end
  def check_block_params(name, sub_block, super_block, self_type:, assumption:, trace:, constraints:); end
  def check_block_return(sub_block, super_block, self_type:, assumption:, trace:, constraints:); end
  def check_generic_method_type(name, sub_type, super_type, self_type:, assumption:, trace:, constraints:); end
  def check_interface(sub_interface, super_interface, self_type:, assumption:, trace:, constraints:); end
  def check_method(name, sub_method, super_method, self_type:, assumption:, trace:, constraints:); end
  def check_method_params(name, sub_params, super_params, self_type:, assumption:, trace:, constraints:); end
  def check_method_type(name, sub_type, super_type, self_type:, assumption:, trace:, constraints:); end
  def check_type_arg(relation, self_type:, assumption:, trace:, constraints:); end
  def definition_for_type(type); end
  def expand_alias(type, &block); end
  def extract_nominal_pairs(relation); end
  def factory; end
  def failure(error:, trace:); end
  def false_type?(type); end
  def instance_super_types(type_name, args:); end
  def match_method_type(name, sub_type, super_type, trace:); end
  def match_params(name, sub_params, super_params, trace:); end
  def same_type?(relation, assumption:); end
  def singleton_super_types(type_name); end
  def success(constraints:); end
  def success_all?(collection, &block); end
  def success_any?(collection, &block); end
  def true_type?(type); end
end

class Steep::Subtyping::Constraints
  def initialize(unknowns:); end

  def add(var, sub_type: T.unsafe(nil), super_type: T.unsafe(nil)); end
  def add_var(*vars); end
  def dictionary; end
  def each; end
  def eliminate_variable(type, to:); end
  def empty?; end
  def has_constraint?(var); end
  def lower_bound(var); end
  def solution(checker, variance:, variables:, self_type:); end
  def to_s; end
  def unknown?(var); end
  def unknowns; end
  def upper_bound(var); end
  def vars; end

  class << self
    def empty; end
  end
end

class Steep::Subtyping::Constraints::UnsatisfiableConstraint < ::StandardError
  def initialize(var:, sub_type:, super_type:, result:); end

  def result; end
  def sub_type; end
  def super_type; end
  def var; end
end

class Steep::Subtyping::Constraints::UnsatisfiedInvariantError < ::StandardError
  def initialize(reason:, constraints:); end

  def constraints; end
  def reason; end
end

class Steep::Subtyping::Constraints::UnsatisfiedInvariantError::UnknownsFreeVariableNotDisjoint
  def initialize(var:, lower_bound:, upper_bound:); end

  def lower_bound; end
  def message; end
  def upper_bound; end
  def var; end
end

class Steep::Subtyping::Constraints::UnsatisfiedInvariantError::VariablesFreeVariablesNotDisjoint
  def initialize(var: T.unsafe(nil), lower_bound: T.unsafe(nil), upper_bound: T.unsafe(nil)); end

  def lower_bound; end
  def message; end
  def upper_bound; end
  def var; end
end

class Steep::Subtyping::Constraints::UnsatisfiedInvariantError::VariablesUnknownsNotDisjoint
  def initialize(vars:); end

  def message; end
  def vars; end
end

class Steep::Subtyping::Relation
  def initialize(sub_type:, super_type:); end

  def ==(other); end
  def eql?(other); end
  def flip; end
  def hash; end
  def map; end
  def sub_type; end
  def super_type; end
  def to_s; end
end

module Steep::Subtyping::Result
end

class Steep::Subtyping::Result::Base
  def else; end
  def failure?; end
  def then; end
end

class Steep::Subtyping::Result::Failure < ::Steep::Subtyping::Result::Base
  def initialize(error:, trace:); end

  def drop(n); end
  def error; end
  def merge_trace(trace); end
  def success?; end
  def trace; end
end

class Steep::Subtyping::Result::Failure::BlockMismatchError
  def initialize(name:); end

  def message; end
  def name; end
end

class Steep::Subtyping::Result::Failure::MethodMissingError
  def initialize(name:); end

  def message; end
  def name; end
end

class Steep::Subtyping::Result::Failure::ParameterMismatchError
  def initialize(name:); end

  def message; end
  def name; end
end

class Steep::Subtyping::Result::Failure::PolyMethodSubtyping
  def initialize(name:); end

  def message; end
  def name; end
end

class Steep::Subtyping::Result::Failure::UnknownPairError
  def initialize(relation:); end

  def message; end
  def relation; end
end

class Steep::Subtyping::Result::Success < ::Steep::Subtyping::Result::Base
  def initialize(constraints:); end

  def constraints; end
  def success?; end
end

class Steep::Subtyping::Trace
  def initialize(array: T.unsafe(nil)); end

  def +(other); end
  def add(sup, sub); end
  def array; end
  def drop(n); end
  def each; end
  def empty?; end
  def interface(sub, sup, &block); end
  def method(name, sub, sup, &block); end
  def method_type(name, sub, sup, &block); end
  def push(*xs); end
  def size; end
  def type(sub, sup, &block); end

  private

  def initialize_copy(source); end
end

class Steep::Subtyping::VariableOccurence
  def initialize; end

  def add_method_type(method_type); end
  def each_var(type, &block); end
  def params; end
  def returns; end
  def strictly_return?(var); end

  class << self
    def from_method_type(method_type); end
  end
end

class Steep::Subtyping::VariableVariance
  def initialize(covariants:, contravariants:); end

  def contravariant?(var); end
  def contravariants; end
  def covariant?(var); end
  def covariants; end
  def invariant?(var); end

  class << self
    def add_params(params, block:, covariants:, contravariants:); end
    def add_type(type, variance:, covariants:, contravariants:); end
    def from_method_type(method_type); end
  end
end

class Steep::TypeConstruction
  include(::Steep::ModuleHelper)

  def initialize(checker:, source:, annotations:, typing:, context:); end

  def absolute_name(module_name); end
  def absolute_type(type); end
  def add_call(call); end
  def add_typing(node, type:, constr: T.unsafe(nil)); end
  def annotations; end
  def block_context; end
  def break_context; end
  def check(node, type, constraints: T.unsafe(nil)); end
  def check_keyword_arg(receiver_type:, node:, method_type:, constraints:); end
  def check_relation(sub_type:, super_type:, constraints: T.unsafe(nil)); end
  def checker; end
  def context; end
  def current_namespace; end
  def deep_expand_alias(type, &block); end
  def each_child_node(node); end
  def expand_alias(type, &block); end
  def expand_self(type); end
  def fallback_any_rec(node); end
  def fallback_to_any(node); end
  def flatten_array_elements(type); end
  def flatten_const_name(node); end
  def flatten_union(type); end
  def for_block(block_params:, block_param_hint:, block_type_hint:, block_annotations:, node_type_hint:); end
  def for_branch(node, truthy_vars: T.unsafe(nil), type_case_override: T.unsafe(nil), break_context: T.unsafe(nil)); end
  def for_class(node); end
  def for_module(node); end
  def for_new_method(method_name, node, args:, self_type:, definition:); end
  def for_sclass(node, type); end
  def implement_module(module_name:, annotations:, super_name: T.unsafe(nil)); end
  def ivasgn(node, type); end
  def lvasgn(node, type); end
  def masgn_lhs?(lhs); end
  def method_context; end
  def module_context; end
  def namespace_module?(node); end
  def nested_namespace_for_module(module_name); end
  def partition_flatten_types(type, &block); end
  def select_flatten_types(type, &block); end
  def select_super_type(sub_type, super_type); end
  def self_class?(node); end
  def self_type; end
  def source; end
  def synthesize(node, hint: T.unsafe(nil), condition: T.unsafe(nil)); end
  def synthesize_block(node:, block_type_hint:, block_body:); end
  def synthesize_children(node, skips: T.unsafe(nil)); end
  def test_literal_type(literal, hint); end
  def to_instance_type(type, args: T.unsafe(nil)); end
  def try_array_type(node, hint); end
  def try_hash_type(node, hint); end
  def try_method_type(node, receiver_type:, method_name:, method_type:, args:, arg_pairs:, block_params:, block_body:, topdown_hint:); end
  def try_tuple_type(node, hint); end
  def type_any_rec(node); end
  def type_block_without_hint(node:, block_annotations:, block_params:, block_body:, &block); end
  def type_env; end
  def type_ivasgn(name, rhs, node); end
  def type_lambda(node, block_params:, block_body:, type_hint:); end
  def type_masgn(node); end
  def type_method_call(node, method_name:, receiver_type:, method:, args:, block_params:, block_body:, topdown_hint:); end
  def type_send(node, send_node:, block_params:, block_body:, unwrap: T.unsafe(nil)); end
  def type_send_interface(node, interface:, receiver:, receiver_type:, method_name:, arguments:, block_params:, block_body:); end
  def typing; end
  def union_type(*types); end
  def unwrap(type); end
  def update_context; end
  def update_lvar_env; end
  def validate_method_definitions(node, module_name); end
  def with(annotations: T.unsafe(nil), context: T.unsafe(nil), typing: T.unsafe(nil)); end
  def with_new_typing(typing); end
  def with_updated_context(lvar_env: T.unsafe(nil)); end

  class << self
    def parameter_types(nodes, type); end
    def valid_parameter_env?(env, nodes, params); end
    def value_variables(node); end
  end
end

class Steep::TypeConstruction::Pair
  def initialize(type:, constr:); end

  def +(other); end
  def constr; end
  def context; end
  def to_ary; end
  def type; end
  def with(type: T.unsafe(nil), constr: T.unsafe(nil)); end
end

module Steep::TypeInference
end

class Steep::TypeInference::BlockParams
  def initialize(leading_params:, optional_params:, rest_param:, trailing_params:); end

  def each(&block); end
  def expandable?; end
  def expandable_params?(params_type); end
  def leading_params; end
  def optional_params; end
  def params; end
  def params_type(hint: T.unsafe(nil)); end
  def params_type0(hint:); end
  def rest_param; end
  def trailing_params; end
  def zip(params_type); end

  class << self
    def from_node(node, annotations:); end
  end
end

class Steep::TypeInference::BlockParams::Param
  def initialize(var:, type:, value:, node:); end

  def ==(other); end
  def eql?(other); end
  def hash; end
  def node; end
  def type; end
  def value; end
  def var; end
end

class Steep::TypeInference::ConstantEnv
  def initialize(factory:, context:); end

  def cache; end
  def context; end
  def factory; end
  def lookup(name); end
  def lookup_constant(name); end
  def table; end
end

class Steep::TypeInference::Context
  def initialize(method_context:, block_context:, break_context:, module_context:, self_type:, type_env:, lvar_env:, call_context:); end

  def block_context; end
  def break_context; end
  def call_context; end
  def lvar_env; end
  def method_context; end
  def module_context; end
  def self_type; end
  def type_env; end
  def with(method_context: T.unsafe(nil), block_context: T.unsafe(nil), break_context: T.unsafe(nil), module_context: T.unsafe(nil), self_type: T.unsafe(nil), type_env: T.unsafe(nil), lvar_env: T.unsafe(nil), call_context: T.unsafe(nil)); end
end

class Steep::TypeInference::Context::BlockContext
  def initialize(body_type:); end

  def body_type; end
end

class Steep::TypeInference::Context::BreakContext
  def initialize(break_type:, next_type:); end

  def break_type; end
  def next_type; end
end

class Steep::TypeInference::Context::MethodContext
  def initialize(name:, method:, method_type:, return_type:, constructor:, super_method:); end

  def block_type; end
  def constructor; end
  def method; end
  def method_type; end
  def name; end
  def return_type; end
  def super_method; end
end

class Steep::TypeInference::Context::ModuleContext
  def initialize(instance_type:, module_type:, implement_name:, current_namespace:, const_env:, class_name:, instance_definition: T.unsafe(nil), module_definition: T.unsafe(nil)); end

  def class_name; end
  def class_variables; end
  def const_context; end
  def const_env; end
  def current_namespace; end
  def defined_instance_methods; end
  def defined_module_methods; end
  def implement_name; end
  def instance_definition; end
  def instance_type; end
  def module_definition; end
  def module_type; end
  def namespaces; end
end

class Steep::TypeInference::ContextArray
  def initialize(buffer:, context:, range: T.unsafe(nil)); end

  def [](index); end
  def at(line:, column:); end
  def buffer; end
  def context_at(index, entry: T.unsafe(nil)); end
  def each_entry; end
  def insert_context(range, context:, entry: T.unsafe(nil)); end
  def merge(subtree); end
  def range; end
  def root; end

  class << self
    def from_source(source:, range: T.unsafe(nil), context: T.unsafe(nil)); end
  end
end

class Steep::TypeInference::ContextArray::Entry
  def initialize(range:, context:); end

  def context; end
  def range; end
  def sub_entries; end
end

class Steep::TypeInference::LocalVariableTypeEnv
  def initialize(subtyping:, declared_types:, assigned_types:, self_type:); end

  def [](var); end
  def annotate(collection); end
  def assign(var, node:, type:); end
  def assign!(var, node:, type:); end
  def assigned_types; end
  def declared_types; end
  def each; end
  def entry(var); end
  def except(variables); end
  def join(*envs); end
  def join_entry(e1, e2); end
  def pin_assignments; end
  def self_type; end
  def subst(s); end
  def subtyping; end
  def to_s; end
  def update(declared_types: T.unsafe(nil), assigned_types: T.unsafe(nil), self_type: T.unsafe(nil)); end
  def vars; end

  class << self
    def empty(subtyping:, self_type:); end
  end
end

class Steep::TypeInference::LocalVariableTypeEnv::Entry
  def initialize(type:, annotations: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def +(other); end
  def ==(other); end
  def annotations; end
  def nodes; end
  def optional; end
  def type; end
  def update(type: T.unsafe(nil), annotations: T.unsafe(nil), nodes: T.unsafe(nil)); end
end

class Steep::TypeInference::Logic
  def initialize(subtyping:); end

  def environments(truthy_vars:, falsey_vars:, lvar_env:); end
  def nodes(node:); end
  def partition_union(type); end
  def subtyping; end
end

class Steep::TypeInference::Logic::Result
  def initialize(nodes = T.unsafe(nil)); end

  def +(other); end
  def merge(nodes); end
  def nodes; end
  def vars; end
end

class Steep::TypeInference::LogicTypeInterpreter
  def initialize(subtyping:, typing:); end

  def decompose_value(node); end
  def eval(env:, type:, node:); end
  def factory; end
  def guess_type_from_method(node); end
  def literal_var_type_case_select(value_node, arg_type); end
  def subtyping; end
  def type_case_select(type, klass); end
  def type_case_select0(type, klass); end
  def typing; end
end

class Steep::TypeInference::MethodCall
end

class Steep::TypeInference::MethodCall::Base
  def initialize(node:, context:, method_name:, receiver_type:, return_type:); end

  def context; end
  def method_name; end
  def node; end
  def receiver_type; end
  def return_type; end
  def with_return_type(new_type); end
end

class Steep::TypeInference::MethodCall::Error < ::Steep::TypeInference::MethodCall::Base
  def initialize(node:, context:, method_name:, receiver_type:, errors:, method_decls: T.unsafe(nil), return_type: T.unsafe(nil)); end

  def errors; end
  def method_decls; end
end

class Steep::TypeInference::MethodCall::MethodContext < ::Struct
  def method_name; end
  def method_name=(_); end
  def to_s; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Steep::TypeInference::MethodCall::MethodDecl
  def initialize(method_name:, method_def:); end

  def ==(other); end
  def eql?(other); end
  def hash; end
  def method_def; end
  def method_name; end
  def method_type; end
end

class Steep::TypeInference::MethodCall::ModuleContext < ::Struct
  def to_s; end
  def type_name; end
  def type_name=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Steep::TypeInference::MethodCall::NoMethodError < ::Steep::TypeInference::MethodCall::Base
  def initialize(node:, context:, method_name:, receiver_type:, error:); end

  def error; end
end

class Steep::TypeInference::MethodCall::TopLevelContext
  def to_s; end
end

class Steep::TypeInference::MethodCall::Typed < ::Steep::TypeInference::MethodCall::Base
  def initialize(node:, context:, method_name:, receiver_type:, actual_method_type:, method_decls:, return_type: T.unsafe(nil)); end

  def actual_method_type; end
  def method_decls; end
end

class Steep::TypeInference::MethodCall::UnknownContext
  def to_s; end
end

class Steep::TypeInference::MethodCall::Untyped < ::Steep::TypeInference::MethodCall::Base
  def initialize(node:, context:, method_name:); end
end

class Steep::TypeInference::SendArgs
  def initialize(args:, block_pass_arg:); end

  def add_pair(pairs, pair); end
  def args; end
  def block_pass_arg; end
  def drop_first; end
  def drop_last; end
  def each_keyword_arg; end
  def group_pairs(pairs); end
  def kwsplat_nodes; end
  def zip0(params, block_type); end
  def zips(params, block_type); end

  class << self
    def from_nodes(nodes); end
  end
end

class Steep::TypeInference::TypeEnv
  def initialize(subtyping:, const_env:); end

  def assert_annotation(name, annotated_type:, original_type:, self_type:); end
  def assert_assign(var_type:, lhs_type:, self_type:); end
  def assign(type:, self_type:, const: T.unsafe(nil), gvar: T.unsafe(nil), ivar: T.unsafe(nil), &block); end
  def const_env; end
  def const_types; end
  def get(const: T.unsafe(nil), gvar: T.unsafe(nil), ivar: T.unsafe(nil)); end
  def gvar_types; end
  def ivar_types; end
  def lookup_dictionary(ivar:, gvar:); end
  def merge!(original_env:, override_env:, self_type:, &block); end
  def set(type:, const: T.unsafe(nil), gvar: T.unsafe(nil), ivar: T.unsafe(nil)); end
  def subtyping; end
  def with_annotations(self_type:, ivar_types: T.unsafe(nil), const_types: T.unsafe(nil), gvar_types: T.unsafe(nil), &block); end

  private

  def initialize_copy(other); end

  class << self
    def build(annotations:, signatures:, subtyping:, const_env:); end
  end
end

class Steep::Typing
  def initialize(source:, root_context:, parent: T.unsafe(nil), parent_last_update: T.unsafe(nil), contexts: T.unsafe(nil), source_index: T.unsafe(nil)); end

  def add_call(node, call); end
  def add_context(range, context:); end
  def add_context_for_body(node, context:); end
  def add_context_for_node(node, context:); end
  def add_error(error); end
  def add_typing(node, type, _context); end
  def block_range(node); end
  def call_of(node:); end
  def context_at(line:, column:); end
  def contexts; end
  def dump(io); end
  def each_typing(&block); end
  def errors; end
  def has_type?(node); end
  def last_update; end
  def method_calls; end
  def new_child(range); end
  def parent; end
  def parent_last_update; end
  def root_context; end
  def save!; end
  def should_update; end
  def source; end
  def source_index; end
  def type_of(node:); end
  def typing; end

  class << self
    def summary(node); end
  end
end

class Steep::Typing::UnknownNodeError < ::StandardError
  def initialize(op, node:); end

  def node; end
  def op; end
end

Steep::VERSION = T.let(T.unsafe(nil), String)
