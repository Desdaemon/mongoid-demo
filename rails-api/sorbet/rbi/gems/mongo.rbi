# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/mongo/all/mongo.rbi
#
# mongo-2.14.0

module Mongo
  def clear_ocsp_cache; end
  def self.clear_ocsp_cache; end
end
module Mongo::Id
  def self.included(klass); end
end
class Symbol
  def bson_type; end
end
class Mongo::Semaphore
  def broadcast; end
  def initialize; end
  def signal; end
  def wait(timeout = nil); end
end
class Mongo::DistinguishingSemaphore
  def broadcast; end
  def initialize; end
  def signal; end
  def wait(timeout = nil); end
end
module Mongo::Options
end
module Mongo::Options::Mapper
  def transform(options, mappings); end
  def transform_documents(options, mappings, document = nil); end
  def transform_keys_to_strings(options); end
  def transform_keys_to_symbols(options); end
  def transform_values_to_strings(options); end
  extend Mongo::Options::Mapper
end
class Mongo::Options::Redacted < BSON::Document
  def has_key?(key); end
  def inspect; end
  def key?(key); end
  def redact(k, v, method); end
  def redacted_string(method); end
  def reject!; end
  def reject(&block); end
  def select!; end
  def select(&block); end
  def to_s; end
end
module Mongo::Loggable
  def _mongo_log_prefix; end
  def format_message(message); end
  def log_debug(message); end
  def log_error(message); end
  def log_fatal(message); end
  def log_info(message); end
  def log_warn(message); end
  def logger; end
end
class Mongo::ClusterTime < BSON::Document
  def <(other); end
  def <=(other); end
  def <=>(other); end
  def ==(other); end
  def >(other); end
  def >=(other); end
  def advance(other); end
  def initialize(elements = nil); end
  def self.[](doc); end
end
module Mongo::ClusterTime::Consumer
  def advance_cluster_time(new_cluster_time); end
  def cluster_time; end
end
class Mongo::TopologyVersion < BSON::Document
  def counter; end
  def gt?(other); end
  def gte?(other); end
  def initialize(doc); end
  def process_id; end
  def to_doc; end
end
module Mongo::Event
end
class Mongo::Event::Base
  def short_class_name; end
  def summary; end
end
class Mongo::Event::Listeners
  def add_listener(event, listener); end
  def initialize; end
  def listeners_for(event); end
end
module Mongo::Event::Publisher
  def event_listeners; end
  def publish(event, *args); end
end
module Mongo::Event::Subscriber
  def event_listeners; end
  def subscribe_to(event, listener); end
end
class Mongo::Monitoring
  def failed(topic, event); end
  def initialize(options = nil); end
  def initialize_copy(original); end
  def monitoring?; end
  def options; end
  def publish_heartbeat(server, awaited: nil); end
  def published(topic, event); end
  def self.next_id; end
  def self.next_operation_id; end
  def started(topic, event); end
  def succeeded(topic, event); end
  include Mongo::Id
  include Mongo::Monitoring::Subscribable
end
module Mongo::Monitoring::Event
end
module Mongo::Monitoring::Event::Secure
  def compression_allowed?(command_name); end
  def redacted(command_name, document); end
end
class Mongo::Monitoring::Event::CommandStarted < Mongo::Event::Base
  def address; end
  def command; end
  def command_name; end
  def command_summary; end
  def connection_generation; end
  def connection_id; end
  def database_name; end
  def initialize(command_name, database_name, address, request_id, operation_id, command, socket_object_id: nil, connection_id: nil, connection_generation: nil, server_connection_id: nil); end
  def inspect; end
  def operation_id; end
  def request_id; end
  def self.generate(address, operation_id, payload, socket_object_id: nil, connection_id: nil, connection_generation: nil, server_connection_id: nil); end
  def server_connection_id; end
  def socket_object_id; end
  def summary; end
  include Mongo::Monitoring::Event::Secure
end
class Mongo::Monitoring::Event::CommandSucceeded < Mongo::Event::Base
  def address; end
  def command_name; end
  def database_name; end
  def duration; end
  def initialize(command_name, database_name, address, request_id, operation_id, reply, duration); end
  def operation_id; end
  def reply; end
  def request_id; end
  def self.generate(address, operation_id, command_payload, reply_payload, duration); end
  def self.generate_reply(command_payload, reply_payload); end
  def self.namespace(payload); end
  def summary; end
  include Mongo::Monitoring::Event::Secure
end
class Mongo::Monitoring::Event::CommandFailed < Mongo::Event::Base
  def address; end
  def command_name; end
  def database_name; end
  def duration; end
  def failure; end
  def initialize(command_name, database_name, address, request_id, operation_id, message, failure, duration); end
  def message; end
  def operation_id; end
  def request_id; end
  def self.generate(address, operation_id, payload, message, failure, duration); end
  def summary; end
end
module Mongo::Monitoring::Event::Cmap
end
class Mongo::Monitoring::Event::Cmap::Base < Mongo::Event::Base
end
class Mongo::Monitoring::Event::Cmap::ConnectionCheckedIn < Mongo::Monitoring::Event::Cmap::Base
  def address; end
  def connection_id; end
  def initialize(address, id, pool); end
  def pool; end
  def summary; end
end
class Mongo::Monitoring::Event::Cmap::ConnectionCheckedOut < Mongo::Monitoring::Event::Cmap::Base
  def address; end
  def connection_id; end
  def initialize(address, id, pool); end
  def pool; end
  def summary; end
end
class Mongo::Monitoring::Event::Cmap::ConnectionCheckOutFailed < Mongo::Monitoring::Event::Cmap::Base
  def address; end
  def initialize(address, reason); end
  def reason; end
  def summary; end
end
class Mongo::Monitoring::Event::Cmap::ConnectionCheckOutStarted < Mongo::Monitoring::Event::Cmap::Base
  def address; end
  def initialize(address); end
  def summary; end
end
class Mongo::Monitoring::Event::Cmap::ConnectionClosed < Mongo::Monitoring::Event::Cmap::Base
  def address; end
  def connection_id; end
  def initialize(address, id, reason); end
  def reason; end
  def summary; end
end
class Mongo::Monitoring::Event::Cmap::ConnectionCreated < Mongo::Monitoring::Event::Cmap::Base
  def address; end
  def connection_id; end
  def initialize(address, id); end
  def summary; end
end
class Mongo::Monitoring::Event::Cmap::ConnectionReady < Mongo::Monitoring::Event::Cmap::Base
  def address; end
  def connection_id; end
  def initialize(address, id); end
  def summary; end
end
class Mongo::Monitoring::Event::Cmap::PoolCleared < Mongo::Monitoring::Event::Cmap::Base
  def address; end
  def initialize(address); end
  def summary; end
end
class Mongo::Monitoring::Event::Cmap::PoolClosed < Mongo::Monitoring::Event::Cmap::Base
  def address; end
  def initialize(address, pool); end
  def pool; end
  def summary; end
end
class Mongo::Monitoring::Event::Cmap::PoolCreated < Mongo::Monitoring::Event::Cmap::Base
  def address; end
  def initialize(address, options, pool); end
  def options; end
  def pool; end
  def summary; end
end
class Mongo::Monitoring::Event::ServerClosed < Mongo::Event::Base
  def address; end
  def initialize(address, topology); end
  def summary; end
  def topology; end
end
class Mongo::Monitoring::Event::ServerDescriptionChanged < Mongo::Event::Base
  def address; end
  def awaited?; end
  def awaited_indicator; end
  def initialize(address, topology, previous_description, new_description, awaited: nil); end
  def new_description; end
  def previous_description; end
  def summary; end
  def topology; end
end
class Mongo::Monitoring::Event::ServerOpening < Mongo::Event::Base
  def address; end
  def initialize(address, topology); end
  def summary; end
  def topology; end
end
class Mongo::Monitoring::Event::ServerHeartbeatStarted < Mongo::Event::Base
  def address; end
  def awaited?; end
  def initialize(address, awaited: nil); end
  def summary; end
end
class Mongo::Monitoring::Event::ServerHeartbeatSucceeded < Mongo::Event::Base
  def address; end
  def awaited?; end
  def duration; end
  def initialize(address, round_trip_time, awaited: nil); end
  def round_trip_time; end
  def summary; end
end
class Mongo::Monitoring::Event::ServerHeartbeatFailed < Mongo::Event::Base
  def address; end
  def awaited?; end
  def duration; end
  def error; end
  def failure; end
  def initialize(address, round_trip_time, error, awaited: nil); end
  def round_trip_time; end
  def summary; end
end
class Mongo::Monitoring::Event::TopologyChanged < Mongo::Event::Base
  def initialize(previous_topology, new_topology); end
  def new_topology; end
  def previous_topology; end
  def summary; end
end
class Mongo::Monitoring::Event::TopologyClosed < Mongo::Event::Base
  def initialize(topology); end
  def summary; end
  def topology; end
end
class Mongo::Monitoring::Event::TopologyOpening < Mongo::Event::Base
  def initialize(topology); end
  def summary; end
  def topology; end
end
module Mongo::Monitoring::Publishable
  def command_completed(result, address, operation_id, payload, duration); end
  def command_failed(failure, address, operation_id, payload, message, duration); end
  def command_started(address, operation_id, payload, socket_object_id: nil, connection_id: nil, connection_generation: nil, server_connection_id: nil); end
  def command_succeeded(result, address, operation_id, payload, duration); end
  def duration(start); end
  def monitoring; end
  def monitoring?; end
  def publish_cmap_event(event); end
  def publish_event(topic, event); end
  def publish_sdam_event(topic, event); end
  include Mongo::Loggable
end
class Mongo::Monitoring::CommandLogSubscriber
  def failed(event); end
  def format_command(args); end
  def initialize(options = nil); end
  def options; end
  def prefix(event, connection_generation: nil, connection_id: nil, server_connection_id: nil); end
  def started(event); end
  def succeeded(event); end
  def truncate(command); end
  def truncating?; end
  include Mongo::Loggable
end
class Mongo::Monitoring::CmapLogSubscriber
  def initialize(options = nil); end
  def options; end
  def published(event); end
  include Mongo::Loggable
end
class Mongo::Monitoring::SDAMLogSubscriber
  def initialize(options = nil); end
  def options; end
  def succeeded(event); end
  include Mongo::Loggable
end
class Mongo::Monitoring::ServerDescriptionChangedLogSubscriber < Mongo::Monitoring::SDAMLogSubscriber
  def awaited_indicator(event); end
  def log_event(event); end
end
class Mongo::Monitoring::ServerClosedLogSubscriber < Mongo::Monitoring::SDAMLogSubscriber
  def log_event(event); end
end
class Mongo::Monitoring::ServerOpeningLogSubscriber < Mongo::Monitoring::SDAMLogSubscriber
  def log_event(event); end
end
class Mongo::Monitoring::TopologyChangedLogSubscriber < Mongo::Monitoring::SDAMLogSubscriber
  def log_event(event); end
end
class Mongo::Monitoring::TopologyOpeningLogSubscriber < Mongo::Monitoring::SDAMLogSubscriber
  def log_event(event); end
end
class Mongo::Monitoring::TopologyClosedLogSubscriber < Mongo::Monitoring::SDAMLogSubscriber
  def log_event(event); end
end
class Mongo::Monitoring::UnifiedSdamLogSubscriber
  def initialize(options = nil); end
  def options; end
  def published(event); end
  def subscribe(client); end
  def succeeded(event); end
  include Mongo::Loggable
end
module Mongo::Monitoring::Subscribable
  def subscribe(topic, subscriber); end
  def subscribers; end
  def subscribers?(topic); end
  def subscribers_for(topic); end
  def unsubscribe(topic, subscriber); end
end
module Mongo::Monitoring::Global
  extend Mongo::Monitoring::Subscribable
end
class Mongo::Logger
  def self.default_logger; end
  def self.level; end
  def self.level=(level); end
  def self.logger; end
  def self.logger=(other); end
end
module Mongo::Retryable
  def legacy_read_with_retry(session, server_selector); end
  def legacy_write_with_retry(server = nil, session = nil); end
  def log_retry(e, options = nil); end
  def modern_read_with_retry(session, server_selector, &block); end
  def nro_write_with_retry(session, write_concern, &block); end
  def raise_unsupported_error(e); end
  def read_with_one_retry(options = nil); end
  def read_with_retry(session = nil, server_selector = nil, &block); end
  def read_with_retry_cursor(session, server_selector, view, &block); end
  def retry_read(original_error, server_selector, session, &block); end
  def retry_write(original_error, session, txn_num, &block); end
  def retry_write_allowed?(session, write_concern); end
  def select_server(cluster, server_selector, session); end
  def write_with_retry(session, write_concern, ending_transaction = nil, &block); end
end
module Mongo::Operation
end
class Mongo::Operation::Result
  def acknowledged?; end
  def aggregate_returned_count; end
  def aggregate_written_count; end
  def cluster_time; end
  def connection_description; end
  def cursor_id; end
  def documents; end
  def each(&block); end
  def error; end
  def first_document; end
  def initialize(replies, connection_description = nil); end
  def inspect; end
  def labels; end
  def n; end
  def namespace; end
  def node_recovering?(*args, &block); end
  def node_shutting_down?(*args, &block); end
  def not_master?(*args, &block); end
  def ok?; end
  def operation_time; end
  def parser; end
  def query_failure?; end
  def raise_operation_failure; end
  def replies; end
  def reply; end
  def returned_count; end
  def successful?; end
  def topology_version; end
  def validate!; end
  def write_concern_error?; end
  def written_count; end
  extend Forwardable
  include Enumerable
end
module Mongo::Operation::Result::Aggregatable
  def aggregate_write_concern_errors(count); end
  def aggregate_write_errors(count); end
end
module Mongo::Operation::Result::UseLegacyErrorParser
  def parser; end
end
module Mongo::Operation::ResponseHandling
  def add_error_labels(client, connection, session); end
  def add_server_diagnostics(connection); end
  def maybe_add_retryable_write_error_label!(error, connection, client, session); end
  def unpin_maybe(session); end
  def validate_result(result, client, connection); end
end
module Mongo::Operation::Executable
  def build_message(connection); end
  def dispatch_message(connection, client, options = nil); end
  def do_execute(connection, client, options = nil); end
  def execute(connection, client:, options: nil); end
  def get_result(connection, client, options = nil); end
  def process_result(result, connection); end
  def process_result_for_sdam(result, connection); end
  def result_class; end
  include Mongo::Operation::ResponseHandling
end
module Mongo::Operation::ExecutableNoValidate
  def execute(connection, client:); end
end
module Mongo::Operation::ExecutableTransactionLabel
end
module Mongo::Operation::PolymorphicLookup
  def polymorphic_class(base, name); end
end
module Mongo::Operation::PolymorphicResult
  def result_class; end
  def self.included(base); end
  include Mongo::Operation::PolymorphicLookup
end
module Mongo::Operation::PolymorphicResult::ClassMethods
  def result_class; end
  def result_class=(arg0); end
end
module Mongo::Operation::ReadPreferenceSupported
  def add_slave_ok_flag_maybe(options, connection); end
  def command(connection); end
  def options(connection); end
  def update_selector_for_read_pref(sel, connection); end
end
module Mongo::Operation::BypassDocumentValidation
  def add_bypass_document_validation(sel); end
  def command(connection); end
end
module Mongo::Operation::WriteConcernSupported
  def add_write_concern!(sel, connection); end
  def command(connection); end
  def write_concern_supported?(connection); end
end
module Mongo::Operation::Limited
  def options(connection); end
end
module Mongo::Operation::SessionsSupported
  def add_read_preference(sel, connection); end
  def add_write_concern!(sel); end
  def apply_autocommit!(selector); end
  def apply_causal_consistency!(selector, connection); end
  def apply_causal_consistency_if_possible(selector, connection); end
  def apply_cluster_time!(selector, connection); end
  def apply_read_pref!(selector); end
  def apply_session_options(sel, connection); end
  def apply_start_transaction!(selector); end
  def apply_txn_num!(selector); end
  def apply_txn_opts!(selector); end
  def build_message(connection); end
  def command(connection); end
  def flags; end
  def read_command?(sel); end
  def suppress_read_write_concern!(selector); end
  def validate_read_preference!(selector); end
end
module Mongo::Operation::CausalConsistencySupported
  def apply_causal_consistency!(selector, connection); end
end
module Mongo::Operation::Write
  def bulk_execute(connection, client:); end
  def execute(server, client:); end
  def validate!(connection); end
  include Mongo::Operation::ResponseHandling
end
module Mongo::Operation::Idable
  def documents; end
  def ensure_ids(documents); end
  def has_id?(doc); end
  def id(doc); end
  def id_generator; end
end
module Mongo::Operation::Specifiable
  def ==(other); end
  def acknowledged_write?; end
  def array_filters(connection); end
  def bypass_document_validation; end
  def coll_name; end
  def collation; end
  def command(connection); end
  def commit_quorum; end
  def cursor_count; end
  def cursor_id; end
  def cursor_ids; end
  def db_name; end
  def delete; end
  def deletes; end
  def documents; end
  def eql?(other); end
  def index; end
  def index_name; end
  def indexes; end
  def initialize(spec); end
  def max_time_ms; end
  def namespace; end
  def operation_id; end
  def options(connection); end
  def ordered?; end
  def read; end
  def read_concern; end
  def selector(connection); end
  def session; end
  def spec; end
  def to_return; end
  def txn_num; end
  def update; end
  def updates; end
  def user; end
  def user_name; end
  def write_concern; end
end
class Mongo::Operation::ObjectIdGenerator
  def generate; end
end
module Mongo::Operation::OpMsgOrCommand
  def execute(server, client:, options: nil); end
  def final_operation(connection); end
  include Mongo::Operation::PolymorphicLookup
end
module Mongo::Operation::OpMsgOrFindCommand
  def execute(server, client:); end
  def final_operation(connection); end
  include Mongo::Operation::PolymorphicLookup
end
module Mongo::Operation::OpMsgOrListIndexesCommand
  def execute(server, client:); end
  def final_operation(connection); end
  include Mongo::Operation::PolymorphicLookup
end
module Mongo::Operation::CollectionsInfoOrListCollections
  def execute(server, client:); end
  def final_operation(connection); end
  include Mongo::Operation::PolymorphicLookup
end
class Mongo::Operation::OpMsgBase
  def message(connection); end
  include Mongo::Operation::Executable
  include Mongo::Operation::SessionsSupported
  include Mongo::Operation::Specifiable
end
class Mongo::Operation::Command
  include Mongo::Operation::OpMsgOrCommand
  include Mongo::Operation::Specifiable
end
class Mongo::Operation::Command::Command
  def message(connection); end
  include Mongo::Operation::Executable
  include Mongo::Operation::Limited
  include Mongo::Operation::ReadPreferenceSupported
  include Mongo::Operation::Specifiable
end
class Mongo::Operation::Command::OpMsg < Mongo::Operation::OpMsgBase
end
class Mongo::Operation::Aggregate
  include Mongo::Operation::OpMsgOrCommand
  include Mongo::Operation::Specifiable
end
class Mongo::Operation::Aggregate::Command
  def message(connection); end
  def write_concern_supported?(connection); end
  extend Mongo::Operation::PolymorphicResult::ClassMethods
  include Mongo::Operation::Executable
  include Mongo::Operation::Limited
  include Mongo::Operation::PolymorphicResult
  include Mongo::Operation::ReadPreferenceSupported
  include Mongo::Operation::Specifiable
  include Mongo::Operation::WriteConcernSupported
end
class Mongo::Operation::Aggregate::OpMsg < Mongo::Operation::OpMsgBase
  extend Mongo::Operation::PolymorphicResult::ClassMethods
  include Mongo::Operation::CausalConsistencySupported
  include Mongo::Operation::ExecutableTransactionLabel
  include Mongo::Operation::PolymorphicResult
end
class Mongo::Operation::Aggregate::Result < Mongo::Operation::Result
  def cursor_document; end
  def cursor_id; end
  def documents; end
  def explain_document; end
  def first_document; end
  def post_batch_resume_token; end
end
class Mongo::Operation::CollectionsInfo
  include Mongo::Operation::CollectionsInfoOrListCollections
  include Mongo::Operation::Specifiable
end
class Mongo::Operation::CollectionsInfo::Command
  def get_result(connection, client, options = nil); end
  def message(connection); end
  def selector(connection); end
  extend Mongo::Operation::PolymorphicResult::ClassMethods
  include Mongo::Operation::Executable
  include Mongo::Operation::PolymorphicResult
  include Mongo::Operation::ReadPreferenceSupported
  include Mongo::Operation::Specifiable
end
class Mongo::Operation::CollectionsInfo::Result < Mongo::Operation::Result
  def initialize(replies, connection_description, database_name); end
  def namespace; end
end
class Mongo::Operation::ListCollections
  include Mongo::Operation::OpMsgOrCommand
  include Mongo::Operation::Specifiable
end
class Mongo::Operation::ListCollections::Command
  def message(connection); end
  def selector(connection); end
  extend Mongo::Operation::PolymorphicResult::ClassMethods
  include Mongo::Operation::Executable
  include Mongo::Operation::Limited
  include Mongo::Operation::PolymorphicResult
  include Mongo::Operation::ReadPreferenceSupported
  include Mongo::Operation::Specifiable
end
class Mongo::Operation::ListCollections::OpMsg < Mongo::Operation::OpMsgBase
  def selector(connection); end
  extend Mongo::Operation::PolymorphicResult::ClassMethods
  include Mongo::Operation::ExecutableTransactionLabel
  include Mongo::Operation::PolymorphicResult
end
class Mongo::Operation::ListCollections::Result < Mongo::Operation::Result
  def cursor_document; end
  def cursor_id; end
  def documents; end
  def first_document; end
  def namespace; end
  def validate!; end
end
class Mongo::Operation::Update
  include Mongo::Operation::Specifiable
  include Mongo::Operation::Write
end
class Mongo::Operation::Update::Command
  def message(connection); end
  def selector(connection); end
  extend Mongo::Operation::PolymorphicResult::ClassMethods
  include Mongo::Operation::BypassDocumentValidation
  include Mongo::Operation::Executable
  include Mongo::Operation::ExecutableNoValidate
  include Mongo::Operation::Limited
  include Mongo::Operation::PolymorphicResult
  include Mongo::Operation::Specifiable
  include Mongo::Operation::WriteConcernSupported
end
class Mongo::Operation::Update::OpMsg < Mongo::Operation::OpMsgBase
  def message(connection); end
  def selector(connection); end
  extend Mongo::Operation::PolymorphicResult::ClassMethods
  include Mongo::Operation::BypassDocumentValidation
  include Mongo::Operation::ExecutableNoValidate
  include Mongo::Operation::ExecutableTransactionLabel
  include Mongo::Operation::PolymorphicResult
end
class Mongo::Operation::Update::Legacy
  def gle; end
  def message(connection); end
  def selector; end
  extend Mongo::Operation::PolymorphicResult::ClassMethods
  include Mongo::Operation::Executable
  include Mongo::Operation::PolymorphicResult
  include Mongo::Operation::Specifiable
end
class Mongo::Operation::Update::Legacy::Result < Mongo::Operation::Result
  def matched_count; end
  def modified_count; end
  def updated_existing?; end
  def upsert?; end
  def upserted_count; end
  def upserted_id; end
  include Mongo::Operation::Result::UseLegacyErrorParser
end
class Mongo::Operation::Update::Result < Mongo::Operation::Result
  def bulk_result; end
  def matched_count; end
  def modified_count; end
  def upsert?; end
  def upserted_count; end
  def upserted_id; end
end
class Mongo::Operation::Update::BulkResult < Mongo::Operation::Result
  def n_matched; end
  def n_modified; end
  def n_upserted; end
  def upsert?(reply); end
  def upserted; end
  include Mongo::Operation::Result::Aggregatable
end
class Mongo::Operation::Insert
  def validate!(connection); end
  include Mongo::Operation::Specifiable
  include Mongo::Operation::Write
end
class Mongo::Operation::Insert::Command
  def get_result(connection, client, options = nil); end
  def message(connection); end
  def options(server); end
  def selector(connection); end
  include Mongo::Operation::BypassDocumentValidation
  include Mongo::Operation::Executable
  include Mongo::Operation::ExecutableNoValidate
  include Mongo::Operation::Idable
  include Mongo::Operation::Limited
  include Mongo::Operation::Specifiable
  include Mongo::Operation::WriteConcernSupported
end
class Mongo::Operation::Insert::OpMsg < Mongo::Operation::OpMsgBase
  def get_result(connection, client, options = nil); end
  def message(connection); end
  def selector(connection); end
  extend Mongo::Operation::PolymorphicResult::ClassMethods
  include Mongo::Operation::BypassDocumentValidation
  include Mongo::Operation::ExecutableNoValidate
  include Mongo::Operation::ExecutableTransactionLabel
  include Mongo::Operation::Idable
  include Mongo::Operation::PolymorphicResult
end
class Mongo::Operation::Insert::Legacy
  def get_result(connection, client, options = nil); end
  def gle; end
  def message(connection); end
  def selector; end
  include Mongo::Operation::Executable
  include Mongo::Operation::Idable
  include Mongo::Operation::Specifiable
end
class Mongo::Operation::Insert::Result < Mongo::Operation::Result
  def bulk_result; end
  def initialize(replies, connection_description, ids); end
  def inserted_id; end
  def inserted_ids; end
end
class Mongo::Operation::Insert::BulkResult < Mongo::Operation::Result
  def initialize(replies, connection_description, ids); end
  def inserted_id; end
  def inserted_ids; end
  def n_inserted; end
  include Mongo::Operation::Result::Aggregatable
end
class Mongo::Operation::Delete
  include Mongo::Operation::Specifiable
  include Mongo::Operation::Write
end
class Mongo::Operation::Delete::Command
  def message(connection); end
  def selector(connection); end
  extend Mongo::Operation::PolymorphicResult::ClassMethods
  include Mongo::Operation::Executable
  include Mongo::Operation::ExecutableNoValidate
  include Mongo::Operation::Limited
  include Mongo::Operation::PolymorphicResult
  include Mongo::Operation::Specifiable
  include Mongo::Operation::WriteConcernSupported
end
class Mongo::Operation::Delete::OpMsg < Mongo::Operation::OpMsgBase
  def message(connection); end
  def selector(connection); end
  extend Mongo::Operation::PolymorphicResult::ClassMethods
  include Mongo::Operation::BypassDocumentValidation
  include Mongo::Operation::ExecutableNoValidate
  include Mongo::Operation::ExecutableTransactionLabel
  include Mongo::Operation::PolymorphicResult
end
class Mongo::Operation::Delete::Legacy
  def gle; end
  def message(connection); end
  def selector; end
  extend Mongo::Operation::PolymorphicResult::ClassMethods
  include Mongo::Operation::Executable
  include Mongo::Operation::PolymorphicResult
  include Mongo::Operation::Specifiable
end
class Mongo::Operation::Delete::Result < Mongo::Operation::Result
  def bulk_result; end
  def deleted_count; end
end
class Mongo::Operation::Delete::BulkResult < Mongo::Operation::Result
  def n_removed; end
  include Mongo::Operation::Result::Aggregatable
end
class Mongo::Operation::Count
  include Mongo::Operation::OpMsgOrCommand
  include Mongo::Operation::Specifiable
end
class Mongo::Operation::Count::Command
  def message(connection); end
  include Mongo::Operation::Executable
  include Mongo::Operation::Limited
  include Mongo::Operation::ReadPreferenceSupported
  include Mongo::Operation::Specifiable
end
class Mongo::Operation::Count::OpMsg < Mongo::Operation::OpMsgBase
  include Mongo::Operation::CausalConsistencySupported
end
class Mongo::Operation::Distinct
  include Mongo::Operation::OpMsgOrCommand
  include Mongo::Operation::Specifiable
end
class Mongo::Operation::Distinct::Command
  def message(connection); end
  include Mongo::Operation::Executable
  include Mongo::Operation::Limited
  include Mongo::Operation::ReadPreferenceSupported
  include Mongo::Operation::Specifiable
end
class Mongo::Operation::Distinct::OpMsg < Mongo::Operation::OpMsgBase
  include Mongo::Operation::CausalConsistencySupported
  include Mongo::Operation::ExecutableTransactionLabel
end
class Mongo::Operation::Create
  include Mongo::Operation::OpMsgOrCommand
  include Mongo::Operation::Specifiable
end
class Mongo::Operation::Create::Command
  def message(connection); end
  include Mongo::Operation::Executable
  include Mongo::Operation::Limited
  include Mongo::Operation::Specifiable
  include Mongo::Operation::WriteConcernSupported
end
class Mongo::Operation::Create::OpMsg < Mongo::Operation::OpMsgBase
  include Mongo::Operation::ExecutableTransactionLabel
end
class Mongo::Operation::Drop
  include Mongo::Operation::OpMsgOrCommand
  include Mongo::Operation::Specifiable
end
class Mongo::Operation::Drop::Command
  def message(connection); end
  include Mongo::Operation::Executable
  include Mongo::Operation::Limited
  include Mongo::Operation::Specifiable
  include Mongo::Operation::WriteConcernSupported
end
class Mongo::Operation::Drop::OpMsg < Mongo::Operation::OpMsgBase
  include Mongo::Operation::ExecutableTransactionLabel
end
class Mongo::Operation::DropDatabase
  include Mongo::Operation::OpMsgOrCommand
  include Mongo::Operation::Specifiable
end
class Mongo::Operation::DropDatabase::Command
  def message(connection); end
  include Mongo::Operation::Executable
  include Mongo::Operation::Limited
  include Mongo::Operation::Specifiable
  include Mongo::Operation::WriteConcernSupported
end
class Mongo::Operation::DropDatabase::OpMsg < Mongo::Operation::OpMsgBase
  include Mongo::Operation::ExecutableTransactionLabel
end
class Mongo::Operation::GetMore
  include Mongo::Operation::OpMsgOrFindCommand
  include Mongo::Operation::Specifiable
end
class Mongo::Operation::GetMore::Command
  def message(connection); end
  extend Mongo::Operation::PolymorphicResult::ClassMethods
  include Mongo::Operation::Executable
  include Mongo::Operation::Limited
  include Mongo::Operation::PolymorphicResult
  include Mongo::Operation::ReadPreferenceSupported
  include Mongo::Operation::Specifiable
end
class Mongo::Operation::GetMore::OpMsg < Mongo::Operation::OpMsgBase
  extend Mongo::Operation::PolymorphicResult::ClassMethods
  include Mongo::Operation::ExecutableTransactionLabel
  include Mongo::Operation::PolymorphicResult
end
class Mongo::Operation::GetMore::Legacy
  def message(connection); end
  include Mongo::Operation::Executable
  include Mongo::Operation::Specifiable
end
class Mongo::Operation::GetMore::Result < Mongo::Operation::Result
  def cursor_document; end
  def cursor_id; end
  def documents; end
  def first_document; end
  def post_batch_resume_token; end
end
class Mongo::Operation::Find
  include Mongo::Operation::OpMsgOrFindCommand
  include Mongo::Operation::Specifiable
end
class Mongo::Operation::Find::Command
  def message(connection); end
  extend Mongo::Operation::PolymorphicResult::ClassMethods
  include Mongo::Operation::Executable
  include Mongo::Operation::Limited
  include Mongo::Operation::PolymorphicResult
  include Mongo::Operation::ReadPreferenceSupported
  include Mongo::Operation::Specifiable
end
class Mongo::Operation::Find::OpMsg < Mongo::Operation::OpMsgBase
  extend Mongo::Operation::PolymorphicResult::ClassMethods
  include Mongo::Operation::CausalConsistencySupported
  include Mongo::Operation::ExecutableTransactionLabel
  include Mongo::Operation::PolymorphicResult
end
class Mongo::Operation::Find::Legacy
  def message(connection); end
  extend Mongo::Operation::PolymorphicResult::ClassMethods
  include Mongo::Operation::Executable
  include Mongo::Operation::PolymorphicResult
  include Mongo::Operation::ReadPreferenceSupported
  include Mongo::Operation::Specifiable
end
class Mongo::Operation::Find::Legacy::Result < Mongo::Operation::Result
  def successful?; end
  include Mongo::Operation::Result::UseLegacyErrorParser
end
class Mongo::Operation::Find::Result < Mongo::Operation::Result
  def cursor_document; end
  def cursor_id; end
  def documents; end
  def first_document; end
  def namespace; end
end
class Mongo::Operation::Explain
  include Mongo::Operation::OpMsgOrFindCommand
  include Mongo::Operation::Specifiable
end
class Mongo::Operation::Explain::Result < Mongo::Operation::Result
  def cursor_id; end
  def documents; end
end
class Mongo::Operation::Explain::OpMsg < Mongo::Operation::OpMsgBase
  def selector(connection); end
  extend Mongo::Operation::PolymorphicResult::ClassMethods
  include Mongo::Operation::CausalConsistencySupported
  include Mongo::Operation::ExecutableTransactionLabel
  include Mongo::Operation::PolymorphicResult
end
class Mongo::Operation::Explain::Command
  def message(connection); end
  def selector(connection); end
  extend Mongo::Operation::PolymorphicResult::ClassMethods
  include Mongo::Operation::Executable
  include Mongo::Operation::Limited
  include Mongo::Operation::PolymorphicResult
  include Mongo::Operation::ReadPreferenceSupported
  include Mongo::Operation::Specifiable
end
class Mongo::Operation::Explain::Legacy
  def message(connection); end
  def selector(connection); end
  extend Mongo::Operation::PolymorphicResult::ClassMethods
  include Mongo::Operation::Executable
  include Mongo::Operation::PolymorphicResult
  include Mongo::Operation::ReadPreferenceSupported
  include Mongo::Operation::Specifiable
end
class Mongo::Operation::KillCursors
  include Mongo::Operation::OpMsgOrFindCommand
  include Mongo::Operation::Specifiable
end
class Mongo::Operation::KillCursors::Command
  def message(connection); end
  include Mongo::Operation::Executable
  include Mongo::Operation::Limited
  include Mongo::Operation::Specifiable
end
class Mongo::Operation::KillCursors::OpMsg < Mongo::Operation::OpMsgBase
  include Mongo::Operation::ExecutableTransactionLabel
end
class Mongo::Operation::KillCursors::Legacy
  def message(connection); end
  include Mongo::Operation::Executable
  include Mongo::Operation::Specifiable
end
class Mongo::Operation::Indexes
  include Mongo::Operation::OpMsgOrListIndexesCommand
  include Mongo::Operation::Specifiable
end
class Mongo::Operation::Indexes::Command
  def message(connection); end
  extend Mongo::Operation::PolymorphicResult::ClassMethods
  include Mongo::Operation::Executable
  include Mongo::Operation::Limited
  include Mongo::Operation::PolymorphicResult
  include Mongo::Operation::ReadPreferenceSupported
  include Mongo::Operation::Specifiable
end
class Mongo::Operation::Indexes::OpMsg < Mongo::Operation::OpMsgBase
  extend Mongo::Operation::PolymorphicResult::ClassMethods
  include Mongo::Operation::ExecutableTransactionLabel
  include Mongo::Operation::Limited
  include Mongo::Operation::PolymorphicResult
end
class Mongo::Operation::Indexes::Legacy
  def message(connection); end
  def result_class; end
  def selector(connection); end
  include Mongo::Operation::Executable
  include Mongo::Operation::ReadPreferenceSupported
  include Mongo::Operation::Specifiable
end
class Mongo::Operation::Indexes::Result < Mongo::Operation::Result
  def cursor_document; end
  def cursor_id; end
  def documents; end
  def first_document; end
  def namespace; end
  def validate!; end
end
class Mongo::Operation::MapReduce
  include Mongo::Operation::OpMsgOrCommand
  include Mongo::Operation::Specifiable
end
class Mongo::Operation::MapReduce::Command
  def message(connection); end
  extend Mongo::Operation::PolymorphicResult::ClassMethods
  include Mongo::Operation::Executable
  include Mongo::Operation::Limited
  include Mongo::Operation::PolymorphicResult
  include Mongo::Operation::ReadPreferenceSupported
  include Mongo::Operation::Specifiable
  include Mongo::Operation::WriteConcernSupported
end
class Mongo::Operation::MapReduce::OpMsg < Mongo::Operation::OpMsgBase
  extend Mongo::Operation::PolymorphicResult::ClassMethods
  include Mongo::Operation::CausalConsistencySupported
  include Mongo::Operation::ExecutableTransactionLabel
  include Mongo::Operation::PolymorphicResult
end
class Mongo::Operation::MapReduce::Result < Mongo::Operation::Result
  def counts; end
  def cursor_id; end
  def documents; end
  def first_document; end
  def successful?; end
  def time; end
  def validate!; end
end
class Mongo::Operation::UsersInfo
  include Mongo::Operation::OpMsgOrCommand
  include Mongo::Operation::Specifiable
end
class Mongo::Operation::UsersInfo::Command
  def message(connection); end
  def selector(connection); end
  extend Mongo::Operation::PolymorphicResult::ClassMethods
  include Mongo::Operation::Executable
  include Mongo::Operation::Limited
  include Mongo::Operation::PolymorphicResult
  include Mongo::Operation::ReadPreferenceSupported
  include Mongo::Operation::Specifiable
end
class Mongo::Operation::UsersInfo::OpMsg < Mongo::Operation::OpMsgBase
  def selector(connection); end
  extend Mongo::Operation::PolymorphicResult::ClassMethods
  include Mongo::Operation::ExecutableTransactionLabel
  include Mongo::Operation::PolymorphicResult
end
class Mongo::Operation::UsersInfo::Result < Mongo::Operation::Result
  def documents; end
  def first_document; end
end
class Mongo::Operation::ParallelScan
  include Mongo::Operation::OpMsgOrCommand
  include Mongo::Operation::Specifiable
end
class Mongo::Operation::ParallelScan::Command
  def message(connection); end
  def selector(connection); end
  extend Mongo::Operation::PolymorphicResult::ClassMethods
  include Mongo::Operation::Executable
  include Mongo::Operation::Limited
  include Mongo::Operation::PolymorphicResult
  include Mongo::Operation::ReadPreferenceSupported
  include Mongo::Operation::Specifiable
end
class Mongo::Operation::ParallelScan::OpMsg < Mongo::Operation::OpMsgBase
  def selector(connection); end
  extend Mongo::Operation::PolymorphicResult::ClassMethods
  include Mongo::Operation::CausalConsistencySupported
  include Mongo::Operation::ExecutableTransactionLabel
  include Mongo::Operation::PolymorphicResult
end
class Mongo::Operation::ParallelScan::Result < Mongo::Operation::Result
  def cursor_ids; end
  def documents; end
  def first; end
end
class Mongo::Operation::CreateUser
  include Mongo::Operation::OpMsgOrCommand
  include Mongo::Operation::Specifiable
end
class Mongo::Operation::CreateUser::Command
  def message(connection); end
  def selector(connection); end
  include Mongo::Operation::Executable
  include Mongo::Operation::Limited
  include Mongo::Operation::ReadPreferenceSupported
  include Mongo::Operation::Specifiable
  include Mongo::Operation::WriteConcernSupported
end
class Mongo::Operation::CreateUser::OpMsg < Mongo::Operation::OpMsgBase
  def selector(connection); end
  include Mongo::Operation::ExecutableTransactionLabel
end
class Mongo::Operation::UpdateUser
  include Mongo::Operation::OpMsgOrCommand
  include Mongo::Operation::Specifiable
end
class Mongo::Operation::UpdateUser::Command
  def message(connection); end
  def selector(connection); end
  include Mongo::Operation::Executable
  include Mongo::Operation::Limited
  include Mongo::Operation::Specifiable
  include Mongo::Operation::WriteConcernSupported
end
class Mongo::Operation::UpdateUser::OpMsg < Mongo::Operation::OpMsgBase
  def selector(connection); end
  include Mongo::Operation::ExecutableTransactionLabel
end
class Mongo::Operation::RemoveUser
  include Mongo::Operation::OpMsgOrCommand
  include Mongo::Operation::Specifiable
end
class Mongo::Operation::RemoveUser::Command
  def message(connection); end
  def selector(connection); end
  include Mongo::Operation::Executable
  include Mongo::Operation::Limited
  include Mongo::Operation::ReadPreferenceSupported
  include Mongo::Operation::Specifiable
  include Mongo::Operation::WriteConcernSupported
end
class Mongo::Operation::RemoveUser::OpMsg < Mongo::Operation::OpMsgBase
  def selector(connection); end
  include Mongo::Operation::ExecutableTransactionLabel
end
class Mongo::Operation::CreateIndex
  include Mongo::Operation::OpMsgOrCommand
  include Mongo::Operation::Specifiable
end
class Mongo::Operation::CreateIndex::Command
  def message(connection); end
  def selector(connection); end
  include Mongo::Operation::Executable
  include Mongo::Operation::Limited
  include Mongo::Operation::Specifiable
  include Mongo::Operation::WriteConcernSupported
end
class Mongo::Operation::CreateIndex::OpMsg < Mongo::Operation::OpMsgBase
  def selector(connection); end
  include Mongo::Operation::ExecutableTransactionLabel
end
class Mongo::Operation::DropIndex
  include Mongo::Operation::OpMsgOrCommand
  include Mongo::Operation::Specifiable
end
class Mongo::Operation::DropIndex::Command
  def message(connection); end
  def selector(connection); end
  include Mongo::Operation::Executable
  include Mongo::Operation::Limited
  include Mongo::Operation::Specifiable
  include Mongo::Operation::WriteConcernSupported
end
class Mongo::Operation::DropIndex::OpMsg < Mongo::Operation::OpMsgBase
  def selector(connection); end
  include Mongo::Operation::ExecutableTransactionLabel
end
class Mongo::Error < StandardError
  def add_label(label); end
  def change_stream_resumable?; end
  def initialize(msg = nil); end
  def label?(label); end
  def labels; end
  def write_concern_error_label?(label); end
  def write_concern_error_labels; end
  include Mongo::Error::Notable
end
module Mongo::Error::Notable
  def add_note(note); end
  def generation; end
  def generation=(arg0); end
  def notes; end
  def notes_tail; end
  def to_s; end
end
class Mongo::Error::AuthError < RuntimeError
  include Mongo::Error::Notable
end
module Mongo::Error::SdamErrorDetection
  def node_recovering?; end
  def node_shutting_down?; end
  def not_master?; end
end
class Mongo::Error::Parser
  def append(message, error); end
  def code; end
  def code_name; end
  def document; end
  def initialize(document, replies = nil, options = nil); end
  def labels; end
  def message; end
  def parse!; end
  def parse_code; end
  def parse_flag(message); end
  def parse_labels; end
  def parse_multiple(message, key); end
  def parse_single(message, key, doc = nil); end
  def parse_wtimeout; end
  def replies; end
  def write_concern_error?; end
  def write_concern_error_code; end
  def write_concern_error_code_name; end
  def write_concern_error_document; end
  def write_concern_error_labels; end
  def wtimeout; end
  include Mongo::Error::SdamErrorDetection
end
module Mongo::Error::WriteRetryable
  def write_retryable?; end
end
module Mongo::Error::ChangeStreamResumable
  def change_stream_resumable?; end
end
class Mongo::Error::BulkWriteError < Mongo::Error
  def build_message; end
  def initialize(result); end
  def result; end
end
class Mongo::Error::ClosedStream < Mongo::Error
  def initialize; end
end
class Mongo::Error::ConnectionCheckOutTimeout < Timeout::Error
  def address; end
  def initialize(msg, options); end
end
class Mongo::Error::ConnectionPerished < Mongo::Error
end
class Mongo::Error::CredentialCheckError < Mongo::Error::AuthError
end
class Mongo::Error::CryptError < Mongo::Error
  def initialize(message, code: nil); end
end
class Mongo::Error::ExtraFileChunk < Mongo::Error
  def initialize; end
end
class Mongo::Error::FileNotFound < Mongo::Error
  def initialize(value, property); end
end
class Mongo::Error::OperationFailure < Mongo::Error
  def change_stream_resumable?; end
  def change_stream_resumable_code?; end
  def code; end
  def code_name; end
  def connection_description(*args, &block); end
  def initialize(message = nil, result = nil, options = nil); end
  def max_time_ms_expired?; end
  def operation_time(*args, &block); end
  def retryable?; end
  def unsupported_retryable_write?; end
  def write_concern_error?; end
  def write_concern_error_code; end
  def write_concern_error_code_name; end
  def write_concern_error_document; end
  def write_retryable?; end
  def write_retryable_code?; end
  def wtimeout?; end
  extend Forwardable
  include Mongo::Error::SdamErrorDetection
end
class Mongo::Error::InvalidAddress < Mongo::Error
end
class Mongo::Error::InvalidBulkOperation < Mongo::Error
  def initialize(type, operation); end
end
class Mongo::Error::InvalidBulkOperationType < Mongo::Error
  def initialize(type); end
end
class Mongo::Error::InvalidCollectionName < Mongo::Error
  def initialize; end
end
class Mongo::Error::InvalidCursorOperation < Mongo::Error
end
class Mongo::Error::InvalidDatabaseName < Mongo::Error
  def initialize; end
end
class Mongo::Error::InvalidDocument < Mongo::Error
  def initialize; end
end
class Mongo::Error::InvalidFile < Mongo::Error
  def initialize(client_md5, server_md5); end
end
class Mongo::Error::InvalidFileRevision < Mongo::Error
  def initialize(filename, revision); end
end
class Mongo::Error::InvalidMinPoolSize < Mongo::Error
  def initialize(min, max); end
end
class Mongo::Error::InvalidReadOption < Mongo::Error
  def initialize(read_option, msg); end
end
class Mongo::Error::InvalidApplicationName < Mongo::Error
  def initialize(app_name, max_size); end
end
class Mongo::Error::InvalidNonce < Mongo::Error
  def initialize(nonce, rnonce); end
  def nonce; end
  def rnonce; end
end
class Mongo::Error::InvalidReadConcern < Mongo::Error
  def initialize(msg = nil); end
end
class Mongo::Error::InvalidReplacementDocument < Mongo::Error
  def initialize; end
end
class Mongo::Error::InvalidServerAuthResponse < Mongo::Error::AuthError
end
class Mongo::Error::InvalidServerAuthHost < Mongo::Error::InvalidServerAuthResponse
end
class Mongo::Error::InvalidServerPreference < Mongo::Error
  def initialize(message); end
end
class Mongo::Error::InvalidSession < Mongo::Error
  def initialize(message); end
end
class Mongo::Error::InvalidSignature < Mongo::Error
  def initialize(verifier, server_signature); end
  def server_signature; end
  def verifier; end
end
class Mongo::Error::InvalidTransactionOperation < Mongo::Error
  def initialize(msg); end
  def self.cannot_call_after_msg(last_op, current_op); end
  def self.cannot_call_twice_msg(op); end
end
class Mongo::Error::InvalidTXTRecord < Mongo::Error
end
class Mongo::Error::InvalidUpdateDocument < Mongo::Error
  def initialize; end
end
class Mongo::Error::InvalidURI < Mongo::Error
  def initialize(uri, details, format = nil); end
end
class Mongo::Error::InvalidWriteConcern < Mongo::Error
  def initialize(msg = nil); end
end
class Mongo::Error::InsufficientIterationCount < Mongo::Error
  def initialize(msg); end
  def self.message(required_count, given_count); end
end
class Mongo::Error::KmsError < Mongo::Error::CryptError
end
class Mongo::Error::LintError < Mongo::Error
end
class Mongo::Error::MaxBSONSize < Mongo::Error
  def initialize(max_size_or_msg = nil); end
end
class Mongo::Error::MaxMessageSize < Mongo::Error
  def initialize(max_size = nil); end
end
class Mongo::Error::MismatchedDomain < Mongo::Error
end
class Mongo::Error::MongocryptdSpawnError < Mongo::Error::CryptError
end
class Mongo::Error::MultiIndexDrop < Mongo::Error
  def initialize; end
end
class Mongo::Error::NeedPrimaryServer < Mongo::Error
end
class Mongo::Error::NoServerAvailable < Mongo::Error
  def initialize(server_selector, cluster = nil, msg = nil); end
end
class Mongo::Error::NoSRVRecords < Mongo::Error
end
class Mongo::Error::SessionEnded < Mongo::Error
  def initialize; end
end
class Mongo::Error::SessionsNotSupported < Mongo::Error::InvalidSession
  def initialize(message); end
end
class Mongo::Error::PoolClosedError < Mongo::Error
  def address; end
  def initialize(address, pool); end
  def pool; end
end
class Mongo::Error::RaiseOriginalError < Exception
end
class Mongo::Error::ServerCertificateRevoked < Mongo::Error
end
class Mongo::Error::SocketError < Mongo::Error
  include Mongo::Error::ChangeStreamResumable
  include Mongo::Error::WriteRetryable
end
class Mongo::Error::SocketTimeoutError < Mongo::Error
  include Mongo::Error::ChangeStreamResumable
  include Mongo::Error::WriteRetryable
end
class Mongo::Error::FailedStringPrepValidation < Mongo::Error
  def initialize(msg); end
end
class Mongo::Error::UnchangeableCollectionOption < Mongo::Error
  def initialize(option); end
end
class Mongo::Error::UnexpectedChunkLength < Mongo::Error
  def initialize(expected_len, chunk); end
end
class Mongo::Error::UnexpectedResponse < Mongo::Error
  def initialize(expected_response_to, response_to); end
end
class Mongo::Error::MissingFileChunk < Mongo::Error
  def initialize(expected_n, chunk); end
end
class Mongo::Error::MissingPassword < Mongo::Error
  def initialize(msg = nil); end
end
class Mongo::Error::MissingResumeToken < Mongo::Error
  def initialize; end
end
class Mongo::Error::MissingScramServerSignature < Mongo::Error
  def initialize(msg = nil); end
end
class Mongo::Error::UnknownPayloadType < Mongo::Error
  def initialize(byte); end
end
class Mongo::Error::UnsupportedOption < Mongo::Error
  def self.allow_disk_use_error; end
  def self.commit_quorum_error; end
  def self.hint_error(**options); end
end
class Mongo::Error::UnsupportedArrayFilters < Mongo::Error::UnsupportedOption
  def initialize(message = nil); end
end
class Mongo::Error::UnsupportedCollation < Mongo::Error::UnsupportedOption
  def initialize(message = nil); end
end
class Mongo::Error::UnsupportedFeatures < Mongo::Error
end
class Mongo::Error::UnsupportedMessageType < Mongo::Error
end
class Mongo::Address
  def ==(other); end
  def eql?(other); end
  def hash; end
  def host; end
  def initialize(seed, options = nil); end
  def inspect; end
  def map_exceptions; end
  def options; end
  def parse_host_port; end
  def port; end
  def seed; end
  def socket(socket_timeout, opts = nil); end
  def to_s; end
  extend Forwardable
end
class Mongo::Address::IPv4
  def host; end
  def host_name; end
  def initialize(host, port, host_name = nil); end
  def port; end
  def self.parse(address); end
  def socket(socket_timeout, options = nil); end
end
class Mongo::Address::IPv6
  def host; end
  def host_name; end
  def initialize(host, port, host_name = nil); end
  def port; end
  def self.parse(address); end
  def socket(socket_timeout, options = nil); end
end
class Mongo::Address::Unix
  def host; end
  def initialize(host, port = nil, host_name = nil); end
  def port; end
  def self.parse(address); end
  def socket(socket_timeout, options = nil); end
end
module Mongo::Address::Validator
  def validate_address_str!(address_str); end
  def validate_hostname!(host); end
  def validate_port_str!(port); end
end
module Mongo::Auth
  def get(user, connection, **opts); end
  extend Mongo::Auth
end
module Mongo::Auth::CredentialCache
  def cache(key); end
  def clear; end
  def get(key); end
  def self.cache(key); end
  def self.clear; end
  def self.get(key); end
  def self.set(key, value); end
  def self.store; end
  def set(key, value); end
end
module Mongo::Auth::StringPrep
  def apply_maps(data, mappings); end
  def check_bidi!(out); end
  def check_prohibited!(out, prohibited); end
  def mapping(c, mappings); end
  def normalize!(out); end
  def prepare(data, mappings, prohibited, options = nil); end
  def table_contains?(table, c); end
  extend Mongo::Auth::StringPrep
end
module Mongo::Auth::StringPrep::Tables
end
module Mongo::Auth::StringPrep::Profiles
end
module Mongo::Auth::StringPrep::Profiles::SASL
end
class Mongo::Auth::ConversationBase
  def connection; end
  def initialize(user, connection, **opts); end
  def speculative_auth_document; end
  def user; end
end
class Mongo::Auth::SaslConversationBase < Mongo::Auth::ConversationBase
  def auth_mechanism_name; end
  def client_first_document; end
  def client_first_message_options; end
  def start(connection); end
  def validate_server_nonce!; end
end
class Mongo::Auth::ScramConversationBase < Mongo::Auth::SaslConversationBase
  def auth_message; end
  def cache_key(*extra); end
  def check_server_signature(payload_data); end
  def client_empty_message; end
  def client_final; end
  def client_final_message; end
  def client_first_message_options; end
  def client_first_payload; end
  def client_key; end
  def client_nonce; end
  def client_proof(key, signature); end
  def client_signature(key, message); end
  def compare_digest(a, b); end
  def continue(reply_document, connection); end
  def finalize(connection); end
  def first_bare; end
  def h(string); end
  def hmac(data, key); end
  def id; end
  def initialize(user, connection, client_nonce: nil); end
  def iterations; end
  def parse_payload(payload); end
  def payload_data; end
  def process_continue_response(reply_document); end
  def salt; end
  def server_key; end
  def server_nonce; end
  def server_signature; end
  def server_verified?; end
  def speculative_auth_document; end
  def stored_key(key); end
  def without_proof; end
  def xor(first, second); end
end
class Mongo::Auth::User
  def ==(other); end
  def auth_key(nonce); end
  def auth_mech_properties; end
  def auth_source; end
  def database; end
  def encoded_name; end
  def hash; end
  def hashed_password; end
  def initialize(options); end
  def mechanism; end
  def name; end
  def options; end
  def password; end
  def roles; end
  def sasl_prepped_password; end
  def self.default_auth_source(options); end
  def spec; end
  include Mongo::Loggable
end
class Mongo::Auth::User::View
  def client(*args, &block); end
  def cluster(*args, &block); end
  def create(user_or_name, options = nil); end
  def database; end
  def generate(user, options); end
  def info(name, options = nil); end
  def initialize(database); end
  def next_primary(*args, &block); end
  def read_preference(*args, &block); end
  def remove(name, options = nil); end
  def update(user_or_name, options = nil); end
  def user_query(name, options = nil); end
  extend Forwardable
end
module Mongo::Auth::Roles
end
class Mongo::Auth::Base
  def connection; end
  def conversation; end
  def converse_1_step(connection, conversation); end
  def converse_2_step(connection, conversation); end
  def converse_multi_step(connection, conversation, speculative_auth_result: nil); end
  def dispatch_msg(connection, conversation, msg); end
  def initialize(user, connection, **opts); end
  def user; end
  def validate_reply!(connection, conversation, doc); end
end
class Mongo::Auth::Aws < Mongo::Auth::Base
  def login; end
end
class Mongo::Auth::Aws::Conversation < Mongo::Auth::SaslConversationBase
  def client_final_payload; end
  def client_first_data; end
  def client_first_payload; end
  def client_nonce; end
  def continue(reply_document, connection); end
  def conversation_id; end
  def server_nonce; end
  def wrap_data(data); end
end
class Mongo::Auth::Aws::CredentialsRetriever
  def credentials; end
  def credentials_valid?(credentials, source); end
  def ec2_metadata_credentials; end
  def ecs_metadata_credentials; end
  def http_get(http, uri, metadata_token); end
  def initialize(user = nil); end
  def user; end
end
module Net
end
class Mongo::Auth::Aws::Request
  def access_key_id; end
  def authorization; end
  def canonical_request; end
  def formatted_date; end
  def formatted_time; end
  def headers; end
  def headers_to_sign; end
  def hmac(key, data); end
  def hmac_hex(key, data); end
  def host; end
  def initialize(access_key_id:, secret_access_key:, host:, server_nonce:, session_token: nil, time: nil); end
  def region; end
  def scope; end
  def secret_access_key; end
  def server_nonce; end
  def session_token; end
  def signature; end
  def signed_headers_string; end
  def time; end
  def validate!; end
end
class Mongo::Auth::Aws::Credentials < Struct
  def access_key_id; end
  def access_key_id=(_); end
  def secret_access_key; end
  def secret_access_key=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def session_token; end
  def session_token=(_); end
end
class Mongo::Auth::CR < Mongo::Auth::Base
  def login; end
end
class Mongo::Auth::CR::Conversation < Mongo::Auth::ConversationBase
  def continue(reply_document, connection); end
  def database; end
  def nonce; end
  def start(connection); end
end
class Mongo::Auth::Gssapi < Mongo::Auth::Base
  def login; end
end
class Mongo::Auth::Gssapi::Conversation < Mongo::Auth::SaslConversationBase
  def authenticator; end
  def client_first_document; end
  def continue(reply_document, connection); end
  def finalize(connection); end
  def id; end
  def initialize(user, connection, **opts); end
  def process_continue_response(reply_document); end
end
class Mongo::Auth::LDAP < Mongo::Auth::Base
  def login; end
end
class Mongo::Auth::LDAP::Conversation < Mongo::Auth::ConversationBase
  def payload; end
  def start(connection); end
end
class Mongo::Auth::Scram < Mongo::Auth::Base
  def conversation; end
  def initialize(user, connection, **opts); end
  def login; end
  def speculative_auth_client_nonce; end
  def speculative_auth_result; end
end
class Mongo::Auth::Scram::Conversation < Mongo::Auth::ScramConversationBase
  def digest; end
  def hi(data); end
  def salted_password; end
end
class Mongo::Auth::Scram256 < Mongo::Auth::Scram
end
class Mongo::Auth::Scram256::Conversation < Mongo::Auth::ScramConversationBase
  def digest; end
  def hi(data); end
  def salted_password; end
end
class Mongo::Auth::X509 < Mongo::Auth::Base
  def initialize(user, connection, **opts); end
  def login; end
end
class Mongo::Auth::X509::Conversation < Mongo::Auth::ConversationBase
  def client_first_document; end
  def speculative_auth_document; end
  def start(connection); end
end
class Mongo::Auth::InvalidConfiguration < Mongo::Error::AuthError
end
class Mongo::Auth::InvalidMechanism < Mongo::Auth::InvalidConfiguration
  def initialize(mechanism); end
end
class Mongo::Auth::Unauthorized < Mongo::Error::AuthError
  def initialize(user, used_mechanism: nil, message: nil, server: nil); end
end
module Mongo::Protocol
end
module Mongo::Protocol::Serializers
end
module Mongo::Protocol::Serializers::Header
  def self.deserialize(buffer, options = nil); end
  def self.serialize(buffer, value, validating_keys = nil); end
end
module Mongo::Protocol::Serializers::CString
  def self.serialize(buffer, value, validating_keys = nil); end
end
module Mongo::Protocol::Serializers::Zero
  def self.serialize(buffer, value, validating_keys = nil); end
end
module Mongo::Protocol::Serializers::Int32
  def self.deserialize(buffer, options = nil); end
  def self.serialize(buffer, value, validating_keys = nil); end
end
module Mongo::Protocol::Serializers::Int64
  def self.deserialize(buffer, options = nil); end
  def self.serialize(buffer, value, validating_keys = nil); end
end
module Mongo::Protocol::Serializers::Sections
  def self.deserialize(buffer, options = nil); end
  def self.serialize(buffer, value, max_bson_size = nil, validating_keys = nil); end
  def self.size_limited?; end
end
module Mongo::Protocol::Serializers::Sections::PayloadZero
  def self.deserialize(buffer, options = nil); end
  def self.serialize(buffer, value, max_bson_size = nil, validating_keys = nil); end
end
module Mongo::Protocol::Serializers::Sections::PayloadOne
  def self.deserialize(buffer); end
  def self.serialize(buffer, value, max_bson_size = nil, validating_keys = nil); end
end
module Mongo::Protocol::Serializers::Document
  def self.deserialize(buffer, options = nil); end
  def self.serialize(buffer, value, max_bson_size = nil, validating_keys = nil); end
  def self.size_limited?; end
end
module Mongo::Protocol::Serializers::Byte
  def self.deserialize(buffer, options = nil); end
  def self.serialize(buffer, value, validating_keys = nil); end
end
module Mongo::Protocol::Serializers::Bytes
  def self.deserialize(buffer, options = nil); end
  def self.serialize(buffer, value, validating_keys = nil); end
end
module Mongo::Protocol::Registry
  def define_type_reader(type); end
  def get(op_code, message = nil); end
  def handle_unsupported_op_code!(op_code); end
  def register(op_code, type); end
  extend Mongo::Protocol::Registry
end
class Mongo::Protocol::Serializers::BitVector
  def deserialize(buffer, options = nil); end
  def initialize(layout); end
  def serialize(buffer, value, validating_keys = nil); end
end
class Mongo::Protocol::Message
  def ==(other); end
  def compress_if_possible(command_name, compressor, zlib_compression_level); end
  def eql?(other); end
  def fields; end
  def hash; end
  def initialize(*args); end
  def maybe_compress(compressor, zlib_compression_level = nil); end
  def maybe_decrypt(client); end
  def maybe_encrypt(server, client); end
  def maybe_inflate; end
  def merge_sections; end
  def number_returned; end
  def replyable?; end
  def request_id; end
  def self.deserialize(io, max_message_size = nil, expected_response_to = nil, options = nil); end
  def self.deserialize_array(message, io, field, options = nil); end
  def self.deserialize_field(message, io, field, options = nil); end
  def self.deserialize_header(io); end
  def self.field(name, type, multi = nil); end
  def self.fields; end
  def self.next_id; end
  def serialize(buffer = nil, max_bson_size = nil, bson_overhead = nil); end
  def serialize_fields(buffer, max_bson_size = nil); end
  def serialize_header(buffer); end
  def set_request_id; end
  def to_s(buffer = nil, max_bson_size = nil, bson_overhead = nil); end
  def validating_keys?; end
  include Mongo::Id
  include Mongo::Protocol::Serializers
end
class Mongo::Protocol::Compressed < Mongo::Protocol::Message
  def compressed_message; end
  def compressor_id; end
  def initialize(message, compressor, zlib_compression_level = nil); end
  def maybe_inflate; end
  def op_code; end
  def original_op_code; end
  def replyable?; end
  def serialize_fields(buffer, max_bson_size); end
  def uncompressed_size; end
end
class Mongo::Protocol::Delete < Mongo::Protocol::Message
  def flags; end
  def initialize(database, collection, selector, options = nil); end
  def namespace; end
  def op_code; end
  def payload; end
  def selector; end
  def upconverter; end
  def zero; end
end
class Mongo::Protocol::Delete::Upconverter
  def collection; end
  def command; end
  def filter; end
  def initialize(collection, filter, options); end
  def limit; end
  def options; end
end
class Mongo::Protocol::GetMore < Mongo::Protocol::Message
  def cursor_id; end
  def initialize(database, collection, number_to_return, cursor_id); end
  def namespace; end
  def number_to_return; end
  def op_code; end
  def payload; end
  def replyable?; end
  def upconverter; end
  def zero; end
end
class Mongo::Protocol::GetMore::Upconverter
  def collection; end
  def command; end
  def cursor_id; end
  def initialize(collection, cursor_id, number_to_return); end
  def number_to_return; end
end
class Mongo::Protocol::Insert < Mongo::Protocol::Message
  def documents; end
  def flags; end
  def initialize(database, collection, documents, options = nil); end
  def namespace; end
  def op_code; end
  def payload; end
  def upconverter; end
  def validating_keys?; end
end
class Mongo::Protocol::Insert::Upconverter
  def collection; end
  def command; end
  def documents; end
  def initialize(collection, documents, options); end
  def options; end
end
class Mongo::Protocol::KillCursors < Mongo::Protocol::Message
  def cursor_ids; end
  def id_count; end
  def initialize(collection, database, cursor_ids); end
  def op_code; end
  def payload; end
  def upconverter; end
  def zero; end
end
class Mongo::Protocol::KillCursors::Upconverter
  def collection; end
  def command; end
  def cursor_ids; end
  def initialize(collection, cursor_ids); end
end
class Mongo::Protocol::Query < Mongo::Protocol::Message
  def determine_limit; end
  def flags; end
  def initialize(database, collection, selector, options = nil); end
  def limit; end
  def maybe_compress(compressor, zlib_compression_level = nil); end
  def namespace; end
  def op_code; end
  def payload; end
  def project; end
  def replyable?; end
  def selector; end
  def serialize(buffer = nil, max_bson_size = nil, bson_overhead = nil); end
  def skip; end
  def upconverter; end
  def validate_document_size!(max_bson_size); end
  include Mongo::Monitoring::Event::Secure
end
class Mongo::Protocol::Query::Upconverter
  def collection; end
  def command; end
  def command?; end
  def command_name; end
  def filter; end
  def find_command; end
  def flags; end
  def initialize(collection, filter, options, flags); end
  def op_command; end
  def options; end
  def query_filter; end
end
class Mongo::Protocol::Update < Mongo::Protocol::Message
  def flags; end
  def initialize(database, collection, selector, update, options = nil); end
  def namespace; end
  def op_code; end
  def payload; end
  def selector; end
  def upconverter; end
  def update; end
  def zero; end
end
class Mongo::Protocol::Update::Upconverter
  def collection; end
  def command; end
  def filter; end
  def flags; end
  def initialize(collection, filter, update, flags); end
  def update; end
end
class Mongo::Protocol::Msg < Mongo::Protocol::Message
  def add_check_sum(buffer); end
  def bulk_write?; end
  def command; end
  def documents; end
  def fix_after_deserialization; end
  def flags; end
  def initialize(flags, options, main_document, *sequences); end
  def maybe_compress(compressor, zlib_compression_level = nil); end
  def maybe_decrypt(client); end
  def maybe_encrypt(connection, client); end
  def op_code; end
  def payload; end
  def replyable?; end
  def sections; end
  def serialize(buffer = nil, max_bson_size = nil, bson_overhead = nil); end
  def validate_document_size!(max_bson_size); end
  include Mongo::Monitoring::Event::Secure
end
class Mongo::Protocol::Msg::Section1
  def ==(other); end
  def documents; end
  def eql?(other); end
  def identifier; end
  def initialize(identifier, documents); end
end
class Mongo::Protocol::Reply < Mongo::Protocol::Message
  def cursor_id; end
  def cursor_not_found?; end
  def documents; end
  def flags; end
  def number_returned; end
  def op_code; end
  def payload; end
  def query_failure?; end
  def starting_from; end
  def upconverter; end
end
class Mongo::Protocol::Reply::Upconverter
  def batch_field; end
  def command; end
  def command?; end
  def cursor_id; end
  def documents; end
  def find_command; end
  def initialize(documents, cursor_id, starting_from); end
  def op_command; end
  def starting_from; end
end
module Mongo::BackgroundThread
  def do_work; end
  def pre_stop; end
  def run!; end
  def running?; end
  def start!; end
  def stop!; end
  def wait_for_stop; end
  include Mongo::Loggable
end
class Mongo::Cluster
  def ==(other); end
  def add(host, add_options = nil); end
  def addresses; end
  def app_metadata; end
  def connected?; end
  def connecting?; end
  def disconnect!; end
  def disconnect_server_if_connected(server); end
  def has_readable_server?(server_selector = nil); end
  def has_writable_server?; end
  def heartbeat_interval; end
  def initialize(seeds, monitoring, options = nil); end
  def inspect; end
  def logical_session_timeout(*args, &block); end
  def max_read_retries; end
  def monitoring; end
  def next_primary(ping = nil, session = nil); end
  def options; end
  def pool(server); end
  def raise_sessions_not_supported; end
  def read_retry_interval; end
  def reconnect!; end
  def register_cursor(*args); end
  def remove(host, disconnect: nil); end
  def replica_set?(*args, &block); end
  def replica_set_name(*args, &block); end
  def run_sdam_flow(previous_desc, updated_desc, options = nil); end
  def scan!(sync = nil); end
  def schedule_kill_cursor(*args); end
  def seeds; end
  def self.create(client); end
  def self.finalize(pools, periodic_executor, session_pool); end
  def server_selection_semaphore; end
  def servers; end
  def servers_list; end
  def session_pool; end
  def set_server_list(server_address_strs); end
  def sharded?(*args, &block); end
  def single?(*args, &block); end
  def srv_monitor; end
  def start_stop_srv_monitor; end
  def summary; end
  def topology; end
  def unknown?(*args, &block); end
  def unregister_cursor(*args); end
  def update_cluster_time(result); end
  def update_topology(new_topology); end
  def validate_session_support!; end
  extend Forwardable
  include Mongo::ClusterTime::Consumer
  include Mongo::Event::Subscriber
  include Mongo::Loggable
  include Mongo::Monitoring::Publishable
end
module Mongo::Cluster::Topology
  def initial(cluster, monitoring, options); end
  extend Mongo::Cluster::Topology
end
class Mongo::Cluster::Topology::Base
  def addresses; end
  def cluster; end
  def compatibility_error; end
  def compatible?; end
  def data_bearing_servers?; end
  def initialize(options, monitoring, cluster); end
  def logical_session_timeout; end
  def max_election_id; end
  def max_set_version; end
  def monitoring; end
  def new_max_election_id(description); end
  def new_max_set_version(description); end
  def options; end
  def replica_set_name; end
  def server_descriptions; end
  def validate_options(options, cluster); end
  extend Forwardable
  include Mongo::Loggable
  include Mongo::Monitoring::Publishable
end
module Mongo::Cluster::Topology::NoReplicaSetOptions
  def validate_options(options, cluster); end
end
class Mongo::Cluster::Topology::ReplicaSetNoPrimary < Mongo::Cluster::Topology::Base
  def display_name; end
  def has_readable_server?(cluster, server_selector = nil); end
  def has_writable_server?(cluster); end
  def replica_set?; end
  def servers(servers); end
  def sharded?; end
  def single?; end
  def summary; end
  def unknown?; end
  def validate_options(options, cluster); end
end
class Mongo::Cluster::Topology::ReplicaSetWithPrimary < Mongo::Cluster::Topology::ReplicaSetNoPrimary
end
class Mongo::Cluster::Topology::Sharded < Mongo::Cluster::Topology::Base
  def display_name; end
  def has_readable_server?(cluster, server_selector = nil); end
  def has_writable_server?(cluster); end
  def replica_set?; end
  def servers(servers); end
  def sharded?; end
  def single?; end
  def summary; end
  def unknown?; end
  include Mongo::Cluster::Topology::NoReplicaSetOptions
end
class Mongo::Cluster::Topology::Single < Mongo::Cluster::Topology::Base
  def display_name; end
  def has_readable_server?(cluster, server_selector = nil); end
  def has_writable_server?(cluster); end
  def replica_set?; end
  def servers(servers, name = nil); end
  def sharded?; end
  def single?; end
  def summary; end
  def unknown?; end
  def validate_options(options, cluster); end
end
class Mongo::Cluster::Topology::Unknown < Mongo::Cluster::Topology::Base
  def display_name; end
  def has_readable_server?(cluster, server_selector = nil); end
  def has_writable_server?(cluster); end
  def replica_set?; end
  def servers(servers); end
  def sharded?; end
  def single?; end
  def summary; end
  def unknown?; end
  include Mongo::Cluster::Topology::NoReplicaSetOptions
end
class Mongo::Cluster::SocketReaper
  def execute; end
  def flush; end
  def initialize(cluster); end
end
class Mongo::Cluster::CursorReaper
  def execute; end
  def flush; end
  def initialize; end
  def kill_cursors; end
  def register_cursor(id); end
  def schedule_kill_cursor(id, op_spec, server); end
  def unregister_cursor(id); end
  include Mongo::Retryable
end
class Mongo::Cluster::PeriodicExecutor
  def do_work; end
  def execute; end
  def flush; end
  def initialize(executors = nil, options = nil); end
  def options; end
  def pre_stop; end
  def restart!; end
  def stop(final = nil); end
  include Mongo::BackgroundThread
end
class Mongo::Cluster::SdamFlow
  def add_servers_from_desc(updated_desc); end
  def awaited?; end
  def became_unknown?; end
  def check_if_has_primary; end
  def cluster; end
  def commit_changes; end
  def disconnect_servers; end
  def do_remove(address_str); end
  def initialize(cluster, previous_desc, updated_desc, awaited: nil); end
  def log_warn(*args, &block); end
  def original_desc; end
  def previous_desc; end
  def publish_description_change_event; end
  def publish_sdam_event(*args, &block); end
  def remove; end
  def remove_servers_not_in_desc(updated_desc); end
  def replica_set_name(*args, &block); end
  def seeds(*args, &block); end
  def server_description_changed; end
  def servers_list(*args, &block); end
  def stale_primary?; end
  def start_pool_if_data_bearing; end
  def topology; end
  def topology_effectively_changed?; end
  def update_rs_from_primary; end
  def update_rs_with_primary_from_member; end
  def update_rs_without_primary; end
  def update_server_descriptions; end
  def update_unknown_with_standalone; end
  def updated_desc; end
  extend Forwardable
end
class Mongo::Cursor
  def batch_size; end
  def cache_batch_resume_token; end
  def cache_resume_token(doc); end
  def client(*args, &block); end
  def close; end
  def closed?; end
  def cluster(*args, &block); end
  def collection(*args, &block); end
  def collection_name; end
  def database(*args, &block); end
  def each; end
  def end_session; end
  def exhausted?; end
  def get_more; end
  def get_more_operation; end
  def id; end
  def initialize(view, result, server, options = nil); end
  def inspect; end
  def kill_cursors_op_spec; end
  def kill_cursors_operation; end
  def limit; end
  def limited?; end
  def process(result); end
  def register; end
  def resume_token; end
  def self.finalize(cursor_id, cluster, op_spec, server, session); end
  def server; end
  def to_return; end
  def try_next; end
  def unregister; end
  def use_limit?; end
  def view; end
  extend Forwardable
  include Enumerable
  include Mongo::Retryable
end
module Mongo::Cursor::Builder
end
class Mongo::Cursor::Builder::OpGetMore
  def collection_name(*args, &block); end
  def cursor; end
  def database(*args, &block); end
  def initialize(cursor); end
  def specification; end
  def to_return(*args, &block); end
  extend Forwardable
end
class Mongo::Cursor::Builder::OpKillCursors
  def collection_name(*args, &block); end
  def cursor; end
  def database(*args, &block); end
  def initialize(cursor); end
  def self.get_cursors_list(spec); end
  def self.update_cursors(spec, ids); end
  def specification; end
  extend Forwardable
end
class Mongo::Cursor::Builder::GetMoreCommand
  def batch_size(*args, &block); end
  def collection_name(*args, &block); end
  def cursor; end
  def database(*args, &block); end
  def get_more_command; end
  def initialize(cursor, session = nil); end
  def specification; end
  def view(*args, &block); end
  extend Forwardable
end
class Mongo::Cursor::Builder::KillCursorsCommand
  def collection_name(*args, &block); end
  def cursor; end
  def database(*args, &block); end
  def initialize(cursor); end
  def kill_cursors_command; end
  def self.get_cursors_list(spec); end
  def self.update_cursors(spec, ids); end
  def specification; end
  extend Forwardable
end
class Mongo::CachingCursor < Mongo::Cursor
  def cached_docs; end
  def each; end
  def inspect; end
  def try_next; end
end
class Mongo::BulkWrite
  def base_spec(operation_id, session); end
  def client(*args, &block); end
  def cluster(*args, &block); end
  def collection; end
  def database(*args, &block); end
  def delete_many(documents, connection, operation_id, session, txn_num); end
  def delete_one(documents, connection, operation_id, session, txn_num); end
  def execute; end
  def execute_operation(name, values, connection, operation_id, result_combiner, session, txn_num = nil); end
  def initialize(collection, requests, options = nil); end
  def insert_one(documents, connection, operation_id, session, txn_num); end
  def next_primary(*args, &block); end
  def nro_write_with_retry(*args, &block); end
  def op_combiner; end
  def options; end
  def ordered?; end
  def replace_one(documents, connection, operation_id, session, txn_num); end
  def requests; end
  def single_statement?(operation); end
  def split_execute(name, values, connection, operation_id, result_combiner, session, txn_num); end
  def update_many(documents, connection, operation_id, session, txn_num); end
  def update_one(documents, connection, operation_id, session, txn_num); end
  def validate_array_filters!(connection); end
  def validate_collation!(connection); end
  def validate_hint!(connection); end
  def write_concern(session = nil); end
  def write_with_retry(*args, &block); end
  extend Forwardable
  include Mongo::Operation::ResponseHandling
end
class Mongo::BulkWrite::Result
  def deleted_count; end
  def initialize(results); end
  def inserted_count; end
  def inserted_ids; end
  def matched_count; end
  def modified_count; end
  def upserted_count; end
  def upserted_ids; end
  def validate!; end
end
module Mongo::BulkWrite::Transformable
  def transform(name, document); end
end
module Mongo::BulkWrite::Validatable
  def validate(name, document); end
  def validate_document(name, document); end
  def validate_operation(name); end
end
module Mongo::BulkWrite::Combineable
  def combine_requests(ops); end
  def has_array_filters?; end
  def has_collation?; end
  def has_hint?; end
  def initialize(requests); end
  def requests; end
end
class Mongo::BulkWrite::OrderedCombiner
  def add(operations, name, document); end
  def combine; end
  def next_group?(name, operations); end
  include Mongo::BulkWrite::Combineable
  include Mongo::BulkWrite::Transformable
  include Mongo::BulkWrite::Validatable
end
class Mongo::BulkWrite::UnorderedCombiner
  def add(operations, name, document); end
  def combine; end
  include Mongo::BulkWrite::Combineable
  include Mongo::BulkWrite::Transformable
  include Mongo::BulkWrite::Validatable
end
class Mongo::BulkWrite::ResultCombiner
  def combine!(result, count); end
  def combine_counts!(result); end
  def combine_errors!(result); end
  def combine_ids!(result); end
  def combine_write_concern_errors!(result); end
  def combine_write_errors!(result); end
  def count; end
  def initialize; end
  def result; end
  def results; end
end
class Mongo::Collection
  def ==(other); end
  def aggregate(pipeline, options = nil); end
  def bulk_write(requests, options = nil); end
  def capped?; end
  def client(*args, &block); end
  def cluster(*args, &block); end
  def count(filter = nil, options = nil); end
  def count_documents(filter = nil, options = nil); end
  def create(opts = nil); end
  def database; end
  def delete_many(filter = nil, options = nil); end
  def delete_one(filter = nil, options = nil); end
  def distinct(field_name, filter = nil, options = nil); end
  def drop(opts = nil); end
  def estimated_document_count(options = nil); end
  def find(filter = nil, options = nil); end
  def find_one_and_delete(filter, options = nil); end
  def find_one_and_replace(filter, replacement, options = nil); end
  def find_one_and_update(filter, update, options = nil); end
  def indexes(options = nil); end
  def initialize(database, name, options = nil); end
  def insert_many(documents, options = nil); end
  def insert_one(document, opts = nil); end
  def inspect; end
  def name; end
  def namespace; end
  def next_primary(*args, &block); end
  def options; end
  def parallel_scan(cursor_count, options = nil); end
  def read_concern; end
  def read_preference; end
  def replace_one(filter, replacement, options = nil); end
  def server_selector; end
  def system_collection?; end
  def update_many(filter, update, options = nil); end
  def update_one(filter, update, options = nil); end
  def watch(pipeline = nil, options = nil); end
  def with(new_options); end
  def write_concern; end
  def write_concern_with_session(session); end
  extend Forwardable
  include Mongo::Retryable
end
class Mongo::Collection::View
  def ==(other); end
  def apply_collation!(doc, server, opts = nil); end
  def client(*args, &block); end
  def cluster(*args, &block); end
  def collection; end
  def database(*args, &block); end
  def eql?(other); end
  def filter; end
  def hash; end
  def initialize(collection, filter = nil, options = nil); end
  def initialize_copy(other); end
  def inspect; end
  def new(options); end
  def next_primary(*args, &block); end
  def nro_write_with_retry(*args, &block); end
  def parse_parameters!(filter, options); end
  def read_with_retry(*args, &block); end
  def read_with_retry_cursor(*args, &block); end
  def selector; end
  def validate_collation!(server, coll); end
  def view; end
  def with_session(opts = nil, &block); end
  def write_concern; end
  def write_concern_with_session(*args, &block); end
  def write_with_retry(*args, &block); end
  extend Forwardable
  include Enumerable
  include Mongo::Collection::View::Explainable
  include Mongo::Collection::View::Immutable
  include Mongo::Collection::View::Iterable
  include Mongo::Collection::View::Readable
  include Mongo::Collection::View::Writable
end
module Mongo::Collection::View::Builder
end
class Mongo::Collection::View::Builder::Aggregation
  def aggregation_command; end
  def batch_size_doc; end
  def collection(*args, &block); end
  def cursor; end
  def database(*args, &block); end
  def initialize(pipeline, view, options); end
  def options; end
  def pipeline; end
  def read(*args, &block); end
  def specification; end
  def view; end
  def write?; end
  def write_concern(*args, &block); end
  extend Forwardable
end
class Mongo::Collection::View::Builder::MapReduce
  def collection(*args, &block); end
  def command_specification; end
  def database(*args, &block); end
  def filter(*args, &block); end
  def find_command; end
  def initialize(map, reduce, view, options); end
  def map; end
  def map_reduce_command; end
  def options; end
  def query_collection; end
  def query_database; end
  def query_specification; end
  def read(*args, &block); end
  def reduce; end
  def specification; end
  def view; end
  def view_options; end
  def write?(spec); end
  def write_concern(*args, &block); end
  extend Forwardable
end
class Mongo::Collection::View::Builder::OpQuery
  def cluster(*args, &block); end
  def collection(*args, &block); end
  def database(*args, &block); end
  def filter(*args, &block); end
  def initialize(view); end
  def modifiers; end
  def options(*args, &block); end
  def query_options; end
  def read(*args, &block); end
  def read_pref_formatted; end
  def requires_special_filter?; end
  def special_filter; end
  def specification; end
  extend Forwardable
end
class Mongo::Collection::View::Builder::FindCommand
  def collection(*args, &block); end
  def convert_flags(options); end
  def convert_limit_and_batch_size(command); end
  def database(*args, &block); end
  def explain_specification; end
  def filter(*args, &block); end
  def find_command; end
  def initialize(view, session); end
  def log_warn(*args); end
  def options(*args, &block); end
  def read(*args, &block); end
  def specification; end
  extend Forwardable
end
module Mongo::Collection::View::Builder::Flags
  def map_flags(options); end
  extend Mongo::Collection::View::Builder::Flags
end
module Mongo::Collection::View::Builder::Modifiers
  def self.map_driver_options(modifiers); end
  def self.map_server_modifiers(options); end
  extend Mongo::Collection::View::Builder::Modifiers
end
module Mongo::Collection::View::Immutable
  def configure(field, value); end
  def options; end
end
module Mongo::Collection::View::Iterable
  def cache_options; end
  def cached_cursor; end
  def close_query; end
  def each; end
  def initial_command_op(session); end
  def initial_query_op(server, session); end
  def kill_cursors; end
  def select_cursor(session); end
  def send_initial_query(server, session = nil); end
  def use_query_cache?; end
end
module Mongo::Collection::View::Explainable
  def explain(**opts); end
  def explain_options(**opts); end
  def explained?; end
end
class Mongo::Collection::View::Aggregation
  def aggregate_spec(session); end
  def allow_disk_use(value = nil); end
  def cache_options; end
  def client(*args, &block); end
  def cluster(*args, &block); end
  def collection(*args, &block); end
  def database(*args, &block); end
  def explain; end
  def initial_query_op(session); end
  def initialize(view, pipeline, options = nil); end
  def new(options); end
  def pipeline; end
  def read(*args, &block); end
  def secondary_ok?; end
  def send_initial_query(server, session); end
  def server_selector; end
  def valid_server?(server); end
  def validate_collation!(server); end
  def view; end
  def write?; end
  extend Forwardable
  include Enumerable
  include Mongo::Collection::View::Explainable
  include Mongo::Collection::View::Immutable
  include Mongo::Collection::View::Iterable
  include Mongo::Loggable
  include Mongo::Retryable
end
class Mongo::Collection::View::ChangeStream < Mongo::Collection::View::Aggregation
  def aggregate_spec(session); end
  def change_doc; end
  def close; end
  def closed?; end
  def create_cursor!; end
  def each; end
  def for_cluster?; end
  def for_collection?; end
  def for_database?; end
  def initialize(view, pipeline, changes_for, options = nil); end
  def inspect; end
  def options; end
  def pipeline; end
  def resume_token; end
  def resuming?; end
  def send_initial_query(server, session); end
  def time_to_bson_timestamp(time); end
  def to_enum; end
  def try_next; end
  include Mongo::Collection::View::ChangeStream::Retryable
end
module Mongo::Collection::View::ChangeStream::Retryable
  def read_with_one_retry; end
end
class Mongo::Collection::View::MapReduce
  def client(*args, &block); end
  def cluster(*args, &block); end
  def collection(*args, &block); end
  def database(*args, &block); end
  def each; end
  def execute; end
  def fetch_query_op(server, session); end
  def fetch_query_spec; end
  def finalize(function = nil); end
  def find_command_spec(session); end
  def initial_query_op(session); end
  def initialize(view, map, reduce, options = nil); end
  def inline?; end
  def js_mode(value = nil); end
  def map_function; end
  def map_reduce_spec(session = nil); end
  def new(options); end
  def out(location = nil); end
  def read(*args, &block); end
  def reduce_function; end
  def scope(object = nil); end
  def secondary_ok?; end
  def send_fetch_query(server, session); end
  def send_initial_query(server, session); end
  def server_selector; end
  def valid_server?(server); end
  def validate_collation!(server); end
  def verbose(value = nil); end
  def view; end
  extend Forwardable
  include Enumerable
  include Mongo::Collection::View::Immutable
  include Mongo::Loggable
  include Mongo::Retryable
end
module Mongo::Collection::View::Readable
  def aggregate(pipeline, options = nil); end
  def allow_disk_use; end
  def allow_partial_results; end
  def await_data; end
  def batch_size(batch_size = nil); end
  def collation(doc = nil); end
  def comment(comment = nil); end
  def count(opts = nil); end
  def count_documents(opts = nil); end
  def cursor_type(type = nil); end
  def distinct(field_name, opts = nil); end
  def estimated_document_count(opts = nil); end
  def hint(hint = nil); end
  def limit(limit = nil); end
  def map_reduce(map, reduce, options = nil); end
  def max_await_time_ms(max = nil); end
  def max_scan(value = nil); end
  def max_time_ms(max = nil); end
  def max_value(value = nil); end
  def min_value(value = nil); end
  def modifiers(doc = nil); end
  def no_cursor_timeout; end
  def parallel_scan(cursor_count, options = nil); end
  def projection(document = nil); end
  def read(value = nil); end
  def read_concern; end
  def read_preference; end
  def return_key(value = nil); end
  def server_selector; end
  def show_disk_loc(value = nil); end
  def show_record_id(value = nil); end
  def skip(number = nil); end
  def snapshot(value = nil); end
  def sort(spec = nil); end
  def validate_doc!(doc); end
end
module Mongo::Collection::View::Writable
  def applied_write_concern(session); end
  def apply_array_filters!(doc, server, opts = nil); end
  def apply_hint!(doc, server, opts); end
  def delete_many(opts = nil); end
  def delete_one(opts = nil); end
  def find_one_and_delete(opts = nil); end
  def find_one_and_replace(replacement, opts = nil); end
  def find_one_and_update(document, opts = nil); end
  def replace_one(replacement, opts = nil); end
  def update_many(spec, opts = nil); end
  def update_one(spec, opts = nil); end
  def validate_array_filters!(server, filters); end
end
class Mongo::Database
  def ==(other); end
  def [](collection_name, options = nil); end
  def aggregate(pipeline, options = nil); end
  def client; end
  def cluster(*args, &block); end
  def collection(collection_name, options = nil); end
  def collection_names(options = nil); end
  def collections(options = nil); end
  def command(operation, opts = nil); end
  def drop(options = nil); end
  def fs(options = nil); end
  def initialize(client, name, options = nil); end
  def inspect; end
  def list_collections(options = nil); end
  def name; end
  def next_primary(*args, &block); end
  def options; end
  def read_command(operation, opts = nil); end
  def read_concern(*args, &block); end
  def read_preference(*args, &block); end
  def self.create(client); end
  def server_selector(*args, &block); end
  def users; end
  def watch(pipeline = nil, options = nil); end
  def write_concern(*args, &block); end
  extend Forwardable
  include Mongo::Retryable
end
class Mongo::Database::View
  def aggregate(pipeline, options = nil); end
  def batch_size; end
  def client(*args, &block); end
  def cluster(*args, &block); end
  def collection; end
  def collection_names(options = nil); end
  def collections_info(session, server_selector, options = nil, &block); end
  def collections_info_spec(session, options = nil); end
  def database; end
  def initial_query_op(session, options = nil); end
  def initialize(database); end
  def limit; end
  def list_collections(options = nil); end
  def next_primary(*args, &block); end
  def read_concern(*args, &block); end
  def read_preference(*args, &block); end
  def send_initial_query(server, session, options = nil); end
  def server_selector(*args, &block); end
  extend Forwardable
  include Enumerable
  include Mongo::Retryable
end
module Mongo::Crypt
end
class Mongo::Client
  def ==(other); end
  def [](collection_name, options = nil); end
  def build_encrypter; end
  def close; end
  def close_encrypter; end
  def cluster; end
  def cluster_modifying?(new_options); end
  def cluster_options; end
  def collections(*args, &block); end
  def command(*args, &block); end
  def database; end
  def database_names(filter = nil, opts = nil); end
  def default_options(options); end
  def do_close; end
  def encrypter; end
  def eql?(other); end
  def get_session!(options = nil); end
  def get_session(options = nil); end
  def hash; end
  def initialize(addresses_or_uri, options = nil); end
  def initialize_copy(original); end
  def inspect; end
  def list_databases(filter = nil, name_only = nil, opts = nil); end
  def list_mongo_databases(filter = nil, opts = nil); end
  def max_read_retries; end
  def max_write_retries; end
  def monitoring; end
  def options; end
  def read_concern; end
  def read_preference; end
  def read_retry_interval; end
  def reconnect; end
  def self.canonicalize_ruby_options(options); end
  def server_selector; end
  def start_session(options = nil); end
  def subscribe(*args, &block); end
  def summary; end
  def unsubscribe(*args, &block); end
  def update_options(new_options); end
  def use(name); end
  def valid_compressors(compressors); end
  def validate_authentication_options!; end
  def validate_max_min_pool_size!(option, opts); end
  def validate_new_options!(opts = nil); end
  def validate_options!(addresses = nil); end
  def validate_read!(option, opts); end
  def watch(pipeline = nil, options = nil); end
  def with(new_options = nil); end
  def with_session(options = nil, &block); end
  def write_concern; end
  extend Forwardable
  include Mongo::Loggable
end
class Mongo::ClientEncryption
  def create_data_key(kms_provider, options = nil); end
  def decrypt(value); end
  def encrypt(value, options = nil); end
  def initialize(key_vault_client, options = nil); end
end
class Mongo::DBRef
  def as_json(*args); end
  def collection; end
  def database; end
  def id; end
  def initialize(collection, id, database = nil); end
  def to_bson(buffer = nil, validating_keys = nil); end
  include BSON::JSON
end
module Mongo::DBRef::ClassMethods
  def from_bson(buffer, **options); end
end
class Hash
  extend Mongo::DBRef::ClassMethods
end
module Mongo::Grid
end
class Mongo::Grid::File
  def ==(other); end
  def chunk_size(*args, &block); end
  def chunks; end
  def content_type(*args, &block); end
  def data; end
  def filename(*args, &block); end
  def id(*args, &block); end
  def info; end
  def initialize(data, options = nil); end
  def initialize_chunks!(value); end
  def inspect; end
  def md5(*args, &block); end
  def upload_date(*args, &block); end
  extend Forwardable
end
class Mongo::Grid::File::Chunk
  def ==(other); end
  def bson_type; end
  def data; end
  def document; end
  def files_id; end
  def id; end
  def initialize(document); end
  def n; end
  def self.assemble(chunks); end
  def self.split(io, file_info, offset = nil); end
  def to_bson(buffer = nil, validating_keys = nil); end
end
class Mongo::Grid::File::Info
  def ==(other); end
  def bson_type; end
  def chunk_size; end
  def content_type; end
  def default_document; end
  def document; end
  def filename; end
  def id; end
  def initialize(document); end
  def inspect; end
  def length; end
  def md5; end
  def metadata; end
  def size; end
  def to_bson(buffer = nil, validating_keys = nil); end
  def update_md5(bytes); end
  def upload_date; end
end
class Mongo::Grid::FSBucket
  def chunks_collection; end
  def chunks_name; end
  def client(*args, &block); end
  def database; end
  def delete(id); end
  def delete_one(file); end
  def download_to_stream(id, io); end
  def download_to_stream_by_name(filename, io, opts = nil); end
  def ensure_indexes!; end
  def files_collection; end
  def files_name; end
  def find(selector = nil, options = nil); end
  def find_one(selector = nil); end
  def initialize(database, options = nil); end
  def insert_one(file); end
  def open_download_stream(id, options = nil); end
  def open_download_stream_by_name(filename, opts = nil, &block); end
  def open_upload_stream(filename, opts = nil); end
  def options; end
  def prefix; end
  def read_preference; end
  def read_stream(id, **opts); end
  def upload_from_stream(filename, io, opts = nil); end
  def write_concern; end
  def write_stream(filename, **opts); end
  extend Forwardable
end
module Mongo::Grid::FSBucket::Stream
  def get(fs, mode, options = nil); end
  extend Mongo::Grid::FSBucket::Stream
end
class Mongo::Grid::FSBucket::Stream::Read
  def close; end
  def closed?; end
  def each; end
  def ensure_file_info!; end
  def ensure_open!; end
  def ensure_readable!; end
  def file_id; end
  def file_info; end
  def fs; end
  def initialize(fs, options); end
  def options; end
  def raise_unexpected_chunk_length!(chunk); end
  def read; end
  def read_preference; end
  def validate!(index, num_chunks, chunk, length_read); end
  def validate_length!(index, num_chunks, chunk, length_read); end
  def validate_n!(index, chunk); end
  def view; end
  include Enumerable
end
class Mongo::Grid::FSBucket::Stream::Write
  def abort; end
  def chunks_collection; end
  def close; end
  def closed?; end
  def ensure_indexes!; end
  def ensure_open!; end
  def file_id; end
  def file_info; end
  def filename; end
  def files_collection; end
  def fs; end
  def initialize(fs, options); end
  def options; end
  def update_length; end
  def with_write_concern(collection); end
  def write(io); end
  def write_concern; end
end
module Mongo::Index
end
class Mongo::Index::View
  def batch_size; end
  def client(*args, &block); end
  def cluster(*args, &block); end
  def collection; end
  def create_many(*models); end
  def create_one(keys, options = nil); end
  def database(*args, &block); end
  def drop_all; end
  def drop_by_name(name); end
  def drop_one(name); end
  def each(&block); end
  def get(keys_or_name); end
  def index_name(spec); end
  def indexes_spec(session); end
  def initial_query_op(session); end
  def initialize(collection, options = nil); end
  def limit; end
  def next_primary(*args, &block); end
  def normalize_keys(spec); end
  def normalize_models(models, server); end
  def read_preference(*args, &block); end
  def send_initial_query(server, session); end
  def validate_collation!(model, server); end
  def with_generated_names(models, server); end
  def write_concern(*args, &block); end
  extend Forwardable
  include Enumerable
  include Mongo::Retryable
end
module Mongo::Lint
  def assert_type(obj, cls); end
  def enabled?; end
  def self.assert_type(obj, cls); end
  def self.enabled?; end
  def self.validate_camel_case_read_preference(read_pref); end
  def self.validate_camel_case_read_preference_mode(mode); end
  def self.validate_read_concern_option(read_concern); end
  def self.validate_underscore_read_preference(read_pref); end
  def self.validate_underscore_read_preference_mode(mode); end
  def validate_camel_case_read_preference(read_pref); end
  def validate_camel_case_read_preference_mode(mode); end
  def validate_read_concern_option(read_concern); end
  def validate_underscore_read_preference(read_pref); end
  def validate_underscore_read_preference_mode(mode); end
end
module Mongo::QueryCache
  def self.cache; end
  def self.cache_key(**opts); end
  def self.cache_table; end
  def self.clear; end
  def self.clear_namespace(namespace); end
  def self.enabled=(value); end
  def self.enabled?; end
  def self.get(**opts); end
  def self.namespace_key(**opts); end
  def self.set(cursor, **opts); end
  def self.uncached; end
end
class Mongo::Server
  def ==(other); end
  def address; end
  def app_metadata(*args, &block); end
  def arbiter?(*args, &block); end
  def average_round_trip_time(*args, &block); end
  def check_driver_support!(*args, &block); end
  def clear_connection_pool; end
  def cluster; end
  def cluster_time(*args, &block); end
  def compressor; end
  def connectable?; end
  def connected?; end
  def context; end
  def description; end
  def disconnect!; end
  def features(*args, &block); end
  def ghost?(*args, &block); end
  def handle_auth_failure!; end
  def handle_handshake_failure!; end
  def heartbeat_frequency; end
  def heartbeat_frequency_seconds; end
  def initialize(address, cluster, monitoring, event_listeners, options = nil); end
  def inspect; end
  def last_scan; end
  def last_write_date(*args, &block); end
  def logical_session_timeout(*args, &block); end
  def matches_tag_set?(tag_set); end
  def max_bson_object_size(*args, &block); end
  def max_message_size(*args, &block); end
  def max_wire_version(*args, &block); end
  def max_write_batch_size(*args, &block); end
  def mongos?(*args, &block); end
  def monitor; end
  def monitoring; end
  def next_connection_id; end
  def options; end
  def other?(*args, &block); end
  def pool; end
  def primary?(*args, &block); end
  def reconnect!; end
  def replica_set_name(*args, &block); end
  def retry_reads?; end
  def retry_writes?; end
  def round_trip_time_averager; end
  def scan!(*args, &block); end
  def scan_semaphore; end
  def secondary?(*args, &block); end
  def self.finalize(monitor); end
  def standalone?(*args, &block); end
  def start_monitoring; end
  def status; end
  def summary; end
  def tags(*args, &block); end
  def unknown!(options = nil); end
  def unknown?(*args, &block); end
  def update_cluster_time(*args, &block); end
  def update_description(description); end
  def update_last_scan; end
  def with_connection(&block); end
  extend Forwardable
  include Mongo::Event::Publisher
  include Mongo::Monitoring::Publishable
end
class Mongo::Server::AppMetadata
  def architecture; end
  def document; end
  def driver_doc; end
  def full_client_document; end
  def initialize(options); end
  def ismaster_bytes; end
  def name; end
  def os_doc; end
  def platform; end
  def serialize; end
  def type; end
  def validate!; end
  def validated_document; end
  def wrapping_libraries; end
  extend Forwardable
end
class Mongo::Server::ConnectionCommon
  def add_server_diagnostics; end
  def compressor; end
  def connected?; end
  def ensure_connected; end
  def pid; end
  def set_compressor!(reply); end
  def socket; end
  def ssl_options; end
end
class Mongo::Server::ConnectionBase < Mongo::Server::ConnectionCommon
  def address(*args, &block); end
  def app_metadata; end
  def cluster_time(*args, &block); end
  def deliver(message, client, options = nil); end
  def description; end
  def dispatch(messages, operation_id = nil, client = nil, options = nil); end
  def features(*args, &block); end
  def generation; end
  def max_bson_object_size(*args, &block); end
  def max_message_size(*args, &block); end
  def mongos?(*args, &block); end
  def options; end
  def serialize(message, client, buffer = nil); end
  def server; end
  def update_cluster_time(*args, &block); end
  extend Forwardable
  include Mongo::Monitoring::Publishable
end
class Mongo::Server::PendingConnection < Mongo::Server::ConnectionBase
  def authenticate!(speculative_auth_client_nonce: nil, speculative_auth_mech: nil, speculative_auth_result: nil); end
  def default_mechanism; end
  def ensure_connected; end
  def handshake!(speculative_auth_doc: nil); end
  def handshake_and_authenticate!; end
  def id; end
  def initialize(socket, server, monitoring, options = nil); end
  def post_handshake(response, average_rtt); end
  def resolved_user(speculative_auth_mech: nil); end
  extend Forwardable
end
class Mongo::Server::Connection < Mongo::Server::ConnectionBase
  def closed?; end
  def connect!; end
  def connection_pool; end
  def deliver(message, client, options = nil); end
  def disconnect!(options = nil); end
  def do_connect; end
  def error?; end
  def handle_errors; end
  def id; end
  def initialize(server, options = nil); end
  def last_checkin; end
  def ping; end
  def record_checkin!; end
  def socket_timeout; end
  def timeout; end
  extend Forwardable
  include Mongo::Monitoring::Publishable
  include Mongo::Retryable
end
class Mongo::Server::Populator
  def do_work; end
  def initialize(pool, options = nil); end
  def options; end
  def pre_stop; end
  include Mongo::BackgroundThread
end
class Mongo::Server::ConnectionPool
  def address(*args, &block); end
  def available_count; end
  def check_in(connection); end
  def check_invariants; end
  def check_out; end
  def clear(options = nil); end
  def close(options = nil); end
  def close_idle_sockets; end
  def closed?; end
  def connect_connection(connection); end
  def create_and_add_connection; end
  def create_connection; end
  def disconnect!(options = nil); end
  def generation; end
  def initialize(server, options = nil); end
  def inspect; end
  def max_idle_time; end
  def max_size; end
  def min_size; end
  def monitoring(*args, &block); end
  def options; end
  def populate; end
  def populate_semaphore; end
  def populator; end
  def raise_if_closed!; end
  def self.finalize(available_connections, pending_connections, populator); end
  def size; end
  def stop_populator; end
  def summary; end
  def unsynchronized_size; end
  def wait_timeout; end
  def with_connection; end
  extend Forwardable
  include Mongo::Loggable
  include Mongo::Monitoring::Publishable
end
class Mongo::Server::Context
  def cluster(*args, &block); end
  def features(*args, &block); end
  def initialize(server); end
  def max_wire_version(*args, &block); end
  def max_write_batch_size(*args, &block); end
  def mongos?(*args, &block); end
  def primary?(*args, &block); end
  def secondary?(*args, &block); end
  def server; end
  def standalone?(*args, &block); end
  def with_connection(&block); end
  extend Forwardable
end
class Mongo::Server::Description
  def ==(other); end
  def address; end
  def arbiter?; end
  def arbiters; end
  def average_round_trip_time; end
  def config; end
  def data_bearing?; end
  def election_id; end
  def eql?(other); end
  def features; end
  def ghost?; end
  def hidden?; end
  def hosts; end
  def initialize(address, config = nil, average_round_trip_time = nil); end
  def inspect; end
  def is_server?(server); end
  def last_update_time; end
  def last_write_date; end
  def lists_server?(server); end
  def logical_session_timeout; end
  def max_bson_object_size; end
  def max_message_size; end
  def max_wire_version; end
  def max_write_batch_size; end
  def me; end
  def me_mismatch?; end
  def min_wire_version; end
  def mongos?; end
  def ok?; end
  def op_time; end
  def other?; end
  def passive?; end
  def passives; end
  def primary?; end
  def primary_host; end
  def replica_set_member?; end
  def replica_set_name; end
  def secondary?; end
  def server_connection_id; end
  def server_type; end
  def server_version_gte?(version); end
  def servers; end
  def set_version; end
  def standalone?; end
  def tags; end
  def topology_version; end
  def topology_version_gt?(other_desc); end
  def topology_version_gte?(other_desc); end
  def unknown?; end
  def wire_versions; end
end
class Mongo::Server::Description::Features
  def array_filters_enabled?; end
  def check_driver_support!; end
  def collation_enabled?; end
  def find_and_modify_option_validation_enabled?; end
  def find_command_enabled?; end
  def initialize(server_wire_versions, address = nil); end
  def list_collections_enabled?; end
  def list_indexes_enabled?; end
  def max_staleness_enabled?; end
  def op_msg_enabled?; end
  def retryable_write_error_label_enabled?; end
  def scram_sha_1_enabled?; end
  def scram_sha_256_enabled?; end
  def server_wire_versions; end
  def sessions_enabled?; end
  def transactions_enabled?; end
  def update_delete_option_validation_enabled?; end
  def users_info_enabled?; end
  def write_command_enabled?; end
end
class Mongo::Server::Monitor
  def compressor(*args, &block); end
  def connection; end
  def do_scan; end
  def do_work; end
  def heartbeat_interval; end
  def initialize(server, event_listeners, monitoring, options = nil); end
  def ismaster; end
  def last_scan(*args, &block); end
  def monitoring; end
  def options; end
  def pre_stop; end
  def push_monitor; end
  def restart!; end
  def run_sdam_flow(result, awaited: nil); end
  def scan!; end
  def server; end
  def stop!; end
  def stop_push_monitor!; end
  def throttle_scan_frequency!; end
  extend Forwardable
  include Mongo::BackgroundThread
  include Mongo::Event::Publisher
  include Mongo::Loggable
end
class Mongo::Server::Monitor::Connection < Mongo::Server::ConnectionCommon
  def add_server_connection_id; end
  def address; end
  def connect!; end
  def disconnect!(options = nil); end
  def dispatch(message); end
  def dispatch_bytes(bytes, **opts); end
  def handshake!; end
  def initialize(address, options = nil); end
  def options; end
  def read_response(**opts); end
  def server_connection_id; end
  def socket_timeout; end
  def write_bytes(bytes); end
  include Mongo::Loggable
end
class Mongo::Server::Monitor::AppMetadata < Mongo::Server::AppMetadata
  def initialize(options); end
end
class Mongo::Server::RoundTripTimeAverager
  def average_round_trip_time; end
  def initialize; end
  def last_round_trip_time; end
  def measure; end
  def update_average_round_trip_time; end
end
class Mongo::Server::PushMonitor
  def do_work; end
  def initialize(monitor, topology_version, monitoring, **options); end
  def ismaster; end
  def monitor; end
  def monitoring; end
  def options; end
  def read_response; end
  def server(*args, &block); end
  def start!; end
  def stop!; end
  def topology_version; end
  def write_ismaster; end
  extend Forwardable
  include Mongo::BackgroundThread
end
class Mongo::Server::PushMonitor::Connection < Mongo::Server::Monitor::Connection
  def socket_timeout; end
end
module Mongo::ServerSelector
  def get(preference = nil); end
  def primary; end
  extend Mongo::ServerSelector
end
class Mongo::ServerSelector::Base
  def ==(other); end
  def candidates(cluster); end
  def filter_stale_servers(candidates, primary = nil); end
  def full_doc; end
  def hedge; end
  def initialize(options = nil); end
  def inspect; end
  def local_threshold; end
  def local_threshold_with_cluster(cluster); end
  def match_tag_sets(candidates); end
  def max_staleness; end
  def near_servers(candidates = nil, local_threshold = nil); end
  def options; end
  def primary(candidates); end
  def secondaries(candidates); end
  def select_server(cluster, ping = nil, session = nil); end
  def server_selection_diagnostic_message(cluster); end
  def server_selection_timeout; end
  def suitable_servers(cluster); end
  def tag_sets; end
  def try_select_server(cluster); end
  def validate!; end
  def validate_max_staleness_support!(server); end
  def validate_max_staleness_value!(cluster); end
  def validate_max_staleness_value_early!; end
  def wait_for_server_selection(cluster, time_remaining); end
end
class Mongo::ServerSelector::Nearest < Mongo::ServerSelector::Base
  def hedge_allowed?; end
  def max_staleness_allowed?; end
  def name; end
  def select_in_replica_set(candidates); end
  def slave_ok?; end
  def tags_allowed?; end
  def to_doc; end
  def to_mongos; end
end
class Mongo::ServerSelector::Primary < Mongo::ServerSelector::Base
  def hedge_allowed?; end
  def max_staleness_allowed?; end
  def name; end
  def select_in_replica_set(candidates); end
  def slave_ok?; end
  def tags_allowed?; end
  def to_doc; end
  def to_mongos; end
end
class Mongo::ServerSelector::PrimaryPreferred < Mongo::ServerSelector::Base
  def hedge_allowed?; end
  def max_staleness_allowed?; end
  def name; end
  def select_in_replica_set(candidates); end
  def slave_ok?; end
  def tags_allowed?; end
  def to_doc; end
  def to_mongos; end
end
class Mongo::ServerSelector::Secondary < Mongo::ServerSelector::Base
  def hedge_allowed?; end
  def max_staleness_allowed?; end
  def name; end
  def select_in_replica_set(candidates); end
  def slave_ok?; end
  def tags_allowed?; end
  def to_doc; end
  def to_mongos; end
end
class Mongo::ServerSelector::SecondaryPreferred < Mongo::ServerSelector::Base
  def hedge_allowed?; end
  def max_staleness_allowed?; end
  def name; end
  def select_in_replica_set(candidates); end
  def slave_ok?; end
  def tags_allowed?; end
  def to_doc; end
  def to_mongos; end
end
class Mongo::Session
  def abort_transaction; end
  def aborting_transaction?; end
  def add_autocommit!(command); end
  def add_start_transaction!(command); end
  def add_txn_num!(command); end
  def add_txn_opts!(command, read); end
  def advance_operation_time(new_operation_time); end
  def causal_consistency?; end
  def causal_consistency_doc; end
  def check_if_ended!; end
  def check_if_no_transaction!; end
  def check_matching_cluster!(client); end
  def client; end
  def cluster; end
  def commit_transaction(options = nil); end
  def committing_transaction?; end
  def end_session; end
  def ended?; end
  def explicit?; end
  def implicit?; end
  def in_transaction?; end
  def initialize(server_session, client, options = nil); end
  def inspect; end
  def next_txn_num; end
  def operation_time; end
  def options; end
  def pin(server); end
  def pinned_server; end
  def process(result); end
  def recovery_token; end
  def recovery_token=(arg0); end
  def retry_reads?; end
  def retry_writes?; end
  def session_id; end
  def set_operation_time(result); end
  def start_transaction(options = nil); end
  def starting_transaction?; end
  def suppress_read_write_concern!(command); end
  def txn_num; end
  def txn_options; end
  def txn_read_concern; end
  def txn_read_preference; end
  def txn_write_concern; end
  def unpin; end
  def unpin_maybe(error); end
  def update_state!; end
  def validate!(client); end
  def validate_read_preference!(command); end
  def with_transaction(options = nil); end
  def within_states?(*states); end
  extend Forwardable
  include Mongo::ClusterTime::Consumer
  include Mongo::Loggable
  include Mongo::Retryable
end
class Mongo::Session::SessionPool
  def about_to_expire?(session); end
  def checkin(session); end
  def checkout; end
  def end_sessions; end
  def initialize(cluster); end
  def inspect; end
  def prune!; end
  def self.create(cluster); end
end
class Mongo::Session::ServerSession
  def initialize; end
  def inspect; end
  def last_use; end
  def next_txn_num; end
  def session_id; end
  def set_last_use!; end
  def txn_num; end
end
class Mongo::Socket
  def alive?; end
  def allocate_string(capacity); end
  def close; end
  def connectable?; end
  def connection_address; end
  def connection_generation; end
  def do_write(*args); end
  def eof?; end
  def family; end
  def gets(*args); end
  def human_address; end
  def initialize(timeout, options); end
  def map_exceptions; end
  def monitor?; end
  def options; end
  def read(length, timeout: nil); end
  def read_buffer_size; end
  def read_from_socket(length, timeout: nil); end
  def readbyte; end
  def set_keepalive_opts(sock); end
  def set_option(sock, option, default); end
  def set_socket_options(sock); end
  def socket; end
  def summary; end
  def timeout; end
  def unix_socket?(sock); end
  def write(*args); end
  include Socket::Constants
end
class Mongo::Socket::SSL < Mongo::Socket
  def connect!; end
  def context; end
  def create_context(options); end
  def host; end
  def host_name; end
  def human_address; end
  def initialize(host, port, host_name, timeout, family, options = nil); end
  def load_private_key(text, passphrase); end
  def port; end
  def read_buffer_size; end
  def readbyte; end
  def set_cert(context, options); end
  def set_cert_verification(context, options); end
  def set_key(context, options); end
  def verify_certificate!(socket); end
  def verify_certificate?; end
  def verify_hostname?; end
  def verify_ocsp_endpoint!(socket); end
  def verify_ocsp_endpoint?; end
  include OpenSSL
end
class Mongo::Socket::TCP < Mongo::Socket
  def connect!; end
  def host; end
  def human_address; end
  def initialize(host, port, timeout, family, options = nil); end
  def port; end
end
class Mongo::Socket::Unix < Mongo::Socket
  def human_address; end
  def initialize(path, timeout, options = nil); end
  def path; end
end
class Mongo::Socket::OcspVerifier
  def ca_cert; end
  def cert; end
  def cert_id; end
  def cert_store; end
  def do_verify; end
  def handle_exceptions; end
  def host_name; end
  def initialize(host_name, cert, ca_cert, cert_store, **opts); end
  def ocsp_uris; end
  def options; end
  def raise_revoked_error(resp); end
  def report_response_body(body); end
  def report_uri(original_uri, uri); end
  def return_ocsp_response(resp, errors = nil); end
  def timeout; end
  def verify; end
  def verify_one_responder(uri); end
  def verify_with_cache; end
  include Mongo::Loggable
end
module Mongo::Socket::OcspCache
  def clear; end
  def delete(cert_id); end
  def get(cert_id); end
  def responses; end
  def self.clear; end
  def self.delete(cert_id); end
  def self.get(cert_id); end
  def self.responses; end
  def self.set(cert_id, response); end
  def set(cert_id, response); end
end
module Mongo::Srv
end
class Mongo::Srv::Result
  def add_record(record); end
  def address_strs; end
  def empty?; end
  def initialize(hostname); end
  def min_ttl; end
  def min_ttl=(arg0); end
  def normalize_hostname(host); end
  def query_hostname; end
  def validate_same_origin!(record_host); end
  include Mongo::Address::Validator
end
class Mongo::Srv::Resolver
  def get_records(hostname); end
  def get_txt_options_string(hostname); end
  def initialize(**opts); end
  def options; end
  def raise_on_invalid?; end
  def timeout; end
  include Mongo::Loggable
end
class Mongo::Srv::Monitor
  def cluster; end
  def do_work; end
  def initialize(cluster, **opts); end
  def last_result; end
  def options; end
  def scan!; end
  def scan_interval; end
  def self.finalize(thread); end
  def start!; end
  def timeout; end
  include Mongo::BackgroundThread
  include Mongo::Loggable
end
module Mongo::Timeout
  def self.timeout(sec, klass = nil, message = nil); end
  def timeout(sec, klass = nil, message = nil); end
end
class Mongo::URI
  def client_options; end
  def credentials; end
  def database; end
  def decode(value); end
  def encode(value); end
  def extract_db_opts!(string); end
  def initialize(string, options = nil); end
  def options; end
  def options_mapper; end
  def parse!(remaining); end
  def parse_database!(string); end
  def parse_password!(string); end
  def parse_uri_options!(string); end
  def parse_user!(string); end
  def raise_invalid_error!(details); end
  def raise_invalid_error_no_fmt!(details); end
  def scheme; end
  def self.get(string, opts = nil); end
  def servers; end
  def srv_records; end
  def uri_options; end
  def validate_uri_options!; end
  include Mongo::Address::Validator
  include Mongo::Loggable
end
class Mongo::URI::OptionsMapper
  def add_uri_option(key, value, uri_options); end
  def apply_transform(key, value, type); end
  def convert_array(name, value); end
  def convert_auth_mech(name, value); end
  def convert_auth_mech_props(name, value); end
  def convert_bool(name, value); end
  def convert_integer(name, value); end
  def convert_inverse_bool(name, value); end
  def convert_max_staleness(name, value); end
  def convert_ms(name, value); end
  def convert_read_mode(name, value); end
  def convert_read_set(name, value); end
  def convert_read_tags(name, value); end
  def convert_repeated_bool(name, value); end
  def convert_symbol(name, value); end
  def convert_w(name, value); end
  def convert_zlib_compression_level(name, value); end
  def hash_extractor(name, value); end
  def initialize(**opts); end
  def merge_uri_option(target, value, name); end
  def options; end
  def revert_array(value); end
  def revert_auth_mech(value); end
  def revert_auth_mech_props(value); end
  def revert_bool(value); end
  def revert_integer(value); end
  def revert_inverse_bool(value); end
  def revert_max_staleness(value); end
  def revert_ms(value); end
  def revert_read_mode(value); end
  def revert_read_tags(value); end
  def revert_repeated_bool(value); end
  def revert_symbol(value); end
  def revert_w(value); end
  def revert_zlib_compression_level(value); end
  def ruby_to_smc(opts); end
  def self.uri_option(uri_key, name, **extra); end
  include Mongo::Loggable
end
class Mongo::URI::SRVProtocol < Mongo::URI
  def client_options; end
  def get_txt_options(hostname); end
  def parse!(remaining); end
  def parse_txt_options!(string); end
  def query_hostname; end
  def raise_invalid_error!(details); end
  def resolver; end
  def scheme; end
  def srv_records; end
  def srv_result; end
  def validate_srv_hostname(hostname); end
  def validate_uri_options!; end
end
module Mongo::WriteConcern
  def get(options); end
  extend Mongo::WriteConcern
end
class Mongo::WriteConcern::Base
  def initialize(options); end
  def options; end
end
class Mongo::WriteConcern::Acknowledged < Mongo::WriteConcern::Base
  def acknowledged?; end
  def get_last_error; end
  def inspect; end
end
class Mongo::WriteConcern::Unacknowledged < Mongo::WriteConcern::Base
  def acknowledged?; end
  def get_last_error; end
  def inspect; end
end
module Mongo::Utils
  def camelize(sym); end
  def excerpt_backtrace(exc, **opts); end
  def self.camelize(sym); end
  def self.excerpt_backtrace(exc, **opts); end
  def self.shallow_camelize_keys(hash); end
  def self.shallow_symbolize_keys(hash); end
  def self.warn_bg_exception(msg, exc, **opts); end
  def shallow_camelize_keys(hash); end
  def shallow_symbolize_keys(hash); end
  def warn_bg_exception(msg, exc, **opts); end
end
class Mongo::Utils::LocalLogger
  def initialize(**opts); end
  def options; end
  include Mongo::Loggable
end
