# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/mongoid/all/mongoid.rbi
#
# mongoid-7.2.0

class Object < BasicObject
  def invalid_version?; end
  def raise_version_error(message); end
  extend Mongoid::Criteria::Queryable::Extensions::Object::ClassMethods
  extend Mongoid::Extensions::Object::ClassMethods
  include Mongoid::Criteria::Queryable::Extensions::Object
  include Mongoid::Extensions::Object
end
module Mongoid
  def app_name(*args, &block); end
  def app_name=(*args, &block); end
  def app_name?(*args, &block); end
  def background_indexing(*args, &block); end
  def background_indexing=(*args, &block); end
  def background_indexing?(*args, &block); end
  def belongs_to_required_by_default(*args, &block); end
  def belongs_to_required_by_default=(*args, &block); end
  def belongs_to_required_by_default?(*args, &block); end
  def client(name); end
  def clients(*args, &block); end
  def configure; end
  def configured?(*args, &block); end
  def connect_to(*args, &block); end
  def default_client; end
  def destructive_fields(*args, &block); end
  def disconnect_clients; end
  def discriminator_key(*args, &block); end
  def discriminator_key=(*args, &block); end
  def discriminator_key?(*args, &block); end
  def duplicate_fields_exception(*args, &block); end
  def duplicate_fields_exception=(*args, &block); end
  def duplicate_fields_exception?(*args, &block); end
  def include_root_in_json(*args, &block); end
  def include_root_in_json=(*args, &block); end
  def include_root_in_json?(*args, &block); end
  def include_type_for_serialization(*args, &block); end
  def include_type_for_serialization=(*args, &block); end
  def include_type_for_serialization?(*args, &block); end
  def join_contexts(*args, &block); end
  def join_contexts=(*args, &block); end
  def join_contexts?(*args, &block); end
  def load!(*args, &block); end
  def load_configuration(*args, &block); end
  def log_level=(*args, &block); end
  def log_level?(*args, &block); end
  def models(*args, &block); end
  def options=(*args, &block); end
  def override_client(*args, &block); end
  def override_database(*args, &block); end
  def preload_models(*args, &block); end
  def preload_models=(*args, &block); end
  def preload_models?(*args, &block); end
  def purge!(*args, &block); end
  def raise_not_found_error(*args, &block); end
  def raise_not_found_error=(*args, &block); end
  def raise_not_found_error?(*args, &block); end
  def register_model(*args, &block); end
  def running_with_passenger?(*args, &block); end
  def scope_overwrite_exception(*args, &block); end
  def scope_overwrite_exception=(*args, &block); end
  def scope_overwrite_exception?(*args, &block); end
  def time_zone(*args, &block); end
  def truncate!(*args, &block); end
  def use_activesupport_time_zone(*args, &block); end
  def use_activesupport_time_zone=(*args, &block); end
  def use_activesupport_time_zone?(*args, &block); end
  def use_utc(*args, &block); end
  def use_utc=(*args, &block); end
  def use_utc?(*args, &block); end
  extend Forwardable
  extend Mongoid
  extend Mongoid::Loggable
end
module Mongoid::Config
  def app_name; end
  def app_name=(value); end
  def app_name?; end
  def background_indexing; end
  def background_indexing=(value); end
  def background_indexing?; end
  def belongs_to_required_by_default; end
  def belongs_to_required_by_default=(value); end
  def belongs_to_required_by_default?; end
  def clients; end
  def clients=(clients); end
  def configured?; end
  def connect_to(name, options = nil); end
  def destructive_fields; end
  def discriminator_key; end
  def discriminator_key=(value); end
  def discriminator_key?; end
  def duplicate_fields_exception; end
  def duplicate_fields_exception=(value); end
  def duplicate_fields_exception?; end
  def include_root_in_json; end
  def include_root_in_json=(value); end
  def include_root_in_json?; end
  def include_type_for_serialization; end
  def include_type_for_serialization=(value); end
  def include_type_for_serialization?; end
  def join_contexts; end
  def join_contexts=(value); end
  def join_contexts?; end
  def load!(path, environment = nil); end
  def load_configuration(settings); end
  def log_level=(value); end
  def log_level?; end
  def logger(*args, &block); end
  def logger=(*args, &block); end
  def models; end
  def options=(options); end
  def override_client(name); end
  def override_database(name); end
  def preload_models; end
  def preload_models=(value); end
  def preload_models?; end
  def purge!; end
  def raise_not_found_error; end
  def raise_not_found_error=(value); end
  def raise_not_found_error?; end
  def register_model(klass); end
  def running_with_passenger?; end
  def scope_overwrite_exception; end
  def scope_overwrite_exception=(value); end
  def scope_overwrite_exception?; end
  def set_log_levels; end
  def time_zone; end
  def truncate!; end
  def use_activesupport_time_zone; end
  def use_activesupport_time_zone=(value); end
  def use_activesupport_time_zone?; end
  def use_utc; end
  def use_utc=(value); end
  def use_utc?; end
  extend Forwardable
  extend Mongoid::Config
  extend Mongoid::Config::Options
end
module Mongoid::Config::Environment
  def env_name; end
  def load_yaml(path, environment = nil); end
  extend Mongoid::Config::Environment
end
module Mongoid::Config::Options
  def defaults; end
  def log_level; end
  def option(name, options = nil); end
  def reset; end
  def settings; end
end
module Mongoid::Config::Validators
end
module Mongoid::Config::Validators::Option
  def validate(option); end
  extend Mongoid::Config::Validators::Option
end
module Mongoid::Config::Validators::Client
  def both_uri_and_standard?(config); end
  def no_database_or_uri?(config); end
  def no_hosts_or_uri?(config); end
  def validate(clients); end
  def validate_client_database(name, config); end
  def validate_client_hosts(name, config); end
  def validate_client_uri(name, config); end
  extend Mongoid::Config::Validators::Client
end
class Mongoid::PersistenceContext
  def ==(other); end
  def __evaluate__(name); end
  def client; end
  def client_name; end
  def client_options; end
  def cluster(*args, &block); end
  def collection(parent = nil); end
  def collection_name; end
  def database_name; end
  def database_name_option; end
  def initialize(object, opts = nil); end
  def options; end
  def self.clear(object, cluster = nil, original_context = nil); end
  def self.get(object); end
  def self.set(object, options_or_context); end
  def set_options!(opts); end
  def storage_options(*args, &block); end
  extend Forwardable
end
module Mongoid::Loggable
  def default_logger; end
  def logger; end
  def logger=(logger); end
  def rails_logger; end
end
module Mongoid::Clients
  def self.clear; end
  def self.clients; end
  def self.default; end
  def self.disconnect; end
  def self.set(name, client); end
  def self.with_name(name); end
  extend ActiveSupport::Concern
  include Mongoid::Clients::Options
  include Mongoid::Clients::Sessions
  include Mongoid::Clients::StorageOptions
end
module Mongoid::Clients::Factory
  def create(name = nil); end
  def create_client(configuration); end
  def default; end
  def driver_version; end
  def options(configuration); end
  extend Mongoid::Clients::Factory
end
module Mongoid::Clients::Validators
end
module Mongoid::Clients::Validators::Storage
  def valid_keys?(options); end
  def valid_parent?(klass); end
  def validate(klass, options); end
  extend Mongoid::Clients::Validators::Storage
end
module Mongoid::Clients::StorageOptions
  extend ActiveSupport::Concern
end
module Mongoid::Clients::StorageOptions::ClassMethods
  def reset_storage_options!; end
  def storage_options_defaults; end
  def store_in(options); end
end
module Mongoid::Clients::Options
  def clear_persistence_context(original_cluster = nil, context = nil); end
  def collection(parent = nil); end
  def collection_name; end
  def mongo_client; end
  def persistence_context; end
  def set_persistence_context(options_or_context); end
  def with(options_or_context, &block); end
  extend ActiveSupport::Concern
end
module Mongoid::Clients::Options::ClassMethods
  def client_name; end
  def collection; end
  def collection_name; end
  def database_name; end
  def mongo_client; end
  def persistence_context; end
  def with(options, &block); end
end
module Mongoid::Clients::Sessions
  def _session; end
  def with_session(options = nil); end
end
module Mongoid::Clients::Sessions::ClassMethods
  def _session; end
  def with_session(options = nil); end
end
module Mongoid::Positional
  def positionally(selector, operations, processed = nil); end
  def process_operations(keys, operations, processed); end
  def process_updates(keys, update, updates = nil); end
  def replace_index(keys, position); end
end
module Mongoid::Evolvable
  def __evolve_object_id__; end
end
module Mongoid::Extensions
end
module Mongoid::Extensions::Array
  def __evolve_object_id__; end
  def __find_args__; end
  def __mongoize_object_id__; end
  def __mongoize_time__; end
  def blank_criteria?; end
  def delete_one(object); end
  def mongoize; end
  def multi_arged?; end
  def resizable?; end
end
module Mongoid::Extensions::Array::ClassMethods
  def __mongoize_fk__(association, object); end
  def mongoize(object); end
  def resizable?; end
end
class Array
  extend Mongoid::Criteria::Queryable::Extensions::Array::ClassMethods
  extend Mongoid::Extensions::Array::ClassMethods
  include Mongoid::Criteria::Queryable::Extensions::Array
  include Mongoid::Extensions::Array
end
module Mongoid::Extensions::BigDecimal
  def __to_inc__; end
  def mongoize; end
  def numeric?; end
end
module Mongoid::Extensions::BigDecimal::ClassMethods
  def demongoize(object); end
  def mongoize(object); end
end
class BigDecimal < Numeric
  extend Mongoid::Criteria::Queryable::Extensions::BigDecimal::ClassMethods
  extend Mongoid::Extensions::BigDecimal::ClassMethods
  include Mongoid::Extensions::BigDecimal
end
class Mongoid::Boolean
  def self.evolve(object); end
  def self.mongoize(object); end
end
module Mongoid::Extensions::Date
  def __mongoize_time__; end
  def mongoize; end
end
module Mongoid::Extensions::Date::ClassMethods
  def demongoize(object); end
  def mongoize(object); end
end
class Date
  extend Mongoid::Criteria::Queryable::Extensions::Date::ClassMethods
  extend Mongoid::Extensions::Date::ClassMethods
  include Mongoid::Criteria::Queryable::Extensions::Date
  include Mongoid::Extensions::Date
end
module Mongoid::Extensions::DateTime
  def __mongoize_time__; end
  def mongoize; end
end
module Mongoid::Extensions::DateTime::ClassMethods
  def demongoize(object); end
  def mongoize(object); end
end
class DateTime < Date
  extend Mongoid::Criteria::Queryable::Extensions::DateTime::ClassMethods
  extend Mongoid::Extensions::DateTime::ClassMethods
  include Mongoid::Criteria::Queryable::Extensions::DateTime
  include Mongoid::Extensions::DateTime
end
module Mongoid::Extensions::Decimal128
  def __evolve_decimal128__; end
end
module Mongoid::Extensions::Decimal128::ClassMethods
  def evolve(object); end
end
class BSON::Decimal128
  extend Mongoid::Extensions::Decimal128::ClassMethods
  include Mongoid::Extensions::Decimal128
end
module Mongoid::Extensions::FalseClass
  def __sortable__; end
  def is_a?(other); end
end
class FalseClass
  include Mongoid::Extensions::FalseClass
end
module Mongoid::Extensions::Float
  def __mongoize_time__; end
  def numeric?; end
end
module Mongoid::Extensions::Float::ClassMethods
  def demongoize(object); end
  def mongoize(object); end
end
class Float < Numeric
  extend Mongoid::Criteria::Queryable::Extensions::Numeric::ClassMethods
  extend Mongoid::Extensions::Float::ClassMethods
  include Mongoid::Criteria::Queryable::Extensions::Numeric
  include Mongoid::Extensions::Float
end
module Mongoid::Extensions::Hash
  def __consolidate__(klass); end
  def __evolve_object_id__; end
  def __mongoize_object_id__; end
  def __nested__(string); end
  def _mongoid_unsatisfiable_criteria?; end
  def blank_criteria?; end
  def delete_id; end
  def extract_id; end
  def mongoize; end
  def mongoize_for(operator, klass, key, value); end
  def resizable?; end
  def to_criteria; end
end
module Mongoid::Extensions::Hash::ClassMethods
  def mongoize(object); end
  def resizable?; end
end
class Hash
  extend Mongoid::Extensions::Hash::ClassMethods
  include Mongoid::Criteria::Queryable::Extensions::Hash
  include Mongoid::Extensions::Hash
end
module Mongoid::Extensions::Integer
  def __mongoize_time__; end
  def numeric?; end
  def unconvertable_to_bson?; end
end
module Mongoid::Extensions::Integer::ClassMethods
  def demongoize(object); end
  def mongoize(object); end
end
class Integer < Numeric
  extend Mongoid::Criteria::Queryable::Extensions::Numeric::ClassMethods
  extend Mongoid::Extensions::Integer::ClassMethods
  include Mongoid::Criteria::Queryable::Extensions::Numeric
  include Mongoid::Extensions::Integer
end
module Mongoid::Extensions::Module
  def re_define_method(name, &block); end
end
class Module
  include Mongoid::Extensions::Module
end
module Mongoid::Extensions::NilClass
  def __setter__; end
  def collectionize; end
end
class NilClass
  include Mongoid::Criteria::Queryable::Extensions::NilClass
  include Mongoid::Extensions::NilClass
end
module Mongoid::Extensions::Object
  def __evolve_object_id__; end
  def __find_args__; end
  def __mongoize_object_id__; end
  def __mongoize_time__; end
  def __setter__; end
  def __sortable__; end
  def __to_inc__; end
  def blank_criteria?; end
  def do_or_do_not(name, *args); end
  def ivar(name); end
  def mongoize; end
  def multi_arged?; end
  def numeric?; end
  def remove_ivar(name); end
  def resizable?; end
  def substitutable; end
  def you_must(name, *args); end
end
module Mongoid::Extensions::Object::ClassMethods
  def __mongoize_fk__(association, object); end
  def demongoize(object); end
  def mongoize(object); end
end
module Mongoid::Extensions::ObjectId
  def __evolve_object_id__; end
  def __mongoize_object_id__; end
end
module Mongoid::Extensions::ObjectId::ClassMethods
  def evolve(object); end
  def mongoize(object); end
end
class BSON::ObjectId
  extend Mongoid::Extensions::ObjectId::ClassMethods
  include Mongoid::Extensions::ObjectId
end
module Mongoid::Extensions::Range
  def __find_args__; end
  def mongoize; end
  def resizable?; end
end
module Mongoid::Extensions::Range::ClassMethods
  def demongoize(object); end
  def mongoize(object); end
end
class Range
  extend Mongoid::Criteria::Queryable::Extensions::Range::ClassMethods
  extend Mongoid::Extensions::Range::ClassMethods
  include Mongoid::Criteria::Queryable::Extensions::Range
  include Mongoid::Extensions::Range
end
module Mongoid::Extensions::Regexp
end
module Mongoid::Extensions::Regexp::ClassMethods
  def mongoize(object); end
end
class Regexp
  extend Mongoid::Criteria::Queryable::Extensions::Regexp::ClassMethods
  extend Mongoid::Extensions::Regexp::ClassMethods
  include Mongoid::Criteria::Queryable::Extensions::Regexp
end
module Mongoid::Extensions::Set
  def mongoize; end
end
module Mongoid::Extensions::Set::ClassMethods
  def demongoize(object); end
  def mongoize(object); end
end
class Set
  extend Mongoid::Criteria::Queryable::Extensions::Set::ClassMethods
  extend Mongoid::Extensions::Set::ClassMethods
  include Mongoid::Extensions::Set
end
module Mongoid::Extensions::String
  def __evolve_object_id__; end
  def __mongoize_object_id__; end
  def __mongoize_time__; end
  def before_type_cast?; end
  def collectionize; end
  def convert_to_object_id; end
  def mongoid_id?; end
  def numeric?; end
  def reader; end
  def unconvertable_to_bson; end
  def unconvertable_to_bson=(arg0); end
  def unconvertable_to_bson?; end
  def valid_method_name?; end
  def writer?; end
end
module Mongoid::Extensions::String::ClassMethods
  def demongoize(object); end
  def mongoize(object); end
end
class String
  extend Mongoid::Criteria::Queryable::Extensions::String::ClassMethods
  extend Mongoid::Extensions::String::ClassMethods
  include Mongoid::Criteria::Queryable::Extensions::String
  include Mongoid::Extensions::String
end
class Mongoid::StringifiedSymbol
  def self.demongoize(object); end
  def self.evolve(object); end
  def self.mongoize(object); end
end
module Mongoid::Extensions::Symbol
  def mongoid_id?; end
end
module Mongoid::Extensions::Symbol::ClassMethods
  def demongoize(object); end
  def mongoize(object); end
end
class Symbol
  def add_to_set; end
  def all; end
  def asc; end
  def ascending; end
  def avg; end
  def desc; end
  def descending; end
  def elem_match; end
  def exists; end
  def first; end
  def gt; end
  def gte; end
  def in; end
  def intersects_line; end
  def intersects_point; end
  def intersects_polygon; end
  def last; end
  def lt; end
  def lte; end
  def max; end
  def min; end
  def mod; end
  def ne; end
  def near; end
  def near_sphere; end
  def nin; end
  def not; end
  def push; end
  def sum; end
  def with_size; end
  def with_type; end
  def within_box; end
  def within_polygon; end
  extend Mongoid::Criteria::Queryable::Extensions::Symbol::ClassMethods
  extend Mongoid::Extensions::Symbol::ClassMethods
  include Mongoid::Criteria::Queryable::Extensions::Symbol
  include Mongoid::Extensions::Symbol
end
module Mongoid::Extensions::Time
  def __mongoize_time__; end
  def mongoize; end
end
module Mongoid::Extensions::Time::ClassMethods
  def configured; end
  def demongoize(object); end
  def mongoize(object); end
end
class Time
  extend Mongoid::Criteria::Queryable::Extensions::Time::ClassMethods
  extend Mongoid::Extensions::Time::ClassMethods
  include Mongoid::Criteria::Queryable::Extensions::Time
  include Mongoid::Extensions::Time
end
module Mongoid::Extensions::TimeWithZone
  def __mongoize_time__; end
  def mongoize; end
end
module Mongoid::Extensions::TimeWithZone::ClassMethods
  def demongoize(object); end
  def mongoize(object); end
end
class ActiveSupport::TimeWithZone
  extend Mongoid::Criteria::Queryable::Extensions::TimeWithZone::ClassMethods
  extend Mongoid::Extensions::TimeWithZone::ClassMethods
  include Mongoid::Criteria::Queryable::Extensions::TimeWithZone
  include Mongoid::Extensions::TimeWithZone
end
module Mongoid::Extensions::TrueClass
  def __sortable__; end
  def is_a?(other); end
end
class TrueClass
  include Mongoid::Extensions::TrueClass
end
class BSON::Document < Hash
  def transform_keys; end
end
module Mongoid::Errors
end
class Mongoid::Errors::MongoidError < StandardError
  def compose_message(key, attributes = nil); end
  def problem; end
  def resolution; end
  def summary; end
  def translate(key, options); end
  def translate_problem(key, attributes); end
  def translate_resolution(key, attributes); end
  def translate_summary(key, attributes); end
end
class Mongoid::Errors::AmbiguousRelationship < Mongoid::Errors::MongoidError
  def initialize(klass, inverse, name, candidates); end
end
class Mongoid::Errors::Callback < Mongoid::Errors::MongoidError
  def initialize(klass, method); end
end
class Mongoid::Errors::CriteriaArgumentRequired < Mongoid::Errors::MongoidError
  def initialize(query_method); end
end
class Mongoid::Errors::DocumentNotDestroyed < Mongoid::Errors::MongoidError
  def initialize(id, klass); end
end
class Mongoid::Errors::DocumentNotFound < Mongoid::Errors::MongoidError
  def initialize(klass, params, unmatched = nil); end
  def klass; end
  def message_key(params); end
  def missing(unmatched); end
  def params; end
  def searched(params); end
  def total(params); end
end
class Mongoid::Errors::EagerLoad < Mongoid::Errors::MongoidError
  def initialize(name); end
end
class Mongoid::Errors::InMemoryCollationNotSupported < Mongoid::Errors::MongoidError
  def initialize; end
end
class Mongoid::Errors::InvalidCollection < Mongoid::Errors::MongoidError
  def initialize(klass); end
end
class Mongoid::Errors::InvalidConfigOption < Mongoid::Errors::MongoidError
  def initialize(name); end
end
class Mongoid::Errors::InvalidDependentStrategy < Mongoid::Errors::MongoidError
  def initialize(association, invalid_strategy, valid_strategies); end
end
class Mongoid::Errors::InvalidField < Mongoid::Errors::MongoidError
  def initialize(klass, name); end
  def location(klass, name); end
  def origin(klass, name); end
end
class Mongoid::Errors::InvalidFieldOption < Mongoid::Errors::MongoidError
  def initialize(klass, name, option, valid); end
end
class Mongoid::Errors::InvalidFind < Mongoid::Errors::MongoidError
  def initialize; end
end
class Mongoid::Errors::InvalidIncludes < Mongoid::Errors::MongoidError
  def initialize(klass, args); end
end
class Mongoid::Errors::InvalidIndex < Mongoid::Errors::MongoidError
  def initialize(klass, spec, options); end
end
class Mongoid::Errors::InvalidOptions < Mongoid::Errors::MongoidError
  def initialize(name, invalid, valid); end
end
class Mongoid::Errors::InvalidPath < Mongoid::Errors::MongoidError
  def initialize(klass); end
end
class Mongoid::Errors::InvalidPersistenceOption < Mongoid::Errors::MongoidError
  def initialize(invalid, valid); end
end
class Mongoid::Errors::InvalidQuery < Mongoid::Errors::MongoidError
  def initialize(msg); end
  def self.truncate_expr(expr); end
end
class Mongoid::Errors::InvalidDiscriminatorKeyTarget < Mongoid::Errors::MongoidError
  def initialize(class_name, superclass); end
end
class Mongoid::Errors::InvalidElemMatchOperator < Mongoid::Errors::InvalidQuery
  def initialize(operator); end
  def operator; end
end
class Mongoid::Errors::InvalidEstimatedCountCriteria < Mongoid::Errors::MongoidError
  def initialize(class_name); end
end
class Mongoid::Errors::InvalidExpressionOperator < Mongoid::Errors::InvalidQuery
  def initialize(operator); end
  def operator; end
end
class Mongoid::Errors::InvalidFieldOperator < Mongoid::Errors::InvalidQuery
  def initialize(operator); end
  def operator; end
end
class Mongoid::Errors::InvalidRelation < Mongoid::Errors::MongoidError
  def initialize(klass, name); end
  def location(klass, name); end
  def origin(klass, name); end
end
class Mongoid::Errors::InvalidRelationOption < Mongoid::Errors::MongoidError
  def initialize(klass, name, option, valid_options); end
end
class Mongoid::Errors::InvalidScope < Mongoid::Errors::MongoidError
  def initialize(klass, value); end
end
class Mongoid::Errors::InvalidSessionUse < Mongoid::Errors::MongoidError
  def initialize(error_type); end
end
class Mongoid::Errors::InvalidSetPolymorphicRelation < Mongoid::Errors::MongoidError
  def initialize(name, klass, other_klass); end
end
class Mongoid::Errors::InvalidStorageOptions < Mongoid::Errors::MongoidError
  def initialize(klass, options); end
end
class Mongoid::Errors::InvalidStorageParent < Mongoid::Errors::MongoidError
  def initialize(klass); end
end
class Mongoid::Errors::InvalidTime < Mongoid::Errors::MongoidError
  def initialize(value); end
end
class Mongoid::Errors::InvalidValue < Mongoid::Errors::MongoidError
  def initialize(field_class, value_class); end
end
class Mongoid::Errors::InverseNotFound < Mongoid::Errors::MongoidError
  def initialize(base, name, klass, inverse); end
end
class Mongoid::Errors::MixedRelations < Mongoid::Errors::MongoidError
  def initialize(root_klass, embedded_klass); end
end
class Mongoid::Errors::MixedClientConfiguration < Mongoid::Errors::MongoidError
  def initialize(name, config); end
end
class Mongoid::Errors::NestedAttributesMetadataNotFound < Mongoid::Errors::MongoidError
  def initialize(klass, name); end
end
class Mongoid::Errors::NoDefaultClient < Mongoid::Errors::MongoidError
  def initialize(keys); end
end
class Mongoid::Errors::NoEnvironment < Mongoid::Errors::MongoidError
  def initialize; end
end
class Mongoid::Errors::NoMapReduceOutput < Mongoid::Errors::MongoidError
  def initialize(command); end
end
class Mongoid::Errors::NoMetadata < Mongoid::Errors::MongoidError
  def initialize(klass); end
end
class Mongoid::Errors::NoParent < Mongoid::Errors::MongoidError
  def initialize(klass); end
end
class Mongoid::Errors::NoClientConfig < Mongoid::Errors::MongoidError
  def initialize(name); end
end
class Mongoid::Errors::NoClientsConfig < Mongoid::Errors::MongoidError
  def initialize; end
end
class Mongoid::Errors::NoClientDatabase < Mongoid::Errors::MongoidError
  def initialize(name, config); end
end
class Mongoid::Errors::NoClientHosts < Mongoid::Errors::MongoidError
  def initialize(name, config); end
end
class Mongoid::Errors::ReadonlyAttribute < Mongoid::Errors::MongoidError
  def initialize(name, value); end
end
class Mongoid::Errors::ReadonlyDocument < Mongoid::Errors::MongoidError
  def initialize(klass); end
end
class Mongoid::Errors::ScopeOverwrite < Mongoid::Errors::MongoidError
  def initialize(model_name, scope_name); end
end
class Mongoid::Errors::TooManyNestedAttributeRecords < Mongoid::Errors::MongoidError
  def initialize(association, limit); end
end
class Mongoid::Errors::UnknownAttribute < Mongoid::Errors::MongoidError
  def initialize(klass, name); end
end
class Mongoid::Errors::UnknownModel < Mongoid::Errors::MongoidError
  def initialize(klass, value); end
end
class Mongoid::Errors::UnsavedDocument < Mongoid::Errors::MongoidError
  def initialize(base, document); end
end
class Mongoid::Errors::UnsupportedJavascript < Mongoid::Errors::MongoidError
  def initialize(klass, javascript); end
end
class Mongoid::Errors::Validations < Mongoid::Errors::MongoidError
  def document; end
  def initialize(document); end
  def record; end
end
class Mongoid::Errors::DeleteRestriction < Mongoid::Errors::MongoidError
  def initialize(document, relation); end
end
module Mongoid::Threaded
  def autosaved?(document); end
  def autosaves; end
  def autosaves_for(klass); end
  def begin_autosave(document); end
  def begin_execution(name); end
  def begin_validate(document); end
  def begin_without_default_scope(klass); end
  def clear_session; end
  def client_override; end
  def client_override=(name); end
  def current_scope(klass = nil); end
  def current_scope=(scope); end
  def database_override; end
  def database_override=(name); end
  def executing?(name); end
  def exit_autosave(document); end
  def exit_execution(name); end
  def exit_validate(document); end
  def exit_without_default_scope(klass); end
  def get_session; end
  def set_current_scope(scope, klass); end
  def set_session(session); end
  def stack(name); end
  def validated?(document); end
  def validations; end
  def validations_for(klass); end
  def without_default_scope?(klass); end
  extend Mongoid::Threaded
end
module Mongoid::Threaded::Lifecycle
  def _assigning; end
  def _assigning?; end
  def _binding; end
  def _binding?; end
  def _building; end
  def _building?; end
  def _creating?; end
  def _loading; end
  def _loading?; end
  extend ActiveSupport::Concern
end
module Mongoid::Threaded::Lifecycle::ClassMethods
  def _creating; end
end
module Mongoid::Atomic
  def _updates(_use_indexes = nil); end
  def add_atomic_pull(document); end
  def add_atomic_unset(document); end
  def atomic_array_add_to_sets; end
  def atomic_array_pulls; end
  def atomic_array_pushes; end
  def atomic_attribute_name(name); end
  def atomic_delete_modifier; end
  def atomic_insert_modifier; end
  def atomic_path; end
  def atomic_paths; end
  def atomic_position; end
  def atomic_pulls; end
  def atomic_pushes; end
  def atomic_sets; end
  def atomic_unsets; end
  def atomic_updates(_use_indexes = nil); end
  def delayed_atomic_pulls; end
  def delayed_atomic_sets; end
  def delayed_atomic_unsets; end
  def flag_as_destroyed; end
  def flagged_destroys; end
  def generate_atomic_updates(mods, doc); end
  def process_flagged_destroys; end
  def touch_atomic_updates(field = nil); end
  extend ActiveSupport::Concern
end
class Mongoid::Atomic::Modifiers < Hash
  def add_each_operation(mods, field, value); end
  def add_operation(mods, field, value); end
  def add_to_set(modifications); end
  def add_to_sets; end
  def conflicting_pulls; end
  def conflicting_pushes; end
  def conflicting_sets; end
  def conflicts; end
  def pull(modifications); end
  def pull_all(modifications); end
  def pull_alls; end
  def pull_fields; end
  def pulls; end
  def push(modifications); end
  def push_conflict?(field); end
  def push_fields; end
  def pushes; end
  def set(modifications); end
  def set_conflict?(field); end
  def set_fields; end
  def sets; end
  def unset(modifications); end
  def unsets; end
end
module Mongoid::Atomic::Paths
end
module Mongoid::Atomic::Paths::Embedded
  def delete_modifier; end
  def document; end
  def insert_modifier; end
  def parent; end
  def path; end
end
class Mongoid::Atomic::Paths::Embedded::One
  def initialize(document); end
  def position; end
  include Mongoid::Atomic::Paths::Embedded
end
class Mongoid::Atomic::Paths::Embedded::Many
  def initialize(document); end
  def position; end
  include Mongoid::Atomic::Paths::Embedded
end
class Mongoid::Atomic::Paths::Root
  def document; end
  def initialize(document); end
  def insert_modifier; end
  def path; end
  def position; end
end
module Mongoid::Attributes
  def [](name); end
  def []=(name, value); end
  def assign_attributes(attrs = nil); end
  def attribute_missing?(name); end
  def attribute_present?(name); end
  def attributes; end
  def attributes=(attrs = nil); end
  def attributes_before_type_cast; end
  def has_attribute?(name); end
  def has_attribute_before_type_cast?(name); end
  def hash_dot_syntax?(string); end
  def lookup_attribute_presence(name, value); end
  def raw_attributes; end
  def read_attribute(name); end
  def read_attribute_before_type_cast(name); end
  def read_raw_attribute(name); end
  def remove_attribute(name); end
  def selection_excluded?(name, selection, field); end
  def selection_included?(name, selection, field); end
  def typed_attributes; end
  def typed_value_for(key, value); end
  def validate_attribute_value(field_name, value); end
  def write_attribute(name, value); end
  def write_attributes(attrs = nil); end
  extend ActiveSupport::Concern
  include Mongoid::Attributes::Nested
  include Mongoid::Attributes::Processing
  include Mongoid::Attributes::Readonly
end
module Mongoid::Attributes::Dynamic
  def define_dynamic_before_type_cast_reader(name); end
  def define_dynamic_reader(name); end
  def define_dynamic_writer(name); end
  def inspect_dynamic_fields; end
  def method_missing(name, *args); end
  def process_attribute(name, value); end
  def respond_to?(name, include_private = nil); end
  extend ActiveSupport::Concern
end
module Mongoid::Attributes::Nested
  extend ActiveSupport::Concern
end
module Mongoid::Attributes::Nested::ClassMethods
  def accepts_nested_attributes_for(*args); end
  def autosave_nested_attributes(association); end
end
module Mongoid::Attributes::Processing
  def pending_attribute?(key, value); end
  def pending_nested; end
  def pending_relations; end
  def process_attribute(name, value); end
  def process_attributes(attrs = nil); end
  def process_nested; end
  def process_pending; end
  def process_relations; end
end
module Mongoid::Attributes::Readonly
  def _loaded?(name); end
  def as_writable_attribute!(name, value = nil); end
  def attribute_writable?(name); end
  def projected_field?(name); end
  extend ActiveSupport::Concern
end
module Mongoid::Attributes::Readonly::ClassMethods
  def attr_readonly(*names); end
end
module Mongoid::Attributes::ClassMethods
  def alias_attribute(name, original); end
end
module Mongoid::Contextual
  def add_each_to_set(*args, &block); end
  def add_to_set(*args, &block); end
  def aggregates(*args, &block); end
  def avg(*args, &block); end
  def bit(*args, &block); end
  def blank?(*args, &block); end
  def cached?(*args, &block); end
  def collection(*args, &block); end
  def context; end
  def count(*args, &block); end
  def create_context; end
  def criteria(*args, &block); end
  def database_field_name(*args, &block); end
  def delete(*args, &block); end
  def delete_all(*args, &block); end
  def destroy(*args, &block); end
  def destroy_all(*args, &block); end
  def distinct(*args, &block); end
  def each(*args, &block); end
  def empty?(*args, &block); end
  def estimated_count(*args, &block); end
  def exists?(*args, &block); end
  def explain(*args, &block); end
  def find_first(*args, &block); end
  def find_one_and_delete(*args, &block); end
  def find_one_and_replace(*args, &block); end
  def find_one_and_update(*args, &block); end
  def first(*args, &block); end
  def geo_near(*args, &block); end
  def inc(*args, &block); end
  def klass(*args, &block); end
  def last(*args, &block); end
  def length(*args, &block); end
  def map(*args, &block); end
  def map_reduce(*args, &block); end
  def max(*args, &block); end
  def min(*args, &block); end
  def one(*args, &block); end
  def pluck(*args, &block); end
  def pop(*args, &block); end
  def pull(*args, &block); end
  def pull_all(*args, &block); end
  def push(*args, &block); end
  def push_all(*args, &block); end
  def rename(*args, &block); end
  def set(*args, &block); end
  def size(*args, &block); end
  def sort(*args, &block); end
  def sum(*args, &block); end
  def unset(*args, &block); end
  def update(*args, &block); end
  def update_all(*args, &block); end
  def view(*args, &block); end
  extend Forwardable
end
module Mongoid::Contextual::Queryable
  def blank?; end
  def collection; end
  def criteria; end
  def empty?; end
  def klass; end
end
module Mongoid::Contextual::Atomic
  def add_each_to_set(adds); end
  def add_to_set(adds); end
  def bit(bits); end
  def collect_each_operations(ops); end
  def collect_operations(ops); end
  def inc(incs); end
  def pop(pops); end
  def pull(pulls); end
  def pull_all(pulls); end
  def push(pushes); end
  def push_all(pushes); end
  def rename(renames); end
  def set(sets); end
  def unset(*args); end
end
module Mongoid::Contextual::Aggregable
end
module Mongoid::Contextual::Aggregable::Mongo
  def aggregates(field); end
  def avg(field); end
  def max(field = nil); end
  def min(field = nil); end
  def pipeline(field); end
  def sum(field = nil); end
end
module Mongoid::Contextual::Command
  def client; end
  def collection; end
  def command; end
  def criteria; end
end
class Mongoid::Contextual::GeoNear
  def ==(*args, &block); end
  def [](*args, &block); end
  def apply_criteria_options; end
  def average_distance; end
  def distance_multiplier(value); end
  def documents; end
  def each; end
  def empty?(*args, &block); end
  def empty_and_chainable?; end
  def execute; end
  def initialize(collection, criteria, near); end
  def inspect; end
  def max_distance(value = nil); end
  def min_distance(value); end
  def results; end
  def spherical; end
  def stats; end
  def time; end
  def unique(value = nil); end
  extend Forwardable
  include Enumerable
  include Mongoid::Contextual::Command
end
class Mongoid::Contextual::MapReduce
  def ==(*args, &block); end
  def [](*args, &block); end
  def _session; end
  def command; end
  def counts; end
  def each; end
  def emitted; end
  def empty?(*args, &block); end
  def execute; end
  def finalize(function); end
  def initialize(collection, criteria, map, reduce); end
  def input; end
  def inspect; end
  def js_mode; end
  def out(location); end
  def output; end
  def raw; end
  def reduced; end
  def results; end
  def scope(object); end
  def time; end
  def validate_out!; end
  extend Forwardable
  include Enumerable
  include Mongoid::Contextual::Command
end
module Mongoid::Association
  def _association; end
  def _association=(arg0); end
  def association_name; end
  def embedded?; end
  def embedded_many?; end
  def embedded_one?; end
  def referenced_many?; end
  def referenced_one?; end
  def reload_relations; end
  extend ActiveSupport::Concern
  include Mongoid::Association::Accessors
  include Mongoid::Association::Builders
  include Mongoid::Association::Depending
  include Mongoid::Association::Embedded::Cyclic
  include Mongoid::Association::Macros
  include Mongoid::Association::Referenced::AutoSave
  include Mongoid::Association::Referenced::CounterCache
  include Mongoid::Association::Referenced::Syncable
  include Mongoid::Association::Reflections
end
module Mongoid::Association::Referenced
end
module Mongoid::Association::Referenced::Eager
end
class Mongoid::Association::Referenced::Eager::Base
  def each_loaded_document(&block); end
  def each_loaded_document_of_class(cls, keys); end
  def group_by_key; end
  def grouped_docs; end
  def initialize(associations, docs); end
  def keys_from_docs; end
  def preload; end
  def run; end
  def set_on_parent(id, element); end
  def set_relation(doc, element); end
  def shift_association; end
end
module Mongoid::Association::EagerLoadable
  def eager_load(docs); end
  def eager_loadable?; end
  def preload(relations, docs); end
end
class Mongoid::Contextual::Mongo
  def _session; end
  def acknowledged_write?; end
  def apply_fields; end
  def apply_option(name); end
  def apply_options; end
  def cache_loaded?; end
  def cacheable?; end
  def cached?; end
  def count(options = nil, &block); end
  def database_field_name(*args, &block); end
  def delete; end
  def delete_all; end
  def destroy; end
  def destroy_all; end
  def distinct(field); end
  def documents; end
  def documents_for_iteration; end
  def each(&block); end
  def estimated_count(options = nil); end
  def exists?; end
  def explain; end
  def find_first; end
  def find_one_and_delete; end
  def find_one_and_replace(replacement, options = nil); end
  def find_one_and_update(update, options = nil); end
  def first(opts = nil); end
  def geo_near(coordinates); end
  def initialize(criteria); end
  def last(opts = nil); end
  def length; end
  def limit(value); end
  def map(field = nil, &block); end
  def map_reduce(map, reduce); end
  def one(opts = nil); end
  def pluck(*fields); end
  def size; end
  def skip(value); end
  def sort(values = nil, &block); end
  def try_cache(key, &block); end
  def update(attributes = nil, opts = nil); end
  def update_all(attributes = nil, opts = nil); end
  def update_documents(attributes, method = nil, opts = nil); end
  def view; end
  def with_inverse_sorting(opts = nil); end
  def yield_document(document, &block); end
  extend Forwardable
  include Enumerable
  include Mongoid::Association::EagerLoadable
  include Mongoid::Contextual::Aggregable::Mongo
  include Mongoid::Contextual::Atomic
  include Mongoid::Contextual::Queryable
end
module Mongoid::Contextual::Aggregable::Memory
  def aggregate_by(field, method); end
  def avg(field); end
  def max(field = nil); end
  def min(field = nil); end
  def sum(field = nil); end
end
class Mongoid::Contextual::Memory
  def ==(other); end
  def _session; end
  def apply_options; end
  def apply_sorting; end
  def compare(a, b); end
  def delete; end
  def delete_all; end
  def destroy; end
  def destroy_all; end
  def distinct(field); end
  def documents; end
  def documents_for_iteration; end
  def each; end
  def exists?; end
  def find_first(*args); end
  def first(*args); end
  def in_place_sort(values); end
  def inc(incs); end
  def initialize(criteria); end
  def last; end
  def length; end
  def limit(value); end
  def limiting; end
  def limiting=(value); end
  def one(*args); end
  def path; end
  def pluck(*fields); end
  def prepare_remove(doc); end
  def root; end
  def selector; end
  def size; end
  def skip(value); end
  def skipping; end
  def skipping=(value); end
  def sort(values); end
  def update(attributes = nil); end
  def update_all(attributes = nil); end
  def update_documents(attributes, docs); end
  include Enumerable
  include Mongoid::Association::EagerLoadable
  include Mongoid::Contextual::Aggregable::Memory
  include Mongoid::Contextual::Queryable
  include Mongoid::Positional
end
class Mongoid::Contextual::None
  def ==(other); end
  def criteria; end
  def distinct(field); end
  def each; end
  def exists?; end
  def initialize(criteria); end
  def klass; end
  def last; end
  def length; end
  def pluck(*args); end
  def size; end
  include Enumerable
  include Mongoid::Contextual::Queryable
end
module Mongoid::Copyable
  def clone; end
  def clone_document; end
  def dup; end
  def process_localized_attributes(klass, attrs); end
  extend ActiveSupport::Concern
end
module Mongoid::Equality
  def <=>(other); end
  def ==(other); end
  def ===(other); end
  def eql?(other); end
end
class Mongoid::Criteria
  def ==(other); end
  def _enumerable_find(*arg0); end
  def _findable_find(*args); end
  def as_json(options = nil); end
  def association; end
  def association=(arg0); end
  def cache; end
  def cached?; end
  def check_for_missing_documents!(result, ids); end
  def documents; end
  def documents=(docs); end
  def embedded; end
  def embedded=(arg0); end
  def embedded?; end
  def empty_and_chainable?; end
  def extract_id; end
  def extras(extras); end
  def field_list; end
  def find(*args, &block); end
  def for_js(javascript, scope = nil); end
  def freeze; end
  def initialize(klass); end
  def initialize_copy(other); end
  def klass; end
  def klass=(arg0); end
  def merge!(other); end
  def merge(other); end
  def merge_type_selection; end
  def method_missing(name, *args, &block); end
  def none; end
  def only(*args); end
  def parent_document; end
  def parent_document=(arg0); end
  def read(value = nil); end
  def respond_to?(name, include_private = nil); end
  def selector_with_type_selection; end
  def to_ary(*arg0); end
  def to_criteria; end
  def to_proc; end
  def type(types); end
  def type_selectable?; end
  def type_selection; end
  def where(*args); end
  def without(*args); end
  def without_options; end
  extend Mongoid::Clients::Options::ClassMethods
  include Enumerable
  include Mongoid::Clients::Options
  include Mongoid::Clients::Sessions
  include Mongoid::Contextual
  include Mongoid::Criteria::Findable
  include Mongoid::Criteria::Includable
  include Mongoid::Criteria::Inspectable
  include Mongoid::Criteria::Marshalable
  include Mongoid::Criteria::Modifiable
  include Mongoid::Criteria::Options
  include Mongoid::Criteria::Queryable
  include Mongoid::Criteria::Scopable
end
module Mongoid::Criteria::Findable
  def execute_or_raise(ids, multi); end
  def find(*args); end
  def for_ids(ids); end
  def from_database(ids); end
  def from_database_selector(ids); end
  def id_finder; end
  def mongoize_ids(ids); end
  def multiple_from_db(ids); end
  def raise_invalid; end
end
module Mongoid::Criteria::Includable
  def add_inclusion(_klass, association); end
  def extract_includes_list(_parent_class, *relations_list); end
  def includes(*relations); end
  def inclusions; end
  def inclusions=(value); end
end
module Mongoid::Criteria::Inspectable
  def inspect; end
end
module Mongoid::Criteria::Marshalable
  def dump_hash(name); end
  def load_hash(hash_class, raw); end
  def marshal_dump; end
  def marshal_load(data); end
end
module Mongoid::Criteria::Modifiable
  def build(attrs = nil, &block); end
  def create!(attrs = nil, &block); end
  def create(attrs = nil, &block); end
  def create_attrs; end
  def create_document(method, attrs = nil, &block); end
  def create_with(attrs = nil); end
  def find_or(method, attrs = nil, &block); end
  def find_or_create_by!(attrs = nil, &block); end
  def find_or_create_by(attrs = nil, &block); end
  def find_or_initialize_by(attrs = nil, &block); end
  def first_or(method, attrs = nil, &block); end
  def first_or_create!(attrs = nil, &block); end
  def first_or_create(attrs = nil, &block); end
  def first_or_initialize(attrs = nil, &block); end
  def invalid_embedded_doc?(value); end
  def invalid_key?(hash, key); end
  def new(attrs = nil, &block); end
end
module Mongoid::Criteria::Queryable
  def ==(other); end
  def aliases; end
  def driver; end
  def initialize(aliases = nil, serializers = nil, driver = nil); end
  def initialize_copy(other); end
  def serializers; end
  include Mongoid::Criteria::Queryable::Aggregable
  include Mongoid::Criteria::Queryable::Expandable
  include Mongoid::Criteria::Queryable::Mergeable
  include Mongoid::Criteria::Queryable::Optional
  include Mongoid::Criteria::Queryable::Selectable
  include Mongoid::Criteria::Queryable::Storable
end
module Mongoid::Criteria::Queryable::Expandable
  def expand_condition(condition); end
  def expand_condition_to_array_values(criterion); end
  def expand_one_condition(field, value); end
end
module Mongoid::Criteria::Queryable::Extensions
end
module Mongoid::Criteria::Queryable::Extensions::TimeWithZone
  def __evolve_date__; end
  def __evolve_time__; end
end
module Mongoid::Criteria::Queryable::Extensions::TimeWithZone::ClassMethods
  def evolve(object); end
end
module Mongoid::Criteria::Queryable::Extensions::Object
  def __add__(object); end
  def __add_from_array__(array); end
  def __array__; end
  def __deep_copy__; end
  def __expand_complex__; end
  def __intersect__(object); end
  def __intersect_from_array__(array); end
  def __intersect_from_object__(object); end
  def __union__(object); end
  def __union_from_object__(object); end
  def regexp?; end
end
module Mongoid::Criteria::Queryable::Extensions::Object::ClassMethods
  def __evolve__(object); end
  def evolve(object); end
end
module Mongoid::Criteria::Queryable::Extensions::Array
  def __add__(object); end
  def __array__; end
  def __deep_copy__; end
  def __evolve_date__; end
  def __evolve_time__; end
  def __expand_complex__; end
  def __intersect__(object); end
  def __sort_option__; end
  def __sort_pair__; end
  def multi; end
  def update_values(&block); end
end
module Mongoid::Criteria::Queryable::Extensions::Array::ClassMethods
  def evolve(object); end
end
module Mongoid::Criteria::Queryable::Extensions::BigDecimal
end
module Mongoid::Criteria::Queryable::Extensions::BigDecimal::ClassMethods
  def evolve(object); end
end
module Mongoid::Criteria::Queryable::Extensions::Boolean
end
module Mongoid::Criteria::Queryable::Extensions::Boolean::ClassMethods
  def evolve(object); end
end
class Boolean
  extend Mongoid::Criteria::Queryable::Extensions::Boolean::ClassMethods
end
module Mongoid::Criteria::Queryable::Extensions::Date
  def __evolve_date__; end
  def __evolve_time__; end
end
module Mongoid::Criteria::Queryable::Extensions::Date::ClassMethods
  def evolve(object); end
end
module Mongoid::Criteria::Queryable::Extensions::DateTime
  def __evolve_time__; end
end
module Mongoid::Criteria::Queryable::Extensions::DateTime::ClassMethods
  def evolve(object); end
end
module Mongoid::Criteria::Queryable::Extensions::Hash
  def __add__(object); end
  def __add_from_array__(array); end
  def __deep_copy__; end
  def __expand_complex__; end
  def __intersect__(object); end
  def __intersect_from_array__(array); end
  def __intersect_from_object__(object); end
  def __sort_option__; end
  def __union__(object); end
  def __union_from_object__(object); end
  def apply_strategy(strategy, object); end
  def update_values(&block); end
end
module Mongoid::Criteria::Queryable::Extensions::NilClass
  def __add__(object); end
  def __evolve_date__; end
  def __evolve_time__; end
  def __expanded__(object); end
  def __intersect__(object); end
  def __override__(object); end
  def __union__(object); end
end
module Mongoid::Criteria::Queryable::Extensions::Numeric
  def __evolve_date__; end
  def __evolve_time__; end
  def to_direction; end
end
module Mongoid::Criteria::Queryable::Extensions::Numeric::ClassMethods
  def __numeric__(object); end
  def evolve(object); end
end
module Mongoid::Criteria::Queryable::Extensions::Range
  def __array__; end
  def __evolve_date__; end
  def __evolve_time__; end
end
module Mongoid::Criteria::Queryable::Extensions::Range::ClassMethods
  def evolve(object); end
end
module Mongoid::Criteria::Queryable::Extensions::Regexp
  def regexp?; end
end
module Mongoid::Criteria::Queryable::Extensions::Regexp::ClassMethods
  def evolve(object); end
end
module Mongoid::Criteria::Queryable::Extensions::Regexp::Raw_
  def regexp?; end
end
module Mongoid::Criteria::Queryable::Extensions::Regexp::Raw_::ClassMethods
  def evolve(object); end
end
class BSON::Regexp::Raw
  extend Mongoid::Criteria::Queryable::Extensions::Regexp::Raw_::ClassMethods
  include Mongoid::Criteria::Queryable::Extensions::Regexp::Raw_
end
module Mongoid::Criteria::Queryable::Extensions::Set
end
module Mongoid::Criteria::Queryable::Extensions::Set::ClassMethods
  def evolve(object); end
end
module Mongoid::Criteria::Queryable::Extensions::String
  def __evolve_date__; end
  def __evolve_time__; end
  def __expr_part__(value, negating = nil); end
  def __mongo_expression__; end
  def __sort_option__; end
  def to_direction; end
end
module Mongoid::Criteria::Queryable::Extensions::String::ClassMethods
  def __expr_part__(key, value, negating = nil); end
  def evolve(object); end
end
module Mongoid::Criteria::Queryable::Extensions::Symbol
  def __expr_part__(value, negating = nil); end
  def to_direction; end
end
module Mongoid::Criteria::Queryable::Extensions::Symbol::ClassMethods
  def add_key(name, strategy, operator, additional = nil, &block); end
  def evolve(object); end
end
module Mongoid::Criteria::Queryable::Extensions::Time
  def __evolve_date__; end
  def __evolve_time__; end
end
module Mongoid::Criteria::Queryable::Extensions::Time::ClassMethods
  def evolve(object); end
end
class Mongoid::Criteria::Queryable::Key
  def ==(other); end
  def __expr_part__(object, negating = nil); end
  def __sort_option__; end
  def __sort_pair__; end
  def block; end
  def eql?(other); end
  def expanded; end
  def hash; end
  def initialize(name, strategy, operator, expanded = nil, &block); end
  def name; end
  def operator; end
  def strategy; end
  def to_s; end
  def transform_value(value, negating = nil); end
end
module Mongoid::Criteria::Queryable::Macroable
  def key(name, strategy, operator, additional = nil, &block); end
end
module Mongoid::Criteria::Queryable::Mergeable
  def __add__(criterion, operator); end
  def __expanded__(criterion, outer, inner); end
  def __intersect__(criterion, operator); end
  def __merge__(criterion); end
  def __multi__(criteria, operator); end
  def __override__(criterion, operator); end
  def __union__(criterion, operator); end
  def _mongoid_add_top_level_operation(operator, criteria); end
  def _mongoid_expand_keys(expr); end
  def _mongoid_flatten_arrays(array); end
  def intersect; end
  def override; end
  def prepare(field, operator, value); end
  def reset_strategies!; end
  def strategy; end
  def strategy=(arg0); end
  def union; end
  def use(strategy); end
  def with_strategy(strategy, criterion, operator); end
end
class Mongoid::Criteria::Queryable::Smash < Hash
  def [](key); end
  def __deep_copy__; end
  def aliases; end
  def initialize(aliases = nil, serializers = nil); end
  def localized_key(name, serializer); end
  def serializers; end
  def storage_pair(key); end
end
module Mongoid::Criteria::Queryable::Aggregable
  def aggregating=(arg0); end
  def aggregating?; end
  def aggregation(operation); end
  def group(operation); end
  def pipeline; end
  def project(operation = nil); end
  def unwind(field); end
  extend Mongoid::Criteria::Queryable::Macroable
end
class Mongoid::Criteria::Queryable::Pipeline < Array
  def __deep_copy__; end
  def aliases; end
  def evolve(entry); end
  def group(entry); end
  def initialize(aliases = nil); end
  def project(entry); end
  def unwind(field_or_doc); end
end
module Mongoid::Criteria::Queryable::Optional
  def add_sort_option(options, field, direction); end
  def asc(*fields); end
  def ascending(*fields); end
  def batch_size(value = nil); end
  def collation(collation_doc); end
  def comment(comment = nil); end
  def cursor_type(type); end
  def desc(*fields); end
  def descending(*fields); end
  def hint(value = nil); end
  def limit(value = nil); end
  def max_scan(value = nil); end
  def max_time_ms(value = nil); end
  def no_timeout; end
  def offset(value = nil); end
  def only(*args); end
  def option(*args); end
  def options; end
  def options=(arg0); end
  def order(*spec); end
  def order_by(*spec); end
  def reorder(*spec); end
  def self.forwardables; end
  def skip(value = nil); end
  def slice(criterion = nil); end
  def snapshot; end
  def sort_with_list(*fields, direction); end
  def without(*args); end
  extend Mongoid::Criteria::Queryable::Macroable
end
class Mongoid::Criteria::Queryable::Options < Mongoid::Criteria::Queryable::Smash
  def []=(key, value, localize = nil); end
  def __deep_copy__; end
  def evolve(value, localize = nil); end
  def evolve_hash(value, localize = nil); end
  def fields; end
  def limit; end
  def skip; end
  def sort; end
  def store(key, value, localize = nil); end
  def to_pipeline; end
end
module Mongoid::Criteria::Queryable::Selectable
  def all(*criteria); end
  def all_in(*criteria); end
  def all_of(*criteria); end
  def and(*criteria); end
  def any_in(condition); end
  def any_of(*criteria); end
  def between(criterion); end
  def elem_match(criterion); end
  def excludes(criterion); end
  def exists(criterion); end
  def expr_query(criterion); end
  def geo_spacial(criterion); end
  def geo_spatial(criterion); end
  def gt(criterion); end
  def gte(criterion); end
  def in(condition); end
  def js_query(criterion); end
  def lt(criterion); end
  def lte(criterion); end
  def max_distance(criterion); end
  def mod(criterion); end
  def ne(criterion); end
  def near(criterion); end
  def near_sphere(criterion); end
  def negating; end
  def negating=(arg0); end
  def negating?; end
  def nin(condition); end
  def nor(*criteria); end
  def not(*criteria); end
  def not_in(condition); end
  def or(*criteria); end
  def selection(criterion = nil); end
  def selector; end
  def selector=(arg0); end
  def self.forwardables; end
  def text_search(terms, opts = nil); end
  def typed_override(criterion, operator); end
  def where(*criteria); end
  def with_size(criterion); end
  def with_type(criterion); end
  extend Mongoid::Criteria::Queryable::Macroable
end
class Mongoid::Criteria::Queryable::Selector < Mongoid::Criteria::Queryable::Smash
  def []=(key, value); end
  def evolve(serializer, value); end
  def evolve_array(serializer, value); end
  def evolve_hash(serializer, value); end
  def evolve_multi(specs); end
  def merge!(other); end
  def multi_selection?(key); end
  def store(key, value); end
  def to_pipeline; end
end
module Mongoid::Criteria::Queryable::Storable
  def add_field_expression(field, value); end
  def add_logical_operator_expression(operator, op_expr); end
  def add_one_expression(field, value); end
  def add_operator_expression(operator, op_expr); end
end
module Mongoid::Criteria::Scopable
  def apply_default_scope; end
  def reject_matching(other, *methods); end
  def remove_scoping(other); end
  def scoped(options = nil); end
  def scoped?; end
  def scoping_options; end
  def scoping_options=(options); end
  def unscoped; end
  def unscoped?; end
  def with_default_scope; end
end
module Mongoid::Criteria::Options
  def clear_persistence_context(original_cluster, original_context); end
  def persistence_context; end
  def set_persistence_context(options); end
end
module Mongoid::Factory
  def build(klass, attributes = nil); end
  def from_db(klass, attributes = nil, criteria = nil, selected_fields = nil); end
  extend Mongoid::Factory
end
module Mongoid::Fields
  def apply_default(name); end
  def apply_defaults; end
  def apply_post_processed_defaults; end
  def apply_pre_processed_defaults; end
  def attribute_names; end
  def database_field_name(name); end
  def lazy_settable?(field, value); end
  def self.option(option_name, &block); end
  def self.options; end
  def using_object_ids?; end
  extend ActiveSupport::Concern
end
class Mongoid::Fields::Standard
  def add_atomic_changes(document, name, key, mods, new, old); end
  def association; end
  def default_name; end
  def default_val; end
  def default_val=(arg0); end
  def define_default_method(object); end
  def demongoize(*args, &block); end
  def eval_default(doc); end
  def evaluate_default_proc(doc); end
  def evaluated_default(doc); end
  def evolve(*args, &block); end
  def foreign_key?; end
  def included?(fields); end
  def initialize(name, options = nil); end
  def label; end
  def label=(arg0); end
  def lazy?; end
  def localized?; end
  def mongoize(*args, &block); end
  def name; end
  def name=(arg0); end
  def object_id_field?; end
  def options; end
  def options=(arg0); end
  def pre_processed?; end
  def serialize_default(object); end
  def type; end
  extend Forwardable
end
class Mongoid::Fields::ForeignKey < Mongoid::Fields::Standard
  def add_atomic_changes(document, name, key, mods, new_elements, old_elements); end
  def evaluate_default_proc(doc); end
  def evolve(object); end
  def foreign_key?; end
  def lazy?; end
  def mongoize(object); end
  def object_id_field?; end
  def related_id_field; end
  def resizable?; end
  def serialize_default(object); end
end
class Mongoid::Fields::Localized < Mongoid::Fields::Standard
  def demongoize(object); end
  def fallbacks?; end
  def localized?; end
  def lookup(object); end
  def mongoize(object); end
end
module Mongoid::Fields::Validators
end
module Mongoid::Fields::Validators::Macro
  def validate(klass, name, options); end
  def validate_field_name(klass, name); end
  def validate_name_uniqueness(klass, name, options); end
  def validate_options(klass, name, options); end
  def validate_relation(klass, name, options = nil); end
  extend Mongoid::Fields::Validators::Macro
end
module Mongoid::Fields::ClassMethods
  def add_defaults(field); end
  def add_field(name, options = nil); end
  def attribute_names; end
  def create_accessors(name, meth, options = nil); end
  def create_field_check(name, meth); end
  def create_field_getter(name, meth, field); end
  def create_field_getter_before_type_cast(name, meth); end
  def create_field_setter(name, meth, field); end
  def create_translations_getter(name, meth); end
  def create_translations_setter(name, meth, field); end
  def database_field_name(name); end
  def field(name, options = nil); end
  def field_for(name, options); end
  def generated_methods; end
  def process_options(field); end
  def remove_defaults(name); end
  def replace_field(name, type); end
  def unmapped_type(options); end
  def using_object_ids?; end
end
module Mongoid::Timestamps
  extend ActiveSupport::Concern
  include Mongoid::Timestamps::Created
  include Mongoid::Timestamps::Updated
end
module Mongoid::Timestamps::Timeless
  def clear_timeless_option; end
  def self.[](*args, &block); end
  def self.[]=(*args, &block); end
  def self.timeless_table; end
  def timeless; end
  def timeless?; end
  extend ActiveSupport::Concern
end
module Mongoid::Timestamps::Timeless::ClassMethods
  def clear_timeless_option; end
  def clear_timeless_option_on_update; end
  def set_timeless_counter(counter); end
  def timeless; end
  def timeless?; end
end
module Mongoid::Timestamps::Created
  def set_created_at; end
  extend ActiveSupport::Concern
end
module Mongoid::Timestamps::Created::Short
  extend ActiveSupport::Concern
end
module Mongoid::Timestamps::Updated
  def able_to_set_updated_at?; end
  def set_updated_at; end
  extend ActiveSupport::Concern
end
module Mongoid::Timestamps::Updated::Short
  extend ActiveSupport::Concern
end
module Mongoid::Timestamps::Short
  extend ActiveSupport::Concern
  include Mongoid::Timestamps::Created::Short
  include Mongoid::Timestamps::Updated::Short
end
module Mongoid::Association::Accessors
  def __build__(name, object, association, selected_fields = nil); end
  def _mongoid_filter_selected_fields(assoc_key); end
  def create_relation(object, association, selected_fields = nil); end
  def get_relation(name, association, object, reload = nil); end
  def needs_no_database_query?(object, association); end
  def parse_args(*args); end
  def reset_relation_criteria(name); end
  def self.define_builder!(association); end
  def self.define_creator!(association); end
  def self.define_existence_check!(association); end
  def self.define_getter!(association); end
  def self.define_ids_getter!(association); end
  def self.define_ids_setter!(association); end
  def self.define_setter!(association); end
  def set_relation(name, relation); end
  def without_autobuild; end
  def without_autobuild?; end
  extend ActiveSupport::Concern
end
module Mongoid::Association::Builders
  def parse_args(*args); end
  def self.define_builder!(association); end
  def self.define_creator!(association); end
  extend ActiveSupport::Concern
end
module Mongoid::Association::Bindable
  def _association; end
  def _base; end
  def _target; end
  def bind_foreign_key(keyed, id); end
  def bind_from_relational_parent(doc); end
  def bind_inverse(doc, inverse); end
  def bind_polymorphic_inverse_type(typed, name); end
  def bind_polymorphic_type(typed, name); end
  def binding; end
  def check_inverse!(doc); end
  def initialize(base, target, association); end
  def record_id(_base); end
  def set_base_association; end
  def unbind_from_relational_parent(doc); end
  extend Mongoid::Threaded::Lifecycle::ClassMethods
  include Mongoid::Threaded::Lifecycle
end
module Mongoid::Association::Depending
  def _dependent_delete_all!(association); end
  def _dependent_destroy!(association); end
  def _dependent_nullify!(association); end
  def _dependent_restrict_with_error!(association); end
  def _dependent_restrict_with_exception!(association); end
  def apply_delete_dependencies!; end
  def self.define_dependency!(association); end
  def self.validate!(association); end
  extend ActiveSupport::Concern
end
module Mongoid::Association::Depending::ClassMethods
  def _all_dependents; end
end
module Mongoid::Association::Marshalable
  def marshal_dump; end
  def marshal_load(data); end
end
class Mongoid::Association::Proxy
  def _association; end
  def _association=(arg0); end
  def _base; end
  def _base=(arg0); end
  def _target; end
  def _target=(arg0); end
  def bind_one(*args, &block); end
  def characterize_one(document); end
  def collection; end
  def collection_name(*args, &block); end
  def execute_callback(callback, doc); end
  def extend_proxies(*extension); end
  def extend_proxy(mod, *args); end
  def foreign_key(*args, &block); end
  def init(base, target, association); end
  def inverse_foreign_key(*args, &block); end
  def klass; end
  def method_missing(name, *args, &block); end
  def raise_mixed; end
  def raise_unsaved(doc); end
  def reset_unloaded; end
  def self.apply_ordering(criteria, association); end
  def substitutable; end
  def unbind_one(*args, &block); end
  extend Forwardable
  extend Mongoid::Threaded::Lifecycle::ClassMethods
  include Mongoid::Association::Marshalable
  include Mongoid::Threaded::Lifecycle
end
class Mongoid::Association::Many < Mongoid::Association::Proxy
  def _session; end
  def any?(*args, &block); end
  def avg(*args, &block); end
  def blank?; end
  def create!(attributes = nil, type = nil, &block); end
  def create(attributes = nil, type = nil, &block); end
  def find_or(method, attrs = nil, type = nil, &block); end
  def find_or_create_by!(attrs = nil, type = nil, &block); end
  def find_or_create_by(attrs = nil, type = nil, &block); end
  def find_or_initialize_by(attrs = nil, type = nil, &block); end
  def length(*args, &block); end
  def max(*args, &block); end
  def min(*args, &block); end
  def nil?; end
  def respond_to?(name, include_private = nil); end
  def scoped; end
  def serializable_hash(options = nil); end
  def size(*args, &block); end
  def sum(*args, &block); end
  def unscoped; end
  extend Forwardable
  include Enumerable
end
class Mongoid::Association::One < Mongoid::Association::Proxy
  def __evolve_object_id__; end
  def clear; end
  def in_memory; end
  def respond_to?(name, include_private = nil); end
end
module Mongoid::Association::Constrainable
  def convert_polymorphic(object); end
  def convert_to_foreign_key(object); end
end
module Mongoid::Association::Options
  def as; end
  def autobuilding?; end
  def autosave; end
  def autosave?; end
  def cascading_callbacks?; end
  def counter_cached?; end
  def cyclic?; end
  def dependent; end
  def forced_nil_inverse?; end
  def indexed?; end
  def inverse_of; end
  def order; end
  def polymorphic?; end
  def primary_key; end
  def store_as; end
  def touch_field; end
  def touchable?; end
  def type; end
end
module Mongoid::Association::Relatable
  def ==(other); end
  def bindable?(doc); end
  def class_name; end
  def counter_cache_column_name; end
  def create_extension!(&block); end
  def create_relation(owner, target); end
  def default_inverse; end
  def define_autosaver!; end
  def define_builder!; end
  def define_counter_cache_callbacks!; end
  def define_creator!; end
  def define_dependency!; end
  def define_existence_check!; end
  def define_getter!; end
  def define_ids_getter!; end
  def define_ids_setter!; end
  def define_setter!; end
  def define_touchable!; end
  def destructive?; end
  def extension; end
  def foreign_key_check; end
  def foreign_key_setter; end
  def get_callbacks(callback_type); end
  def initialize(_class, name, opts = nil, &block); end
  def inverse(other = nil); end
  def inverse_association(other = nil); end
  def inverse_association_classes; end
  def inverse_class; end
  def inverse_class_name; end
  def inverse_klass; end
  def inverse_setter(other = nil); end
  def inverse_type; end
  def inverse_type_setter; end
  def inverses(other = nil); end
  def key; end
  def klass; end
  def name; end
  def namespace_hierarchy(mod); end
  def options; end
  def path(document); end
  def polymorph!; end
  def relation_class; end
  def relation_class_name; end
  def resolve_name(mod, name); end
  def setter; end
  def setup_index!; end
  def type_setter; end
  def validate!; end
  def validate?; end
  include Mongoid::Association::Constrainable
  include Mongoid::Association::Options
end
module Mongoid::Association::Nested
end
module Mongoid::Association::Nested::Buildable
  def allow_destroy?; end
  def association; end
  def association=(arg0); end
  def attributes; end
  def attributes=(arg0); end
  def convert_id(klass, id); end
  def existing; end
  def existing=(arg0); end
  def options; end
  def options=(arg0); end
  def reject?(document, attrs); end
  def update_only?; end
end
class Mongoid::Association::Nested::Many
  def build(parent, options = nil); end
  def destroy(parent, relation, doc); end
  def destroy_document(relation, doc); end
  def destroyable?(attributes); end
  def initialize(association, attributes, options = nil); end
  def over_limit?(attributes); end
  def process_attributes(parent, attrs); end
  def update_document(doc, attrs); end
  def update_nested_relation(parent, id, attrs); end
  include Mongoid::Association::Nested::Buildable
end
class Mongoid::Association::Nested::One
  def acceptable_id?; end
  def build(parent); end
  def delete?; end
  def destroy; end
  def destroy=(arg0); end
  def destroyable?; end
  def initialize(association, attributes, options); end
  def replace?; end
  def update?; end
  include Mongoid::Association::Nested::Buildable
end
module Mongoid::Association::Referenced::AutoSave
  def __autosaving__; end
  def autosaved?; end
  def changed_for_autosave?(doc); end
  def self.define_autosave!(association); end
  extend ActiveSupport::Concern
end
module Mongoid::Association::Referenced::CounterCache
  def reset_counters(*counters); end
  def self.define_callbacks!(association); end
  extend ActiveSupport::Concern
end
module Mongoid::Association::Referenced::CounterCache::ClassMethods
  def decrement_counter(counter_name, id); end
  def increment_counter(counter_name, id); end
  def reset_counters(id, *counters); end
  def update_counters(id, counters); end
end
module Mongoid::Association::Referenced::Syncable
  def _syncable?(association); end
  def _synced; end
  def _synced?(foreign_key); end
  def remove_inverse_keys(association); end
  def update_inverse_keys(association); end
end
module Mongoid::Association::Referenced::Syncable::ClassMethods
  def _synced(association); end
  def synced_destroy(association); end
  def synced_save(association); end
end
class Mongoid::Association::Referenced::BelongsTo
  def create_foreign_key_field!; end
  def default_foreign_key_field; end
  def default_primary_key; end
  def determine_inverses(other); end
  def embedded?; end
  def foreign_key; end
  def index_spec; end
  def inverse_type; end
  def nested_builder(attributes, options); end
  def path(document); end
  def polymorph!; end
  def polymorphic?; end
  def polymorphic_inverses(other = nil); end
  def relation; end
  def relation_complements; end
  def require_association?; end
  def setup!; end
  def setup_instance_methods!; end
  def stores_foreign_key?; end
  def validation_default; end
  include Mongoid::Association::Referenced::BelongsTo::Buildable
  include Mongoid::Association::Relatable
end
class Mongoid::Association::Referenced::BelongsTo::Binding
  def bind_one; end
  def check_polymorphic_inverses!(doc); end
  def unbind_one; end
  include Mongoid::Association::Bindable
end
module Mongoid::Association::Referenced::BelongsTo::Buildable
  def build(base, object, type = nil, selected_fields = nil); end
  def execute_query(object, type); end
  def query?(object); end
  def query_criteria(object, type); end
end
class Mongoid::Association::Referenced::BelongsTo::Proxy < Mongoid::Association::One
  def binding; end
  def initialize(base, target, association); end
  def normalize(replacement); end
  def nullify; end
  def persistable?; end
  def self.eager_loader(association, docs); end
  def self.embedded?; end
  def substitute(replacement); end
  include Mongoid::Evolvable
end
class Mongoid::Association::Referenced::BelongsTo::Eager < Mongoid::Association::Referenced::Eager::Base
  def each_loaded_document(&block); end
  def group_by_key; end
  def key; end
  def keys_by_type_from_docs; end
  def preload; end
end
class Mongoid::Association::Referenced::HasMany
  def add_polymorphic_criterion(criteria, object_class); end
  def bindable?(doc); end
  def criteria(base); end
  def default_foreign_key_field; end
  def default_primary_key; end
  def determine_inverses(other); end
  def embedded?; end
  def foreign_key; end
  def nested_builder(attributes, options); end
  def path(document); end
  def polymorphic?; end
  def polymorphic_inverses(other); end
  def query_criteria(object, base); end
  def relation; end
  def relation_complements; end
  def setup!; end
  def setup_instance_methods!; end
  def stores_foreign_key?; end
  def type; end
  def validation_default; end
  def with_inverse_field_criterion(criteria); end
  def with_ordering(criteria); end
  def with_polymorphic_criterion(criteria, base); end
  include Mongoid::Association::Referenced::HasMany::Buildable
  include Mongoid::Association::Relatable
end
class Mongoid::Association::Referenced::HasMany::Binding
  def bind_one(doc); end
  def unbind_one(doc); end
  include Mongoid::Association::Bindable
end
module Mongoid::Association::Referenced::HasMany::Buildable
  def build(base, object, type = nil, selected_fields = nil); end
  def query?(object); end
end
class Mongoid::Association::Referenced::HasMany::Proxy < Mongoid::Association::Many
  def <<(*args); end
  def already_related?(document); end
  def append(document); end
  def binding; end
  def build(attributes = nil, type = nil); end
  def cascade!(document); end
  def clear; end
  def collection; end
  def concat(documents); end
  def count(*args, &block); end
  def criteria; end
  def delete(document); end
  def delete_all(conditions = nil); end
  def destroy_all(conditions = nil); end
  def each; end
  def exists?; end
  def find(*args); end
  def first(*args, &block); end
  def in_memory(*args, &block); end
  def initialize(base, target, association); end
  def last(*args, &block); end
  def method_missing(name, *args, &block); end
  def new(attributes = nil, type = nil); end
  def nullify; end
  def nullify_all; end
  def persist_delayed(docs, inserts); end
  def persistable?; end
  def purge; end
  def push(*args); end
  def remove_all(conditions = nil, method = nil); end
  def remove_not_in(ids); end
  def reset(*args, &block); end
  def save_or_delay(doc, docs, inserts); end
  def self.eager_loader(association, docs); end
  def self.embedded?; end
  def substitute(replacement); end
  def uniq(*args, &block); end
  def unscoped; end
  def with_add_callbacks(document, already_related); end
  extend Forwardable
end
module Mongoid::Association::Referenced::HasMany::Targets
end
class Mongoid::Association::Referenced::HasMany::Targets::Enumerable
  def <<(document); end
  def ==(other); end
  def ===(other); end
  def _added; end
  def _added=(arg0); end
  def _loaded; end
  def _loaded=(arg0); end
  def _loaded?; end
  def _unloaded; end
  def _unloaded=(arg0); end
  def any?(*args); end
  def as_json(options = nil); end
  def clear; end
  def clone; end
  def delete(document); end
  def delete_if(&block); end
  def each; end
  def empty?; end
  def first(opts = nil); end
  def in_memory; end
  def include?(doc); end
  def initialize(target, base = nil, association = nil); end
  def inspect; end
  def is_a?(*args, &block); end
  def kind_of?(*args, &block); end
  def last(opts = nil); end
  def length; end
  def load_all!(*arg0); end
  def marshal_dump; end
  def marshal_load(data); end
  def method_missing(name, *args, &block); end
  def push(document); end
  def reset; end
  def reset_unloaded(criteria); end
  def respond_to?(name, include_private = nil); end
  def set_base(document); end
  def size; end
  def to_json(options = nil); end
  def uniq; end
  def unloaded_documents; end
  extend Forwardable
  include Enumerable
end
class Mongoid::Association::Referenced::HasMany::Eager < Mongoid::Association::Referenced::Eager::Base
  def group_by_key; end
  def key; end
  def preload; end
  def set_relation(doc, element); end
end
class Mongoid::Association::Referenced::HasAndBelongsToMany
  def bindable?(doc); end
  def create_foreign_key_field!; end
  def criteria(base, id_list = nil); end
  def default_foreign_key_field; end
  def default_primary_key; end
  def determine_inverses(other); end
  def embedded?; end
  def forced_nil_inverse?; end
  def foreign_key; end
  def index_spec; end
  def inverse_foreign_key; end
  def inverse_foreign_key_setter; end
  def nested_builder(attributes, options); end
  def path(document); end
  def query_criteria(id_list); end
  def relation; end
  def relation_complements; end
  def setup!; end
  def setup_instance_methods!; end
  def setup_syncing!; end
  def stores_foreign_key?; end
  def synced_destroy; end
  def synced_save; end
  def validation_default; end
  def with_ordering(criteria); end
  include Mongoid::Association::Referenced::HasAndBelongsToMany::Buildable
  include Mongoid::Association::Relatable
end
class Mongoid::Association::Referenced::HasAndBelongsToMany::Binding
  def bind_one(doc); end
  def determine_inverse_association(doc); end
  def inverse_record_id(doc); end
  def unbind_one(doc); end
  include Mongoid::Association::Bindable
end
module Mongoid::Association::Referenced::HasAndBelongsToMany::Buildable
  def build(base, object, type = nil, selected_fields = nil); end
  def query?(object); end
end
class Mongoid::Association::Referenced::HasAndBelongsToMany::Proxy < Mongoid::Association::Referenced::HasMany::Proxy
  def <<(*args); end
  def append(document); end
  def binding; end
  def build(attributes = nil, type = nil); end
  def child_persistable?(doc); end
  def clear(replacement = nil); end
  def concat(documents); end
  def criteria(id_list = nil); end
  def delete(document); end
  def new(attributes = nil, type = nil); end
  def nullify(replacement = nil); end
  def nullify_all(replacement = nil); end
  def purge(replacement = nil); end
  def push(*args); end
  def self.eager_loader(association, docs); end
  def self.embedded?; end
  def substitute(replacement); end
  def unscoped; end
  def unsynced(doc, key); end
end
class Mongoid::Association::Referenced::HasAndBelongsToMany::Eager < Mongoid::Association::Referenced::Eager::Base
  def group_by_key; end
  def key; end
  def keys_from_docs; end
  def preload; end
  def set_relation(doc, element); end
end
class Mongoid::Association::Referenced::HasOne
  def bindable?(doc); end
  def default_foreign_key_field; end
  def default_primary_key; end
  def determine_inverses(other); end
  def embedded?; end
  def foreign_key; end
  def nested_builder(attributes, options); end
  def path(document); end
  def polymorphic?; end
  def polymorphic_inverses(other); end
  def relation; end
  def relation_complements; end
  def setup!; end
  def setup_instance_methods!; end
  def stores_foreign_key?; end
  def type; end
  def validation_default; end
  include Mongoid::Association::Referenced::HasOne::Buildable
  include Mongoid::Association::Relatable
end
class Mongoid::Association::Referenced::HasOne::Binding
  def bind_one; end
  def unbind_one; end
  include Mongoid::Association::Bindable
end
module Mongoid::Association::Referenced::HasOne::Buildable
  def build(base, object, type = nil, selected_fields = nil); end
  def clear_associated(object); end
  def execute_query(object, base); end
  def query?(object); end
  def query_criteria(object, base); end
  def with_polymorphic_criterion(criteria, base); end
end
class Mongoid::Association::Referenced::HasOne::Proxy < Mongoid::Association::One
  def binding; end
  def initialize(base, target, association); end
  def nullify; end
  def persistable?; end
  def self.eager_loader(association, docs); end
  def self.embedded?; end
  def substitute(replacement); end
end
class Mongoid::Association::Referenced::HasOne::Eager < Mongoid::Association::Referenced::Eager::Base
  def group_by_key; end
  def key; end
  def preload; end
end
module Mongoid::Association::Embedded
end
module Mongoid::Association::Embedded::Cyclic
  extend ActiveSupport::Concern
end
module Mongoid::Association::Embedded::Cyclic::ClassMethods
  def cyclic_child_name(many = nil); end
  def cyclic_parent_name; end
  def recursively_embeds_many(options = nil); end
  def recursively_embeds_one(options = nil); end
end
class Mongoid::Association::Embedded::EmbeddedIn
  def determine_inverses(other); end
  def embedded?; end
  def key; end
  def nested_builder(attributes, options); end
  def polymorphic?; end
  def polymorphic_inverses(other = nil); end
  def primary_key; end
  def relation; end
  def relation_complements; end
  def setup!; end
  def setup_instance_methods!; end
  def stores_foreign_key?; end
  def validation_default; end
  include Mongoid::Association::Embedded::EmbeddedIn::Buildable
  include Mongoid::Association::Relatable
end
class Mongoid::Association::Embedded::EmbeddedIn::Binding
  def bind_one; end
  def unbind_one; end
  include Mongoid::Association::Bindable
end
module Mongoid::Association::Embedded::EmbeddedIn::Buildable
  def build(base, object, type = nil, selected_fields = nil); end
  extend Mongoid::Threaded::Lifecycle::ClassMethods
  include Mongoid::Threaded::Lifecycle
end
class Mongoid::Association::Embedded::EmbeddedIn::Proxy < Mongoid::Association::One
  def binding; end
  def characterize_one(document); end
  def initialize(base, target, association); end
  def persistable?; end
  def self.embedded?; end
  def self.path(document); end
  def substitute(replacement); end
end
class Mongoid::Association::Embedded::EmbedsMany
  def apply_ordering(criteria); end
  def criteria(base, target); end
  def determine_inverses(other); end
  def embedded?; end
  def key; end
  def nested_builder(attributes, options); end
  def path(document); end
  def polymorphic?; end
  def polymorphic_inverses(other = nil); end
  def primary_key; end
  def relation; end
  def relation_complements; end
  def setup!; end
  def setup_instance_methods!; end
  def store_as; end
  def stores_foreign_key?; end
  def type; end
  def validation_default; end
  include Mongoid::Association::Embedded::EmbedsMany::Buildable
  include Mongoid::Association::Relatable
end
class Mongoid::Association::Embedded::EmbedsMany::Binding
  def bind_one(doc); end
  def unbind_one(doc); end
  include Mongoid::Association::Bindable
end
module Mongoid::Association::Embedded::EmbedsMany::Buildable
  def build(base, object, type = nil, selected_fields = nil); end
  extend Mongoid::Threaded::Lifecycle::ClassMethods
  include Mongoid::Threaded::Lifecycle
end
module Mongoid::Association::Embedded::Batchable
  def add_atomic_sets(sets); end
  def batch_clear(docs); end
  def batch_insert(docs); end
  def batch_remove(docs, method = nil); end
  def batch_replace(docs); end
  def execute_batch_push(docs); end
  def execute_batch_set(docs); end
  def insertable?; end
  def inserts_valid; end
  def inserts_valid=(value); end
  def normalize_docs(docs); end
  def path; end
  def path=(value); end
  def post_process_batch_insert(docs); end
  def post_process_batch_remove(docs, method); end
  def pre_process_batch_insert(docs); end
  def pre_process_batch_remove(docs, method); end
  def selector; end
  include Mongoid::Positional
end
class Mongoid::Association::Embedded::EmbedsMany::Proxy < Mongoid::Association::Many
  def <<(*args); end
  def _unscoped; end
  def _unscoped=(docs); end
  def append(document); end
  def as_attributes; end
  def as_document; end
  def binding; end
  def build(attributes = nil, type = nil); end
  def clear; end
  def concat(docs); end
  def count; end
  def criteria; end
  def delete(document); end
  def delete_all(conditions = nil); end
  def delete_if; end
  def delete_one(document); end
  def destroy_all(conditions = nil); end
  def exists?; end
  def find(*args); end
  def in_memory; end
  def initialize(base, target, association); end
  def integrate(document); end
  def method_missing(name, *args, &block); end
  def new(attributes = nil, type = nil); end
  def object_already_related?(document); end
  def persistable?; end
  def pop(count = nil); end
  def push(*args); end
  def reindex; end
  def remove_all(conditions = nil, method = nil); end
  def scope(docs); end
  def self.embedded?; end
  def self.foreign_key_suffix; end
  def shift(count = nil); end
  def substitute(docs); end
  def unscoped; end
  include Mongoid::Association::Embedded::Batchable
end
class Mongoid::Association::Embedded::EmbedsOne
  def determine_inverses(other); end
  def embedded?; end
  def key; end
  def nested_builder(attributes, options); end
  def polymorphic?; end
  def polymorphic_inverses(other = nil); end
  def primary_key; end
  def relation; end
  def relation_complements; end
  def setup!; end
  def setup_instance_methods!; end
  def store_as; end
  def stores_foreign_key?; end
  def type; end
  def validation_default; end
  include Mongoid::Association::Embedded::EmbedsOne::Buildable
  include Mongoid::Association::Relatable
end
class Mongoid::Association::Embedded::EmbedsOne::Binding
  def bind_one; end
  def unbind_one; end
  include Mongoid::Association::Bindable
end
module Mongoid::Association::Embedded::EmbedsOne::Buildable
  def build(base, object, _type = nil, selected_fields = nil); end
  extend Mongoid::Threaded::Lifecycle::ClassMethods
  include Mongoid::Threaded::Lifecycle
end
class Mongoid::Association::Embedded::EmbedsOne::Proxy < Mongoid::Association::One
  def binding; end
  def initialize(base, target, association); end
  def persistable?; end
  def self.embedded?; end
  def self.path(document); end
  def substitute(replacement); end
end
module Mongoid::Association::Macros
  def associations; end
  extend ActiveSupport::Concern
end
module Mongoid::Association::Macros::ClassMethods
  def belongs_to(name, options = nil, &block); end
  def define_association!(macro_name, name, options = nil, &block); end
  def embedded_in(name, options = nil, &block); end
  def embeds_many(name, options = nil, &block); end
  def embeds_one(name, options = nil, &block); end
  def has_and_belongs_to_many(name, options = nil, &block); end
  def has_many(name, options = nil, &block); end
  def has_one(name, options = nil, &block); end
end
module Mongoid::Association::Reflections
  def reflect_on_all_association(*macros); end
  def reflect_on_association(name); end
  extend ActiveSupport::Concern
end
module Mongoid::Association::Reflections::ClassMethods
  def reflect_on_all_associations(*macros); end
  def reflect_on_association(name); end
end
module Mongoid::Changeable
  def attribute_change(attr); end
  def attribute_changed?(attr); end
  def attribute_changed_from_default?(attr); end
  def attribute_was(attr); end
  def attribute_will_change!(attr); end
  def changed; end
  def changed?; end
  def changed_attributes; end
  def changes; end
  def children_changed?; end
  def move_changes; end
  def post_persist; end
  def previous_changes; end
  def remove_change(name); end
  def reset_attribute!(attr); end
  def reset_attribute_to_default!(attr); end
  def setters; end
  extend ActiveSupport::Concern
end
module Mongoid::Changeable::ClassMethods
  def create_dirty_change_accessor(name, meth); end
  def create_dirty_change_check(name, meth); end
  def create_dirty_change_flag(name, meth); end
  def create_dirty_default_change_check(name, meth); end
  def create_dirty_methods(name, meth); end
  def create_dirty_previous_change(name, meth); end
  def create_dirty_previous_value_accessor(name, meth); end
  def create_dirty_previously_changed?(name, meth); end
  def create_dirty_reset(name, meth); end
  def create_dirty_reset_to_default(name, meth); end
end
module Mongoid::Findable
  def aggregates(*args, &block); end
  def all(*args, &block); end
  def all_in(*args, &block); end
  def all_of(*args, &block); end
  def and(*args, &block); end
  def any_in(*args, &block); end
  def any_of(*args, &block); end
  def asc(*args, &block); end
  def ascending(*args, &block); end
  def avg(*args, &block); end
  def batch_size(*args, &block); end
  def between(*args, &block); end
  def collation(*args, &block); end
  def comment(*args, &block); end
  def count; end
  def create_with(*args, &block); end
  def cursor_type(*args, &block); end
  def desc(*args, &block); end
  def descending(*args, &block); end
  def distinct(*args, &block); end
  def each(*args, &block); end
  def each_with_index(*args, &block); end
  def elem_match(*args, &block); end
  def empty?; end
  def estimated_count; end
  def excludes(*args, &block); end
  def exists(*args, &block); end
  def exists?; end
  def extras(*args, &block); end
  def find(*args); end
  def find_by!(attrs = nil); end
  def find_by(attrs = nil); end
  def find_one_and_delete(*args, &block); end
  def find_one_and_replace(*args, &block); end
  def find_one_and_update(*args, &block); end
  def find_or_create_by!(*args, &block); end
  def find_or_create_by(*args, &block); end
  def find_or_initialize_by(*args, &block); end
  def first; end
  def first_or_create!(*args, &block); end
  def first_or_create(*args, &block); end
  def first_or_initialize(*args, &block); end
  def for_js(*args, &block); end
  def geo_near(*args, &block); end
  def geo_spacial(*args, &block); end
  def geo_spatial(*args, &block); end
  def gt(*args, &block); end
  def gte(*args, &block); end
  def hint(*args, &block); end
  def in(*args, &block); end
  def includes(*args, &block); end
  def last; end
  def limit(*args, &block); end
  def lt(*args, &block); end
  def lte(*args, &block); end
  def map_reduce(*args, &block); end
  def max(*args, &block); end
  def max_distance(*args, &block); end
  def max_scan(*args, &block); end
  def max_time_ms(*args, &block); end
  def min(*args, &block); end
  def mod(*args, &block); end
  def ne(*args, &block); end
  def near(*args, &block); end
  def near_sphere(*args, &block); end
  def nin(*args, &block); end
  def no_timeout(*args, &block); end
  def none(*args, &block); end
  def nor(*args, &block); end
  def not(*args, &block); end
  def not_in(*args, &block); end
  def offset(*args, &block); end
  def one; end
  def only(*args, &block); end
  def or(*args, &block); end
  def order(*args, &block); end
  def order_by(*args, &block); end
  def pluck(*args, &block); end
  def read(*args, &block); end
  def reorder(*args, &block); end
  def skip(*args, &block); end
  def slice(*args, &block); end
  def snapshot(*args, &block); end
  def sum(*args, &block); end
  def text_search(*args, &block); end
  def update(*args, &block); end
  def update_all(*args, &block); end
  def where(*args, &block); end
  def with_size(*args, &block); end
  def with_type(*args, &block); end
  def without(*args, &block); end
  extend Forwardable
end
module Mongoid::Indexable
  extend ActiveSupport::Concern
end
class Mongoid::Indexable::Specification
  def ==(other); end
  def fields; end
  def initialize(klass, key, opts = nil); end
  def key; end
  def klass; end
  def name; end
  def normalize_key(key); end
  def normalize_options(opts); end
  def options; end
end
module Mongoid::Indexable::Validators
end
module Mongoid::Indexable::Validators::Options
  def validate(klass, spec, options); end
  def validate_options(klass, spec, options); end
  def validate_spec(klass, spec, options); end
  extend Mongoid::Indexable::Validators::Options
end
module Mongoid::Indexable::ClassMethods
  def add_indexes; end
  def create_indexes; end
  def index(spec, options = nil); end
  def index_keys; end
  def index_specification(index_hash, index_name = nil); end
  def indexed_database_names; end
  def remove_indexes; end
end
module Mongoid::Inspectable
  def inspect; end
  def inspect_dynamic_fields; end
  def inspect_fields; end
end
module Mongoid::Interceptable
  def before_callback_halted?; end
  def callback_executable?(kind); end
  def cascadable_child?(kind, child, association); end
  def cascadable_children(kind, children = nil); end
  def child_callback_type(kind, child); end
  def halted_callback_hook(filter); end
  def in_callback_state?(kind); end
  def run_after_callbacks(*kinds); end
  def run_before_callbacks(*kinds); end
  def run_callbacks(kind, *args, &block); end
  def run_targeted_callbacks(place, kind); end
  extend ActiveSupport::Concern
end
module Mongoid::Matcher
  def extract_attribute(document, key); end
  def self.extract_attribute(document, key); end
end
module Mongoid::Matcher::All
  def matches?(exists, value, condition); end
  def self.matches?(exists, value, condition); end
end
module Mongoid::Matcher::And
  def matches?(document, expr); end
  def self.matches?(document, expr); end
end
module Mongoid::Matcher::ElemMatch
  def matches?(exists, value, condition); end
  def self.matches?(exists, value, condition); end
end
module Mongoid::Matcher::ElemMatchExpression
  def matches?(document, expr); end
  def self.matches?(document, expr); end
end
module Mongoid::Matcher::Eq
  def matches?(exists, value, condition); end
  def self.matches?(exists, value, condition); end
end
module Mongoid::Matcher::EqImpl
  def matches?(exists, value, condition, original_operator); end
  def self.matches?(exists, value, condition, original_operator); end
end
module Mongoid::Matcher::EqImplWithRegexp
  def matches?(original_operator, value, condition); end
  def self.matches?(original_operator, value, condition); end
end
module Mongoid::Matcher::Exists
  def matches?(exists, value, condition); end
  def self.matches?(exists, value, condition); end
end
module Mongoid::Matcher::Expression
  def matches?(document, expr); end
  def self.matches?(document, expr); end
end
module Mongoid::Matcher::FieldExpression
  def matches?(exists, value, condition); end
  def self.matches?(exists, value, condition); end
end
module Mongoid::Matcher::Gt
  def matches?(exists, value, condition); end
  def self.matches?(exists, value, condition); end
end
module Mongoid::Matcher::Gte
  def matches?(exists, value, condition); end
  def self.matches?(exists, value, condition); end
end
module Mongoid::Matcher::In
  def matches?(exists, value, condition); end
  def self.matches?(exists, value, condition); end
end
module Mongoid::Matcher::Lt
  def matches?(exists, value, condition); end
  def self.matches?(exists, value, condition); end
end
module Mongoid::Matcher::Lte
  def matches?(exists, value, condition); end
  def self.matches?(exists, value, condition); end
end
module Mongoid::Matcher::Ne
  def matches?(exists, value, condition); end
  def self.matches?(exists, value, condition); end
end
module Mongoid::Matcher::Nin
  def matches?(exists, value, condition); end
  def self.matches?(exists, value, condition); end
end
module Mongoid::Matcher::Nor
  def matches?(document, expr); end
  def self.matches?(document, expr); end
end
module Mongoid::Matcher::Not
  def matches?(exists, value, condition); end
  def self.matches?(exists, value, condition); end
end
module Mongoid::Matcher::Or
  def matches?(document, expr); end
  def self.matches?(document, expr); end
end
module Mongoid::Matcher::Regex
  def matches?(exists, value, condition); end
  def matches_array_or_scalar?(value, condition); end
  def self.matches?(exists, value, condition); end
  def self.matches_array_or_scalar?(value, condition); end
end
module Mongoid::Matcher::Size
  def matches?(exists, value, condition); end
  def self.matches?(exists, value, condition); end
end
module Mongoid::Matcher::ExpressionOperator
  def get(op); end
  def self.get(op); end
end
module Mongoid::Matcher::FieldOperator
  def apply_array_field_operator(exists, value, condition); end
  def apply_comparison_operator(operator, left, right); end
  def get(op); end
  def self.apply_array_field_operator(exists, value, condition); end
  def self.apply_comparison_operator(operator, left, right); end
  def self.get(op); end
end
module Mongoid::Matchable
  def _matches?(selector); end
  extend ActiveSupport::Concern
end
module Mongoid::Persistable
  def _mongoid_atomic_context_changed_fields; end
  def _mongoid_pop_atomic_context; end
  def _mongoid_push_atomic_context; end
  def _mongoid_remove_atomic_context_changes; end
  def _mongoid_reset_atomic_context_changes!; end
  def atomically(join_context: nil); end
  def executing_atomically?; end
  def fail_due_to_callback!(method); end
  def fail_due_to_validation!; end
  def persist_atomic_operations(operations); end
  def persist_or_delay_atomic_operation(operation); end
  def post_process_persist(result, options = nil); end
  def prepare_atomic_operation; end
  def process_atomic_operations(operations); end
  extend ActiveSupport::Concern
  include Mongoid::Persistable::Creatable
  include Mongoid::Persistable::Deletable
  include Mongoid::Persistable::Destroyable
  include Mongoid::Persistable::Incrementable
  include Mongoid::Persistable::Logical
  include Mongoid::Persistable::Poppable
  include Mongoid::Persistable::Pullable
  include Mongoid::Persistable::Pushable
  include Mongoid::Persistable::Renamable
  include Mongoid::Persistable::Savable
  include Mongoid::Persistable::Settable
  include Mongoid::Persistable::Unsettable
  include Mongoid::Persistable::Updatable
  include Mongoid::Persistable::Upsertable
  include Mongoid::Positional
end
module Mongoid::Persistable::Creatable
  def atomic_inserts; end
  def insert(options = nil); end
  def insert_as_embedded; end
  def insert_as_root; end
  def post_process_insert; end
  def prepare_insert(options = nil); end
  extend ActiveSupport::Concern
end
module Mongoid::Persistable::Creatable::ClassMethods
  def create!(attributes = nil, &block); end
  def create(attributes = nil, &block); end
end
module Mongoid::Persistable::Deletable
  def atomic_deletes; end
  def delete(options = nil); end
  def delete_as_embedded(options = nil); end
  def delete_as_root; end
  def notifying_parent?(options = nil); end
  def prepare_delete; end
  def remove(options = nil); end
  extend ActiveSupport::Concern
end
module Mongoid::Persistable::Deletable::ClassMethods
  def delete_all(conditions = nil); end
end
module Mongoid::Persistable::Destroyable
  def destroy!(options = nil); end
  def destroy(options = nil); end
  extend ActiveSupport::Concern
end
module Mongoid::Persistable::Destroyable::ClassMethods
  def destroy_all(conditions = nil); end
end
module Mongoid::Persistable::Incrementable
  def inc(increments); end
  extend ActiveSupport::Concern
end
module Mongoid::Persistable::Logical
  def bit(operations); end
  extend ActiveSupport::Concern
end
module Mongoid::Persistable::Poppable
  def pop(pops); end
  extend ActiveSupport::Concern
end
module Mongoid::Persistable::Pullable
  def pull(pulls); end
  def pull_all(pulls); end
  extend ActiveSupport::Concern
end
module Mongoid::Persistable::Pushable
  def add_to_set(adds); end
  def push(pushes); end
  extend ActiveSupport::Concern
end
module Mongoid::Persistable::Renamable
  def rename(renames); end
  extend ActiveSupport::Concern
end
module Mongoid::Persistable::Savable
  def save!(options = nil); end
  def save(options = nil); end
end
module Mongoid::Persistable::Settable
  def set(setters); end
  extend ActiveSupport::Concern
end
module Mongoid::Persistable::Updatable
  def init_atomic_updates; end
  def prepare_update(options = nil); end
  def update!(attributes = nil); end
  def update(attributes = nil); end
  def update_attribute(name, value); end
  def update_attributes!(attributes = nil); end
  def update_attributes(attributes = nil); end
  def update_document(options = nil); end
end
module Mongoid::Persistable::Upsertable
  def prepare_upsert(options = nil); end
  def upsert(options = nil); end
end
module Mongoid::Persistable::Unsettable
  def unset(*fields); end
  extend ActiveSupport::Concern
end
module Mongoid::Reloadable
  def _reload; end
  def extract_embedded_attributes(attributes); end
  def reload; end
  def reload_embedded_document; end
  def reload_root_document; end
end
module Mongoid::Selectable
  def atomic_selector; end
  def embedded_atomic_selector; end
  def root_atomic_selector; end
  extend ActiveSupport::Concern
end
module Mongoid::Scopable
  def apply_default_scoping; end
  extend ActiveSupport::Concern
end
module Mongoid::Scopable::ClassMethods
  def check_scope_name(name); end
  def check_scope_validity(value); end
  def criteria; end
  def default_scopable?; end
  def default_scope(value = nil); end
  def define_scope_method(name); end
  def process_default_scope(value); end
  def queryable; end
  def scope(name, value, &block); end
  def scoped(options = nil); end
  def scopes; end
  def unscoped; end
  def with_default_scope; end
  def with_scope(criteria); end
  def without_default_scope; end
end
module Mongoid::Serializable
  def field_names(options); end
  def relation_names(inclusions); end
  def relation_options(inclusions, options, name); end
  def serializable_hash(options = nil); end
  def serialize_attribute(attrs, name, names, options); end
  def serialize_relations(attributes = nil, options = nil); end
  extend ActiveSupport::Concern
end
module Mongoid::Shardable
  def shard_key_fields; end
  def shard_key_selector; end
  extend ActiveSupport::Concern
end
module Mongoid::Shardable::ClassMethods
  def shard_key(*args); end
end
module Mongoid::Stateful
  def _destroy; end
  def destroyed=(arg0); end
  def destroyed?; end
  def flagged_for_destroy=(arg0); end
  def flagged_for_destroy?; end
  def marked_for_destruction?; end
  def new_record=(arg0); end
  def new_record?; end
  def persisted?; end
  def pushable?; end
  def readonly?; end
  def reset_readonly; end
  def settable?; end
  def updateable?; end
end
module Mongoid::Cacheable
  def cache_key; end
  extend ActiveSupport::Concern
end
module Mongoid::Traversable
  def _children; end
  def _parent; end
  def _parent=(p); end
  def _reset_memoized_children!; end
  def _root; end
  def _root?; end
  def collect_children; end
  def flag_children_persisted; end
  def hereditary?; end
  def parentize(document); end
  def remove_child(child); end
  def reset_persisted_children; end
  extend ActiveSupport::Concern
end
module Mongoid::Traversable::DiscriminatorAssignment
  def discriminator_key=(value); end
  def discriminator_value=(value); end
end
module Mongoid::Traversable::DiscriminatorRetrieval
  def discriminator_value; end
end
module Mongoid::Traversable::ClassMethods
  def hereditary?; end
  def inherited(subclass); end
end
module Mongoid::Validatable
  def begin_validate; end
  def exit_validate; end
  def performing_validations?(options = nil); end
  def read_attribute_for_validation(attr); end
  def valid?(context = nil); end
  def validated?; end
  def validating_with_query?; end
  extend ActiveSupport::Concern
end
module Mongoid::Validatable::Macros
  def validates_associated(*args); end
  def validates_format_of(*args); end
  def validates_length_of(*args); end
  def validates_presence_of(*args); end
  def validates_uniqueness_of(*args); end
  extend ActiveSupport::Concern
end
module Mongoid::Validatable::Localizable
  def validate_each(document, attribute, value); end
end
class Mongoid::Validatable::AssociatedValidator < ActiveModel::EachValidator
  def validate_each(document, attribute, value); end
end
class Mongoid::Validatable::FormatValidator < ActiveModel::Validations::FormatValidator
  include Mongoid::Validatable::Localizable
end
class Mongoid::Validatable::LengthValidator < ActiveModel::Validations::LengthValidator
  include Mongoid::Validatable::Localizable
end
module Mongoid::Validatable::Queryable
  def with_query(document); end
end
class Mongoid::Validatable::PresenceValidator < ActiveModel::EachValidator
  def not_present?(value); end
  def relation_or_fk_missing?(doc, attr, value); end
  def validate_each(document, attribute, value); end
end
class Mongoid::Validatable::UniquenessValidator < ActiveModel::EachValidator
  def add_error(document, attribute, value); end
  def case_sensitive?; end
  def create_criteria(base, document, attribute, value); end
  def criterion(document, attribute, value); end
  def filter(value); end
  def localized?(document, attribute); end
  def scope(criteria, document, _attribute); end
  def scope_value_changed?(document); end
  def skip_validation?(document); end
  def to_validate(document, attribute, value); end
  def validate_each(document, attribute, value); end
  def validate_embedded(document, attribute, value); end
  def validate_root(document, attribute, value); end
  def validation_required?(document, attribute); end
  include Mongoid::Validatable::Queryable
end
module Mongoid::Validatable::ClassMethods
  def validates_relation(association); end
  def validates_with(*args, &block); end
  def validating_with_query?; end
end
module Mongoid::Composable
  def self.prohibited_methods; end
  extend ActiveSupport::Concern
  include ActiveModel::ForbiddenAttributesProtection
  include ActiveModel::Model
  include ActiveModel::Serializers::JSON
  include Mongoid::Association
  include Mongoid::Atomic
  include Mongoid::Attributes
  include Mongoid::Cacheable
  include Mongoid::Changeable
  include Mongoid::Clients
  include Mongoid::Copyable
  include Mongoid::Equality
  include Mongoid::Evolvable
  include Mongoid::Fields
  include Mongoid::Indexable
  include Mongoid::Inspectable
  include Mongoid::Interceptable
  include Mongoid::Matchable
  include Mongoid::Persistable
  include Mongoid::Reloadable
  include Mongoid::Scopable
  include Mongoid::Selectable
  include Mongoid::Serializable
  include Mongoid::Shardable
  include Mongoid::Stateful
  include Mongoid::Threaded::Lifecycle
  include Mongoid::Traversable
  include Mongoid::Validatable
end
module Mongoid::Touchable
  def define_relation_touch_method(name, association); end
  def define_touchable!(association); end
  extend Mongoid::Touchable
end
module Mongoid::Touchable::InstanceMethods
  def touch(field = nil); end
end
module Mongoid::Document
  def __selected_fields; end
  def __selected_fields=(arg0); end
  def as_attributes; end
  def as_document; end
  def as_json(options = nil); end
  def becomes(klass); end
  def freeze; end
  def frozen?; end
  def hash; end
  def identity; end
  def initialize(attrs = nil); end
  def logger; end
  def model_key; end
  def model_name; end
  def new_record; end
  def to_a; end
  def to_ary; end
  def to_key; end
  extend ActiveSupport::Concern
  include Mongoid::Composable
  include Mongoid::Touchable::InstanceMethods
end
module Mongoid::Document::ClassMethods
  def ===(other); end
  def _mongoid_clear_types; end
  def _types; end
  def i18n_scope; end
  def instantiate(attrs = nil, selected_fields = nil); end
  def logger; end
end
module Mongoid::Tasks
end
module Mongoid::Tasks::Database
  def create_indexes(models = nil); end
  def logger; end
  def remove_indexes(models = nil); end
  def remove_undefined_indexes(models = nil); end
  def shard_collections(models = nil); end
  def undefined_indexes(models = nil); end
  extend Mongoid::Tasks::Database
end
module Mongoid::QueryCache
  def self.cache(&block); end
  def self.cache_table; end
  def self.clear_cache; end
  def self.enabled=(value); end
  def self.enabled?; end
  def self.uncached(&block); end
end
class Mongoid::QueryCache::Middleware
  def call(env); end
  def initialize(app); end
end
class Mongoid::QueryCache::CachedCursor < Mongo::Cursor
  def each; end
  def inspect; end
  def process(result); end
end
module Mongoid::QueryCache::Base
  def alias_query_cache_clear(*method_names); end
end
module Mongoid::QueryCache::View
  def cache_key; end
  def cached_cursor; end
  def each; end
  def system_collection?; end
  extend ActiveSupport::Concern
end
module Mongoid::QueryCache::Collection
  extend ActiveSupport::Concern
end
module Mongoid::QueryCache::Document
  def reload; end
end
module Rails
end
module Rails::Mongoid
  def load_model(file); end
  def load_models(app); end
  def preload_models(app); end
  extend Rails::Mongoid
end
class Rails::Mongoid::Railtie < Rails::Railtie
  def handle_configuration_error(e); end
  def self.rescue_responses; end
end
module Mongoid::GlobalDiscriminatorKeyAssignment
  def discriminator_key=(value); end
end
class Mongoid::GlobalDiscriminatorKeyAssignment::InvalidFieldHost
  def ___id_default__; end
  def __callbacks; end
  def __callbacks?; end
  def _build_callbacks; end
  def _create_callbacks; end
  def _declared_scopes; end
  def _declared_scopes=(val); end
  def _declared_scopes?; end
  def _destroy_callbacks; end
  def _find_callbacks; end
  def _index; end
  def _index=(arg0); end
  def _initialize_callbacks; end
  def _run_build_callbacks(&block); end
  def _run_create_callbacks(&block); end
  def _run_destroy_callbacks(&block); end
  def _run_find_callbacks(&block); end
  def _run_initialize_callbacks(&block); end
  def _run_save_callbacks(&block); end
  def _run_touch_callbacks(&block); end
  def _run_update_callbacks(&block); end
  def _run_upsert_callbacks(&block); end
  def _run_validate_callbacks(&block); end
  def _run_validation_callbacks(&block); end
  def _save_callbacks; end
  def _touch_callbacks; end
  def _update_callbacks; end
  def _upsert_callbacks; end
  def _validate_callbacks; end
  def _validation_callbacks; end
  def _validators; end
  def _validators?; end
  def aliased_fields; end
  def aliased_fields=(val); end
  def aliased_fields?; end
  def before_callback_halted; end
  def before_callback_halted=(arg0); end
  def cache_timestamp_format; end
  def cyclic; end
  def cyclic=(val); end
  def cyclic?; end
  def default_scoping; end
  def default_scoping=(val); end
  def default_scoping?; end
  def dependents; end
  def dependents=(val); end
  def dependents?; end
  def dependents_owner; end
  def dependents_owner=(val); end
  def dependents_owner?; end
  def embedded=(val); end
  def embedded_relations; end
  def embedded_relations=(val); end
  def embedded_relations?; end
  def fields; end
  def fields=(val); end
  def fields?; end
  def id; end
  def id=(value); end
  def include_root_in_json; end
  def include_root_in_json?; end
  def index_specifications; end
  def index_specifications=(obj); end
  def localized_fields; end
  def localized_fields=(val); end
  def localized_fields?; end
  def model_name(*args, &block); end
  def nested_attributes; end
  def nested_attributes=(val); end
  def nested_attributes?; end
  def polymorphic; end
  def polymorphic=(val); end
  def polymorphic?; end
  def post_processed_defaults; end
  def post_processed_defaults=(val); end
  def post_processed_defaults?; end
  def pre_processed_defaults; end
  def pre_processed_defaults=(val); end
  def pre_processed_defaults?; end
  def readonly_attributes; end
  def readonly_attributes=(val); end
  def readonly_attributes?; end
  def relations; end
  def relations=(val); end
  def relations?; end
  def self.__callbacks; end
  def self.__callbacks=(val); end
  def self.__callbacks?; end
  def self._build_callbacks; end
  def self._build_callbacks=(value); end
  def self._create_callbacks; end
  def self._create_callbacks=(value); end
  def self._declared_scopes; end
  def self._declared_scopes=(val); end
  def self._declared_scopes?; end
  def self._destroy_callbacks; end
  def self._destroy_callbacks=(value); end
  def self._find_callbacks; end
  def self._find_callbacks=(value); end
  def self._initialize_callbacks; end
  def self._initialize_callbacks=(value); end
  def self._save_callbacks; end
  def self._save_callbacks=(value); end
  def self._touch_callbacks; end
  def self._touch_callbacks=(value); end
  def self._update_callbacks; end
  def self._update_callbacks=(value); end
  def self._upsert_callbacks; end
  def self._upsert_callbacks=(value); end
  def self._validate_callbacks; end
  def self._validate_callbacks=(value); end
  def self._validation_callbacks; end
  def self._validation_callbacks=(value); end
  def self._validators; end
  def self._validators=(val); end
  def self._validators?; end
  def self.add_discriminator_mapping(value, klass = nil); end
  def self.after_build(*args, **options, &block); end
  def self.after_create(*args, **options, &block); end
  def self.after_destroy(*args, **options, &block); end
  def self.after_find(*args, **options, &block); end
  def self.after_initialize(*args, **options, &block); end
  def self.after_save(*args, **options, &block); end
  def self.after_touch(*args, **options, &block); end
  def self.after_update(*args, **options, &block); end
  def self.after_upsert(*args, **options, &block); end
  def self.aliased_fields; end
  def self.aliased_fields=(val); end
  def self.aliased_fields?; end
  def self.around_create(*args, **options, &block); end
  def self.around_destroy(*args, **options, &block); end
  def self.around_save(*args, **options, &block); end
  def self.around_update(*args, **options, &block); end
  def self.around_upsert(*args, **options, &block); end
  def self.before_create(*args, **options, &block); end
  def self.before_destroy(*args, **options, &block); end
  def self.before_save(*args, **options, &block); end
  def self.before_update(*args, **options, &block); end
  def self.before_upsert(*args, **options, &block); end
  def self.cache_timestamp_format; end
  def self.cache_timestamp_format=(obj); end
  def self.cyclic; end
  def self.cyclic=(val); end
  def self.cyclic?; end
  def self.default_scoping; end
  def self.default_scoping=(val); end
  def self.default_scoping?; end
  def self.dependents; end
  def self.dependents=(val); end
  def self.dependents?; end
  def self.dependents_owner; end
  def self.dependents_owner=(val); end
  def self.dependents_owner?; end
  def self.discriminator_key(*args, &block); end
  def self.discriminator_key=(value); end
  def self.discriminator_key?; end
  def self.discriminator_mapping; end
  def self.discriminator_mapping=(arg0); end
  def self.embedded; end
  def self.embedded=(val); end
  def self.embedded?; end
  def self.embedded_relations; end
  def self.embedded_relations=(val); end
  def self.embedded_relations?; end
  def self.fields; end
  def self.fields=(val); end
  def self.fields?; end
  def self.get_discriminator_mapping(value); end
  def self.include_root_in_json(*args, &block); end
  def self.include_root_in_json=(val); end
  def self.include_root_in_json?; end
  def self.index_specifications; end
  def self.index_specifications=(obj); end
  def self.localized_fields; end
  def self.localized_fields=(val); end
  def self.localized_fields?; end
  def self.nested_attributes; end
  def self.nested_attributes=(val); end
  def self.nested_attributes?; end
  def self.polymorphic; end
  def self.polymorphic=(val); end
  def self.polymorphic?; end
  def self.post_processed_defaults; end
  def self.post_processed_defaults=(val); end
  def self.post_processed_defaults?; end
  def self.pre_processed_defaults; end
  def self.pre_processed_defaults=(val); end
  def self.pre_processed_defaults?; end
  def self.readonly_attributes; end
  def self.readonly_attributes=(val); end
  def self.readonly_attributes?; end
  def self.relations; end
  def self.relations=(val); end
  def self.relations?; end
  def self.shard_config; end
  def self.shard_config=(obj); end
  def self.shard_key_fields; end
  def self.shard_key_fields=(obj); end
  def self.storage_options; end
  def self.storage_options=(obj); end
  def shard_config; end
  def shard_config=(obj); end
  def shard_key_fields; end
  def shard_key_fields=(obj); end
  def storage_options; end
  def validation_context; end
  def validation_context=(arg0); end
  extend ActiveModel::Callbacks
  extend ActiveModel::Callbacks
  extend ActiveModel::Conversion::ClassMethods
  extend ActiveModel::Naming
  extend ActiveModel::Naming
  extend ActiveModel::Naming
  extend ActiveModel::Translation
  extend ActiveModel::Translation
  extend ActiveModel::Validations::Callbacks::ClassMethods
  extend ActiveModel::Validations::ClassMethods
  extend ActiveModel::Validations::HelperMethods
  extend ActiveSupport::Callbacks::ClassMethods
  extend ActiveSupport::DescendantsTracker
  extend Mongoid::Association::Depending::ClassMethods
  extend Mongoid::Association::Embedded::Cyclic::ClassMethods
  extend Mongoid::Association::Macros::ClassMethods
  extend Mongoid::Association::Referenced::CounterCache::ClassMethods
  extend Mongoid::Association::Referenced::Syncable::ClassMethods
  extend Mongoid::Association::Reflections::ClassMethods
  extend Mongoid::Attributes::ClassMethods
  extend Mongoid::Attributes::Nested::ClassMethods
  extend Mongoid::Attributes::Readonly::ClassMethods
  extend Mongoid::Changeable::ClassMethods
  extend Mongoid::Clients::Options::ClassMethods
  extend Mongoid::Clients::Sessions::ClassMethods
  extend Mongoid::Clients::StorageOptions::ClassMethods
  extend Mongoid::Criteria::Queryable::Extensions::Object::ClassMethods
  extend Mongoid::Criteria::Queryable::Extensions::Object::ClassMethods
  extend Mongoid::Criteria::Queryable::Extensions::Object::ClassMethods
  extend Mongoid::Criteria::Queryable::Extensions::Object::ClassMethods
  extend Mongoid::Criteria::Queryable::Extensions::Object::ClassMethods
  extend Mongoid::Criteria::Queryable::Extensions::Object::ClassMethods
  extend Mongoid::Criteria::Queryable::Extensions::Object::ClassMethods
  extend Mongoid::Criteria::Queryable::Extensions::Object::ClassMethods
  extend Mongoid::Criteria::Queryable::Extensions::Object::ClassMethods
  extend Mongoid::Criteria::Queryable::Extensions::Object::ClassMethods
  extend Mongoid::Criteria::Queryable::Extensions::Object::ClassMethods
  extend Mongoid::Criteria::Queryable::Extensions::Object::ClassMethods
  extend Mongoid::Criteria::Queryable::Extensions::Object::ClassMethods
  extend Mongoid::Criteria::Queryable::Extensions::Object::ClassMethods
  extend Mongoid::Criteria::Queryable::Extensions::Object::ClassMethods
  extend Mongoid::Criteria::Queryable::Extensions::Object::ClassMethods
  extend Mongoid::Criteria::Queryable::Extensions::Object::ClassMethods
  extend Mongoid::Criteria::Queryable::Extensions::Object::ClassMethods
  extend Mongoid::Criteria::Queryable::Extensions::Object::ClassMethods
  extend Mongoid::Criteria::Queryable::Extensions::Object::ClassMethods
  extend Mongoid::Criteria::Queryable::Extensions::Object::ClassMethods
  extend Mongoid::Criteria::Queryable::Extensions::Object::ClassMethods
  extend Mongoid::Criteria::Queryable::Extensions::Object::ClassMethods
  extend Mongoid::Document::ClassMethods
  extend Mongoid::Fields::ClassMethods
  extend Mongoid::Findable
  extend Mongoid::Indexable::ClassMethods
  extend Mongoid::Persistable::Creatable::ClassMethods
  extend Mongoid::Persistable::Deletable::ClassMethods
  extend Mongoid::Persistable::Destroyable::ClassMethods
  extend Mongoid::Scopable::ClassMethods
  extend Mongoid::Shardable::ClassMethods
  extend Mongoid::Threaded::Lifecycle::ClassMethods
  extend Mongoid::Traversable::ClassMethods
  extend Mongoid::Validatable::ClassMethods
  extend Mongoid::Validatable::Macros
  include ActiveModel::Conversion
  include ActiveModel::Model
  include ActiveModel::Serializers::JSON
  include ActiveModel::Validations
  include ActiveModel::Validations::Callbacks
  include ActiveModel::Validations::HelperMethods
  include ActiveSupport::Callbacks
  include ActiveSupport::Callbacks
  include ActiveSupport::Callbacks
  include Anonymous_Module_11
  include Mongoid::Association
  include Mongoid::Association::Accessors
  include Mongoid::Association::Builders
  include Mongoid::Association::Depending
  include Mongoid::Association::Embedded::Cyclic
  include Mongoid::Association::Macros
  include Mongoid::Association::Referenced::AutoSave
  include Mongoid::Association::Referenced::CounterCache
  include Mongoid::Association::Reflections
  include Mongoid::Atomic
  include Mongoid::Attributes
  include Mongoid::Attributes::Nested
  include Mongoid::Attributes::Readonly
  include Mongoid::Cacheable
  include Mongoid::Changeable
  include Mongoid::Clients
  include Mongoid::Clients::Options
  include Mongoid::Clients::StorageOptions
  include Mongoid::Composable
  include Mongoid::Copyable
  include Mongoid::Document
  include Mongoid::Fields
  include Mongoid::Indexable
  include Mongoid::Interceptable
  include Mongoid::Matchable
  include Mongoid::Persistable
  include Mongoid::Persistable::Creatable
  include Mongoid::Persistable::Deletable
  include Mongoid::Persistable::Destroyable
  include Mongoid::Persistable::Incrementable
  include Mongoid::Persistable::Logical
  include Mongoid::Persistable::Poppable
  include Mongoid::Persistable::Pullable
  include Mongoid::Persistable::Pushable
  include Mongoid::Persistable::Renamable
  include Mongoid::Persistable::Settable
  include Mongoid::Persistable::Unsettable
  include Mongoid::Scopable
  include Mongoid::Selectable
  include Mongoid::Serializable
  include Mongoid::Shardable
  include Mongoid::Threaded::Lifecycle
  include Mongoid::Traversable
  include Mongoid::Validatable
  include Mongoid::Validatable::Macros
end
module Anonymous_Module_11
  def _id; end
  def _id=(value); end
  def _id?; end
  def _id_before_type_cast; end
  def _id_change; end
  def _id_changed?; end
  def _id_changed_from_default?; end
  def _id_previous_change; end
  def _id_previously_changed?; end
  def _id_was; end
  def _id_will_change!; end
  def reset__id!; end
  def reset__id_to_default!; end
end
module Mongoid::Railties
end
module Mongoid::Railties::ControllerRuntime
end
module Mongoid::Railties::ControllerRuntime::ControllerExtension
  def append_info_to_payload(payload); end
  def cleanup_view_runtime; end
  def mongoid_runtime; end
  def mongoid_runtime=(arg0); end
  def process_action(action, *args); end
  extend ActiveSupport::Concern
end
module Mongoid::Railties::ControllerRuntime::ControllerExtension::ClassMethods
  def log_process_action(payload); end
end
class Mongoid::Railties::ControllerRuntime::Collector
  def _completed(e); end
  def failed(e); end
  def self.reset_runtime; end
  def self.runtime; end
  def self.runtime=(value); end
  def started(_); end
  def succeeded(e); end
end
