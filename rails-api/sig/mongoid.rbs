# typed: strong
# A class which sends values to the database as Strings but returns them to the user as Symbols.
module Mongoid
  extend Mongoid

  extend Forwardable

  extend Mongoid::Loggable

  # Sets the Mongoid configuration options. Best used by passing a block.
  #
  # _@return_ — The configuration object.
  #
  # Set up configuration options.
  # ```ruby
  # Mongoid.configure do |config|
  #   config.connect_to("mongoid_test")
  #
  #   config.clients.default = {
  #     hosts: ["localhost:27017"],
  #     database: "mongoid_test",
  #   }
  # end
  # ```
  def configure: () -> Config

  # sord warn - Mongo::Client wasn't able to be resolved to a constant in this project
  # Convenience method for getting the default client.
  #
  # _@return_ — The default client.
  #
  # Get the default client.
  # ```ruby
  # Mongoid.default_client
  # ```
  def default_client: () -> ::Mongo::Client

  # Disconnect all active clients.
  #
  # _@return_ — True.
  #
  # Disconnect all active clients.
  # ```ruby
  # Mongoid.disconnect_clients
  # ```
  def disconnect_clients: () -> bool

  # sord warn - Mongo::Client wasn't able to be resolved to a constant in this project
  # Convenience method for getting a named client.
  #
  # _@return_ — The named client.
  #
  # Get a named client.
  # ```ruby
  # Mongoid.client(:default)
  # ```
  def client: (untyped name) -> ::Client

  # Get the logger.
  #
  # _@return_ — The logger.
  #
  # Get the logger.
  # ```ruby
  # Loggable.logger
  # ```
  #
  # _@note_ — Will try to grab Rails' logger first before creating a new logger
  # with stderr.
  def self.logger: () -> Logger

  # Set the logger.
  #
  # _@param_ `logger` — The logger to set.
  #
  # _@return_ — The new logger.
  #
  # Set the logger.
  # ```ruby
  # Loggable.logger = Logger.new(STDERR)
  # ```
  def self.logger=: (Logger logger) -> Logger

  # Gets the default Mongoid logger - stderr.
  #
  # _@return_ — The default logger.
  #
  # Get the default logger.
  # ```ruby
  # Loggable.default_logger
  # ```
  def self.default_logger: () -> Logger

  # Get the Rails logger if loaded in a Rails application, otherwise nil.
  #
  # _@return_ — The Rails logger.
  #
  # Get Rails' logger.
  # ```ruby
  # Loggable.rails_logger
  # ```
  def self.rails_logger: () -> Logger

  # Sets the Mongoid configuration options. Best used by passing a block.
  #
  # _@return_ — The configuration object.
  #
  # Set up configuration options.
  # ```ruby
  # Mongoid.configure do |config|
  #   config.connect_to("mongoid_test")
  #
  #   config.clients.default = {
  #     hosts: ["localhost:27017"],
  #     database: "mongoid_test",
  #   }
  # end
  # ```
  def self.configure: () -> Config

  # sord warn - Mongo::Client wasn't able to be resolved to a constant in this project
  # Convenience method for getting the default client.
  #
  # _@return_ — The default client.
  #
  # Get the default client.
  # ```ruby
  # Mongoid.default_client
  # ```
  def self.default_client: () -> ::Client

  # Disconnect all active clients.
  #
  # _@return_ — True.
  #
  # Disconnect all active clients.
  # ```ruby
  # Mongoid.disconnect_clients
  # ```
  def self.disconnect_clients: () -> bool

  # sord warn - Mongo::Client wasn't able to be resolved to a constant in this project
  # Convenience method for getting a named client.
  #
  # _@return_ — The named client.
  #
  # Get a named client.
  # ```ruby
  # Mongoid.client(:default)
  # ```
  def self.client: (untyped name) -> ::Client
end

Mongoid::PLATFORM_DETAILS: untyped

Mongoid::MONGODB_VERSION: untyped

Mongoid::VERSION: untyped

# Module used to prepend the discriminator key assignment function to change
# the value assigned to the discriminator key to a string.
#
# @api private
module Mongoid::GlobalDiscriminatorKeyAssignment
  def discriminator_key=: (untyped value) -> untyped
end

# This class is used for obtaining the method definition location for
# Mongoid methods.
class Mongoid::GlobalDiscriminatorKeyAssignment::InvalidFieldHost
  include Mongoid::Document

  # Freezes the internal attributes of the document.
  #
  # _@return_ — The document.
  #
  # Freeze the document
  # ```ruby
  # document.freeze
  # ```
  def freeze: () -> Document

  # Checks if the document is frozen
  #
  # _@return_ — True if frozen, else false.
  #
  # Check if frozen
  # ```ruby
  # document.frozen?
  # ```
  def frozen?: () -> bool

  # Delegates to identity in order to allow two records of the same identity
  # to work with something like:
  #
  #   [ Person.find(1), Person.find(2), Person.find(3) ] &
  #   [ Person.find(1), Person.find(4) ] # => [ Person.find(1) ]
  #
  # _@return_ — The hash of the document's identity.
  #
  # Get the hash.
  # ```ruby
  # document.hash
  # ```
  def hash: () -> Integer

  # A Document's is identified absolutely by its class and database id:
  #
  # Person.first.identity #=> [Person, BSON::ObjectId('4f775130a04745933a000003')]
  #
  # _@return_ — An array containing [document.class, document._id]
  #
  # Get the identity
  # ```ruby
  # document.identity
  # ```
  def identity: () -> ::Array[untyped]

  # Instantiate a new +Document+, setting the Document's attributes if
  # given. If no attributes are provided, they will be initialized with
  # an empty +Hash+.
  #
  # If a primary key is defined, the document's id will be set to that key,
  # otherwise it will be set to a fresh +BSON::ObjectId+ string.
  #
  # _@param_ `attrs` — The attributes to set up the document with.
  #
  # _@return_ — A new document.
  #
  # Create a new document.
  # ```ruby
  # Person.new(:title => "Sir")
  # ```
  def initialize: (?::Hash[untyped, untyped]? attrs) -> void

  # Return the model name of the document.
  #
  # _@return_ — The model name.
  #
  # Return the model name.
  # ```ruby
  # document.model_name
  # ```
  def model_name: () -> String

  # Return the key value for the document.
  #
  # _@return_ — The id of the document or nil if new.
  #
  # Return the key.
  # ```ruby
  # document.to_key
  # ```
  def to_key: () -> String

  # Return an array with this +Document+ only in it.
  #
  # _@return_ — An array with the document as its only item.
  #
  # Return the document in an array.
  # ```ruby
  # document.to_a
  # ```
  def to_a: () -> ::Array[Document]

  # Return a hash of the entire document hierarchy from this document and
  # below. Used when the attributes are needed for everything and not just
  # the current document.
  #
  # _@return_ — A hash of all attributes in the hierarchy.
  #
  # Get the full hierarchy.
  # ```ruby
  # person.as_document
  # ```
  def as_document: () -> ::Hash[untyped, untyped]

  # Calls #as_json on the document with additional, Mongoid-specific options.
  #
  # _@param_ `options` — The options.
  #
  # _@return_ — The document as json.
  #
  # Get the document as json.
  # ```ruby
  # document.as_json(compact: true)
  # ```
  #
  # _@note_ — Rails 6 changes return value of as_json for non-primitive types
  # such as BSON::ObjectId. In Rails <= 5, as_json returned these as
  # instances of the class. In Rails 6, these are returned serialized to
  # primitive types (e.g. {"$oid"=>"5bcfc40bde340b37feda98e9"}).
  # See https://github.com/rails/rails/commit/2e5cb980a448e7f4ab00df6e9ad4c1cc456616aa
  # for more information.
  def as_json: (?::Hash[untyped, untyped]? options) -> ::Hash[untyped, untyped]

  # Returns an instance of the specified class with the attributes,
  # errors, and embedded documents of the current document.
  #
  # _@param_ `klass` — The class to become.
  #
  # _@return_ — An instance of the specified class.
  #
  # Return a subclass document as a superclass instance.
  # ```ruby
  # manager.becomes(Person)
  # ```
  def becomes: (Class klass) -> Document

  # Implement this for calls to flatten on array.
  #
  # _@return_ — Always nil.
  #
  # Get the document as an array.
  # ```ruby
  # document.to_ary
  # ```
  def to_ary: () -> nil

  # Returns the logger
  #
  # _@return_ — The configured logger or a default Logger instance.
  def logger: () -> Logger

  # Get the name of the model used in caching.
  #
  # _@return_ — The model key.
  #
  # Get the model key.
  # ```ruby
  # model.model_key
  # ```
  def model_key: () -> String

  def as_attributes: () -> untyped

  # Touch the document, in effect updating its updated_at timestamp and
  # optionally the provided field to the current time. If any belongs_to
  # associations exist with a touch option, they will be updated as well.
  #
  # _@param_ `field` — The name of an additional field to update.
  #
  # _@return_ — false if record is new_record otherwise true.
  #
  # Update the updated_at timestamp.
  # ```ruby
  # document.touch
  # ```
  #
  # Update the updated_at and provided timestamps.
  # ```ruby
  # document.touch(:audited)
  # ```
  #
  # _@note_ — This will not autobuild associations if those options are set.
  def touch: (?Symbol? field) -> bool

  # Default comparison is via the string version of the id.
  #
  # _@param_ `other` — The document to compare with.
  #
  # _@return_ — -1, 0, 1.
  #
  # Compare two documents.
  # ```ruby
  # person <=> other_person
  # ```
  def <=>: (Document other) -> Integer

  # Performs equality checking on the document ids. For more robust
  # equality checking please override this method.
  #
  # _@param_ `other` — The other object to compare with.
  #
  # _@return_ — True if the ids are equal, false if not.
  #
  # Compare for equality.
  # ```ruby
  # document == other
  # ```
  def ==: (Document | Object other) -> bool

  # Performs class equality checking.
  #
  # _@param_ `other` — The other object to compare with.
  #
  # _@return_ — True if the classes are equal, false if not.
  #
  # Compare the classes.
  # ```ruby
  # document === other
  # ```
  def ===: (Document | Object other) -> bool

  # Delegates to ==. Used when needing checks in hashes.
  #
  # _@param_ `other` — The object to check against.
  #
  # _@return_ — True if equal, false if not.
  #
  # Perform equality checking.
  # ```ruby
  # document.eql?(other)
  # ```
  def eql?: (Document | Object other) -> bool

  # Clone or dup the current +Document+. This will return all attributes with
  # the exception of the document's id, and will reset all the
  # instance variables.
  #
  # This clone also includes embedded documents.
  #
  # _@return_ — The new document.
  #
  # Clone the document.
  # ```ruby
  # document.clone
  # ```
  def clone: () -> Document

  # Clone the document attributes
  #
  # clone document
  # ```ruby
  # model.clone_document
  # ```
  def clone_document: () -> untyped

  # When cloning, if the document has localized fields we need to ensure they
  # are properly processed in the clone.
  #
  # _@param_ `attrs` — The attributes.
  #
  # Process localized attributes.
  # ```ruby
  # model.process_localized_attributes(attributes)
  # ```
  def process_localized_attributes: (untyped klass, ::Hash[untyped, untyped] attrs) -> untyped

  # Is the provided type of callback executable by this document?
  #
  # _@param_ `kind` — The type of callback.
  #
  # _@return_ — If the callback can be executed.
  #
  # Is the callback executable?
  # ```ruby
  # document.callback_executable?(:save)
  # ```
  def callback_executable?: (Symbol kind) -> bool

  # Is the document currently in a state that could potentially require
  # callbacks to be executed?
  #
  # _@param_ `kind` — The callback kind.
  #
  # _@return_ — If the document is in a callback state.
  #
  # Is the document in a callback state?
  # ```ruby
  # document.in_callback_state?(:update)
  # ```
  def in_callback_state?: (Symbol kind) -> bool

  # Run only the after callbacks for the specific event.
  #
  # _@param_ `kinds` — The events that are occurring.
  #
  # _@return_ — The result of the chain executing.
  #
  # Run only the after save callbacks.
  # ```ruby
  # model.run_after_callbacks(:save)
  # ```
  #
  # _@note_ — ActiveSupport does not allow this type of behavior by default, so
  # Mongoid has to get around it and implement itself.
  def run_after_callbacks: (*::Array[Symbol] kinds) -> Object

  # Run only the before callbacks for the specific event.
  #
  # _@param_ `kinds` — The events that are occurring.
  #
  # _@return_ — The result of the chain executing.
  #
  # Run only the before save callbacks.
  # ```ruby
  # model.run_before_callbacks(:save, :create)
  # ```
  #
  # _@note_ — ActiveSupport does not allow this type of behavior by default, so
  # Mongoid has to get around it and implement itself.
  def run_before_callbacks: (*::Array[Symbol] kinds) -> Object

  # Run the callbacks for the document. This overrides active support's
  # functionality to cascade callbacks to embedded documents that have been
  # flagged as such.
  #
  # _@param_ `kind` — The type of callback to execute.
  #
  # _@param_ `args` — Any options.
  #
  # _@return_ — The document
  #
  # Run the callbacks.
  # ```ruby
  # run_callbacks :save do
  #   save!
  # end
  # ```
  def run_callbacks: (Symbol kind, *::Array[untyped] args) { () -> untyped } -> Document

  # We need to hook into this for autosave, since we don't want it firing if
  # the before callbacks were halted.
  #
  # _@return_ — If a before callback was halted.
  #
  # Was a before callback halted?
  # ```ruby
  # document.before_callback_halted?
  # ```
  def before_callback_halted?: () -> bool

  # Get all the child embedded documents that are flagged as cascadable.
  #
  # _@param_ `kind` — The type of callback.
  #
  # _@return_ — The children.
  #
  # Get all the cascading children.
  # ```ruby
  # document.cascadable_children(:update)
  # ```
  def cascadable_children: (Symbol kind, ?untyped children) -> ::Array[Document]

  # Determine if the child should fire the callback.
  #
  # _@param_ `kind` — The type of callback.
  #
  # _@param_ `child` — The child document.
  #
  # _@return_ — If the child should fire the callback.
  #
  # Should the child fire the callback?
  # ```ruby
  # document.cascadable_child?(:update, doc)
  # ```
  def cascadable_child?: (Symbol kind, Document child, untyped association) -> bool

  # Get the name of the callback that the child should fire. This changes
  # depending on whether or not the child is new. A persisted parent with a
  # new child would fire :update from the parent, but needs to fire :create
  # on the child.
  #
  # _@param_ `kind` — The type of callback.
  #
  # _@param_ `child` — The child document
  #
  # _@return_ — The name of the callback.
  #
  # Get the callback type.
  # ```ruby
  # document.child_callback_type(:update, doc)
  # ```
  def child_callback_type: (Symbol kind, Document child) -> Symbol

  # We need to hook into this for autosave, since we don't want it firing if
  # the before callbacks were halted.
  #
  # _@param_ `filter` — The callback that halted.
  #
  # _@param_ `name` — The name of the callback that was halted (requires Rails 6.1+)
  #
  # Hook into the halt.
  # ```ruby
  # document.halted_callback_hook(filter)
  # ```
  def halted_callback_hook: (Symbol filter, ?Symbol? name) -> untyped

  # Run only the callbacks for the target location (before, after, around)
  # and kind (save, update, create).
  #
  # _@param_ `place` — The time to run, :before, :after, :around.
  #
  # _@param_ `kind` — The type of callback, :save, :create, :update.
  #
  # _@return_ — The result of the chain execution.
  #
  # Run the targeted callbacks.
  # ```ruby
  # model.run_targeted_callbacks(:before, :save)
  # ```
  def run_targeted_callbacks: (Symbol place, Symbol kind) -> Object

  # Begin the associated validation.
  #
  # Begin validation.
  # ```ruby
  # document.begin_validate
  # ```
  def begin_validate: () -> untyped

  # Exit the associated validation.
  #
  # Exit validation.
  # ```ruby
  # document.exit_validate
  # ```
  def exit_validate: () -> untyped

  # Given the provided options, are we performing validations?
  #
  # _@param_ `options` — The options to check.
  #
  # _@return_ — If we are validating.
  #
  # Are we performing validations?
  # ```ruby
  # document.performing_validations?(validate: true)
  # ```
  def performing_validations?: (?::Hash[untyped, untyped] options) -> bool

  # Overrides the default ActiveModel behavior since we need to handle
  # validations of associations slightly different than just calling the
  # getter.
  #
  # _@param_ `attr` — The name of the field or association.
  #
  # _@return_ — The value of the field or the association.
  #
  # Read the value.
  # ```ruby
  # person.read_attribute_for_validation(:addresses)
  # ```
  def read_attribute_for_validation: (Symbol attr) -> Object

  # Determine if the document is valid.
  #
  # _@param_ `context` — The optional validation context.
  #
  # _@return_ — True if valid, false if not.
  #
  # Is the document valid?
  # ```ruby
  # person.valid?
  # ```
  #
  # Is the document valid in a context?
  # ```ruby
  # person.valid?(:create)
  # ```
  def valid?: (?Symbol? context) -> bool

  # Used to prevent infinite loops in associated validations.
  #
  # _@return_ — Has the document already been validated?
  #
  # Is the document validated?
  # ```ruby
  # document.validated?
  # ```
  def validated?: () -> bool

  # Are we currently performing a validation that has a query?
  #
  # _@return_ — If we are validating with a query.
  #
  # Are we validating with a query?
  # ```ruby
  # document.validating_with_query?
  # ```
  def validating_with_query?: () -> bool

  def _parent: () -> untyped

  def _parent=: (untyped p) -> untyped

  # Get all child +Documents+ to this +Document+, going n levels deep if
  # necessary. This is used when calling update persistence operations from
  # the root document, where changes in the entire tree need to be
  # determined. Note that persistence from the embedded documents will
  # always be preferred, since they are optimized calls... This operation
  # can get expensive in domains with large hierarchies.
  #
  # _@return_ — All child documents in the hierarchy.
  #
  # Get all the document's children.
  # ```ruby
  # person._children
  # ```
  def _children: () -> ::Array[Document]

  # Collect all the children of this document.
  #
  # _@return_ — The children.
  #
  # Collect all the children.
  # ```ruby
  # document.collect_children
  # ```
  def collect_children: () -> ::Array[Document]

  # Marks all children as being persisted.
  #
  # _@return_ — The flagged children.
  #
  # Flag all the children.
  # ```ruby
  # document.flag_children_persisted
  # ```
  def flag_children_persisted: () -> ::Array[Document]

  # Determines if the document is a subclass of another document.
  #
  # _@return_ — True if hereditary, false if not.
  #
  # Check if the document is a subclass
  # ```ruby
  # Square.new.hereditary?
  # ```
  def hereditary?: () -> bool

  # Sets up a child/parent association. This is used for newly created
  # objects so they can be properly added to the graph.
  #
  # _@param_ `document` — The parent document.
  #
  # _@return_ — The parent document.
  #
  # Set the parent document.
  # ```ruby
  # document.parentize(parent)
  # ```
  def parentize: (Document document) -> Document

  # Remove a child document from this parent. If an embeds one then set to
  # nil, otherwise remove from the embeds many.
  #
  # This is called from the +RemoveEmbedded+ persistence command.
  #
  # _@param_ `child` — The child (embedded) document to remove.
  #
  # Remove the child.
  # ```ruby
  # document.remove_child(child)
  # ```
  def remove_child: (Document child) -> untyped

  # After children are persisted we can call this to move all their changes
  # and flag them as persisted in one call.
  #
  # _@return_ — The children.
  #
  # Reset the children.
  # ```ruby
  # document.reset_persisted_children
  # ```
  def reset_persisted_children: () -> ::Array[Document]

  # Resets the memoized children on the object. Called internally when an
  # embedded array changes size.
  #
  # _@return_ — nil.
  #
  # Reset the memoized children.
  # ```ruby
  # document._reset_memoized_children!
  # ```
  def _reset_memoized_children!: () -> nil

  # Return the root document in the object graph. If the current document
  # is the root object in the graph it will return self.
  #
  # _@return_ — The root document in the hierarchy.
  #
  # Get the root document in the hierarchy.
  # ```ruby
  # document._root
  # ```
  def _root: () -> Document

  # Is this document the root document of the hierarchy?
  #
  # _@return_ — If the document is the root.
  #
  # Is the document the root?
  # ```ruby
  # document._root?
  # ```
  def _root?: () -> bool

  # Begin the assignment of attributes. While in this block embedded
  # documents will not autosave themselves in order to allow the document to
  # be in a valid state.
  #
  # _@return_ — The yielded value.
  #
  # Execute the assignment.
  # ```ruby
  # _assigning do
  #   person.attributes = { :addresses => [ address ] }
  # end
  # ```
  def _assigning: () -> Object

  # Is the current thread in assigning mode?
  #
  # _@return_ — If the thread is assigning.
  #
  # Is the current thread in assigning mode?
  # ```ruby
  # proxy._assigning?
  # ```
  def _assigning?: () -> bool

  # Execute a block in binding mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in binding mode.
  # ```ruby
  # binding do
  #   relation.push(doc)
  # end
  # ```
  def _binding: () -> Object

  # Is the current thread in binding mode?
  #
  # _@return_ — If the thread is binding.
  #
  # Is the current thread in binding mode?
  # ```ruby
  # proxy.binding?
  # ```
  def _binding?: () -> bool

  # Execute a block in building mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in building mode.
  # ```ruby
  # _building do
  #   relation.push(doc)
  # end
  # ```
  def _building: () -> Object

  # Is the current thread in building mode?
  #
  # _@return_ — If the thread is building.
  #
  # Is the current thread in building mode?
  # ```ruby
  # proxy._building?
  # ```
  def _building?: () -> bool

  # Is the current thread in creating mode?
  #
  # _@return_ — If the thread is creating.
  #
  # Is the current thread in creating mode?
  # ```ruby
  # proxy.creating?
  # ```
  def _creating?: () -> bool

  # Execute a block in loading mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in loading mode.
  # ```ruby
  # _loading do
  #   relation.push(doc)
  # end
  # ```
  def _loading: () -> Object

  # Is the current thread in loading mode?
  #
  # _@return_ — If the thread is loading.
  #
  # Is the current thread in loading mode?
  # ```ruby
  # proxy._loading?
  # ```
  def _loading?: () -> bool

  # Print out the cache key. This will append different values on the
  # plural model name.
  #
  # If new_record?     - will append /new
  # If not             - will append /id-updated_at.to_s(cache_timestamp_format)
  # Without updated_at - will append /id
  #
  # This is usually called insode a cache() block
  #
  # _@return_ — the string with or without updated_at
  #
  # Returns the cache key
  # ```ruby
  # document.cache_key
  # ```
  def cache_key: () -> String

  # Returns true if the +Document+ has not been persisted to the database,
  # false if it has. This is determined by the variable @new_record
  # and NOT if the object has an id.
  #
  # _@return_ — True if new, false if not.
  #
  # Is the document new?
  # ```ruby
  # person.new_record?
  # ```
  def new_record?: () -> bool

  # Checks if the document has been saved to the database. Returns false
  # if the document has been destroyed.
  #
  # _@return_ — True if persisted, false if not.
  #
  # Is the document persisted?
  # ```ruby
  # person.persisted?
  # ```
  def persisted?: () -> bool

  # Returns whether or not the document has been flagged for deletion, but
  # not destroyed yet. Used for atomic pulls of child documents.
  #
  # _@return_ — If the document is flagged.
  #
  # Is the document flagged?
  # ```ruby
  # document.flagged_for_destroy?
  # ```
  def flagged_for_destroy?: () -> bool

  # Returns true if the +Document+ has been succesfully destroyed, and false
  # if it hasn't. This is determined by the variable @destroyed and NOT
  # by checking the database.
  #
  # _@return_ — True if destroyed, false if not.
  #
  # Is the document destroyed?
  # ```ruby
  # person.destroyed?
  # ```
  def destroyed?: () -> bool

  # Determine if the document can be pushed.
  #
  # _@return_ — Is the document new and embedded?
  #
  # Is this pushable?
  # ```ruby
  # person.pushable?
  # ```
  def pushable?: () -> bool

  # Is the document readonly?
  #
  # _@return_ — If the document is readonly.
  #
  # Is the document readonly?
  # ```ruby
  # document.readonly?
  # ```
  def readonly?: () -> bool

  # Determine if the document can be set.
  #
  # _@return_ — Is this document a new embeds one?
  #
  # Is this settable?
  # ```ruby
  # person.settable?
  # ```
  def settable?: () -> bool

  # Is the document updateable?
  #
  # _@return_ — If the document is changed and persisted.
  #
  # Is the document updateable?
  # ```ruby
  # person.updateable?
  # ```
  def updateable?: () -> bool

  def reset_readonly: () -> untyped

  # Get the shard key fields.
  #
  # _@return_ — The shard key field names.
  #
  # Get the shard key fields.
  # ```ruby
  # model.shard_key_fields
  # ```
  #
  # _@note_ — Refactored from using delegate for class load performance.
  def shard_key_fields: () -> ::Array[String]

  # Get the document selector with the defined shard keys.
  #
  # _@return_ — The shard key selector.
  #
  # Get the selector for the shard keys.
  # ```ruby
  # person.shard_key_selector
  # ```
  def shard_key_selector: () -> ::Hash[untyped, untyped]

  # Gets the document as a serializable hash, used by ActiveModel's JSON
  # serializer.
  #
  # _@param_ `options` — The options to pass.
  #
  # _@return_ — The document, ready to be serialized.
  #
  # Get the serializable hash.
  # ```ruby
  # document.serializable_hash
  # ```
  #
  # Get the serializable hash with options.
  # ```ruby
  # document.serializable_hash(:include => :addresses)
  # ```
  def serializable_hash: (?::Hash[untyped, untyped]? options) -> ::Hash[untyped, untyped]

  # Get the names of all fields that will be serialized.
  #
  # _@return_ — The names of the fields.
  #
  # Get all the field names.
  # ```ruby
  # document.send(:field_names)
  # ```
  def field_names: (untyped options) -> ::Array[String]

  def serialize_attribute: (::Hash[untyped, untyped] attrs, String name, ::Array[String] names, ::Hash[untyped, untyped] options) -> Object

  # For each of the provided include options, get the association needed and
  # provide it in the hash.
  #
  # _@param_ `attributes` — The attributes to serialize.
  #
  # _@param_ `options` — The serialization options.
  #
  # Serialize the included associations.
  # ```ruby
  # document.serialize_relations({}, :include => :addresses)
  # ```
  def serialize_relations: (?::Hash[untyped, untyped] attributes, ?::Hash[untyped, untyped] options) -> untyped

  # Since the inclusions can be a hash, symbol, or array of symbols, this is
  # provided as a convenience to parse out the names.
  #
  # _@param_ `inclusions` — The inclusions.
  #
  # _@return_ — The names of the included associations.
  #
  # Get the association names.
  # ```ruby
  # document.relation_names(:include => [ :addresses ])
  # ```
  def relation_names: (::Hash[untyped, untyped] | Symbol | ::Array[Symbol] inclusions) -> ::Array[Symbol]

  # Since the inclusions can be a hash, symbol, or array of symbols, this is
  # provided as a convenience to parse out the options.
  #
  # _@param_ `inclusions` — The inclusions.
  #
  # _@param_ `options` — The options.
  #
  # _@param_ `name` — The name of the association.
  #
  # _@return_ — The options for the association.
  #
  # Get the association options.
  # ```ruby
  # document.relation_names(:include => [ :addresses ])
  # ```
  def relation_options: (::Hash[untyped, untyped] | Symbol | ::Array[Symbol] inclusions, ::Hash[untyped, untyped] options, Symbol name) -> ::Hash[untyped, untyped]

  # Get the atomic selector for the document. This is a hash in the simplest
  # case { "_id" => id }, but can become more complex for embedded documents
  # and documents that use a shard key.
  #
  # _@return_ — The document's selector.
  #
  # Get the document's atomic selector.
  # ```ruby
  # document.atomic_selector
  # ```
  def atomic_selector: () -> ::Hash[untyped, untyped]

  # Get the atomic selector for an embedded document.
  #
  # _@return_ — The embedded document selector.
  #
  # Get the embedded atomic selector.
  # ```ruby
  # document.embedded_atomic_selector
  # ```
  def embedded_atomic_selector: () -> ::Hash[untyped, untyped]

  # Get the atomic selector for a root document.
  #
  # _@return_ — The root document selector.
  #
  # Get the root atomic selector.
  # ```ruby
  # document.root_atomic_selector
  # ```
  def root_atomic_selector: () -> ::Hash[untyped, untyped]

  # Apply the default scoping to the attributes of the document, as long as
  # they are not complex queries.
  #
  # _@return_ — If default scoping was applied.
  #
  # Apply the default scoping.
  # ```ruby
  # document.apply_default_scoping
  # ```
  def apply_default_scoping: () -> bool

  # Reloads the +Document+ attributes from the database. If the document has
  # not been saved then an error will get raised if the configuration option
  # was set. This can reload root documents or embedded documents.
  #
  # _@return_ — The document, reloaded.
  #
  # Reload the document.
  # ```ruby
  # person.reload
  # ```
  def reload: () -> Document

  # Reload the document, determining if it's embedded or not and what
  # behavior to use.
  #
  # _@return_ — The reloaded attributes.
  #
  # Reload the document.
  # ```ruby
  # document._reload
  # ```
  def _reload: () -> ::Hash[untyped, untyped]

  # Reload the root document.
  #
  # _@return_ — The reloaded attributes.
  #
  # Reload the document.
  # ```ruby
  # document.reload_root_document
  # ```
  def reload_root_document: () -> ::Hash[untyped, untyped]

  # Reload the embedded document.
  #
  # _@return_ — The reloaded attributes.
  #
  # Reload the document.
  # ```ruby
  # document.reload_embedded_document
  # ```
  def reload_embedded_document: () -> ::Hash[untyped, untyped]

  # Extract only the desired embedded document from the attributes.
  #
  # _@param_ `attributes` — The document in the db.
  #
  # _@return_ — The document's extracted attributes.
  #
  # Extract the embedded document.
  # ```ruby
  # document.extract_embedded_attributes(attributes)
  # ```
  def extract_embedded_attributes: (::Hash[untyped, untyped] attributes) -> ::Hash[untyped, untyped]

  # Determine if the document itself is embedded in another document via the
  # proper channels. (If it has a parent document.)
  #
  # _@return_ — True if the document has a parent document.
  #
  # Is the document embedded?
  # ```ruby
  # address.embedded?
  # ```
  def embedded?: () -> bool

  # Determine if the document is part of an embeds_many association.
  #
  # _@return_ — True if in an embeds many.
  #
  # Is the document in an embeds many?
  # ```ruby
  # address.embedded_many?
  # ```
  def embedded_many?: () -> bool

  # Determine if the document is part of an embeds_one association.
  #
  # _@return_ — True if in an embeds one.
  #
  # Is the document in an embeds one?
  # ```ruby
  # address.embedded_one?
  # ```
  def embedded_one?: () -> bool

  # Get the association name for this document. If no association was defined
  #   an error will be raised.
  #
  # _@return_ — The association name.
  #
  # Get the association name.
  # ```ruby
  # document.association_name
  # ```
  def association_name: () -> Symbol

  # Determine if the document is part of an references_many association.
  #
  # _@return_ — True if in a references many.
  #
  # Is the document in a references many?
  # ```ruby
  # post.referenced_many?
  # ```
  def referenced_many?: () -> bool

  # Determine if the document is part of an references_one association.
  #
  # _@return_ — True if in a references one.
  #
  # Is the document in a references one?
  # ```ruby
  # address.referenced_one?
  # ```
  def referenced_one?: () -> bool

  # Convenience method for iterating through the loaded associations and
  # reloading them.
  #
  # _@return_ — The association metadata.
  #
  # Reload the associations.
  # ```ruby
  # document.reload_relations
  # ```
  def reload_relations: () -> ::Hash[untyped, untyped]

  # Returns the association metadata for the supplied name.
  #
  # _@param_ `name` — The name of the association to find.
  #
  # _@return_ — The matching association metadata.
  #
  # Find association metadata by name.
  # ```ruby
  # person.reflect_on_association(:addresses)
  # ```
  def reflect_on_association: (String | Symbol name) -> Association

  # Returns all association metadata for the supplied macros.
  #
  # _@param_ `macros` — The association macros.
  #
  # _@return_ — The matching association metadata.
  #
  # Find multiple association metadata by macro.
  # ```ruby
  # person.reflect_on_all_associations(:embeds_many)
  # ```
  def reflect_on_all_association: (*::Array[Symbol] macros) -> ::Array[Association]

  # This is convenience for libraries still on the old API.
  #
  # _@return_ — The associations.
  #
  # Get the associations.
  # ```ruby
  # person.associations
  # ```
  def associations: () -> ::Hash[untyped, untyped]

  # Parse out the attributes and the options from the args passed to a
  # build_ or create_ methods.
  #
  # _@param_ `args` — The arguments.
  #
  # _@return_ — The attributes and options.
  #
  # Parse the args.
  # ```ruby
  # doc.parse_args(:name => "Joe")
  # ```
  def parse_args: (*::Array[untyped] args) -> ::Array[::Hash[untyped, untyped]]

  # Perform all cascading deletes, destroys, or nullifies. Will delegate to
  # the appropriate strategy to perform the operation.
  #
  # Execute cascades.
  # ```ruby
  # document.apply_delete_dependencies!
  # ```
  def apply_delete_dependencies!: () -> untyped

  def _dependent_delete_all!: (untyped association) -> untyped

  def _dependent_destroy!: (untyped association) -> untyped

  def _dependent_nullify!: (untyped association) -> untyped

  def _dependent_restrict_with_exception!: (untyped association) -> untyped

  def _dependent_restrict_with_error!: (untyped association) -> untyped

  def __build__: (String | Symbol name, ::Hash[untyped, untyped] | BSON::ObjectId object, Association association, ?::Hash[untyped, untyped]? selected_fields) -> Proxy

  # Create an association from an object and association metadata.
  #
  # _@param_ `object` — The association target.
  #
  # _@param_ `association` — The association metadata.
  #
  # _@param_ `selected_fields` — Fields which were retrieved via #only. If selected_fields is specified, fields not listed in it will not be accessible in the created association document.
  #
  # _@return_ — The association.
  #
  # Create the association.
  # ```ruby
  # person.create_relation(document, association)
  # ```
  def create_relation: (Document | ::Array[Document] object, Association association, ?::Hash[untyped, untyped]? selected_fields) -> Proxy

  # Resets the criteria inside the association proxy. Used by many-to-many
  # associations to keep the underlying ids array in sync.
  #
  # _@param_ `name` — The name of the association.
  #
  # Reset the association criteria.
  # ```ruby
  # person.reset_relation_criteria(:preferences)
  # ```
  def reset_relation_criteria: (Symbol name) -> untyped

  # Set the supplied association to an instance variable on the class with the
  # provided name. Used as a helper just for code cleanliness.
  #
  # _@param_ `name` — The name of the association.
  #
  # _@param_ `relation` — The association to set.
  #
  # _@return_ — The association.
  #
  # Set the proxy on the document.
  # ```ruby
  # person.set(:addresses, addresses)
  # ```
  def set_relation: (String | Symbol name, Proxy relation) -> Proxy

  def get_relation: (Symbol name, Association association, Object object, ?bool reload) -> Proxy

  # Returns a subset of __selected_fields attribute applicable to the
  # (embedded) association with the given key, or nil if no projection
  # is to be performed.
  #
  # For example, if __selected_fields is {'a' => 1, 'b.c' => 2, 'b.c.f' => 3},
  # and assoc_key is 'b', return value would be {'c' => 2, 'c.f' => 3}.
  #
  # _@param_ `assoc_key`
  def _mongoid_filter_selected_fields: (String assoc_key) -> ::Hash[untyped, untyped]?

  def needs_no_database_query?: (untyped object, untyped association) -> bool

  # Is the current code executing without autobuild functionality?
  #
  # _@return_ — If autobuild is disabled.
  #
  # Is autobuild disabled?
  # ```ruby
  # document.without_autobuild?
  # ```
  def without_autobuild?: () -> bool

  # Yield to the block with autobuild functionality turned off.
  #
  # _@return_ — The result of the yield.
  #
  # Execute without autobuild.
  # ```ruby
  # document.without_autobuild do
  #   document.name
  # end
  # ```
  def without_autobuild: () -> Object

  # Is the document able to be synced on the inverse side? This is only if
  # the key has changed and the association bindings have not been run.
  #
  # _@param_ `association` — The association metadata.
  #
  # _@return_ — If we can sync.
  #
  # Are the foreign keys syncable?
  # ```ruby
  # document._syncable?(association)
  # ```
  def _syncable?: (Association association) -> bool

  # Get the synced foreign keys.
  #
  # _@return_ — The synced foreign keys.
  #
  # Get the synced foreign keys.
  # ```ruby
  # document._synced
  # ```
  def _synced: () -> ::Hash[untyped, untyped]

  # Has the document been synced for the foreign key?
  #
  # _@param_ `foreign_key` — The foreign key.
  #
  # _@return_ — If we can sync.
  #
  # Has the document been synced?
  # ```ruby
  # document._synced?
  # ```
  def _synced?: (String foreign_key) -> bool

  # Update the inverse keys on destroy.
  #
  # _@param_ `association` — The association.
  #
  # _@return_ — The updated values.
  #
  # Update the inverse keys.
  # ```ruby
  # document.remove_inverse_keys(association)
  # ```
  def remove_inverse_keys: (Association association) -> Object

  # Update the inverse keys for the association.
  #
  # _@param_ `association` — The document association.
  #
  # _@return_ — The updated values.
  #
  # Update the inverse keys
  # ```ruby
  # document.update_inverse_keys(association)
  # ```
  def update_inverse_keys: (Association association) -> Object

  # Reset the given counter using the .count() query from the
  # db. This method is usuful in case that a counter got
  # corrupted, or a new counter was added to the collection.
  #
  # _@param_ `counters` — One or more counter caches to reset
  #
  # Reset the given counter cache
  # ```ruby
  # post.reset_counters(:comments)
  # ```
  def reset_counters: (*Symbol | ::Array[untyped] counters) -> untyped

  # Used to prevent infinite loops in associated autosaves.
  #
  # _@return_ — Has the document already been autosaved?
  #
  # Is the document autosaved?
  # ```ruby
  # document.autosaved?
  # ```
  def autosaved?: () -> bool

  # Begin the associated autosave.
  #
  # Begin autosave.
  # ```ruby
  # document.__autosaving__
  # ```
  def __autosaving__: () -> untyped

  # Check if there is changes for auto-saving
  #
  #   document.changed_for_autosave?
  #
  # Return true if there is changes on self or in
  # ```ruby
  # autosaved associations.
  # ```
  def changed_for_autosave?: (untyped doc) -> bool

  # Execute operations atomically (in a single database call) for everything
  # that would happen inside the block. This method supports nesting further
  # calls to atomically, which will behave according to the options described
  # below.
  #
  # An option join_context can be given which, when true, will merge the
  # operations declared by the given block with the atomically block wrapping
  # the current invocation for the same document, if one exists. If this
  # block or any other block sharing the same context raises before
  # persisting, then all the operations of that context will not be
  # persisted, and will also be reset in memory.
  #
  # When join_context is false, the given block of operations will be
  # persisted independently of other contexts. Failures in other contexts will
  # not affect this one, so long as this block was able to run and persist
  # changes.
  #
  # The default value of join_context is set by the global configuration
  # option join_contexts, whose own default is false.
  #
  # _@param_ `join_context` — Join the context (i.e. merge declared atomic operations) of the atomically block wrapping this one for the same document, if one exists.
  #
  # _@return_ — If the operation succeeded.
  #
  # Execute the operations atomically.
  # ```ruby
  # document.atomically do
  #   document.set(name: "Tool").inc(likes: 10)
  # end
  # ```
  #
  # Execute some inner operations atomically, but independently from the outer operations.
  # ```ruby
  #
  # document.atomically do
  #   document.inc likes: 10
  #   document.atomically join_context: false do
  #     # The following is persisted to the database independently.
  #     document.unset :origin
  #   end
  #   document.atomically join_context: true do
  #     # The following is persisted along with the other outer operations.
  #     document.inc member_count: 3
  #   end
  #   document.set name: "Tool"
  # end
  # ```
  def atomically: (?join_context: bool? join_context) -> bool

  # Raise an error if validation failed.
  #
  # Raise the validation error.
  # ```ruby
  # Person.fail_due_to_validation!(person)
  # ```
  def fail_due_to_validation!: () -> untyped

  # Raise an error if a callback failed.
  #
  # _@param_ `method` — The method being called.
  #
  # Raise the callback error.
  # ```ruby
  # Person.fail_due_to_callback!(person, :create!)
  # ```
  def fail_due_to_callback!: (Symbol method) -> untyped

  # Are we executing an atomically block on the current document?
  #
  # _@return_ — If we are current executing atomically.
  #
  # Are we executing atomically?
  # ```ruby
  # document.executing_atomically?
  # ```
  def executing_atomically?: () -> bool

  # Post process the persistence operation.
  #
  # _@param_ `result` — The result of the operation.
  #
  # _@param_ `options` — The options.
  #
  # _@return_ — true.
  #
  # Post process the persistence operation.
  # ```ruby
  # document.post_process_persist(true)
  # ```
  def post_process_persist: (Object result, ?::Hash[untyped, untyped] options) -> bool

  # Prepare an atomic persistence operation. Yields an empty hash to be sent
  # to the update.
  #
  # _@return_ — The result of the operation.
  #
  # Prepare the atomic operation.
  # ```ruby
  # document.prepare_atomic_operation do |coll, selector, opts|
  #   ...
  # end
  # ```
  def prepare_atomic_operation: () -> Object

  # Process the atomic operations - this handles the common behavior of
  # iterating through each op, getting the aliased field name, and removing
  # appropriate dirty changes.
  #
  # _@param_ `operations` — The atomic operations.
  #
  # _@return_ — The operations.
  #
  # Process the atomic operations.
  # ```ruby
  # document.process_atomic_operations(pulls) do |field, value|
  #   ...
  # end
  # ```
  def process_atomic_operations: (::Hash[untyped, untyped] operations) -> ::Hash[untyped, untyped]

  # Remove the dirty changes for all fields changed in the current atomic
  # context.
  #
  # Remove the current atomic context's dirty changes.
  # ```ruby
  # document._mongoid_remove_atomic_context_changes
  # ```
  def _mongoid_remove_atomic_context_changes: () -> untyped

  # Reset the attributes for all fields changed in the current atomic
  # context.
  #
  # Reset the current atomic context's changed attributes.
  # ```ruby
  # document._mongoid_reset_atomic_context_changes!
  # ```
  def _mongoid_reset_atomic_context_changes!: () -> untyped

  # Push a new atomic context onto the stack.
  #
  # Push a new atomic context onto the stack.
  # ```ruby
  # document._mongoid_push_atomic_context
  # ```
  def _mongoid_push_atomic_context: () -> untyped

  # Pop an atomic context off the stack.
  #
  # Pop an atomic context off the stack.
  # ```ruby
  # document._mongoid_pop_atomic_context
  # ```
  def _mongoid_pop_atomic_context: () -> untyped

  # Return the current atomic context's changed fields.
  #
  # _@return_ — The changed fields.
  #
  # Return the current atomic context's changed fields.
  # ```ruby
  # document._mongoid_atomic_context_changed_fields
  # ```
  def _mongoid_atomic_context_changed_fields: () -> ::Array[untyped]

  # If we are in an atomically block, add the operations to the delayed group,
  # otherwise persist immediately.
  #
  # _@param_ `operation` — The operation.
  #
  # Persist immediately or delay the operations.
  # ```ruby
  # document.persist_or_delay_atomic_operation(ops)
  # ```
  def persist_or_delay_atomic_operation: (::Hash[untyped, untyped] operation) -> untyped

  # Persist the atomic operations.
  #
  # _@param_ `operations` — The atomic operations.
  #
  # Persist the atomic operations.
  # ```ruby
  # persist_atomic_operations(ops)
  # ```
  def persist_atomic_operations: (::Hash[untyped, untyped] operations) -> untyped

  # Perform an $unset operation on the provided fields and in the
  # values in the document in memory.
  #
  # _@param_ `fields` — The names of the fields to unset.
  #
  # _@return_ — The document.
  #
  # Unset the values.
  # ```ruby
  # document.unset(:first_name, :last_name, :middle)
  # ```
  def unset: (*::Array[String | Symbol] fields) -> Document

  # Perform an upsert of the document. If the document does not exist in the
  # database, then Mongo will insert a new one, otherwise the fields will get
  # overwritten with new values on the existing document.
  #
  # _@param_ `options` — The validation options.
  #
  # _@return_ — True.
  #
  # Upsert the document.
  # ```ruby
  # document.upsert
  # ```
  def upsert: (?::Hash[untyped, untyped] options) -> bool

  # Prepare the upsert for execution.
  #
  # _@param_ `options` — The options hash.
  #
  # _@return_ — If the operation succeeded.
  #
  # Prepare the upsert
  # ```ruby
  # document.prepare_upsert do
  #   collection.find(selector).update(as_document)
  # end
  # ```
  def prepare_upsert: (?::Hash[untyped, untyped] options) -> bool

  # Update a single attribute and persist the entire document.
  # This skips validation but fires the callbacks.
  #
  # _@param_ `name` — The name of the attribute.
  #
  # _@param_ `value` — The new value of the attribute.a
  #
  # _@return_ — True if save was successfull, false if not.
  #
  # Update the attribute.
  # ```ruby
  # person.update_attribute(:title, "Sir")
  # ```
  def update_attribute: (Symbol | String name, Object value) -> bool

  # Update the document attributes in the database.
  #
  # _@param_ `attributes` — The attributes to update.
  #
  # _@return_ — True if validation passed, false if not.
  #
  # Update the document's attributes
  # ```ruby
  # document.update(:title => "Sir")
  # ```
  def update: (?::Hash[untyped, untyped] attributes) -> bool

  # Update the document attributes in the database and raise an error if
  # validation failed.
  #
  # _@param_ `attributes` — The attributes to update.
  #
  # _@return_ — True if validation passed.
  #
  # Update the document's attributes.
  # ```ruby
  # document.update!(:title => "Sir")
  # ```
  def update!: (?::Hash[untyped, untyped] attributes) -> bool

  # Initialize the atomic updates.
  #
  # _@return_ — The updates and conflicts.
  #
  # Initialize the atomic updates.
  # ```ruby
  # document.init_atomic_updates
  # ```
  def init_atomic_updates: () -> ::Array[::Hash[untyped, untyped]]

  # Prepare the update for execution. Validates and runs callbacks, etc.
  #
  # _@param_ `options` — The options.
  #
  # _@return_ — The result of the update.
  #
  # Prepare for update.
  # ```ruby
  # document.prepare_update do
  #   collection.update(atomic_selector)
  # end
  # ```
  def prepare_update: (?::Hash[untyped, untyped] options) -> bool

  # Update the document in the database.
  #
  # _@param_ `options` — Options to pass to update.
  #
  # _@return_ — True if succeeded, false if not.
  #
  # Update an existing document.
  # ```ruby
  # document.update
  # ```
  def update_document: (?::Hash[untyped, untyped] options) -> bool

  # Perform a $set operation on the provided field/value pairs and set the
  # values in the document in memory.
  #
  # The key can be a dotted sequence of keys, in which case the
  # top level field is treated as a nested hash and any missing keys
  # are created automatically:
  #
  # Performing a nested set like this merges values of intermediate keys:
  #
  # If the top level field was not a hash, its original value is discarded
  # and the field is replaced with a hash.
  #
  # Note that unlike MongoDB's $set, Mongoid's set writes out the entire
  # field even when setting a subset of the field via the nested hash
  # semantics. This means performing a $set with nested hash semantics
  # can overwrite other hash keys within the top level field in the database.
  #
  # _@param_ `setters` — The field/value pairs to set.
  #
  # _@return_ — The document.
  #
  # Set the values.
  # ```ruby
  # document.set(title: "sir", dob: Date.new(1970, 1, 1))
  # ```
  #
  # Set the values using nested hash semantics.
  # ```ruby
  # document.set('author.title' => 'Sir')
  # # => document.author == {'title' => 'Sir'}
  # ```
  #
  # Nested hash value merging.
  # ```ruby
  # document.set('author.title' => 'Sir')
  # document.set('author.name' => 'Linus Torvalds')
  # # => document.author == {'title' => 'Sir', 'name' => 'Linus Torvalds'}
  # ```
  #
  # Nested hash overwriting a non-hash value.
  # ```ruby
  # document.set('author' => 'John Doe')
  # document.set('author.title' => 'Sir')
  # # => document.author == {'title' => 'Sir'}
  # ```
  def set: (::Hash[untyped, untyped] setters) -> Document

  # Save the document - will perform an insert if the document is new, and
  # update if not.
  #
  # _@param_ `options` — Options to pass to the save.
  #
  # _@return_ — True is success, false if not.
  #
  # Save the document.
  # ```ruby
  # document.save
  # ```
  def save: (?::Hash[untyped, untyped] options) -> bool

  # Save the document - will perform an insert if the document is new, and
  # update if not. If a validation error occurs an error will get raised.
  #
  # _@param_ `options` — Options to pass to the save.
  #
  # _@return_ — True if validation passed.
  #
  # Save the document.
  # ```ruby
  # document.save!
  # ```
  def save!: (?::Hash[untyped, untyped] options) -> bool

  # Rename fields from one value to another via $rename.
  #
  # _@param_ `renames` — The rename pairs of old name/new name.
  #
  # _@return_ — The document.
  #
  # Rename the fields.
  # ```ruby
  # document.rename(title: "salutation", name: "nombre")
  # ```
  #
  # _@note_ — This does not work for fields in embeds many associations.
  def rename: (::Hash[untyped, untyped] renames) -> Document

  # Add the single values to the arrays only if the value does not already
  # exist in the array.
  #
  # _@param_ `adds` — The field/value pairs to add.
  #
  # _@return_ — The document.
  #
  # Add the values to the sets.
  # ```ruby
  # document.add_to_set(names: "James", aliases: "Bond")
  # ```
  def add_to_set: (::Hash[untyped, untyped] adds) -> Document

  # Push a single value or multiple values onto arrays.
  #
  # _@param_ `pushes` — The $push operations.
  #
  # _@return_ — The document.
  #
  # Push a single value onto arrays.
  # ```ruby
  # document.push(names: "James", aliases: "007")
  # ```
  #
  # Push multiple values onto arrays.
  # ```ruby
  # document.push(names: [ "James", "Bond" ])
  # ```
  def push: (::Hash[untyped, untyped] pushes) -> Document

  # Pull single values from the provided arrays.
  #
  # _@param_ `pulls` — The field/value pull pairs.
  #
  # _@return_ — The document.
  #
  # Pull a value from the array.
  # ```ruby
  # document.pull(names: "Jeff", levels: 5)
  # ```
  #
  # _@note_ — If duplicate values are found they will all be pulled.
  def pull: (::Hash[untyped, untyped] pulls) -> Document

  # Pull multiple values from the provided array fields.
  #
  # _@param_ `pulls` — The pull all operations.
  #
  # _@return_ — The document.
  #
  # Pull values from the arrays.
  # ```ruby
  # document.pull_all(names: [ "Jeff", "Bob" ], levels: [ 5, 6 ])
  # ```
  def pull_all: (::Hash[untyped, untyped] pulls) -> Document

  # Takes the provided selector and atomic operations and replaces the
  # indexes of the embedded documents with the positional operator when
  # needed.
  #
  # _@param_ `selector` — The selector.
  #
  # _@param_ `operations` — The update operations.
  #
  # _@param_ `processed` — The processed update operations.
  #
  # _@return_ — The new operations.
  #
  # Process the operations.
  # ```ruby
  # positionally(
  #   { "_id" => 1, "addresses._id" => 2 },
  #   { "$set" => { "addresses.0.street" => "hobrecht" }}
  # )
  # ```
  #
  # _@note_ — The only time we can accurately know when to use the positional
  # operator is at the exact time we are going to persist something. So
  # we can tell by the selector that we are sending if it is actually
  # possible to use the positional operator at all. For example, if the
  # selector is: { "_id" => 1 }, then we could not use the positional
  # operator for updating embedded documents since there would never be a
  # match - we base whether we can based on the number of levels deep the
  # selector goes, and if the id values are not nil.
  def positionally: (::Hash[untyped, untyped] selector, ::Hash[untyped, untyped] operations, ?::Hash[untyped, untyped] processed) -> ::Hash[untyped, untyped]

  def process_operations: (untyped keys, untyped operations, untyped processed) -> untyped

  def process_updates: (untyped keys, untyped update, ?untyped updates) -> untyped

  def replace_index: (untyped keys, untyped position) -> untyped

  # Pop or shift items from arrays using the $pop operator.
  #
  # _@param_ `pops` — The field/value pop operations.
  #
  # _@return_ — The document.
  #
  # Pop items from an array.
  # ```ruby
  # document.pop(aliases: 1)
  # ```
  #
  # Shift items in the array.
  # ```ruby
  # document.pop(aliases: -1)
  # ```
  #
  # Multiple pops in one call.
  # ```ruby
  # document.pop(names: 1, aliases: 1)
  # ```
  def pop: (::Hash[untyped, untyped] pops) -> Document

  # Performs an atomic $bit operation on the field with the provided hash
  # of bitwise ops to execute in order.
  #
  # _@param_ `operations` — The bitwise operations.
  #
  # _@return_ — The document.
  #
  # Execute the bitwise operations.
  # ```ruby
  # person.bit(age: { :and => 12 }, val: { and: 10, or: 12 })
  # ```
  def bit: (::Hash[untyped, untyped] operations) -> Document

  # Increment the provided fields by the corresponding values. Values can
  # be positive or negative, and if no value exists for the field it will
  # be set with the provided value.
  #
  # _@param_ `increments` — The field/inc increment pairs.
  #
  # _@return_ — The document.
  #
  # Increment the fields.
  # ```ruby
  # document.inc(score: 10, place: 1, lives: -10)
  # ```
  def inc: (::Hash[untyped, untyped] increments) -> Document

  # Remove the document from the database with callbacks.
  #
  # _@param_ `options` — Options to pass to destroy.
  #
  # _@return_ — True if successful, false if not.
  #
  # Destroy a document.
  # ```ruby
  # document.destroy
  # ```
  def destroy: (?::Hash[untyped, untyped]? options) -> bool

  def destroy!: (?untyped options) -> untyped

  # Remove the document from the database.
  #
  # _@param_ `options` — Options to pass to remove.
  #
  # _@return_ — True.
  #
  # Remove the document.
  # ```ruby
  # document.remove
  # ```
  def delete: (?::Hash[untyped, untyped] options) -> TrueClass

  # Get the atomic deletes for the operation.
  #
  # _@return_ — The atomic deletes.
  #
  # Get the atomic deletes.
  # ```ruby
  # document.atomic_deletes
  # ```
  def atomic_deletes: () -> ::Hash[untyped, untyped]

  # Delete the embedded document.
  #
  # _@param_ `options` — The deletion options.
  #
  # _@return_ — If the operation succeeded.
  #
  # Delete the embedded document.
  # ```ruby
  # document.delete_as_embedded
  # ```
  def delete_as_embedded: (?::Hash[untyped, untyped] options) -> bool

  # Delete the root document.
  #
  # _@return_ — If the document was removed.
  #
  # Delete the root document.
  # ```ruby
  # document.delete_as_root
  # ```
  def delete_as_root: () -> bool

  # Are we needing to notify the parent document of the deletion.
  #
  # _@param_ `options` — The delete options.
  #
  # _@return_ — If the parent should be notified.
  #
  # Are we notifying the parent.
  # ```ruby
  # document.notifying_parent?(suppress: true)
  # ```
  def notifying_parent?: (?::Hash[untyped, untyped] options) -> bool

  # Prepare the delete operation.
  #
  # _@return_ — The result of the block.
  #
  # Prepare the delete operation.
  # ```ruby
  # document.prepare_delete do
  #   collection.find(atomic_selector).remove
  # end
  # ```
  def prepare_delete: () -> Object

  # Insert a new document into the database. Will return the document
  # itself whether or not the save was successful.
  #
  # _@param_ `options` — Options to pass to insert.
  #
  # _@return_ — The persisted document.
  #
  # Insert a document.
  # ```ruby
  # document.insert
  # ```
  def insert: (?::Hash[untyped, untyped] options) -> Document

  # Get the atomic insert for embedded documents, either a push or set.
  #
  # _@return_ — The insert ops.
  #
  # Get the inserts.
  # ```ruby
  # document.inserts
  # ```
  def atomic_inserts: () -> ::Hash[untyped, untyped]

  # Insert the embedded document.
  #
  # _@return_ — The document.
  #
  # Insert the document as embedded.
  # ```ruby
  # document.insert_as_embedded
  # ```
  def insert_as_embedded: () -> Document

  # Insert the root document.
  #
  # _@return_ — The document.
  #
  # Insert the document as root.
  # ```ruby
  # document.insert_as_root
  # ```
  def insert_as_root: () -> Document

  # Post process an insert, which sets the new record attribute to false
  # and flags all the children as persisted.
  #
  # _@return_ — true.
  #
  # Post process the insert.
  # ```ruby
  # document.post_process_insert
  # ```
  def post_process_insert: () -> bool

  # Prepare the insert for execution. Validates and runs callbacks, etc.
  #
  # _@param_ `options` — The options.
  #
  # _@return_ — The document.
  #
  # Prepare for insertion.
  # ```ruby
  # document.prepare_insert do
  #   collection.insert(as_document)
  # end
  # ```
  def prepare_insert: (?::Hash[untyped, untyped] options) -> Document

  # Determines if this document has the attributes to match the supplied
  # MongoDB selector. Used for matching on embedded associations.
  #
  # _@param_ `selector` — The MongoDB selector.
  #
  # _@return_ — True if matches, false if not.
  #
  # Does the document match?
  # ```ruby
  # document._matches?(:title => { "$in" => [ "test" ] })
  # ```
  def _matches?: (::Hash[untyped, untyped] selector) -> bool

  # Apply all default values to the document which are not procs.
  #
  # _@return_ — The names of the non-proc defaults.
  #
  # Apply all the non-proc defaults.
  # ```ruby
  # model.apply_pre_processed_defaults
  # ```
  def apply_pre_processed_defaults: () -> ::Array[String]

  # Apply all default values to the document which are procs.
  #
  # _@return_ — The names of the proc defaults.
  #
  # Apply all the proc defaults.
  # ```ruby
  # model.apply_post_processed_defaults
  # ```
  def apply_post_processed_defaults: () -> ::Array[String]

  # Applies a single default value for the given name.
  #
  # _@param_ `name` — The name of the field.
  #
  # Apply a single default.
  # ```ruby
  # model.apply_default("name")
  # ```
  def apply_default: (String name) -> untyped

  # Apply all the defaults at once.
  #
  # Apply all the defaults.
  # ```ruby
  # model.apply_defaults
  # ```
  def apply_defaults: () -> untyped

  # Returns an array of names for the attributes available on this object.
  #
  # Provides the field names in an ORM-agnostic way. Rails v3.1+ uses this
  # method to automatically wrap params in JSON requests.
  #
  # _@return_ — The field names
  #
  # Get the field names
  # ```ruby
  # docment.attribute_names
  # ```
  def attribute_names: () -> ::Array[String]

  # Get the name of the provided field as it is stored in the database.
  # Used in determining if the field is aliased or not.
  #
  # _@param_ `name` — The name to get.
  #
  # _@return_ — The name of the field as it's stored in the db.
  #
  # Get the database field name.
  # ```ruby
  # model.database_field_name(:authorization)
  # ```
  def database_field_name: (String | Symbol name) -> String

  # Is the provided field a lazy evaluation?
  #
  # _@param_ `field` — The field.
  #
  # _@param_ `value` — The current value.
  #
  # _@return_ — If we set the field lazily.
  #
  # If the field is lazy settable.
  # ```ruby
  # doc.lazy_settable?(field, nil)
  # ```
  def lazy_settable?: (Standard | ForeignKey field, Object value) -> bool

  # Is the document using object ids?
  #
  # _@return_ — Using object ids.
  #
  # Is the document using object ids?
  # ```ruby
  # model.using_object_ids?
  # ```
  #
  # _@note_ — Refactored from using delegate for class load performance.
  def using_object_ids?: () -> bool

  # Evolve the document into an object id.
  #
  # _@return_ — The document's id.
  #
  # Evolve the document.
  # ```ruby
  # document.__evolve_object_id__
  # ```
  def __evolve_object_id__: () -> Object

  # Determine if an attribute is present.
  #
  # _@param_ `name` — The name of the attribute.
  #
  # _@return_ — True if present, false if not.
  #
  # Is the attribute present?
  # ```ruby
  # person.attribute_present?("title")
  # ```
  def attribute_present?: (String | Symbol name) -> bool

  # Get the attributes that have not been cast.
  #
  # _@return_ — The uncast attributes.
  #
  # Get the attributes before type cast.
  # ```ruby
  # document.attributes_before_type_cast
  # ```
  def attributes_before_type_cast: () -> ::Hash[untyped, untyped]

  # Does the document have the provided attribute?
  #
  # _@param_ `name` — The name of the attribute.
  #
  # _@return_ — If the key is present in the attributes.
  #
  # Does the document have the attribute?
  # ```ruby
  # model.has_attribute?(:name)
  # ```
  def has_attribute?: (String | Symbol name) -> bool

  # Does the document have the provided attribute before it was assigned
  # and type cast?
  #
  # _@param_ `name` — The name of the attribute.
  #
  # _@return_ — If the key is present in the
  # attributes_before_type_cast.
  #
  # Does the document have the attribute before it was assigned?
  # ```ruby
  # model.has_attribute_before_type_cast?(:name)
  # ```
  def has_attribute_before_type_cast?: (String | Symbol name) -> bool

  # Read a value from the document attributes. If the value does not exist
  # it will return nil.
  #
  # _@param_ `name` — The name of the attribute to get.
  #
  # _@return_ — The value of the attribute.
  #
  # Read an attribute.
  # ```ruby
  # person.read_attribute(:title)
  # ```
  #
  # Read an attribute (alternate syntax.)
  # ```ruby
  # person[:title]
  # ```
  def read_attribute: (String | Symbol name) -> Object

  # Read a value from the attributes before type cast. If the value has not
  # yet been assigned then this will return the attribute's existing value
  # using read_raw_attribute.
  #
  # _@param_ `name` — The name of the attribute to get.
  #
  # _@return_ — The value of the attribute before type cast, if
  # available. Otherwise, the value of the attribute.
  #
  # Read an attribute before type cast.
  # ```ruby
  # person.read_attribute_before_type_cast(:price)
  # ```
  def read_attribute_before_type_cast: (String | Symbol name) -> Object

  # Remove a value from the +Document+ attributes. If the value does not exist
  # it will fail gracefully.
  #
  # _@param_ `name` — The name of the attribute to remove.
  #
  # Remove the attribute.
  # ```ruby
  # person.remove_attribute(:title)
  # ```
  def remove_attribute: (String | Symbol name) -> untyped

  # Write a single attribute to the document attribute hash. This will
  # also fire the before and after update callbacks, and perform any
  # necessary typecasting.
  #
  # _@param_ `name` — The name of the attribute to update.
  #
  # _@param_ `value` — The value to set for the attribute.
  #
  # Write the attribute.
  # ```ruby
  # person.write_attribute(:title, "Mr.")
  # ```
  #
  # Write the attribute (alternate syntax.)
  # ```ruby
  # person[:title] = "Mr."
  # ```
  def write_attribute: (String | Symbol name, Object value) -> untyped

  # Allows you to set all the attributes for a particular mass-assignment security role
  # by passing in a hash of attributes with keys matching the attribute names
  # (which again matches the column names)  and the role name using the :as option.
  # To bypass mass-assignment security you can use the :without_protection => true option.
  #
  # _@param_ `attrs` — The new attributes to set.
  #
  # Assign the attributes.
  # ```ruby
  # person.assign_attributes(:title => "Mr.")
  # ```
  #
  # Assign the attributes (with a role).
  # ```ruby
  # person.assign_attributes({ :title => "Mr." }, :as => :admin)
  # ```
  def assign_attributes: (?::Hash[untyped, untyped]? attrs) -> untyped

  # Writes the supplied attributes hash to the document. This will only
  # overwrite existing attributes if they are present in the new +Hash+, all
  # others will be preserved.
  #
  # _@param_ `attrs` — The new attributes to set.
  #
  # Write the attributes.
  # ```ruby
  # person.write_attributes(:title => "Mr.")
  # ```
  #
  # Write the attributes (alternate syntax.)
  # ```ruby
  # person.attributes = { :title => "Mr." }
  # ```
  def write_attributes: (?::Hash[untyped, untyped]? attrs) -> untyped

  # Determine if the attribute is missing from the document, due to loading
  # it from the database with missing fields.
  #
  # _@param_ `name` — The name of the attribute.
  #
  # _@return_ — If the attribute is missing.
  #
  # Is the attribute missing?
  # ```ruby
  # document.attribute_missing?("test")
  # ```
  def attribute_missing?: (String name) -> bool

  # Return type-casted attributes.
  #
  # _@return_ — The hash with keys and values of the type-casted attributes.
  #
  # Type-casted attributes.
  # ```ruby
  # document.typed_attributes
  # ```
  def typed_attributes: () -> Object

  def selection_excluded?: (untyped name, untyped selection, untyped field) -> bool

  def selection_included?: (untyped name, untyped selection, untyped field) -> bool

  # Does the string contain dot syntax for accessing hashes?
  #
  # _@return_ — If the string contains a "."
  #
  # Is the string in dot syntax.
  # ```ruby
  # model.hash_dot_syntax?
  # ```
  def hash_dot_syntax?: (untyped string) -> bool

  # Return the typecasted value for a field.
  #
  # _@param_ `key` — The field name.
  #
  # _@param_ `value` — The uncast value.
  #
  # _@return_ — The cast value.
  #
  # Get the value typecasted.
  # ```ruby
  # person.typed_value_for(:title, :sir)
  # ```
  def typed_value_for: (String | Symbol key, Object value) -> Object

  def read_raw_attribute: (untyped name) -> untyped

  # Validates an attribute value as being assignable to the specified field.
  #
  # For now, only Hash and Array fields are validated, and the value is
  # being checked to be of an appropriate type (i.e. either Hash or Array,
  # respectively, or nil).
  #
  # This method takes the name of the field as stored in the document
  # in the database, not (necessarily) the Ruby method name used to read/write
  # the said field.
  #
  # _@param_ `field_name` — The name of the field.
  #
  # _@param_ `value` — The value to be validated.
  def validate_attribute_value: (String | Symbol field_name, Object value) -> untyped

  def lookup_attribute_presence: (untyped name, untyped value) -> untyped

  # Are we able to write the attribute with the provided name?
  #
  # _@param_ `name` — The name of the field.
  #
  # _@return_ — If the document is new, or if the field is not
  # readonly.
  #
  # Can we write the attribute?
  # ```ruby
  # model.attribute_writable?(:title)
  # ```
  def attribute_writable?: (String | Symbol name) -> bool

  def as_writable_attribute!: (untyped name, ?untyped value) -> untyped

  def _loaded?: (untyped name) -> bool

  def projected_field?: (untyped name) -> bool

  # Process the provided attributes casting them to their proper values if a
  # field exists for them on the document. This will be limited to only the
  # attributes provided in the suppied +Hash+ so that no extra nil values get
  # put into the document's attributes.
  #
  # _@param_ `attrs` — The attributes to set.
  #
  # Process the attributes.
  # ```ruby
  # person.process_attributes(:title => "sir", :age => 40)
  # ```
  def process_attributes: (?::Hash[untyped, untyped]? attrs) -> untyped

  # If the key provided is the name of an association or a nested attribute, we
  # need to wait until all other attributes are set before processing
  # these.
  #
  # _@param_ `key` — The name of the attribute.
  #
  # _@param_ `value` — The value of the attribute.
  #
  # _@return_ — True if pending, false if not.
  #
  # Is the attribute pending?
  # ```ruby
  # document.pending_attribute?(:name, "Durran")
  # ```
  def pending_attribute?: (Symbol key, Object value) -> bool

  # Get all the pending associations that need to be set.
  #
  # _@return_ — The pending associations in key/value pairs.
  #
  # Get the pending associations.
  # ```ruby
  # document.pending_relations
  # ```
  def pending_relations: () -> ::Hash[untyped, untyped]

  # Get all the pending nested attributes that need to be set.
  #
  # _@return_ — The pending nested attributes in key/value pairs.
  #
  # Get the pending nested attributes.
  # ```ruby
  # document.pending_nested
  # ```
  def pending_nested: () -> ::Hash[untyped, untyped]

  # If the attribute is dynamic, add a field for it with a type of object
  # and then either way set the value.
  #
  # _@param_ `name` — The name of the field.
  #
  # _@param_ `value` — The value of the field.
  #
  # Process the attribute.
  # ```ruby
  # document.process_attribute(name, value)
  # ```
  def process_attribute: (Symbol name, Object value) -> untyped

  # Process all the pending nested attributes that needed to wait until
  # ids were set to fire off.
  #
  # Process the nested attributes.
  # ```ruby
  # document.process_nested
  # ```
  def process_nested: () -> untyped

  # Process all the pending items, then clear them out.
  #
  # Process the pending items.
  # ```ruby
  # document.process_pending
  # ```
  def process_pending: () -> untyped

  # Process all the pending associations that needed to wait until ids were set
  # to fire off.
  #
  # Process the associations.
  # ```ruby
  # document.process_relations
  # ```
  def process_relations: () -> untyped

  # Execute a block within the context of a session.
  #
  # _@param_ `options` — The session options. Please see the driver documentation for the available session options.
  #
  # _@return_ — The result of calling the block.
  #
  # Execute some operations in the context of a session.
  # ```ruby
  # band.with_session(causal_consistency: true) do
  #   band.records << Record.create
  #   band.name = 'FKA Twigs'
  #   band.save
  #   band.reload
  # end
  # ```
  #
  # _@note_ — You cannot do any operations in the block using models or objects
  # that use a different client; the block will execute all operations
  # in the context of the implicit session and operations on any models using
  # another client will fail. For example, if you set a client using store_in on a
  # particular model and execute an operation on it in the session context block,
  # that operation can't use the block's session and an error will be raised.
  # An error will also be raised if sessions are nested.
  def with_session: (?::Hash[untyped, untyped] options) -> Object

  def _session: () -> untyped

  # Change the persistence context for this object during the block.
  #
  # _@param_ `options_or_context` — The storage options or a persistence context.
  #
  # Save the current document to a different collection.
  # ```ruby
  # model.with(collection: "bands") do |m|
  #   m.save
  # end
  # ```
  def with: (::Hash[untyped, untyped] | Mongoid::PersistenceContext options_or_context) { () -> untyped } -> untyped

  def collection: (?untyped parent) -> untyped

  def collection_name: () -> untyped

  def mongo_client: () -> untyped

  def persistence_context: () -> untyped

  def set_persistence_context: (untyped options_or_context) -> untyped

  def clear_persistence_context: (?untyped original_cluster, ?untyped context) -> untyped

  # Get the changed attributes for the document.
  #
  # _@return_ — The changed attributes.
  #
  # Get the changed attributes.
  # ```ruby
  # model.changed
  # ```
  def changed: () -> ::Array[String]

  # Has the document changed?
  #
  # _@return_ — If the document is changed.
  #
  # Has the document changed?
  # ```ruby
  # model.changed?
  # ```
  def changed?: () -> bool

  # Have any children (embedded documents) of this document changed?
  #
  # _@return_ — If any children have changed.
  #
  # Have any children changed?
  # ```ruby
  # model.children_changed?
  # ```
  def children_changed?: () -> bool

  # Get the attribute changes.
  #
  # _@return_ — The attribute changes.
  #
  # Get the attribute changes.
  # ```ruby
  # model.changed_attributes
  # ```
  def changed_attributes: () -> ::Hash[String, Object]

  # Get all the changes for the document.
  #
  # _@return_ — The changes.
  #
  # Get all the changes.
  # ```ruby
  # model.changes
  # ```
  def changes: () -> ::Hash[String, ::Array[Object | Object]]

  # Call this method after save, so the changes can be properly switched.
  #
  # This will unset the memoized children array, set new record to
  # false, set the document as validated, and move the dirty changes.
  #
  # Move the changes to previous.
  # ```ruby
  # person.move_changes
  # ```
  def move_changes: () -> untyped

  # Things that need to execute after a document has been persisted.
  #
  # Handle post persistence.
  # ```ruby
  # document.post_persist
  # ```
  def post_persist: () -> untyped

  # Get the previous changes on the document.
  #
  # _@return_ — The previous changes.
  #
  # Get the previous changes.
  # ```ruby
  # model.previous_changes
  # ```
  def previous_changes: () -> ::Hash[String, ::Array[Object | Object]]

  # Remove a change from the dirty attributes hash. Used by the single field
  # atomic updators.
  #
  # _@param_ `name` — The name of the field.
  #
  # Remove a flagged change.
  # ```ruby
  # model.remove_change(:field)
  # ```
  def remove_change: (Symbol | String name) -> untyped

  # Gets all the new values for each of the changed fields, to be passed to
  # a MongoDB $set modifier.
  #
  # _@return_ — A +Hash+ of atomic setters.
  #
  # Get the setters for the atomic updates.
  # ```ruby
  # person = Person.new(:title => "Sir")
  # person.title = "Madam"
  # person.setters # returns { "title" => "Madam" }
  # ```
  def setters: () -> ::Hash[untyped, untyped]

  # Get the old and new value for the provided attribute.
  #
  # _@param_ `attr` — The name of the attribute.
  #
  # _@return_ — The old and new values.
  #
  # Get the attribute change.
  # ```ruby
  # model.attribute_change("name")
  # ```
  def attribute_change: (String attr) -> ::Array[Object]

  # Determine if a specific attribute has changed.
  #
  # _@param_ `attr` — The name of the attribute.
  #
  # _@return_ — Whether the attribute has changed.
  #
  # Has the attribute changed?
  # ```ruby
  # model.attribute_changed?("name")
  # ```
  def attribute_changed?: (String attr) -> bool

  # Get whether or not the field has a different value from the default.
  #
  # _@param_ `attr` — The name of the attribute.
  #
  # _@return_ — If the attribute differs.
  #
  # Is the field different from the default?
  # ```ruby
  # model.attribute_changed_from_default?
  # ```
  def attribute_changed_from_default?: (String attr) -> bool

  # Get the previous value for the attribute.
  #
  # _@param_ `attr` — The attribute name.
  #
  # Get the previous value.
  # ```ruby
  # model.attribute_was("name")
  # ```
  def attribute_was: (String attr) -> untyped

  # Flag an attribute as going to change.
  #
  # _@param_ `attr` — The name of the attribute.
  #
  # _@return_ — The old value.
  #
  # Flag the attribute.
  # ```ruby
  # model.attribute_will_change!("name")
  # ```
  def attribute_will_change!: (String attr) -> Object

  # Set the attribute back to its old value.
  #
  # _@param_ `attr` — The name of the attribute.
  #
  # _@return_ — The old value.
  #
  # Reset the attribute.
  # ```ruby
  # model.reset_attribute!("name")
  # ```
  def reset_attribute!: (String attr) -> Object

  def reset_attribute_to_default!: (untyped attr) -> untyped

  # Add the document as an atomic pull.
  #
  # _@param_ `document` — The embedded document to pull.
  #
  # Add the atomic pull.
  # ```ruby
  # person.add_atomic_pull(address)
  # ```
  def add_atomic_pull: (Document document) -> untyped

  # Add an atomic unset for the document.
  #
  # _@param_ `document` — The child document.
  #
  # _@return_ — The children.
  #
  # Add an atomic unset.
  # ```ruby
  # document.add_atomic_unset(doc)
  # ```
  def add_atomic_unset: (Document document) -> ::Array[Document]

  # Returns path of the attribute for modification
  #
  # _@return_ — The path to the document attribute in the database
  #
  # Get path of the attribute
  # ```ruby
  # address.atomic_attribute_name(:city)
  # ```
  def atomic_attribute_name: (untyped name) -> String

  # For array fields these are the pushes that need to happen.
  #
  # _@return_ — The array pushes.
  #
  # Get the array pushes.
  # ```ruby
  # person.atomic_array_pushes
  # ```
  def atomic_array_pushes: () -> ::Hash[untyped, untyped]

  # For array fields these are the pulls that need to happen.
  #
  # _@return_ — The array pulls.
  #
  # Get the array pulls.
  # ```ruby
  # person.atomic_array_pulls
  # ```
  def atomic_array_pulls: () -> ::Hash[untyped, untyped]

  # For array fields these are the unique adds that need to happen.
  #
  # _@return_ — The array add_to_sets.
  #
  # Get the array unique adds.
  # ```ruby
  # person.atomic_array_add_to_sets
  # ```
  def atomic_array_add_to_sets: () -> ::Hash[untyped, untyped]

  # Get all the atomic updates that need to happen for the current
  # +Document+. This includes all changes that need to happen in the
  # entire hierarchy that exists below where the save call was made.
  #
  # _@return_ — The updates and their modifiers.
  #
  # Get the updates that need to occur.
  # ```ruby
  # person.atomic_updates(children)
  # ```
  #
  # _@note_ — MongoDB does not allow "conflicting modifications" to be
  # performed in a single operation. Conflicting modifications are
  # detected by the 'haveConflictingMod' function in MongoDB.
  # Examination of the code suggests that two modifications (a $set
  # and a $push with $each, for example) conflict if:
  #   (1) the key paths being modified are equal.
  #   (2) one key path is a prefix of the other.
  # So a $set of 'addresses.0.street' will conflict with a $push and $each
  # to 'addresses', and we will need to split our update into two
  # pieces. We do not, however, attempt to match MongoDB's logic
  # exactly. Instead, we assume that two updates conflict if the
  # first component of the two key paths matches.
  def atomic_updates: (?untyped _use_indexes) -> ::Hash[untyped, untyped]

  # Get the removal modifier for the document. Will be nil on root
  # documents, $unset on embeds_one, $set on embeds_many.
  #
  # _@return_ — The pull or unset operation.
  #
  # Get the removal operator.
  # ```ruby
  # name.atomic_delete_modifier
  # ```
  def atomic_delete_modifier: () -> String

  # Get the insertion modifier for the document. Will be nil on root
  # documents, $set on embeds_one, $push on embeds_many.
  #
  # _@return_ — The pull or set operator.
  #
  # Get the insert operation.
  # ```ruby
  # name.atomic_insert_modifier
  # ```
  def atomic_insert_modifier: () -> String

  # Return the path to this +Document+ in JSON notation, used for atomic
  # updates via $set in MongoDB.
  #
  # _@return_ — The path to the document in the database.
  #
  # Get the path to this document.
  # ```ruby
  # address.atomic_path
  # ```
  def atomic_path: () -> String

  # Returns the positional operator of this document for modification.
  #
  # _@return_ — The positional operator with indexes.
  #
  # Get the positional operator.
  # ```ruby
  # address.atomic_position
  # ```
  def atomic_position: () -> String

  # Get the atomic paths utility for this document.
  #
  # _@return_ — The associated path.
  #
  # Get the atomic paths.
  # ```ruby
  # document.atomic_paths
  # ```
  def atomic_paths: () -> Object

  # Get all the attributes that need to be pulled.
  #
  # _@return_ — The $pullAll operations.
  #
  # Get the pulls.
  # ```ruby
  # person.atomic_pulls
  # ```
  def atomic_pulls: () -> ::Array[::Hash[untyped, untyped]]

  # Get all the push attributes that need to occur.
  #
  # _@return_ — The $push and $each operations.
  #
  # Get the pushes.
  # ```ruby
  # person.atomic_pushes
  # ```
  def atomic_pushes: () -> ::Hash[untyped, untyped]

  # Get all the attributes that need to be set.
  #
  # _@return_ — The $set operations.
  #
  # Get the sets.
  # ```ruby
  # person.atomic_sets
  # ```
  def atomic_sets: () -> ::Hash[untyped, untyped]

  # Get all the attributes that need to be unset.
  #
  # _@return_ — The $unset operations.
  #
  # Get the unsets.
  # ```ruby
  # person.atomic_unsets
  # ```
  def atomic_unsets: () -> ::Array[::Hash[untyped, untyped]]

  # Get all the atomic sets that have had their saves delayed.
  #
  # _@return_ — The delayed $sets.
  #
  # Get the delayed atomic sets.
  # ```ruby
  # person.delayed_atomic_sets
  # ```
  def delayed_atomic_sets: () -> ::Hash[untyped, untyped]

  # Get a hash of atomic pulls that are pending.
  #
  # _@return_ — name/document pairs.
  #
  # Get the atomic pulls.
  # ```ruby
  # document.delayed_atomic_pulls
  # ```
  def delayed_atomic_pulls: () -> ::Hash[untyped, untyped]

  # Get the delayed atomic unsets.
  #
  # _@return_ — The atomic unsets
  #
  # Get the delayed atomic unsets.
  # ```ruby
  # document.delayed_atomic_unsets
  # ```
  def delayed_atomic_unsets: () -> ::Hash[untyped, untyped]

  # Flag the document as destroyed and return the atomic path.
  #
  # _@return_ — The atomic path.
  #
  # Flag destroyed and return path.
  # ```ruby
  # document.flag_as_destroyed
  # ```
  def flag_as_destroyed: () -> String

  # Get the flagged destroys.
  #
  # _@return_ — The flagged destroys.
  #
  # Get the flagged destroy.
  # ```ruby
  # document.flagged_destroys
  # ```
  def flagged_destroys: () -> ::Array[Proc]

  # Process all the pending flagged destroys from nested attributes.
  #
  # _@return_ — The cleared array.
  #
  # Process all the pending flagged destroys.
  # ```ruby
  # document.process_flagged_destroys
  # ```
  def process_flagged_destroys: () -> ::Array[untyped]

  def generate_atomic_updates: (::Array[[ untyped, untyped ]] | ::Hash[untyped, untyped] mods, Document doc) -> untyped

  # Get the atomic updates for a touch operation. Should only include the
  # updated_at field and the optional extra field.
  #
  # _@param_ `field` — The optional field.
  #
  # _@return_ — The atomic updates.
  #
  # Get the touch atomic updates.
  # ```ruby
  # document.touch_atomic_updates
  # ```
  def touch_atomic_updates: (?Symbol? field) -> ::Hash[untyped, untyped]
end

Mongoid::GlobalDiscriminatorKeyAssignment::Mongoid::GlobalDiscriminatorKeyAssignment::InvalidFieldHost::ILLEGAL_KEY: untyped

Mongoid::GlobalDiscriminatorKeyAssignment::Mongoid::GlobalDiscriminatorKeyAssignment::InvalidFieldHost::MODULES: untyped

Mongoid::GlobalDiscriminatorKeyAssignment::Mongoid::GlobalDiscriminatorKeyAssignment::InvalidFieldHost::RESERVED_METHOD_NAMES: untyped

Mongoid::GlobalDiscriminatorKeyAssignment::Mongoid::GlobalDiscriminatorKeyAssignment::InvalidFieldHost::CALLBACKS: untyped

Mongoid::GlobalDiscriminatorKeyAssignment::Mongoid::GlobalDiscriminatorKeyAssignment::InvalidFieldHost::MACRO_MAPPING: untyped

Mongoid::GlobalDiscriminatorKeyAssignment::Mongoid::GlobalDiscriminatorKeyAssignment::InvalidFieldHost::STRATEGIES: untyped

Mongoid::GlobalDiscriminatorKeyAssignment::Mongoid::GlobalDiscriminatorKeyAssignment::InvalidFieldHost::LIST_OPERATIONS: untyped

Mongoid::GlobalDiscriminatorKeyAssignment::Mongoid::GlobalDiscriminatorKeyAssignment::InvalidFieldHost::StringifiedSymbol: untyped

Mongoid::GlobalDiscriminatorKeyAssignment::Mongoid::GlobalDiscriminatorKeyAssignment::InvalidFieldHost::Boolean: untyped

Mongoid::GlobalDiscriminatorKeyAssignment::Mongoid::GlobalDiscriminatorKeyAssignment::InvalidFieldHost::TYPE_MAPPINGS: untyped

Mongoid::GlobalDiscriminatorKeyAssignment::Mongoid::GlobalDiscriminatorKeyAssignment::InvalidFieldHost::IDS: untyped

Mongoid::GlobalDiscriminatorKeyAssignment::Mongoid::GlobalDiscriminatorKeyAssignment::InvalidFieldHost::CREATE_LOCK: untyped

Mongoid::GlobalDiscriminatorKeyAssignment::Mongoid::GlobalDiscriminatorKeyAssignment::InvalidFieldHost::UPDATES: untyped

# This module contains the logic for supporting atomic operations against the
# database.
module Mongoid::Atomic
  extend ActiveSupport::Concern

  # Add the document as an atomic pull.
  #
  # _@param_ `document` — The embedded document to pull.
  #
  # Add the atomic pull.
  # ```ruby
  # person.add_atomic_pull(address)
  # ```
  def add_atomic_pull: (Document document) -> untyped

  # Add an atomic unset for the document.
  #
  # _@param_ `document` — The child document.
  #
  # _@return_ — The children.
  #
  # Add an atomic unset.
  # ```ruby
  # document.add_atomic_unset(doc)
  # ```
  def add_atomic_unset: (Document document) -> ::Array[Document]

  # Returns path of the attribute for modification
  #
  # _@return_ — The path to the document attribute in the database
  #
  # Get path of the attribute
  # ```ruby
  # address.atomic_attribute_name(:city)
  # ```
  def atomic_attribute_name: (untyped name) -> String

  # For array fields these are the pushes that need to happen.
  #
  # _@return_ — The array pushes.
  #
  # Get the array pushes.
  # ```ruby
  # person.atomic_array_pushes
  # ```
  def atomic_array_pushes: () -> ::Hash[untyped, untyped]

  # For array fields these are the pulls that need to happen.
  #
  # _@return_ — The array pulls.
  #
  # Get the array pulls.
  # ```ruby
  # person.atomic_array_pulls
  # ```
  def atomic_array_pulls: () -> ::Hash[untyped, untyped]

  # For array fields these are the unique adds that need to happen.
  #
  # _@return_ — The array add_to_sets.
  #
  # Get the array unique adds.
  # ```ruby
  # person.atomic_array_add_to_sets
  # ```
  def atomic_array_add_to_sets: () -> ::Hash[untyped, untyped]

  # Get all the atomic updates that need to happen for the current
  # +Document+. This includes all changes that need to happen in the
  # entire hierarchy that exists below where the save call was made.
  #
  # _@return_ — The updates and their modifiers.
  #
  # Get the updates that need to occur.
  # ```ruby
  # person.atomic_updates(children)
  # ```
  #
  # _@note_ — MongoDB does not allow "conflicting modifications" to be
  # performed in a single operation. Conflicting modifications are
  # detected by the 'haveConflictingMod' function in MongoDB.
  # Examination of the code suggests that two modifications (a $set
  # and a $push with $each, for example) conflict if:
  #   (1) the key paths being modified are equal.
  #   (2) one key path is a prefix of the other.
  # So a $set of 'addresses.0.street' will conflict with a $push and $each
  # to 'addresses', and we will need to split our update into two
  # pieces. We do not, however, attempt to match MongoDB's logic
  # exactly. Instead, we assume that two updates conflict if the
  # first component of the two key paths matches.
  def atomic_updates: (?untyped _use_indexes) -> ::Hash[untyped, untyped]

  # Get the removal modifier for the document. Will be nil on root
  # documents, $unset on embeds_one, $set on embeds_many.
  #
  # _@return_ — The pull or unset operation.
  #
  # Get the removal operator.
  # ```ruby
  # name.atomic_delete_modifier
  # ```
  def atomic_delete_modifier: () -> String

  # Get the insertion modifier for the document. Will be nil on root
  # documents, $set on embeds_one, $push on embeds_many.
  #
  # _@return_ — The pull or set operator.
  #
  # Get the insert operation.
  # ```ruby
  # name.atomic_insert_modifier
  # ```
  def atomic_insert_modifier: () -> String

  # Return the path to this +Document+ in JSON notation, used for atomic
  # updates via $set in MongoDB.
  #
  # _@return_ — The path to the document in the database.
  #
  # Get the path to this document.
  # ```ruby
  # address.atomic_path
  # ```
  def atomic_path: () -> String

  # Returns the positional operator of this document for modification.
  #
  # _@return_ — The positional operator with indexes.
  #
  # Get the positional operator.
  # ```ruby
  # address.atomic_position
  # ```
  def atomic_position: () -> String

  # Get the atomic paths utility for this document.
  #
  # _@return_ — The associated path.
  #
  # Get the atomic paths.
  # ```ruby
  # document.atomic_paths
  # ```
  def atomic_paths: () -> Object

  # Get all the attributes that need to be pulled.
  #
  # _@return_ — The $pullAll operations.
  #
  # Get the pulls.
  # ```ruby
  # person.atomic_pulls
  # ```
  def atomic_pulls: () -> ::Array[::Hash[untyped, untyped]]

  # Get all the push attributes that need to occur.
  #
  # _@return_ — The $push and $each operations.
  #
  # Get the pushes.
  # ```ruby
  # person.atomic_pushes
  # ```
  def atomic_pushes: () -> ::Hash[untyped, untyped]

  # Get all the attributes that need to be set.
  #
  # _@return_ — The $set operations.
  #
  # Get the sets.
  # ```ruby
  # person.atomic_sets
  # ```
  def atomic_sets: () -> ::Hash[untyped, untyped]

  # Get all the attributes that need to be unset.
  #
  # _@return_ — The $unset operations.
  #
  # Get the unsets.
  # ```ruby
  # person.atomic_unsets
  # ```
  def atomic_unsets: () -> ::Array[::Hash[untyped, untyped]]

  # Get all the atomic sets that have had their saves delayed.
  #
  # _@return_ — The delayed $sets.
  #
  # Get the delayed atomic sets.
  # ```ruby
  # person.delayed_atomic_sets
  # ```
  def delayed_atomic_sets: () -> ::Hash[untyped, untyped]

  # Get a hash of atomic pulls that are pending.
  #
  # _@return_ — name/document pairs.
  #
  # Get the atomic pulls.
  # ```ruby
  # document.delayed_atomic_pulls
  # ```
  def delayed_atomic_pulls: () -> ::Hash[untyped, untyped]

  # Get the delayed atomic unsets.
  #
  # _@return_ — The atomic unsets
  #
  # Get the delayed atomic unsets.
  # ```ruby
  # document.delayed_atomic_unsets
  # ```
  def delayed_atomic_unsets: () -> ::Hash[untyped, untyped]

  # Flag the document as destroyed and return the atomic path.
  #
  # _@return_ — The atomic path.
  #
  # Flag destroyed and return path.
  # ```ruby
  # document.flag_as_destroyed
  # ```
  def flag_as_destroyed: () -> String

  # Get the flagged destroys.
  #
  # _@return_ — The flagged destroys.
  #
  # Get the flagged destroy.
  # ```ruby
  # document.flagged_destroys
  # ```
  def flagged_destroys: () -> ::Array[Proc]

  # Process all the pending flagged destroys from nested attributes.
  #
  # _@return_ — The cleared array.
  #
  # Process all the pending flagged destroys.
  # ```ruby
  # document.process_flagged_destroys
  # ```
  def process_flagged_destroys: () -> ::Array[untyped]

  # Generates the atomic updates in the correct order.
  #
  # _@param_ `mods` — The atomic modifications.
  #
  # _@param_ `doc` — The document to update for.
  #
  # Generate the updates.
  # ```ruby
  # model.generate_atomic_updates(mods, doc)
  # ```
  def generate_atomic_updates: (Modifiers mods, Document doc) -> untyped

  # Get the atomic updates for a touch operation. Should only include the
  # updated_at field and the optional extra field.
  #
  # _@param_ `field` — The optional field.
  #
  # _@return_ — The atomic updates.
  #
  # Get the touch atomic updates.
  # ```ruby
  # document.touch_atomic_updates
  # ```
  def touch_atomic_updates: (?Symbol? field) -> ::Hash[untyped, untyped]
end

Mongoid::Atomic::UPDATES: untyped

# This class contains the logic for supporting atomic operations against the
# database.
class Mongoid::Atomic::Modifiers < Hash
  # Add the atomic $addToSet modifiers to the hash.
  #
  # _@param_ `modifications` — The add to set modifiers.
  #
  # Add the $addToSet modifiers.
  # ```ruby
  # modifiers.add_to_set({ "preference_ids" => [ "one" ] })
  # ```
  def add_to_set: (::Hash[untyped, untyped] modifications) -> untyped

  # Adds pull all modifiers to the modifiers hash.
  #
  # _@param_ `modifications` — The pull all modifiers.
  #
  # Add pull all operations.
  # ```ruby
  # modifiers.pull_all({ "addresses" => { "street" => "Bond" }})
  # ```
  def pull_all: (::Hash[untyped, untyped] modifications) -> untyped

  # Adds pull all modifiers to the modifiers hash.
  #
  # _@param_ `modifications` — The pull all modifiers.
  #
  # Add pull all operations.
  # ```ruby
  # modifiers.pull({ "addresses" => { "_id" => { "$in" => [ 1, 2, 3 ]}}})
  # ```
  def pull: (::Hash[untyped, untyped] modifications) -> untyped

  # Adds push modifiers to the modifiers hash.
  #
  # _@param_ `modifications` — The push modifiers.
  #
  # Add push operations.
  # ```ruby
  # modifiers.push({ "addresses" => { "street" => "Bond" }})
  # ```
  def push: (::Hash[untyped, untyped] modifications) -> untyped

  # Adds set operations to the modifiers hash.
  #
  # _@param_ `modifications` — The set modifiers.
  #
  # Add set operations.
  # ```ruby
  # modifiers.set({ "title" => "sir" })
  # ```
  def set: (::Hash[untyped, untyped] modifications) -> untyped

  # Adds unset operations to the modifiers hash.
  #
  # _@param_ `modifications` — The unset association names.
  #
  # Add unset operations.
  # ```ruby
  # modifiers.unset([ "addresses" ])
  # ```
  def unset: (::Array[String] modifications) -> untyped

  # Add the operation to the modifications, either appending or creating a
  # new one.
  #
  # _@param_ `mods` — The modifications.
  #
  # _@param_ `field` — The field.
  #
  # _@param_ `value` — The atomic op.
  #
  # Add the operation.
  # ```ruby
  # modifications.add_operation(mods, field, value)
  # ```
  def add_operation: (::Hash[untyped, untyped] mods, String field, ::Hash[untyped, untyped] value) -> untyped

  # Adds or appends an array operation with the $each specifier used
  # in conjuction with $push.
  #
  # _@param_ `mods` — The modifications.
  #
  # _@param_ `field` — The field.
  #
  # _@param_ `value` — The atomic op.
  #
  # Add the operation.
  # ```ruby
  # modifications.add_operation(mods, field, value)
  # ```
  def add_each_operation: (::Hash[untyped, untyped] mods, String field, ::Hash[untyped, untyped] value) -> untyped

  # Get the $addToSet operations or intialize a new one.
  #
  # _@return_ — The $addToSet operations.
  #
  # Get the $addToSet operations.
  # ```ruby
  # modifiers.add_to_sets
  # ```
  def add_to_sets: () -> ::Hash[untyped, untyped]

  # Is the operation going to be a conflict for a $set?
  #
  # _@param_ `field` — The field.
  #
  # _@return_ — If this field is a conflict.
  #
  # Is this a conflict for a set?
  # ```ruby
  # modifiers.set_conflict?(field)
  # ```
  def set_conflict?: (String field) -> bool

  # Is the operation going to be a conflict for a $push?
  #
  # _@param_ `field` — The field.
  #
  # _@return_ — If this field is a conflict.
  #
  # Is this a conflict for a push?
  # ```ruby
  # modifiers.push_conflict?(field)
  # ```
  def push_conflict?: (String field) -> bool

  # Get the conflicting pull modifications.
  #
  # _@return_ — The conflicting pull operations.
  #
  # Get the conflicting pulls.
  # ```ruby
  # modifiers.conflicting_pulls
  # ```
  def conflicting_pulls: () -> ::Hash[untyped, untyped]

  # Get the conflicting push modifications.
  #
  # _@return_ — The conflicting push operations.
  #
  # Get the conflicting pushs.
  # ```ruby
  # modifiers.conflicting_pushs
  # ```
  def conflicting_pushes: () -> ::Hash[untyped, untyped]

  # Get the conflicting set modifications.
  #
  # _@return_ — The conflicting set operations.
  #
  # Get the conflicting sets.
  # ```ruby
  # modifiers.conflicting_sets
  # ```
  def conflicting_sets: () -> ::Hash[untyped, untyped]

  # Get the push operations that would have conflicted with the sets.
  #
  # _@return_ — The conflicting modifications.
  #
  # Get the conflicts.
  # ```ruby
  # modifiers.conflicts
  # ```
  def conflicts: () -> ::Hash[untyped, untyped]

  # Get the names of the fields that need to be pulled.
  #
  # _@return_ — The pull fields.
  #
  # Get the pull fields.
  # ```ruby
  # modifiers.pull_fields
  # ```
  def pull_fields: () -> ::Array[String]

  # Get the names of the fields that need to be pushed.
  #
  # _@return_ — The push fields.
  #
  # Get the push fields.
  # ```ruby
  # modifiers.push_fields
  # ```
  def push_fields: () -> ::Array[String]

  # Get the names of the fields that need to be set.
  #
  # _@return_ — The set fields.
  #
  # Get the set fields.
  # ```ruby
  # modifiers.set_fields
  # ```
  def set_fields: () -> ::Array[String]

  # Get the $pullAll operations or intialize a new one.
  #
  # _@return_ — The $pullAll operations.
  #
  # Get the $pullAll operations.
  # ```ruby
  # modifiers.pull_alls
  # ```
  def pull_alls: () -> ::Hash[untyped, untyped]

  # Get the $pull operations or intialize a new one.
  #
  # _@return_ — The $pull operations.
  #
  # Get the $pull operations.
  # ```ruby
  # modifiers.pulls
  # ```
  def pulls: () -> ::Hash[untyped, untyped]

  # Get the $push/$each operations or initialize a new one.
  #
  # _@return_ — The $push/$each operations.
  #
  # Get the $push/$each operations.
  # ```ruby
  # modifiers.pushes
  # ```
  def pushes: () -> ::Hash[untyped, untyped]

  # Get the $set operations or intialize a new one.
  #
  # _@return_ — The $set operations.
  #
  # Get the $set operations.
  # ```ruby
  # modifiers.sets
  # ```
  def sets: () -> ::Hash[untyped, untyped]

  # Get the $unset operations or initialize a new one.
  #
  # _@return_ — The $unset operations.
  #
  # Get the $unset operations.
  # ```ruby
  # modifiers.unsets
  # ```
  def unsets: () -> ::Hash[untyped, untyped]
end

Mongoid::Atomic::Mongoid::Atomic::Modifiers::K: untyped

Mongoid::Atomic::Mongoid::Atomic::Modifiers::V: untyped

Mongoid::Atomic::Mongoid::Atomic::Modifiers::Elem: untyped

module Mongoid::Atomic::Paths
end

# This class encapsulates behavior for locating and updating root
# documents atomically.
class Mongoid::Atomic::Mongoid::Atomic::Paths::Root
  # Create the new root path utility.
  #
  # _@param_ `document` — The document to generate the paths for.
  #
  # Create the root path util.
  # ```ruby
  # Root.new(document)
  # ```
  def initialize: (Document document) -> void

  # Asking for the insert modifier on a document with a root path
  # indicates a mixed association most likely happened.
  #
  # Attempt to get the insert modifier.
  # ```ruby
  # root.insert_modifier
  # ```
  def insert_modifier: () -> untyped
end

# Common functionality between the two different embedded paths.
module Mongoid::Atomic::Mongoid::Atomic::Paths::Embedded
  # Returns the value of attribute document.
  #
  # Returns the value of attribute path.
  #
  # Returns the value of attribute position.
  #
  # Get the path to the document in the hierarchy.
  #
  # _@return_ — The path to the document.
  #
  # Get the path.
  # ```ruby
  # many.path
  # ```
  def path: () -> untyped
          | () -> untyped
          | () -> untyped
          | () -> String
end

# This class encapsulates behavior for locating and updating
# documents that are defined as an embedded 1-1.
class Mongoid::Atomic::Mongoid::Atomic::Paths::Mongoid::Atomic::Mongoid::Atomic::Paths::Embedded::One
  include Mongoid::Atomic::Paths::Embedded

  # Returns the value of attribute delete_modifier.
  #
  # Returns the value of attribute document.
  #
  # Returns the value of attribute insert_modifier.
  #
  # Returns the value of attribute parent.
  #
  # Create the new path utility.
  #
  # _@param_ `document` — The document to generate the paths for.
  #
  # Create the path util.
  # ```ruby
  # One.new(document)
  # ```
  def initialize: () -> untyped
                | () -> untyped
                | () -> untyped
                | () -> untyped
                | (Document document) -> void

  # Get the position of the document in the hierarchy. This will
  # include indexes of 1-n embedded associations that may sit above the
  # embedded one.
  #
  # _@return_ — The position of the document.
  #
  # Get the position.
  # ```ruby
  # one.position
  # ```
  def position: () -> String

  # Get the path to the document in the hierarchy.
  #
  # _@return_ — The path to the document.
  #
  # Get the path.
  # ```ruby
  # many.path
  # ```
  def path: () -> String
end

# This class encapsulates behavior for locating and updating
# documents that are defined as an embedded 1-n.
class Mongoid::Atomic::Mongoid::Atomic::Paths::Mongoid::Atomic::Mongoid::Atomic::Paths::Embedded::Many
  include Mongoid::Atomic::Paths::Embedded

  # Create the new path utility.
  #
  # _@param_ `document` — The document to generate the paths for.
  #
  # Create the path util.
  # ```ruby
  # Many.new(document)
  # ```
  def initialize: (Document document) -> void

  # Get the position of the document in the hierarchy. This will
  # include indexes of 1-n embedded associations that may sit above the
  # embedded many.
  #
  # _@return_ — The position of the document.
  #
  # Get the position.
  # ```ruby
  # many.position
  # ```
  def position: () -> String

  # Get the path to the document in the hierarchy.
  #
  # _@return_ — The path to the document.
  #
  # Get the path.
  # ```ruby
  # many.path
  # ```
  def path: () -> String
end

# This module defines all the configuration options for Mongoid, including
# the database connections.
module Mongoid::Config
  extend Mongoid::Config

  extend Forwardable

  extend Mongoid::Config::Options

  # Has Mongoid been configured? This is checking that at least a valid
  # client config exists.
  #
  # _@return_ — If Mongoid is configured.
  #
  # Is Mongoid configured?
  # ```ruby
  # config.configured?
  # ```
  def configured?: () -> bool

  # Connect to the provided database name on the default client.
  #
  # _@param_ `name` — The database name.
  #
  # Set the database to connect to.
  # ```ruby
  # config.connect_to("mongoid_test")
  # ```
  #
  # _@note_ — Use only in development or test environments for convenience.
  def connect_to: (String name, ?untyped options) -> untyped

  # Return field names that could cause destructive things to happen if
  # defined in a Mongoid::Document.
  #
  # _@return_ — An array of bad field names.
  #
  # Get the destructive fields.
  # ```ruby
  # config.destructive_fields
  # ```
  def destructive_fields: () -> ::Array[String]

  # Load the settings from a compliant mongoid.yml file. This can be used for
  # easy setup with frameworks other than Rails.
  #
  # _@param_ `path` — The path to the file.
  #
  # _@param_ `environment` — The environment to load.
  #
  # Configure Mongoid.
  # ```ruby
  # Mongoid.load!("/path/to/mongoid.yml")
  # ```
  def load!: (String path, ?(String | Symbol)? environment) -> untyped

  # Get all the models in the application - this is everything that includes
  # Mongoid::Document.
  #
  # _@return_ — All the models in the application.
  #
  # Get all the models.
  # ```ruby
  # config.models
  # ```
  def models: () -> ::Array[Class]

  # Register a model in the application with Mongoid.
  #
  # _@param_ `klass` — The model to register.
  #
  # Register a model.
  # ```ruby
  # config.register_model(Band)
  # ```
  def register_model: (Class klass) -> untyped

  # From a hash of settings, load all the configuration.
  #
  # _@param_ `settings` — The configuration settings.
  #
  # Load the configuration.
  # ```ruby
  # config.load_configuration(settings)
  # ```
  def load_configuration: (::Hash[untyped, untyped] settings) -> untyped

  # Override the database to use globally.
  #
  # _@param_ `name` — The name of the database.
  #
  # _@return_ — The global override.
  #
  # Override the database globally.
  # ```ruby
  # config.override_database(:optional)
  # ```
  def override_database: (String | Symbol name) -> (String | Symbol)

  # Override the client to use globally.
  #
  # _@param_ `name` — The name of the client.
  #
  # _@return_ — The global override.
  #
  # Override the client globally.
  # ```ruby
  # config.override_client(:optional)
  # ```
  def override_client: (String | Symbol name) -> (String | Symbol)

  # Purge all data in all collections, including indexes.
  #
  # _@return_ — true.
  #
  # Purge all data.
  # ```ruby
  # Mongoid::Config.purge!
  # ```
  #
  # _@note_ — This is the fastest way to drop all data.
  def purge!: () -> bool

  # Truncate all data in all collections, but not the indexes.
  #
  # _@return_ — true.
  #
  # Truncate all collection data.
  # ```ruby
  # Mongoid::Config.truncate!
  # ```
  #
  # _@note_ — This will be slower than purge!
  def truncate!: () -> bool

  # Set the configuration options. Will validate each one individually.
  #
  # _@param_ `options` — The configuration options.
  #
  # Set the options.
  # ```ruby
  # config.options = { raise_not_found_error: true }
  # ```
  def options=: (::Hash[untyped, untyped] options) -> untyped

  # Get the client configuration or an empty hash.
  #
  # _@return_ — The clients configuration.
  #
  # Get the clients configuration.
  # ```ruby
  # config.clients
  # ```
  def clients: () -> ::Hash[untyped, untyped]

  # Get the time zone to use.
  #
  # _@return_ — The time zone.
  #
  # Get the time zone.
  # ```ruby
  # Config.time_zone
  # ```
  def time_zone: () -> String

  # Is the application running under passenger?
  #
  # _@return_ — If the app is deployed on Passenger.
  #
  # Is the application using passenger?
  # ```ruby
  # config.running_with_passenger?
  # ```
  def running_with_passenger?: () -> bool

  def set_log_levels: () -> untyped

  # sord infer - inferred type of parameter "clients" as T::Hash[T.untyped, T.untyped] using getter's return type
  def clients=: (::Hash[untyped, untyped] clients) -> untyped

  # Get the defaults or initialize a new empty hash.
  #
  # _@return_ — The default options.
  #
  # Get the defaults.
  # ```ruby
  # options.defaults
  # ```
  def self.defaults: () -> ::Hash[untyped, untyped]

  # Define a configuration option with a default.
  #
  # _@param_ `name` — The name of the configuration option.
  #
  # _@param_ `options` — Extras for the option.
  #
  # Define the option.
  # ```ruby
  # Options.option(:logger, :default => Logger.new(STDERR, :warn))
  # ```
  def self.option: (Symbol name, ?::Hash[untyped, untyped] options) -> untyped

  # Reset the configuration options to the defaults.
  #
  # _@return_ — The defaults.
  #
  # Reset the configuration options.
  # ```ruby
  # config.reset
  # ```
  def self.reset: () -> ::Hash[untyped, untyped]

  # Get the settings or initialize a new empty hash.
  #
  # _@return_ — The setting options.
  #
  # Get the settings.
  # ```ruby
  # options.settings
  # ```
  def self.settings: () -> ::Hash[untyped, untyped]

  # Get the log level.
  #
  # _@return_ — The log level.
  #
  # Get the log level.
  # ```ruby
  # config.log_level
  # ```
  def self.log_level: () -> Integer

  # Has Mongoid been configured? This is checking that at least a valid
  # client config exists.
  #
  # _@return_ — If Mongoid is configured.
  #
  # Is Mongoid configured?
  # ```ruby
  # config.configured?
  # ```
  def self.configured?: () -> bool

  # Connect to the provided database name on the default client.
  #
  # _@param_ `name` — The database name.
  #
  # Set the database to connect to.
  # ```ruby
  # config.connect_to("mongoid_test")
  # ```
  #
  # _@note_ — Use only in development or test environments for convenience.
  def self.connect_to: (String name, ?untyped options) -> untyped

  # Return field names that could cause destructive things to happen if
  # defined in a Mongoid::Document.
  #
  # _@return_ — An array of bad field names.
  #
  # Get the destructive fields.
  # ```ruby
  # config.destructive_fields
  # ```
  def self.destructive_fields: () -> ::Array[String]

  # Load the settings from a compliant mongoid.yml file. This can be used for
  # easy setup with frameworks other than Rails.
  #
  # _@param_ `path` — The path to the file.
  #
  # _@param_ `environment` — The environment to load.
  #
  # Configure Mongoid.
  # ```ruby
  # Mongoid.load!("/path/to/mongoid.yml")
  # ```
  def self.load!: (String path, ?(String | Symbol)? environment) -> untyped

  # Get all the models in the application - this is everything that includes
  # Mongoid::Document.
  #
  # _@return_ — All the models in the application.
  #
  # Get all the models.
  # ```ruby
  # config.models
  # ```
  def self.models: () -> ::Array[Class]

  # Register a model in the application with Mongoid.
  #
  # _@param_ `klass` — The model to register.
  #
  # Register a model.
  # ```ruby
  # config.register_model(Band)
  # ```
  def self.register_model: (Class klass) -> untyped

  # From a hash of settings, load all the configuration.
  #
  # _@param_ `settings` — The configuration settings.
  #
  # Load the configuration.
  # ```ruby
  # config.load_configuration(settings)
  # ```
  def self.load_configuration: (::Hash[untyped, untyped] settings) -> untyped

  # Override the database to use globally.
  #
  # _@param_ `name` — The name of the database.
  #
  # _@return_ — The global override.
  #
  # Override the database globally.
  # ```ruby
  # config.override_database(:optional)
  # ```
  def self.override_database: (String | Symbol name) -> (String | Symbol)

  # Override the client to use globally.
  #
  # _@param_ `name` — The name of the client.
  #
  # _@return_ — The global override.
  #
  # Override the client globally.
  # ```ruby
  # config.override_client(:optional)
  # ```
  def self.override_client: (String | Symbol name) -> (String | Symbol)

  # Purge all data in all collections, including indexes.
  #
  # _@return_ — true.
  #
  # Purge all data.
  # ```ruby
  # Mongoid::Config.purge!
  # ```
  #
  # _@note_ — This is the fastest way to drop all data.
  def self.purge!: () -> bool

  # Truncate all data in all collections, but not the indexes.
  #
  # _@return_ — true.
  #
  # Truncate all collection data.
  # ```ruby
  # Mongoid::Config.truncate!
  # ```
  #
  # _@note_ — This will be slower than purge!
  def self.truncate!: () -> bool

  # Set the configuration options. Will validate each one individually.
  #
  # _@param_ `options` — The configuration options.
  #
  # Set the options.
  # ```ruby
  # config.options = { raise_not_found_error: true }
  # ```
  def self.options=: (::Hash[untyped, untyped] options) -> untyped

  # Get the client configuration or an empty hash.
  #
  # _@return_ — The clients configuration.
  #
  # Get the clients configuration.
  # ```ruby
  # config.clients
  # ```
  def self.clients: () -> ::Hash[untyped, untyped]

  # Get the time zone to use.
  #
  # _@return_ — The time zone.
  #
  # Get the time zone.
  # ```ruby
  # Config.time_zone
  # ```
  def self.time_zone: () -> String

  # Is the application running under passenger?
  #
  # _@return_ — If the app is deployed on Passenger.
  #
  # Is the application using passenger?
  # ```ruby
  # config.running_with_passenger?
  # ```
  def self.running_with_passenger?: () -> bool

  def self.set_log_levels: () -> untyped

  # sord infer - inferred type of parameter "clients" as T::Hash[T.untyped, T.untyped] using getter's return type
  def self.clients=: (::Hash[untyped, untyped] clients) -> untyped
end

Mongoid::Config::LOCK: untyped

# Encapsulates logic for setting options.
module Mongoid::Config::Options
  # Get the defaults or initialize a new empty hash.
  #
  # _@return_ — The default options.
  #
  # Get the defaults.
  # ```ruby
  # options.defaults
  # ```
  def defaults: () -> ::Hash[untyped, untyped]

  # Define a configuration option with a default.
  #
  # _@param_ `name` — The name of the configuration option.
  #
  # _@param_ `options` — Extras for the option.
  #
  # Define the option.
  # ```ruby
  # Options.option(:logger, :default => Logger.new(STDERR, :warn))
  # ```
  def option: (Symbol name, ?::Hash[untyped, untyped] options) -> untyped

  # Reset the configuration options to the defaults.
  #
  # _@return_ — The defaults.
  #
  # Reset the configuration options.
  # ```ruby
  # config.reset
  # ```
  def reset: () -> ::Hash[untyped, untyped]

  # Get the settings or initialize a new empty hash.
  #
  # _@return_ — The setting options.
  #
  # Get the settings.
  # ```ruby
  # options.settings
  # ```
  def settings: () -> ::Hash[untyped, untyped]

  # Get the log level.
  #
  # _@return_ — The log level.
  #
  # Get the log level.
  # ```ruby
  # config.log_level
  # ```
  def log_level: () -> Integer
end

# Encapsulates logic for getting environment information.
module Mongoid::Config::Environment
  extend Mongoid::Config::Environment

  # Get the name of the environment that Mongoid is running under.
  #
  # Uses the following sources in order:
  # - If +::Rails+ is defined, +Rails.env+.
  # - If +::Sinatra+ is defined, +Sinatra::Base.environment+.
  # - +RACK_ENV+
  # - +MONGOID_ENV*
  #
  # _@return_ — The name of the current environment.
  #
  # Get the env name.
  # ```ruby
  # Environment.env_name
  # ```
  def env_name: () -> String

  # Load the yaml from the provided path and return the settings for the
  # specified environment, or for the current Mongoid environment.
  #
  # _@param_ `path` — The location of the file.
  #
  # _@param_ `environment` — Optional environment name to override the current Mongoid environment.
  #
  # _@return_ — The settings.
  #
  # Load the yaml.
  # ```ruby
  # Environment.load_yaml("/work/mongoid.yml")
  # ```
  def load_yaml: (String path, ?(String | Symbol)? environment) -> ::Hash[untyped, untyped]

  # Get the name of the environment that Mongoid is running under.
  #
  # Uses the following sources in order:
  # - If +::Rails+ is defined, +Rails.env+.
  # - If +::Sinatra+ is defined, +Sinatra::Base.environment+.
  # - +RACK_ENV+
  # - +MONGOID_ENV*
  #
  # _@return_ — The name of the current environment.
  #
  # Get the env name.
  # ```ruby
  # Environment.env_name
  # ```
  def self.env_name: () -> String

  # Load the yaml from the provided path and return the settings for the
  # specified environment, or for the current Mongoid environment.
  #
  # _@param_ `path` — The location of the file.
  #
  # _@param_ `environment` — Optional environment name to override the current Mongoid environment.
  #
  # _@return_ — The settings.
  #
  # Load the yaml.
  # ```ruby
  # Environment.load_yaml("/work/mongoid.yml")
  # ```
  def self.load_yaml: (String path, ?(String | Symbol)? environment) -> ::Hash[untyped, untyped]
end

module Mongoid::Config::Validators
end

# Validator for client specific configuration.
module Mongoid::Config::Mongoid::Config::Validators::Client
  extend Mongoid::Config::Validators::Client

  # Validate the client configuration.
  #
  # _@param_ `clients` — The clients config.
  #
  # Validate the client config.
  # ```ruby
  # Client.validate({ default: { hosts: [ "localhost:27017" ] }})
  # ```
  def validate: (::Hash[untyped, untyped] clients) -> untyped

  # Validate that the client config has database.
  #
  # _@param_ `name` — The config key.
  #
  # _@param_ `config` — The configuration.
  #
  # Validate the client has database.
  # ```ruby
  # validator.validate_client_database(:default, {})
  # ```
  def validate_client_database: (String | Symbol name, ::Hash[untyped, untyped] config) -> untyped

  # Validate that the client config has hosts.
  #
  # _@param_ `name` — The config key.
  #
  # _@param_ `config` — The configuration.
  #
  # Validate the client has hosts.
  # ```ruby
  # validator.validate_client_hosts(:default, {})
  # ```
  def validate_client_hosts: (String | Symbol name, ::Hash[untyped, untyped] config) -> untyped

  # Validate that not both a uri and standard options are provided for a
  # single client.
  #
  # _@param_ `name` — The config key.
  #
  # _@param_ `config` — The configuration.
  #
  # Validate the uri and options.
  # ```ruby
  # validator.validate_client_uri(:default, {})
  # ```
  def validate_client_uri: (String | Symbol name, ::Hash[untyped, untyped] config) -> untyped

  # Return true if the configuration has no database or uri option
  # defined.
  #
  # _@param_ `config` — The configuration options.
  #
  # _@return_ — If no database or uri is defined.
  #
  # Validate the options.
  # ```ruby
  # validator.no_database_or_uri?(config)
  # ```
  def no_database_or_uri?: (::Hash[untyped, untyped] config) -> bool

  # Return true if the configuration has no hosts or uri option
  # defined.
  #
  # _@param_ `config` — The configuration options.
  #
  # _@return_ — If no hosts or uri is defined.
  #
  # Validate the options.
  # ```ruby
  # validator.no_hosts_or_uri?(config)
  # ```
  def no_hosts_or_uri?: (::Hash[untyped, untyped] config) -> bool

  # Return true if the configuration has both standard options and a uri
  # defined.
  #
  # _@param_ `config` — The configuration options.
  #
  # _@return_ — If both standard and uri are defined.
  #
  # Validate the options.
  # ```ruby
  # validator.no_database_or_uri?(config)
  # ```
  def both_uri_and_standard?: (::Hash[untyped, untyped] config) -> bool

  # Validate the client configuration.
  #
  # _@param_ `clients` — The clients config.
  #
  # Validate the client config.
  # ```ruby
  # Client.validate({ default: { hosts: [ "localhost:27017" ] }})
  # ```
  def self.validate: (::Hash[untyped, untyped] clients) -> untyped

  # Validate that the client config has database.
  #
  # _@param_ `name` — The config key.
  #
  # _@param_ `config` — The configuration.
  #
  # Validate the client has database.
  # ```ruby
  # validator.validate_client_database(:default, {})
  # ```
  def self.validate_client_database: (String | Symbol name, ::Hash[untyped, untyped] config) -> untyped

  # Validate that the client config has hosts.
  #
  # _@param_ `name` — The config key.
  #
  # _@param_ `config` — The configuration.
  #
  # Validate the client has hosts.
  # ```ruby
  # validator.validate_client_hosts(:default, {})
  # ```
  def self.validate_client_hosts: (String | Symbol name, ::Hash[untyped, untyped] config) -> untyped

  # Validate that not both a uri and standard options are provided for a
  # single client.
  #
  # _@param_ `name` — The config key.
  #
  # _@param_ `config` — The configuration.
  #
  # Validate the uri and options.
  # ```ruby
  # validator.validate_client_uri(:default, {})
  # ```
  def self.validate_client_uri: (String | Symbol name, ::Hash[untyped, untyped] config) -> untyped

  # Return true if the configuration has no database or uri option
  # defined.
  #
  # _@param_ `config` — The configuration options.
  #
  # _@return_ — If no database or uri is defined.
  #
  # Validate the options.
  # ```ruby
  # validator.no_database_or_uri?(config)
  # ```
  def self.no_database_or_uri?: (::Hash[untyped, untyped] config) -> bool

  # Return true if the configuration has no hosts or uri option
  # defined.
  #
  # _@param_ `config` — The configuration options.
  #
  # _@return_ — If no hosts or uri is defined.
  #
  # Validate the options.
  # ```ruby
  # validator.no_hosts_or_uri?(config)
  # ```
  def self.no_hosts_or_uri?: (::Hash[untyped, untyped] config) -> bool

  # Return true if the configuration has both standard options and a uri
  # defined.
  #
  # _@param_ `config` — The configuration options.
  #
  # _@return_ — If both standard and uri are defined.
  #
  # Validate the options.
  # ```ruby
  # validator.no_database_or_uri?(config)
  # ```
  def self.both_uri_and_standard?: (::Hash[untyped, untyped] config) -> bool
end

Mongoid::Config::Mongoid::Config::Validators::Mongoid::Config::Mongoid::Config::Validators::Client::STANDARD: untyped

# Validator for configuration options.
module Mongoid::Config::Mongoid::Config::Validators::Option
  extend Mongoid::Config::Validators::Option

  # Validate a configuration option.
  #
  # _@param_ `option` — The name of the option.
  #
  # Validate a configuration option.
  # ```ruby
  # ```
  def validate: (String option) -> untyped

  # Validate a configuration option.
  #
  # _@param_ `option` — The name of the option.
  #
  # Validate a configuration option.
  # ```ruby
  # ```
  def self.validate: (String option) -> untyped
end

# This module defines behavior for fields.
module Mongoid::Fields
  extend ActiveSupport::Concern

  # Apply all default values to the document which are not procs.
  #
  # _@return_ — The names of the non-proc defaults.
  #
  # Apply all the non-proc defaults.
  # ```ruby
  # model.apply_pre_processed_defaults
  # ```
  def apply_pre_processed_defaults: () -> ::Array[String]

  # Apply all default values to the document which are procs.
  #
  # _@return_ — The names of the proc defaults.
  #
  # Apply all the proc defaults.
  # ```ruby
  # model.apply_post_processed_defaults
  # ```
  def apply_post_processed_defaults: () -> ::Array[String]

  # Applies a single default value for the given name.
  #
  # _@param_ `name` — The name of the field.
  #
  # Apply a single default.
  # ```ruby
  # model.apply_default("name")
  # ```
  def apply_default: (String name) -> untyped

  # Apply all the defaults at once.
  #
  # Apply all the defaults.
  # ```ruby
  # model.apply_defaults
  # ```
  def apply_defaults: () -> untyped

  # Returns an array of names for the attributes available on this object.
  #
  # Provides the field names in an ORM-agnostic way. Rails v3.1+ uses this
  # method to automatically wrap params in JSON requests.
  #
  # _@return_ — The field names
  #
  # Get the field names
  # ```ruby
  # docment.attribute_names
  # ```
  def attribute_names: () -> ::Array[String]

  # Get the name of the provided field as it is stored in the database.
  # Used in determining if the field is aliased or not.
  #
  # _@param_ `name` — The name to get.
  #
  # _@return_ — The name of the field as it's stored in the db.
  #
  # Get the database field name.
  # ```ruby
  # model.database_field_name(:authorization)
  # ```
  def database_field_name: (String | Symbol name) -> String

  # Is the provided field a lazy evaluation?
  #
  # _@param_ `field` — The field.
  #
  # _@param_ `value` — The current value.
  #
  # _@return_ — If we set the field lazily.
  #
  # If the field is lazy settable.
  # ```ruby
  # doc.lazy_settable?(field, nil)
  # ```
  def lazy_settable?: (Standard | ForeignKey field, Object value) -> bool

  # Is the document using object ids?
  #
  # _@return_ — Using object ids.
  #
  # Is the document using object ids?
  # ```ruby
  # model.using_object_ids?
  # ```
  #
  # _@note_ — Refactored from using delegate for class load performance.
  def using_object_ids?: () -> bool

  # Stores the provided block to be run when the option name specified is
  # defined on a field.
  #
  # No assumptions are made about what sort of work the handler might
  # perform, so it will always be called if the `option_name` key is
  # provided in the field definition -- even if it is false or nil.
  #
  # _@param_ `option_name` — the option name to match against
  #
  # _@param_ `block` — the handler to execute when the option is provided.
  #
  # ```ruby
  # Mongoid::Fields.option :required do |model, field, value|
  #   model.validates_presence_of field if value
  # end
  # ```
  def self.option: (Symbol option_name) { () -> untyped } -> untyped

  # Return a map of custom option names to their handlers.
  #
  # _@return_ — the option map
  #
  # ```ruby
  # Mongoid::Fields.options
  # # => { :required => #<Proc:0x00000100976b38> }
  # ```
  def self.options: () -> ::Hash[untyped, untyped]
end

Mongoid::Fields::StringifiedSymbol: untyped

Mongoid::Fields::Boolean: untyped

Mongoid::Fields::TYPE_MAPPINGS: untyped

Mongoid::Fields::IDS: untyped

module Mongoid::Fields::ClassMethods
  # Returns the list of id fields for this model class, as both strings
  # and symbols.
  #
  # _@return_ — List of id fields.
  def id_fields: () -> ::Array[Symbol | String]

  # Extracts the id field from the specified attributes hash based on
  # aliases defined in this class.
  #
  # _@param_ `attributes` — The attributes to inspect.
  #
  # _@return_ — The id value.
  def extract_id_field: (::Hash[untyped, untyped] attributes) -> Object

  # Returns an array of names for the attributes available on this object.
  #
  # Provides the field names in an ORM-agnostic way. Rails v3.1+ uses this
  # method to automatically wrap params in JSON requests.
  #
  # _@return_ — The field names
  #
  # Get the field names
  # ```ruby
  # Model.attribute_names
  # ```
  def attribute_names: () -> ::Array[String]

  # Get the name of the provided field as it is stored in the database.
  # Used in determining if the field is aliased or not.
  #
  # _@param_ `name` — The name to get.
  #
  # _@return_ — The name of the field as it's stored in the db.
  #
  # Get the database field name.
  # ```ruby
  # Model.database_field_name(:authorization)
  # ```
  def database_field_name: (String | Symbol name) -> String

  # Defines all the fields that are accessible on the Document
  # For each field that is defined, a getter and setter will be
  # added as an instance method to the Document.
  #
  # _@param_ `name` — The name of the field.
  #
  # _@param_ `options` — The options to pass to the field.
  #
  # _@return_ — The generated field
  #
  # Define a field.
  # ```ruby
  # field :score, :type => Integer, :default => 0
  # ```
  def field: (Symbol name, ?::Hash[untyped, untyped] options) -> (Standard | ForeignKey)

  # Replace a field with a new type.
  #
  # _@param_ `name` — The name of the field.
  #
  # _@param_ `type` — The new type of field.
  #
  # _@return_ — The new field.
  #
  # Replace the field.
  # ```ruby
  # Model.replace_field("_id", String)
  # ```
  def replace_field: (String name, Class `type`) -> Serializable

  # Convenience method for determining if we are using +BSON::ObjectIds+ as
  # our id.
  #
  # _@return_ — If the class uses BSON::ObjectIds for the id.
  #
  # Does this class use object ids?
  # ```ruby
  # person.using_object_ids?
  # ```
  def using_object_ids?: () -> bool

  # Add the defaults to the model. This breaks them up between ones that
  # are procs and ones that are not.
  #
  # _@param_ `field` — The field to add for.
  #
  # Add to the defaults.
  # ```ruby
  # Model.add_defaults(field)
  # ```
  def add_defaults: (Standard | ForeignKey field) -> untyped

  # Define a field attribute for the +Document+.
  #
  # _@param_ `name` — The name of the field.
  #
  # _@param_ `options` — The hash of options.
  #
  # Set the field.
  # ```ruby
  # Person.add_field(:name, :default => "Test")
  # ```
  def add_field: (Symbol name, ?::Hash[untyped, untyped] options) -> untyped

  # Run through all custom options stored in Mongoid::Fields.options and
  # execute the handler if the option is provided.
  #
  # _@param_ `field` — the field to process
  #
  # ```ruby
  # Mongoid::Fields.option :custom do
  #   puts "called"
  # end
  #
  # field = Mongoid::Fields.new(:test, :custom => true)
  # Person.process_options(field)
  # # => "called"
  # ```
  def process_options: (Standard | ForeignKey field) -> untyped

  # Create the field accessors.
  #
  # _@param_ `name` — The name of the field.
  #
  # _@param_ `meth` — The name of the accessor.
  #
  # _@param_ `options` — The options.
  #
  # Generate the accessors.
  # ```ruby
  # Person.create_accessors(:name, "name")
  # person.name #=> returns the field
  # person.name = "" #=> sets the field
  # person.name? #=> Is the field present?
  # person.name_before_type_cast #=> returns the field before type cast
  # ```
  def create_accessors: (Symbol name, Symbol meth, ?::Hash[untyped, untyped] options) -> untyped

  # Create the getter method for the provided field.
  #
  # _@param_ `name` — The name of the attribute.
  #
  # _@param_ `meth` — The name of the method.
  #
  # _@param_ `field` — The field.
  #
  # Create the getter.
  # ```ruby
  # Model.create_field_getter("name", "name", field)
  # ```
  def create_field_getter: (String name, String meth, Standard | ForeignKey field) -> untyped

  # Create the getter_before_type_cast method for the provided field. If
  # the attribute has been assigned, return the attribute before it was
  # type cast. Otherwise, delegate to the getter.
  #
  # _@param_ `name` — The name of the attribute.
  #
  # _@param_ `meth` — The name of the method.
  #
  # Create the getter_before_type_cast.
  # ```ruby
  # Model.create_field_getter_before_type_cast("name", "name")
  # ```
  def create_field_getter_before_type_cast: (String name, String meth) -> untyped

  # Create the setter method for the provided field.
  #
  # _@param_ `name` — The name of the attribute.
  #
  # _@param_ `meth` — The name of the method.
  #
  # _@param_ `field` — The field.
  #
  # Create the setter.
  # ```ruby
  # Model.create_field_setter("name", "name")
  # ```
  def create_field_setter: (String name, String meth, Standard | ForeignKey field) -> untyped

  # Create the check method for the provided field.
  #
  # _@param_ `name` — The name of the attribute.
  #
  # _@param_ `meth` — The name of the method.
  #
  # Create the check.
  # ```ruby
  # Model.create_field_check("name", "name")
  # ```
  def create_field_check: (String name, String meth) -> untyped

  # Create the translation getter method for the provided field.
  #
  # _@param_ `name` — The name of the attribute.
  #
  # _@param_ `meth` — The name of the method.
  #
  # Create the translation getter.
  # ```ruby
  # Model.create_translations_getter("name", "name")
  # ```
  def create_translations_getter: (String name, String meth) -> untyped

  # Create the translation setter method for the provided field.
  #
  # _@param_ `name` — The name of the attribute.
  #
  # _@param_ `meth` — The name of the method.
  #
  # _@param_ `field` — The field.
  #
  # Create the translation setter.
  # ```ruby
  # Model.create_translations_setter("name", "name")
  # ```
  def create_translations_setter: (String name, String meth, Standard | ForeignKey field) -> untyped

  # Include the field methods as a module, so they can be overridden.
  #
  # _@return_ — The module of generated methods.
  #
  # Include the fields.
  # ```ruby
  # Person.generated_methods
  # ```
  def generated_methods: () -> Module

  # Remove the default keys for the provided name.
  #
  # _@param_ `name` — The field name.
  #
  # Remove the default keys.
  # ```ruby
  # Model.remove_defaults(name)
  # ```
  def remove_defaults: (String name) -> untyped

  def field_for: (untyped name, untyped options) -> untyped

  def unmapped_type: (untyped options) -> untyped
end

class Mongoid::Fields::Standard
  extend Forwardable

  def add_atomic_changes: (Document document, String name, String key, ::Hash[untyped, untyped] mods, ::Array[untyped] new, ::Array[untyped] old) -> untyped

  # Evaluate the default value and return it. Will handle the
  # serialization, proc calls, and duplication if necessary.
  #
  # _@param_ `doc` — The document the field belongs to.
  #
  # _@return_ — The serialized default value.
  #
  # Evaluate the default value.
  # ```ruby
  # field.eval_default(document)
  # ```
  def eval_default: (Document doc) -> Object

  # Is this field a foreign key?
  #
  # _@return_ — If the field is a foreign key.
  #
  # Is the field a foreign key?
  # ```ruby
  # field.foreign_key?
  # ```
  def foreign_key?: () -> bool

  # Create the new field with a name and optional additional options.
  #
  # _@param_ `options` — The field options.
  #
  # Create the new field.
  # ```ruby
  # Field.new(:name, :type => String)
  # ```
  def initialize: (untyped name, ?::Hash[untyped, untyped] options) -> void

  # Does this field do lazy default evaluation?
  #
  # _@return_ — If the field is lazy.
  #
  # Is the field lazy?
  # ```ruby
  # field.lazy?
  # ```
  def lazy?: () -> bool

  # Is the field localized or not?
  #
  # _@return_ — If the field is localized.
  #
  # Is the field localized?
  # ```ruby
  # field.localized?
  # ```
  def localized?: () -> bool

  # Get the metadata for the field if its a foreign key.
  #
  # _@return_ — The association metadata.
  #
  # Get the metadata.
  # ```ruby
  # field.metadata
  # ```
  def association: () -> Association

  # Is the field a BSON::ObjectId?
  #
  # _@return_ — If the field is a BSON::ObjectId.
  #
  # Is the field a BSON::ObjectId?
  # ```ruby
  # field.object_id_field?
  # ```
  def object_id_field?: () -> bool

  # Does the field pre-process its default value?
  #
  # _@return_ — If the field's default is pre-processed.
  #
  # Does the field pre-process the default?
  # ```ruby
  # field.pre_processed?
  # ```
  def pre_processed?: () -> bool

  # Get the type of this field - inferred from the class name.
  #
  # _@return_ — The name of the class.
  #
  # Get the type.
  # ```ruby
  # field.type
  # ```
  def type: () -> Class

  # Get the name of the default method for this field.
  #
  # _@return_ — The method name.
  #
  # Get the default name.
  # ```ruby
  # field.default_name
  # ```
  def default_name: () -> String

  # Define the method for getting the default on the document.
  #
  # _@param_ `object` — The class or module the field is defined on.
  #
  # Define the method.
  # ```ruby
  # field.define_default_method(doc)
  # ```
  #
  # _@note_ — Ruby's instance_exec was just too slow.
  def define_default_method: (Class | Module object) -> untyped

  # Is the field included in the fields that were returned from the
  # database? We can apply the default if:
  #   1. The field is included in an only limitation (field: 1)
  #   2. The field is not excluded in a without limitation (field: 0)
  #
  # _@param_ `fields` — The field limitations.
  #
  # _@return_ — If the field was included.
  #
  # Is the field included?
  # ```ruby
  # field.included?(fields)
  # ```
  def included?: (::Hash[untyped, untyped] fields) -> bool

  # Get the evaluated default.
  #
  # _@param_ `doc` — The doc being applied to.
  #
  # _@return_ — The default value.
  #
  # Get the evaluated default.
  # ```ruby
  # field.evaluated_default.
  # ```
  def evaluated_default: (Document doc) -> Object

  # Evaluate the default proc. In some cases we need to instance exec,
  # in others we don't.
  #
  # _@param_ `doc` — The document.
  #
  # _@return_ — The called proc.
  #
  # Eval the default proc.
  # ```ruby
  # field.evaluate_default_proc(band)
  # ```
  def evaluate_default_proc: (Document doc) -> Object

  # This is used when default values need to be serialized. Most of the
  # time just return the object.
  #
  # _@param_ `object` — The default.
  #
  # _@return_ — The serialized default.
  #
  # Serialize the default value.
  # ```ruby
  # field.serialize_default(obj)
  # ```
  def serialize_default: (Object object) -> Object
end

class Mongoid::Fields::Localized < Mongoid::Fields::Standard
  # Defines the behavior for defined fields in the document.
  # Set readers for the instance variables.
  #
  # Defines the behavior for defined fields in the document.
  # Set readers for the instance variables.
  #
  # Defines the behavior for defined fields in the document.
  # Set readers for the instance variables.
  #
  # Defines the behavior for defined fields in the document.
  # Set readers for the instance variables.
  #
  # Demongoize the object based on the current locale. Will look in the
  # hash for the current locale.
  #
  # _@param_ `object` — The hash of translations.
  #
  # _@return_ — The value for the current locale.
  #
  # Get the demongoized value.
  # ```ruby
  # field.demongoize({ "en" => "testing" })
  # ```
  def demongoize: () -> untyped
                | () -> untyped
                | () -> untyped
                | () -> untyped
                | (::Hash[untyped, untyped] object) -> Object

  # Is the field localized or not?
  #
  # _@return_ — If the field is localized.
  #
  # Is the field localized?
  # ```ruby
  # field.localized?
  # ```
  def localized?: () -> bool

  # Convert the provided string into a hash for the locale.
  #
  # _@param_ `object` — The string to convert.
  #
  # _@return_ — The locale with string translation.
  #
  # Serialize the value.
  # ```ruby
  # field.mongoize("testing")
  # ```
  def mongoize: (String object) -> ::Hash[untyped, untyped]

  # Are fallbacks being used for this localized field.
  #
  # _@return_ — If fallbacks should be used.
  #
  # Should fallbacks be used.
  # ```ruby
  # field.fallbacks?
  # ```
  def fallbacks?: () -> bool

  # Lookup the value from the provided object.
  #
  # _@param_ `object` — The localized object.
  #
  # _@return_ — The object for the locale.
  #
  # Lookup the value.
  # ```ruby
  # field.lookup({ "en" => "test" })
  # ```
  def lookup: (::Hash[untyped, untyped] object) -> Object
end

class Mongoid::Fields::ForeignKey < Mongoid::Fields::Standard
  def add_atomic_changes: (Document document, String name, String key, ::Hash[untyped, untyped] mods, ::Array[untyped] new_elements, ::Array[untyped] old_elements) -> untyped

  # Is this field a foreign key?
  #
  # _@return_ — If the field is a foreign key.
  #
  # Is the field a foreign key?
  # ```ruby
  # field.foreign_key?
  # ```
  def foreign_key?: () -> bool

  # Evolve the object into an id compatible object.
  #
  # _@param_ `object` — The object to evolve.
  #
  # _@return_ — The evolved object.
  #
  # Evolve the object.
  # ```ruby
  # field.evolve(object)
  # ```
  def evolve: (Object object) -> Object

  # Does this field do lazy default evaluation?
  #
  # _@return_ — If the field is lazy.
  #
  # Is the field lazy?
  # ```ruby
  # field.lazy?
  # ```
  def lazy?: () -> bool

  # Mongoize the object into the Mongo friendly value.
  #
  # _@param_ `object` — The object to Mongoize.
  #
  # _@return_ — The mongoized object.
  #
  # Mongoize the object.
  # ```ruby
  # field.mongoize(object)
  # ```
  def mongoize: (Object object) -> Object

  # Is the field a BSON::ObjectId?
  #
  # _@return_ — If the field is a BSON::ObjectId.
  #
  # Is the field a BSON::ObjectId?
  # ```ruby
  # field.object_id_field?
  # ```
  def object_id_field?: () -> bool

  # Returns true if an array, false if not.
  #
  # _@return_ — If the field is resizable.
  #
  # Is the field resizable?
  # ```ruby
  # field.resizable?
  # ```
  def resizable?: () -> bool

  # Evaluate the default proc. In some cases we need to instance exec,
  # in others we don't.
  #
  # _@param_ `doc` — The document.
  #
  # _@return_ — The called proc.
  #
  # Eval the default proc.
  # ```ruby
  # field.evaluate_default_proc(band)
  # ```
  def evaluate_default_proc: (Document doc) -> Object

  # Get the id field of the association.
  #
  # _@return_ — The field.
  #
  # Get the related id field.
  # ```ruby
  # field.related_id_field
  # ```
  def related_id_field: () -> Fields::Standard

  # This is used when default values need to be serialized. Most of the
  # time just return the object.
  #
  # _@param_ `object` — The default.
  #
  # _@return_ — The serialized default.
  #
  # Serialize the default value.
  # ```ruby
  # field.serialize_default(obj)
  # ```
  def serialize_default: (Object object) -> Object
end

module Mongoid::Fields::Validators
end

# Validates the params passed to the field macro.
module Mongoid::Fields::Mongoid::Fields::Validators::Macro
  extend Mongoid::Fields::Validators::Macro

  # Validate the field definition.
  #
  # _@param_ `klass` — The model class.
  #
  # _@param_ `name` — The field name.
  #
  # _@param_ `options` — The provided options.
  #
  # Validate the field definition.
  # ```ruby
  # Macro.validate(Model, :name, { localized: true })
  # ```
  def validate: (Class klass, Symbol name, ::Hash[untyped, untyped] options) -> untyped

  # Validate the association definition.
  #
  # _@param_ `klass` — The model class.
  #
  # _@param_ `name` — The field name.
  #
  # _@param_ `options` — The provided options.
  #
  # Validate the association definition.
  # ```ruby
  # Macro.validate(Model, :name)
  # ```
  def validate_relation: (Class klass, Symbol name, ?::Hash[untyped, untyped] options) -> untyped

  # Determine if the field name is valid, if not raise an error.
  #
  # _@param_ `klass` — The model class.
  #
  # _@param_ `name` — The field name.
  #
  # Check the field name.
  # ```ruby
  # Macro.validate_field_name(Model, :name)
  # ```
  def validate_field_name: (Class klass, Symbol name) -> untyped

  # Determine if the field name is unique, if not raise an error.
  #
  # _@param_ `klass` — The model class.
  #
  # _@param_ `name` — The field name.
  #
  # _@param_ `options` — The provided options.
  #
  # Check the field name.
  # ```ruby
  # Macro.validate_name_uniqueness(Model, :name, {})
  # ```
  def validate_name_uniqueness: (Class klass, Symbol name, ::Hash[untyped, untyped] options) -> untyped

  # Validate that the field options are allowed.
  #
  # _@param_ `klass` — The model class.
  #
  # _@param_ `name` — The field name.
  #
  # _@param_ `options` — The provided options.
  #
  # Validate the field options.
  # ```ruby
  # Macro.validate_options(Model, :name, { localized: true })
  # ```
  def validate_options: (Class klass, Symbol name, ::Hash[untyped, untyped] options) -> untyped

  # Validate the field definition.
  #
  # _@param_ `klass` — The model class.
  #
  # _@param_ `name` — The field name.
  #
  # _@param_ `options` — The provided options.
  #
  # Validate the field definition.
  # ```ruby
  # Macro.validate(Model, :name, { localized: true })
  # ```
  def self.validate: (Class klass, Symbol name, ::Hash[untyped, untyped] options) -> untyped

  # Validate the association definition.
  #
  # _@param_ `klass` — The model class.
  #
  # _@param_ `name` — The field name.
  #
  # _@param_ `options` — The provided options.
  #
  # Validate the association definition.
  # ```ruby
  # Macro.validate(Model, :name)
  # ```
  def self.validate_relation: (Class klass, Symbol name, ?::Hash[untyped, untyped] options) -> untyped

  # Determine if the field name is valid, if not raise an error.
  #
  # _@param_ `klass` — The model class.
  #
  # _@param_ `name` — The field name.
  #
  # Check the field name.
  # ```ruby
  # Macro.validate_field_name(Model, :name)
  # ```
  def self.validate_field_name: (Class klass, Symbol name) -> untyped

  # Determine if the field name is unique, if not raise an error.
  #
  # _@param_ `klass` — The model class.
  #
  # _@param_ `name` — The field name.
  #
  # _@param_ `options` — The provided options.
  #
  # Check the field name.
  # ```ruby
  # Macro.validate_name_uniqueness(Model, :name, {})
  # ```
  def self.validate_name_uniqueness: (Class klass, Symbol name, ::Hash[untyped, untyped] options) -> untyped

  # Validate that the field options are allowed.
  #
  # _@param_ `klass` — The model class.
  #
  # _@param_ `name` — The field name.
  #
  # _@param_ `options` — The provided options.
  #
  # Validate the field options.
  # ```ruby
  # Macro.validate_options(Model, :name, { localized: true })
  # ```
  def self.validate_options: (Class klass, Symbol name, ::Hash[untyped, untyped] options) -> untyped
end

Mongoid::Fields::Mongoid::Fields::Validators::Mongoid::Fields::Mongoid::Fields::Validators::Macro::FIELD_TYPE_IS_SYMBOL: untyped

Mongoid::Fields::Mongoid::Fields::Validators::Mongoid::Fields::Mongoid::Fields::Validators::Macro::OPTIONS: untyped

module Mongoid::Clients
  include Mongoid::Clients::StorageOptions

  include Mongoid::Clients::Options

  include Mongoid::Clients::Sessions

  extend ActiveSupport::Concern

  # Clear all clients from the current thread.
  #
  # _@return_ — The empty clients.
  #
  # Clear all clients.
  # ```ruby
  # Mongoid::Clients.clear
  # ```
  def self.clear: () -> ::Array[untyped]

  # sord warn - Mongo::Client wasn't able to be resolved to a constant in this project
  # Get the default client.
  #
  # _@return_ — The default client.
  #
  # Get the default client.
  # ```ruby
  # Mongoid::Clients.default
  # ```
  def self.default: () -> ::Client

  # Disconnect all active clients.
  #
  # _@return_ — True.
  #
  # Disconnect all active clients.
  # ```ruby
  # Mongoid::Clients.disconnect
  # ```
  def self.disconnect: () -> bool

  # sord warn - Mongo::Client wasn't able to be resolved to a constant in this project
  # Get a client with the provided name.
  #
  # _@param_ `name` — The name of the client.
  #
  # _@return_ — The named client.
  #
  # Get a client with the name.
  # ```ruby
  # Mongoid::Clients.with_name(:replica)
  # ```
  def self.with_name: (Symbol name) -> ::Client

  def self.set: (untyped name, untyped client) -> untyped

  def self.clients: () -> untyped

  # Execute a block within the context of a session.
  #
  # _@param_ `options` — The session options. Please see the driver documentation for the available session options.
  #
  # _@return_ — The result of calling the block.
  #
  # Execute some operations in the context of a session.
  # ```ruby
  # band.with_session(causal_consistency: true) do
  #   band.records << Record.create
  #   band.name = 'FKA Twigs'
  #   band.save
  #   band.reload
  # end
  # ```
  #
  # _@note_ — You cannot do any operations in the block using models or objects
  # that use a different client; the block will execute all operations
  # in the context of the implicit session and operations on any models using
  # another client will fail. For example, if you set a client using store_in on a
  # particular model and execute an operation on it in the session context block,
  # that operation can't use the block's session and an error will be raised.
  # An error will also be raised if sessions are nested.
  def with_session: (?::Hash[untyped, untyped] options) -> Object

  def _session: () -> untyped

  # Change the persistence context for this object during the block.
  #
  # _@param_ `options_or_context` — The storage options or a persistence context.
  #
  # Save the current document to a different collection.
  # ```ruby
  # model.with(collection: "bands") do |m|
  #   m.save
  # end
  # ```
  def with: (::Hash[untyped, untyped] | Mongoid::PersistenceContext options_or_context) { () -> untyped } -> untyped

  def collection: (?untyped parent) -> untyped

  def collection_name: () -> untyped

  def mongo_client: () -> untyped

  def persistence_context: () -> untyped

  def set_persistence_context: (untyped options_or_context) -> untyped

  def clear_persistence_context: (?untyped original_cluster, ?untyped context) -> untyped
end

Mongoid::Clients::CREATE_LOCK: untyped

module Mongoid::Clients::Factory
  extend Mongoid::Clients::Factory

  # sord warn - Mongo::Client wasn't able to be resolved to a constant in this project
  # Create a new client given the named configuration. If no name is
  # provided, return a new client with the default configuration. If a
  # name is provided for which no configuration exists, an error will be
  # raised.
  #
  # _@param_ `name` — The named client configuration.
  #
  # _@return_ — The new client.
  #
  # Create the client.
  # ```ruby
  # Factory.create(:analytics)
  # ```
  def create: (?(String | Symbol)? name) -> ::Client

  # sord warn - Mongo::Client wasn't able to be resolved to a constant in this project
  # Get the default client.
  #
  # _@return_ — The default client.
  #
  # Get the default client.
  # ```ruby
  # Factory.default
  # ```
  def default: () -> ::Client

  # sord warn - Mongo::Client wasn't able to be resolved to a constant in this project
  # Create the client for the provided config.
  #
  # _@param_ `configuration` — The client config.
  #
  # _@return_ — The client.
  #
  # Create the client.
  # ```ruby
  # Factory.create_client(config)
  # ```
  def create_client: (::Hash[untyped, untyped] configuration) -> ::Client

  def driver_version: () -> untyped

  def options: (untyped configuration) -> untyped

  # sord warn - Mongo::Client wasn't able to be resolved to a constant in this project
  # Create a new client given the named configuration. If no name is
  # provided, return a new client with the default configuration. If a
  # name is provided for which no configuration exists, an error will be
  # raised.
  #
  # _@param_ `name` — The named client configuration.
  #
  # _@return_ — The new client.
  #
  # Create the client.
  # ```ruby
  # Factory.create(:analytics)
  # ```
  def self.create: (?(String | Symbol)? name) -> ::Client

  # sord warn - Mongo::Client wasn't able to be resolved to a constant in this project
  # Get the default client.
  #
  # _@return_ — The default client.
  #
  # Get the default client.
  # ```ruby
  # Factory.default
  # ```
  def self.default: () -> ::Client

  # sord warn - Mongo::Client wasn't able to be resolved to a constant in this project
  # Create the client for the provided config.
  #
  # _@param_ `configuration` — The client config.
  #
  # _@return_ — The client.
  #
  # Create the client.
  # ```ruby
  # Factory.create_client(config)
  # ```
  def self.create_client: (::Hash[untyped, untyped] configuration) -> ::Client

  def self.driver_version: () -> untyped

  def self.options: (untyped configuration) -> untyped
end

Mongoid::Clients::Mongoid::Clients::Factory::MONGOID_WRAPPING_LIBRARY: untyped

module Mongoid::Clients::Options
  extend ActiveSupport::Concern

  # Change the persistence context for this object during the block.
  #
  # _@param_ `options_or_context` — The storage options or a persistence context.
  #
  # Save the current document to a different collection.
  # ```ruby
  # model.with(collection: "bands") do |m|
  #   m.save
  # end
  # ```
  def with: (::Hash[untyped, untyped] | Mongoid::PersistenceContext options_or_context) { () -> untyped } -> untyped

  def collection: (?untyped parent) -> untyped

  def collection_name: () -> untyped

  def mongo_client: () -> untyped

  def persistence_context: () -> untyped

  def set_persistence_context: (untyped options_or_context) -> untyped

  def clear_persistence_context: (?untyped original_cluster, ?untyped context) -> untyped
end

module Mongoid::Clients::Mongoid::Clients::Options::ClassMethods
  def client_name: () -> untyped

  def collection_name: () -> untyped

  def database_name: () -> untyped

  def collection: () -> untyped

  def mongo_client: () -> untyped

  # Change the persistence context for this class during the block.
  #
  # _@param_ `options` — The storage options.
  #
  # Save the current document to a different collection.
  # ```ruby
  # Model.with(collection: "bands") do |m|
  #   m.create
  # end
  # ```
  def with: (::Hash[untyped, untyped] options) { () -> untyped } -> untyped

  def persistence_context: () -> untyped
end

# Encapsulates behavior for getting a session from the client of a model class or instance,
# setting the session on the current thread, and yielding to a block.
# The session will be closed after the block completes or raises an error.
#
# @since 6.4.0
module Mongoid::Clients::Sessions
  # Execute a block within the context of a session.
  #
  # _@param_ `options` — The session options. Please see the driver documentation for the available session options.
  #
  # _@return_ — The result of calling the block.
  #
  # Execute some operations in the context of a session.
  # ```ruby
  # band.with_session(causal_consistency: true) do
  #   band.records << Record.create
  #   band.name = 'FKA Twigs'
  #   band.save
  #   band.reload
  # end
  # ```
  #
  # _@note_ — You cannot do any operations in the block using models or objects
  # that use a different client; the block will execute all operations
  # in the context of the implicit session and operations on any models using
  # another client will fail. For example, if you set a client using store_in on a
  # particular model and execute an operation on it in the session context block,
  # that operation can't use the block's session and an error will be raised.
  # An error will also be raised if sessions are nested.
  def with_session: (?::Hash[untyped, untyped] options) -> Object

  def _session: () -> untyped
end

module Mongoid::Clients::Mongoid::Clients::Sessions::ClassMethods
  # Execute a block within the context of a session.
  #
  # _@param_ `options` — The session options. Please see the driver documentation for the available session options.
  #
  # _@return_ — The result of calling the block.
  #
  # Execute some operations in the context of a session.
  # ```ruby
  # Band.with_session(causal_consistency: true) do
  #   band = Band.create
  #   band.records << Record.new
  #   band.save
  #   band.reload.records
  # end
  # ```
  #
  # _@note_ — You cannot do any operations in the block using models or objects
  # that use a different client; the block will execute all operations
  # in the context of the implicit session and operations on any models using
  # another client will fail. For example, if you set a client using store_in on a
  # particular model and execute an operation on it in the session context block,
  # that operation can't use the block's session and an error will be raised.
  # You also cannot nest sessions.
  def with_session: (?::Hash[untyped, untyped] options) -> Object

  def _session: () -> untyped
end

module Mongoid::Clients::StorageOptions
  extend ActiveSupport::Concern
end

module Mongoid::Clients::Mongoid::Clients::StorageOptions::ClassMethods
  # Give this model specific custom default storage options.
  #
  # _@param_ `options` — The storage options.
  #
  # _@return_ — The model class.
  #
  # Store this model by default in "artists"
  # ```ruby
  # class Band
  #   include Mongoid::Document
  #   store_in collection: "artists"
  # end
  # ```
  #
  # Store this model by default in the sharded db.
  # ```ruby
  # class Band
  #   include Mongoid::Document
  #   store_in database: "echo_shard"
  # end
  # ```
  #
  # Store this model by default in a different client.
  # ```ruby
  # class Band
  #   include Mongoid::Document
  #   store_in client: "analytics"
  # end
  # ```
  #
  # Store this model with a combination of options.
  # ```ruby
  # class Band
  #   include Mongoid::Document
  #   store_in collection: "artists", database: "music"
  # end
  # ```
  def store_in: (::Hash[untyped, untyped] options) -> Class

  # Reset the store_in options
  #
  # Reset the store_in options
  # ```ruby
  # Model.reset_storage_options!
  # ```
  def reset_storage_options!: () -> untyped

  # Get the default storage options.
  #
  # _@return_ — Default storage options.
  #
  # Get the default storage options.
  # ```ruby
  # Model.storage_options_defaults
  # ```
  def storage_options_defaults: () -> ::Hash[untyped, untyped]
end

module Mongoid::Clients::Validators
end

# Validates the options passed to :store_in.
module Mongoid::Clients::Mongoid::Clients::Validators::Storage
  extend Mongoid::Clients::Validators::Storage

  # Validate the options provided to :store_in.
  #
  # _@param_ `klass` — The model class.
  #
  # _@param_ `options` — The provided options.
  #
  # Validate the options.
  # ```ruby
  # Storage.validate(:collection_name)
  # ```
  def validate: (Class klass, ::Hash[untyped, untyped] | String | Symbol options) -> untyped

  # Determine if the current klass is valid to change store_in
  # options
  #
  # _@param_ `klass`
  #
  # _@return_ — If the class is valid
  def valid_parent?: (Class klass) -> bool

  # Determine if all keys in the options hash are valid.
  #
  # _@param_ `options` — The options hash.
  #
  # _@return_ — If all keys are valid.
  #
  # Are all keys valid?
  # ```ruby
  # validator.valid_keys?({ collection: "name" })
  # ```
  def valid_keys?: (::Hash[untyped, untyped] options) -> bool

  # Validate the options provided to :store_in.
  #
  # _@param_ `klass` — The model class.
  #
  # _@param_ `options` — The provided options.
  #
  # Validate the options.
  # ```ruby
  # Storage.validate(:collection_name)
  # ```
  def self.validate: (Class klass, ::Hash[untyped, untyped] | String | Symbol options) -> untyped

  # Determine if the current klass is valid to change store_in
  # options
  #
  # _@param_ `klass`
  #
  # _@return_ — If the class is valid
  def self.valid_parent?: (Class klass) -> bool

  # Determine if all keys in the options hash are valid.
  #
  # _@param_ `options` — The options hash.
  #
  # _@return_ — If all keys are valid.
  #
  # Are all keys valid?
  # ```ruby
  # validator.valid_keys?({ collection: "name" })
  # ```
  def self.valid_keys?: (::Hash[untyped, untyped] options) -> bool
end

Mongoid::Clients::Mongoid::Clients::Validators::Mongoid::Clients::Mongoid::Clients::Validators::Storage::VALID_OPTIONS: untyped

# Instantiates documents that came from the database.
module Mongoid::Factory
  extend Mongoid::Factory

  # Builds a new +Document+ from the supplied attributes.
  #
  # This method either instantiats klass or a descendant of klass if the attributes include
  # klass' discriminator key.
  #
  # If the attributes contain the discriminator key (which is _type by default) and the
  # discriminator value does not correspond to a descendant of klass then this method
  # would create an instance of klass.
  #
  # _@param_ `klass` — The class to instantiate from if _type is not present.
  #
  # _@param_ `attributes` — The document attributes.
  #
  # _@return_ — The instantiated document.
  #
  # Build the document.
  # ```ruby
  # Mongoid::Factory.build(Person, { "name" => "Durran" })
  # ```
  def build: (Class klass, ?::Hash[untyped, untyped]? attributes) -> Document

  def from_db: (Class klass, ?::Hash[untyped, untyped]? attributes, ?Criteria? criteria, ?::Hash[untyped, untyped]? selected_fields) -> Document

  # Builds a new +Document+ from the supplied attributes.
  #
  # This method either instantiats klass or a descendant of klass if the attributes include
  # klass' discriminator key.
  #
  # If the attributes contain the discriminator key (which is _type by default) and the
  # discriminator value does not correspond to a descendant of klass then this method
  # would create an instance of klass.
  #
  # _@param_ `klass` — The class to instantiate from if _type is not present.
  #
  # _@param_ `attributes` — The document attributes.
  #
  # _@return_ — The instantiated document.
  #
  # Build the document.
  # ```ruby
  # Mongoid::Factory.build(Person, { "name" => "Durran" })
  # ```
  def self.build: (Class klass, ?::Hash[untyped, untyped]? attributes) -> Document

  def self.from_db: (Class klass, ?::Hash[untyped, untyped]? attributes, ?Criteria? criteria, ?::Hash[untyped, untyped]? selected_fields) -> Document
end

Mongoid::Factory::TYPE: untyped

# @api private
module Mongoid::Matcher
  def as_attributes: () -> untyped

  def self.as_attributes: () -> untyped
end

# @api private
module Mongoid::Matcher::Eq
end

# @api private
module Mongoid::Matcher::Gt
  def >: () -> untyped

  def self.>: () -> untyped
end

# @api private
module Mongoid::Matcher::In
end

# @api private
module Mongoid::Matcher::Lt
  def <: () -> untyped

  def self.<: () -> untyped
end

# @api private
module Mongoid::Matcher::Ne
end

# @api private
module Mongoid::Matcher::Or
end

# @api private
module Mongoid::Matcher::All
end

# @api private
module Mongoid::Matcher::And
end

# @api private
module Mongoid::Matcher::Gte
  def >=: () -> untyped

  def self.>=: () -> untyped
end

# @api private
module Mongoid::Matcher::Lte
  def <=: () -> untyped

  def self.<=: () -> untyped
end

# @api private
module Mongoid::Matcher::Mod
end

# @api private
module Mongoid::Matcher::Nin
end

# @api private
module Mongoid::Matcher::Nor
end

# @api private
module Mongoid::Matcher::Not
end

# @api private
module Mongoid::Matcher::Bits
  def matches?: (untyped exists, untyped value, untyped condition) -> bool
end

# @api private
module Mongoid::Matcher::Size
end

# @see https://docs.mongodb.com/manual/reference/operator/query/type/
#
# @api private
module Mongoid::Matcher::Type
end

# @api private
module Mongoid::Matcher::Regex
end

# @api private
module Mongoid::Matcher::Exists
end

# This module is used by $eq and other operators that need to perform
# the matching that $eq performs (for example, $ne which negates the result
# of $eq). Unlike $eq this module takes an original operator as an
# additional argument to +matches?+ to provide the correct exception
# messages reflecting the operator that was first invoked.
#
# @api private
module Mongoid::Matcher::EqImpl
end

# @api private
module Mongoid::Matcher::ElemMatch
end

# @api private
module Mongoid::Matcher::Expression
end

# @api private
module Mongoid::Matcher::BitsAllSet
  include Mongoid::Matcher::Bits

  extend Mongoid::Matcher::BitsAllSet

  def array_matches?: (untyped value, untyped condition) -> bool

  def int_matches?: (untyped value, untyped condition) -> bool

  def self.array_matches?: (untyped value, untyped condition) -> bool

  def self.int_matches?: (untyped value, untyped condition) -> bool

  def self.matches?: (untyped exists, untyped value, untyped condition) -> bool

  def matches?: (untyped exists, untyped value, untyped condition) -> bool
end

# @api private
module Mongoid::Matcher::BitsAnySet
  include Mongoid::Matcher::Bits

  extend Mongoid::Matcher::BitsAnySet

  def array_matches?: (untyped value, untyped condition) -> bool

  def int_matches?: (untyped value, untyped condition) -> bool

  def self.array_matches?: (untyped value, untyped condition) -> bool

  def self.int_matches?: (untyped value, untyped condition) -> bool

  def self.matches?: (untyped exists, untyped value, untyped condition) -> bool

  def matches?: (untyped exists, untyped value, untyped condition) -> bool
end

# @api private
module Mongoid::Matcher::BitsAllClear
  include Mongoid::Matcher::Bits

  extend Mongoid::Matcher::BitsAllClear

  def array_matches?: (untyped value, untyped condition) -> bool

  def int_matches?: (untyped value, untyped condition) -> bool

  def self.array_matches?: (untyped value, untyped condition) -> bool

  def self.int_matches?: (untyped value, untyped condition) -> bool

  def self.matches?: (untyped exists, untyped value, untyped condition) -> bool

  def matches?: (untyped exists, untyped value, untyped condition) -> bool
end

# @api private
module Mongoid::Matcher::BitsAnyClear
  include Mongoid::Matcher::Bits

  extend Mongoid::Matcher::BitsAnyClear

  def array_matches?: (untyped value, untyped condition) -> bool

  def int_matches?: (untyped value, untyped condition) -> bool

  def self.array_matches?: (untyped value, untyped condition) -> bool

  def self.int_matches?: (untyped value, untyped condition) -> bool

  def self.matches?: (untyped exists, untyped value, untyped condition) -> bool

  def matches?: (untyped exists, untyped value, untyped condition) -> bool
end

# @api private
module Mongoid::Matcher::FieldOperator
end

Mongoid::Matcher::Mongoid::Matcher::FieldOperator::MAP: untyped

# @api private
module Mongoid::Matcher::FieldExpression
end

# This is an internal equality implementation that performs exact
# comparisons and regular expression matches.
#
# @api private
module Mongoid::Matcher::EqImplWithRegexp
end

# @api private
module Mongoid::Matcher::ExpressionOperator
end

Mongoid::Matcher::Mongoid::Matcher::ExpressionOperator::MAP: untyped

# $elemMatch argument can be a top-level expression and some specific
# operator combinations like $not with a regular expression.
#
# @api private
module Mongoid::Matcher::ElemMatchExpression
end

# This module contains the behavior of Mongoid's clone/dup of documents.
module Mongoid::Copyable
  extend ActiveSupport::Concern

  # Clone or dup the current +Document+. This will return all attributes with
  # the exception of the document's id, and will reset all the
  # instance variables.
  #
  # This clone also includes embedded documents.
  #
  # _@return_ — The new document.
  #
  # Clone the document.
  # ```ruby
  # document.clone
  # ```
  def clone: () -> Document

  # Clone the document attributes
  #
  # clone document
  # ```ruby
  # model.clone_document
  # ```
  def clone_document: () -> untyped

  # When cloning, if the document has localized fields we need to ensure they
  # are properly processed in the clone.
  #
  # _@param_ `attrs` — The attributes.
  #
  # Process localized attributes.
  # ```ruby
  # model.process_localized_attributes(attributes)
  # ```
  def process_localized_attributes: (untyped klass, ::Hash[untyped, untyped] attrs) -> untyped
end

# The +Criteria+ class is the core object needed in Mongoid to retrieve
# objects from the database. It is a DSL that essentially sets up the
# selector and options arguments that get passed on to a Mongo::Collection
# in the Ruby driver. Each method on the +Criteria+ returns self to they
# can be chained in order to create a readable criterion to be executed
# against the database.
class Mongoid::Criteria
  include Enumerable

  include Mongoid::Contextual

  include Mongoid::Criteria::Queryable

  include Mongoid::Criteria::Findable

  include Mongoid::Criteria::Includable

  include Mongoid::Criteria::Marshalable

  include Mongoid::Criteria::Modifiable

  include Mongoid::Criteria::Scopable

  include Mongoid::Clients::Options

  include Mongoid::Clients::Sessions

  include Mongoid::Criteria::Options

  def _enumerable_find: () -> untyped

  def _findable_find: () -> untyped

  # Returns true if the supplied +Enumerable+ or +Criteria+ is equal to the results
  # of this +Criteria+ or the criteria itself.
  #
  # _@param_ `other` — The other +Enumerable+ or +Criteria+ to compare to.
  #
  # _@return_ — If the objects are equal.
  #
  # _@note_ — This will force a database load when called if an enumerable is passed.
  def ==: (Object other) -> bool

  # Finds one or many documents given the provided _id values, or filters
  # the documents in the current scope in the application process space
  # after loading them if needed.
  #
  # If this method is not given a block, it delegates to +Findable#find+
  # and finds one or many documents for the provided _id values.
  #
  # If this method is given a block, it delegates to +Enumerable#find+ and
  # returns the first document of those found by the current Crieria object
  # for which the block returns a truthy value.
  #
  # Note that the "default proc" argument of Enumerable is not specially
  # treated by Mongoid - the decision between delegating to +Findable+ vs
  # +Enumerable+ is made solely based on whether +find+ is passed a block.
  #
  # _@return_ — A document or matching documents.
  #
  # Finds a document by its _id, invokes Findable#find.
  # ```ruby
  # critera.find("1234")
  # ```
  #
  # Finds the first matching document using a block, invokes Enumerable#find.
  # ```ruby
  # criteria.find { |item| item.name == "Depeche Mode" }
  # ```
  #
  # Finds the first matching document using a block using the default Proc, invokes Enumerable#find.
  # ```ruby
  # criteria.find(-> { "Default Band" }) { |item| item.name == "Milwaukee Mode" }
  # ```
  #
  # Tries to find a document whose _id is the stringification of the provided Proc, typically failing.
  # ```ruby
  # enumerator = criteria.find(-> { "Default Band" })
  # ```
  #
  # _@see_ `https://ruby-doc.org/core/Enumerable.html#method-i-find`
  def find: (*untyped args) { () -> untyped } -> (Document | ::Array[Document])?

  # Needed to properly get a criteria back as json
  #
  # _@param_ `options` — Options to pass through to the serializer.
  #
  # _@return_ — The JSON string.
  #
  # Get the criteria as json.
  # ```ruby
  # Person.where(:title => "Sir").as_json
  # ```
  def as_json: (?::Hash[untyped, untyped]? options) -> String

  # Tells the criteria that the cursor that gets returned needs to be
  # cached. This is so multiple iterations don't hit the database multiple
  # times, however this is not advisable when working with large data sets
  # as the entire results will get stored in memory.
  #
  # _@return_ — The cloned criteria.
  #
  # Flag the criteria as cached.
  # ```ruby
  # criteria.cache
  # ```
  def cache: () -> Criteria

  # Will return true if the cache option has been set.
  #
  # _@return_ — If the criteria is flagged as cached.
  #
  # Is the criteria cached?
  # ```ruby
  # criteria.cached?
  # ```
  def cached?: () -> bool

  # Get the documents from the embedded criteria.
  #
  # _@return_ — The documents.
  #
  # Get the documents.
  # ```ruby
  # criteria.documents
  # ```
  def documents: () -> ::Array[Document]

  # Set the embedded documents on the criteria.
  #
  # _@param_ `docs` — The embedded documents.
  #
  # _@return_ — The embedded documents.
  #
  # Set the documents.
  # ```ruby
  # ```
  def documents=: (::Array[Document] docs) -> ::Array[Document]

  # Is the criteria for embedded documents?
  #
  # _@return_ — If the criteria is embedded.
  #
  # Is the criteria for embedded documents?
  # ```ruby
  # criteria.embedded?
  # ```
  def embedded?: () -> bool

  # Extract a single id from the provided criteria. Could be in an $and
  # query or a straight _id query.
  #
  # _@return_ — The id.
  #
  # Extract the id.
  # ```ruby
  # criteria.extract_id
  # ```
  def extract_id: () -> Object

  # Adds a criterion to the +Criteria+ that specifies additional options
  # to be passed to the Ruby driver, in the exact format for the driver.
  #
  # criteria.extras(:limit => 20, :skip => 40)
  #
  # _@param_ `extras` — The extra driver options.
  #
  # _@return_ — The cloned criteria.
  #
  # Add extra params to the criteria.
  # ```ruby
  # ```
  def extras: (::Hash[untyped, untyped] extras) -> Criteria

  # Get the list of included fields.
  #
  # _@return_ — The fields.
  #
  # Get the field list.
  # ```ruby
  # criteria.field_list
  # ```
  def field_list: () -> ::Array[String]

  # When freezing a criteria we need to initialize the context first
  # otherwise the setting of the context on attempted iteration will raise a
  # runtime error.
  #
  # _@return_ — The frozen criteria.
  #
  # Freeze the criteria.
  # ```ruby
  # criteria.freeze
  # ```
  def freeze: () -> Criteria

  # Initialize the new criteria.
  #
  # _@param_ `klass` — The model class.
  #
  # Init the new criteria.
  # ```ruby
  # Criteria.new(Band)
  # ```
  def initialize: (Class klass) -> void

  # Merges another object with this +Criteria+ and returns a new criteria.
  # The other object may be a +Criteria+ or a +Hash+. This is used to
  # combine multiple scopes together, where a chained scope situation
  # may be desired.
  #
  # _@param_ `other` — The other criterion to merge with.
  #
  # _@return_ — A cloned self.
  #
  # Merge the criteria with another criteria.
  # ```ruby
  # criteri.merge(other_criteria)
  # ```
  #
  # Merge the criteria with a hash. The hash must contain a klass
  # ```ruby
  # key and the key/value pairs correspond to method names/args.
  #
  # criteria.merge({
  #   klass: Band,
  #   where: { name: "Depeche Mode" },
  #   order_by: { name: 1 }
  # })
  # ```
  def merge: (Criteria other) -> Criteria

  # Merge the other criteria into this one.
  #
  # _@param_ `other` — The criteria to merge in.
  #
  # _@return_ — The merged criteria.
  #
  # Merge another criteria into this criteria.
  # ```ruby
  # criteria.merge(Person.where(name: "bob"))
  # ```
  def merge!: (Criteria other) -> Criteria

  # Returns a criteria that will always contain zero results and never hits
  # the database.
  #
  # _@return_ — The none criteria.
  #
  # Return a none criteria.
  # ```ruby
  # criteria.none
  # ```
  def none: () -> Criteria

  # Is the criteria an empty but chainable criteria?
  #
  # _@return_ — If the criteria is a none.
  #
  # Is the criteria a none criteria?
  # ```ruby
  # criteria.empty_and_chainable?
  # ```
  def empty_and_chainable?: () -> bool

  # Overriden to include _type in the fields.
  #
  # _@param_ `args` — The names of the fields.
  #
  # _@return_ — The cloned criteria.
  #
  # Limit the fields returned from the database.
  # ```ruby
  # Band.only(:name)
  # ```
  def only: (*::Array[Symbol] args) -> Criteria

  # Set the read preference for the criteria.
  #
  # _@param_ `value` — The mode preference.
  #
  # _@return_ — The cloned criteria.
  #
  # Set the read preference.
  # ```ruby
  # criteria.read(mode: :primary_preferred)
  # ```
  def read: (?::Hash[untyped, untyped]? value) -> Criteria

  # Overriden to exclude _id from the fields.
  #
  # _@param_ `args` — The names of the fields.
  #
  # _@return_ — The cloned criteria.
  #
  # Exclude fields returned from the database.
  # ```ruby
  # Band.without(:name)
  # ```
  def without: (*::Array[Symbol] args) -> Criteria

  # Returns true if criteria responds to the given method.
  #
  # _@param_ `name` — The name of the class method on the +Document+.
  #
  # _@param_ `include_private` — Whether to include privates.
  #
  # _@return_ — If the criteria responds to the method.
  #
  # Does the criteria respond to the method?
  # ```ruby
  # crtiteria.respond_to?(:each)
  # ```
  def respond_to?: (Symbol name, ?bool include_private) -> bool

  # Convenience for objects that want to be merged into a criteria.
  #
  # _@return_ — self.
  #
  # Convert to a criteria.
  # ```ruby
  # criteria.to_criteria
  # ```
  def to_criteria: () -> Criteria

  # Convert the criteria to a proc.
  #
  # _@return_ — The wrapped criteria.
  #
  # Convert the criteria to a proc.
  # ```ruby
  # criteria.to_proc
  # ```
  def to_proc: () -> Proc

  # Adds a criterion to the +Criteria+ that specifies a type or an Array of
  # types that must be matched.
  #
  # _@param_ `types` — The types to match against.
  #
  # _@return_ — The cloned criteria.
  #
  # Match only specific models.
  # ```ruby
  # criteria.type('Browser')
  # criteria.type(['Firefox', 'Browser'])
  # ```
  def type: (::Array[String] types) -> Criteria

  # sord infer - argument name in single @param inferred as "*args"
  # This is the general entry point for most MongoDB queries. This either
  # creates a standard field: value selection, and expanded selection with
  # the use of hash methods, or a $where selection if a string is provided.
  #
  # _@param_ `expression` — The javascript or standard selection.
  #
  # _@return_ — The cloned selectable.
  #
  # Add a standard selection.
  # ```ruby
  # criteria.where(name: "syd")
  # ```
  #
  # Add a javascript selection.
  # ```ruby
  # criteria.where("this.name == 'syd'")
  # ```
  def where: (*String | ::Hash[untyped, untyped] args) -> Criteria

  # Get a version of this criteria without the options.
  #
  # _@return_ — The cloned criteria.
  #
  # Get the criteria without options.
  # ```ruby
  # criteria.without_options
  # ```
  def without_options: () -> Criteria

  # Find documents by the provided javascript and scope. Uses a $where but is
  # different from +Criteria#where+ in that it will pass a code object to the
  # query instead of a pure string. Safe against Javascript injection
  # attacks.
  #
  # _@param_ `javascript` — The javascript to execute in the $where.
  #
  # _@param_ `scope` — The scope for the code.
  #
  # _@return_ — The criteria.
  #
  # Find by javascript.
  # ```ruby
  # Band.for_js("this.name = param", param: "Tool")
  # ```
  def for_js: (String javascript, ?::Hash[untyped, untyped] scope) -> Criteria

  # Are documents in the query missing, and are we configured to raise an
  # error?
  #
  # _@param_ `result` — The result.
  #
  # _@param_ `ids` — The ids.
  #
  # Check for missing documents.
  # ```ruby
  # criteria.check_for_missing_documents!([], [ 1 ])
  # ```
  def check_for_missing_documents!: (::Array[Document] result, ::Array[Object] ids) -> untyped

  # Clone or dup the current +Criteria+. This will return a new criteria with
  # the selector, options, klass, embedded options, etc intact.
  #
  # _@param_ `other` — The criteria getting cloned.
  #
  # _@return_ — nil.
  #
  # Clone a criteria.
  # ```ruby
  # criteria.clone
  # ```
  #
  # Dup a criteria.
  # ```ruby
  # criteria.dup
  # ```
  def initialize_copy: (Criteria other) -> nil

  # Used for chaining +Criteria+ scopes together in the for of class methods
  # on the +Document+ the criteria is for.
  #
  # _@param_ `name` — The method name.
  #
  # _@param_ `args` — The arguments.
  #
  # _@return_ — The result of the method call.
  #
  # Handle method missing.
  # ```ruby
  # criteria.method_missing(:name)
  # ```
  def method_missing: (Symbol name, *::Array[untyped] args) { () -> untyped } -> Object

  # For models where inheritance is at play we need to add the type
  # selection.
  #
  # _@return_ — If type selection was added.
  #
  # Add the type selection.
  # ```ruby
  # criteria.merge_type_selection
  # ```
  def merge_type_selection: () -> bool

  # Is the criteria type selectable?
  #
  # _@return_ — If type selection should be added.
  #
  # If the criteria type selectable?
  # ```ruby
  # criteria.type_selectable?
  # ```
  def type_selectable?: () -> bool

  # Get the selector for type selection.
  #
  # _@return_ — The type selection.
  #
  # Get a type selection hash.
  # ```ruby
  # criteria.type_selection
  # ```
  def type_selection: () -> ::Hash[untyped, untyped]

  # Get a new selector with type selection in it.
  #
  # _@return_ — The selector.
  #
  # Get a selector with type selection.
  # ```ruby
  # criteria.selector_with_type_selection
  # ```
  def selector_with_type_selection: () -> ::Hash[untyped, untyped]

  def persistence_context: () -> untyped

  def set_persistence_context: (untyped options) -> untyped

  def clear_persistence_context: (untyped original_cluster, untyped original_context) -> untyped

  # Execute a block within the context of a session.
  #
  # _@param_ `options` — The session options. Please see the driver documentation for the available session options.
  #
  # _@return_ — The result of calling the block.
  #
  # Execute some operations in the context of a session.
  # ```ruby
  # band.with_session(causal_consistency: true) do
  #   band.records << Record.create
  #   band.name = 'FKA Twigs'
  #   band.save
  #   band.reload
  # end
  # ```
  #
  # _@note_ — You cannot do any operations in the block using models or objects
  # that use a different client; the block will execute all operations
  # in the context of the implicit session and operations on any models using
  # another client will fail. For example, if you set a client using store_in on a
  # particular model and execute an operation on it in the session context block,
  # that operation can't use the block's session and an error will be raised.
  # An error will also be raised if sessions are nested.
  def with_session: (?::Hash[untyped, untyped] options) -> Object

  def _session: () -> untyped

  # Change the persistence context for this object during the block.
  #
  # _@param_ `options_or_context` — The storage options or a persistence context.
  #
  # Save the current document to a different collection.
  # ```ruby
  # model.with(collection: "bands") do |m|
  #   m.save
  # end
  # ```
  def with: (::Hash[untyped, untyped] | Mongoid::PersistenceContext options_or_context) { () -> untyped } -> untyped

  def collection: (?untyped parent) -> untyped

  def collection_name: () -> untyped

  def mongo_client: () -> untyped

  # Applies the default scope to the criteria.
  #
  # _@return_ — The criteria.
  #
  # Apply the default scope.
  # ```ruby
  # criteria.apply_default_scope
  # ```
  def apply_default_scope: () -> Criteria

  # Given another criteria, remove the other criteria's scoping from this
  # criteria.
  #
  # _@param_ `other` — The other criteria.
  #
  # _@return_ — The criteria with scoping removed.
  #
  # Remove the scoping.
  # ```ruby
  # criteria.remove_scoping(other)
  # ```
  def remove_scoping: (Criteria other) -> Criteria

  # Forces the criteria to be scoped, unless its inside an unscoped block.
  #
  # _@param_ `options` — Additional query options.
  #
  # _@return_ — The scoped criteria.
  #
  # Force the criteria to be scoped.
  # ```ruby
  # criteria.scoped(skip: 10)
  # ```
  def scoped: (?::Hash[untyped, untyped]? options) -> Criteria

  # Has the criteria had the default scope applied?
  #
  # _@return_ — If the default scope is applied.
  #
  # Is the default scope applied?
  # ```ruby
  # criteria.scoped?
  # ```
  def scoped?: () -> bool

  # Clears all scoping from the criteria.
  #
  # _@return_ — The unscoped criteria.
  #
  # Clear all scoping from the criteria.
  # ```ruby
  # criteria.unscoped
  # ```
  def unscoped: () -> Criteria

  # Is the criteria unscoped?
  #
  # _@return_ — If the criteria is force unscoped.
  #
  # Is the criteria unscoped?
  # ```ruby
  # criteria.unscoped?
  # ```
  def unscoped?: () -> bool

  # Get the criteria scoping options, as a pair (scoped, unscoped).
  #
  # _@return_ — Scoped, unscoped.
  #
  # Get the scoping options.
  # ```ruby
  # criteria.scoping_options
  # ```
  def scoping_options: () -> ::Array[untyped]

  # Set the criteria scoping options, as a pair (scoped, unscoped).
  #
  # _@param_ `options` — Scoped, unscoped.
  #
  # _@return_ — The new scoping options.
  #
  # Set the scoping options.
  # ```ruby
  # criteria.scoping_options = true, false
  # ```
  def scoping_options=: (::Array[untyped] options) -> ::Array[untyped]

  # Get the criteria with the default scope applied, if the default scope
  # is able to be applied. Cases in which it cannot are: If we are in an
  # unscoped block, if the criteria is already forced unscoped, or the
  # default scope has already been applied.
  #
  # _@return_ — The criteria.
  #
  # Get the criteria with the default scope.
  # ```ruby
  # criteria.with_default_scope
  # ```
  def with_default_scope: () -> Criteria

  def reject_matching: (untyped other, *untyped methods) -> untyped

  # Build a document given the selector and return it.
  # Complex criteria, such as $in and $or operations will get ignored.
  #
  # _@return_ — A non-persisted document.
  #
  # build the document.
  # ```ruby
  # Person.where(:title => "Sir").build
  # ```
  #
  # Build with selectors getting ignored.
  # ```ruby
  # Person.where(:age.gt => 5).build
  # ```
  def build: (?untyped attrs) { () -> untyped } -> Document

  # Create a document in the database given the selector and return it.
  # Complex criteria, such as $in and $or operations will get ignored.
  #
  # _@return_ — A newly created document.
  #
  # Create the document.
  # ```ruby
  # Person.where(:title => "Sir").create
  # ```
  #
  # Create with selectors getting ignored.
  # ```ruby
  # Person.where(:age.gt => 5).create
  # ```
  def create: (?untyped attrs) { () -> untyped } -> Document

  # Create a document in the database given the selector and return it.
  # Complex criteria, such as $in and $or operations will get ignored.
  # If validation fails, an error will be raised.
  #
  # _@return_ — A newly created document.
  #
  # Create the document.
  # ```ruby
  # Person.where(:title => "Sir").create
  # ```
  #
  # Create with selectors getting ignored.
  # ```ruby
  # Person.where(:age.gt => 5).create
  # ```
  def create!: (?untyped attrs) { () -> untyped } -> Document

  # Define attributes with which new documents will be created.
  #
  # Note that if `find_or_create_by` is called after this in a method chain, the attributes in
  # the query will override those from this method.
  #
  # _@return_ — A criteria.
  #
  # Define attributes to be used when a new document is created.
  # ```ruby
  # Person.create_with(job: 'Engineer').find_or_create_by(employer: 'MongoDB')
  # ```
  def create_with: (?untyped attrs) -> Mongoid::Criteria

  # Find the first +Document+ given the conditions, or creates a new document
  # with the conditions that were supplied.
  #
  # _@param_ `attrs` — The attributes to check.
  #
  # _@return_ — A matching or newly created document.
  #
  # Find or create the document.
  # ```ruby
  # Person.find_or_create_by(:attribute => "value")
  # ```
  def find_or_create_by: (?::Hash[untyped, untyped] attrs) { () -> untyped } -> Document

  # Find the first +Document+ given the conditions, or creates a new document
  # with the conditions that were supplied. If validation fails an
  # exception will be raised.
  #
  # _@param_ `attrs` — The attributes to check.
  #
  # _@return_ — A matching or newly created document.
  #
  # Find or create the document.
  # ```ruby
  # Person.find_or_create_by!(:attribute => "value")
  # ```
  def find_or_create_by!: (?::Hash[untyped, untyped] attrs) { () -> untyped } -> Document

  # Find the first +Document+ given the conditions, or initializes a new document
  # with the conditions that were supplied.
  #
  # _@param_ `attrs` — The attributes to check.
  #
  # _@return_ — A matching or newly initialized document.
  #
  # Find or initialize the document.
  # ```ruby
  # Person.find_or_initialize_by(:attribute => "value")
  # ```
  def find_or_initialize_by: (?::Hash[untyped, untyped] attrs) { () -> untyped } -> Document

  # Find the first +Document+, or creates a new document
  # with the conditions that were supplied plus attributes.
  #
  # _@param_ `attrs` — The additional attributes to add.
  #
  # _@return_ — A matching or newly created document.
  #
  # First or create the document.
  # ```ruby
  # Person.where(name: "Jon").first_or_create(attribute: "value")
  # ```
  def first_or_create: (?::Hash[untyped, untyped]? attrs) { () -> untyped } -> Document

  # Find the first +Document+, or creates a new document
  # with the conditions that were supplied plus attributes and will
  # raise an error if validation fails.
  #
  # _@param_ `attrs` — The additional attributes to add.
  #
  # _@return_ — A matching or newly created document.
  #
  # First or create the document.
  # ```ruby
  # Person.where(name: "Jon").first_or_create!(attribute: "value")
  # ```
  def first_or_create!: (?::Hash[untyped, untyped]? attrs) { () -> untyped } -> Document

  # Find the first +Document+, or initializes a new document
  # with the conditions that were supplied plus attributes.
  #
  # _@param_ `attrs` — The additional attributes to add.
  #
  # _@return_ — A matching or newly initialized document.
  #
  # First or initialize the document.
  # ```ruby
  # Person.where(name: "Jon").first_or_initialize(attribute: "value")
  # ```
  def first_or_initialize: (?::Hash[untyped, untyped]? attrs) { () -> untyped } -> Document

  # Create a document given the provided method and attributes from the
  # existing selector.
  #
  # _@param_ `method` — Either :new or :create.
  #
  # _@param_ `attrs` — Additional attributes to use.
  #
  # _@return_ — The new or saved document.
  #
  # Create a new document.
  # ```ruby
  # criteria.create_document(:new, {})
  # ```
  def create_document: (Symbol method, ?::Hash[untyped, untyped]? attrs) { () -> untyped } -> Document

  # Find the first object or create/initialize it.
  #
  # _@param_ `method` — The method to invoke.
  #
  # _@param_ `attrs` — The attributes to query or set.
  #
  # _@return_ — The first or new document.
  #
  # Find or perform an action.
  # ```ruby
  # Person.find_or(:create, :name => "Dev")
  # ```
  def find_or: (Symbol method, ?::Hash[untyped, untyped] attrs) { () -> untyped } -> Document

  # Find the first document or create/initialize it.
  #
  # _@param_ `method` — The method to invoke.
  #
  # _@param_ `attrs` — The attributes to query or set.
  #
  # _@return_ — The first or new document.
  #
  # First or perform an action.
  # ```ruby
  # Person.first_or(:create, :name => "Dev")
  # ```
  def first_or: (Symbol method, ?::Hash[untyped, untyped] attrs) { () -> untyped } -> Document

  def invalid_key?: (untyped hash, untyped key) -> bool

  def invalid_embedded_doc?: (untyped value) -> bool

  # Provides the data needed to Marshal.dump a criteria.
  #
  # _@return_ — The dumped data.
  #
  # Dump the criteria.
  # ```ruby
  # Marshal.dump(criteria)
  # ```
  def marshal_dump: () -> ::Array[Object]

  # Resets the criteria object after a Marshal.load
  #
  # _@param_ `data` — The raw data.
  #
  # Load the criteria.
  # ```ruby
  # Marshal.load(criteria)
  # ```
  def marshal_load: (::Array[untyped] data) -> untyped

  def dump_hash: (untyped name) -> untyped

  def load_hash: (untyped hash_class, untyped raw) -> untyped

  # Eager loads all the provided associations. Will load all the documents
  # into the identity map whose ids match based on the extra query for the
  # ids.
  #
  # _@param_ `relations` — The names of the associations to eager load.
  #
  # _@return_ — The cloned criteria.
  #
  # Eager load the provided associations.
  # ```ruby
  # Person.includes(:posts, :game)
  # ```
  #
  # _@note_ — This will work for embedded associations that reference another
  # collection via belongs_to as well.
  #
  # _@note_ — Eager loading brings all the documents into memory, so there is a
  # sweet spot on the performance gains. Internal benchmarks show that
  # eager loading becomes slower around 100k documents, but this will
  # naturally depend on the specific application.
  def includes: (*::Array[Symbol] | ::Array[::Hash[untyped, untyped]] relations) -> Criteria

  # Get a list of criteria that are to be executed for eager loading.
  #
  # _@return_ — The inclusions.
  #
  # Get the eager loading inclusions.
  # ```ruby
  # Person.includes(:game).inclusions
  # ```
  def inclusions: () -> ::Array[Association]

  # Set the inclusions for the criteria.
  #
  # _@param_ `value` — The inclusions.
  #
  # _@return_ — The new inclusions.
  #
  # Set the inclusions.
  # ```ruby
  # criteria.inclusions = [ association ]
  # ```
  def inclusions=: (::Array[Association] value) -> ::Array[Association]

  # Add an inclusion definition to the list of inclusions for the criteria.
  #
  # _@param_ `_klass` — The class or string/symbol of the class name.
  #
  # _@param_ `association` — The association.
  #
  # Add an inclusion.
  # ```ruby
  # criteria.add_inclusion(Person, :posts)
  # ```
  def add_inclusion: (Class | String | Symbol _klass, Symbol association) -> untyped

  def extract_includes_list: (untyped _parent_class, *untyped relations_list) -> untyped

  # Execute the criteria or raise an error if no documents found.
  #
  # _@param_ `ids` — The arguments passed.
  #
  # _@param_ `multi` — Whether there arguments were a list.
  #
  # _@return_ — The document(s).
  #
  # Execute or raise
  # ```ruby
  # criteria.execute_or_raise(id)
  # ```
  def execute_or_raise: (Object ids, bool multi) -> (Document | ::Array[Document])

  # Adds a criterion to the +Criteria+ that specifies an id that must be matched.
  #
  # _@param_ `ids` — The array of ids.
  #
  # _@return_ — The cloned criteria.
  #
  # Add a single id criteria.
  # ```ruby
  # criteria.for_ids([ 1 ])
  # ```
  #
  # Add multiple id criteria.
  # ```ruby
  # criteria.for_ids([ 1, 2 ])
  # ```
  def for_ids: (::Array[untyped] ids) -> Criteria

  # Get the documents from the identity map, and if not found hit the
  # database.
  #
  # _@param_ `ids` — The searched ids.
  #
  # _@return_ — The found documents.
  #
  # Get the documents from the map or criteria.
  # ```ruby
  # criteria.multiple_from_map_or_db(ids)
  # ```
  def multiple_from_db: (::Array[Object] ids) -> ::Array[Document]

  # Get the finder used to generate the id query.
  #
  # _@return_ — The name of the finder method.
  #
  # Get the id finder.
  # ```ruby
  # criteria.id_finder
  # ```
  def id_finder: () -> Symbol

  # Get documents from the database only.
  #
  # _@param_ `ids` — The ids to fetch with.
  #
  # _@return_ — The matching documents.
  #
  # Get documents from the database.
  # ```ruby
  # criteria.from_database(ids)
  # ```
  def from_database: (::Array[Object] ids) -> ::Array[Document]

  def from_database_selector: (untyped ids) -> untyped

  # Convert all the ids to their proper types.
  #
  # _@param_ `ids` — The ids to convert.
  #
  # _@return_ — The converted ids.
  #
  # Convert the ids.
  # ```ruby
  # criteria.mongoize_ids(ids)
  # ```
  def mongoize_ids: (::Array[Object] ids) -> ::Array[Object]

  # Convenience method of raising an invalid options error.
  #
  # Raise the error.
  # ```ruby
  # criteria.raise_invalid
  # ```
  def raise_invalid: () -> untyped

  # Add ascending sorting options for all the provided fields.
  #
  # _@param_ `fields` — The fields to sort.
  #
  # _@return_ — The cloned optional.
  #
  # Add ascending sorting.
  # ```ruby
  # optional.ascending(:first_name, :last_name)
  # ```
  def ascending: (*::Array[Symbol] fields) -> Optional

  # Adds the option for telling MongoDB how many documents to retrieve in
  # it's batching.
  #
  # _@param_ `value` — The batch size.
  #
  # _@return_ — The cloned optional.
  #
  # Apply the batch size options.
  # ```ruby
  # optional.batch_size(500)
  # ```
  def batch_size: (?Integer? value) -> Optional

  # Add descending sorting options for all the provided fields.
  #
  # _@param_ `fields` — The fields to sort.
  #
  # _@return_ — The cloned optional.
  #
  # Add descending sorting.
  # ```ruby
  # optional.descending(:first_name, :last_name)
  # ```
  def descending: (*::Array[Symbol] fields) -> Optional

  # Add an index hint to the query options.
  #
  # _@param_ `value` — The index hint.
  #
  # _@return_ — The cloned optional.
  #
  # Add an index hint.
  # ```ruby
  # optional.hint("$natural" => 1)
  # ```
  def hint: (?::Hash[untyped, untyped]? value) -> Optional

  # Add the number of documents to limit in the returned results.
  #
  # _@param_ `value` — The number of documents to return.
  #
  # _@return_ — The cloned optional.
  #
  # Limit the number of returned documents.
  # ```ruby
  # optional.limit(20)
  # ```
  def limit: (?Integer? value) -> Optional

  # Adds the option to limit the number of documents scanned in the
  # collection.
  #
  # _@param_ `value` — The max number of documents to scan.
  #
  # _@return_ — The cloned optional.
  #
  # Add the max scan limit.
  # ```ruby
  # optional.max_scan(1000)
  # ```
  def max_scan: (?Integer? value) -> Optional

  # Adds a cumulative time limit in milliseconds for processing operations on a cursor.
  #
  # _@param_ `value` — The max time in milliseconds for processing operations on a cursor.
  #
  # _@return_ — The cloned optional.
  #
  # Add the max time ms option.
  # ```ruby
  # optional.max_time_ms(200)
  # ```
  def max_time_ms: (?Integer? value) -> Optional

  # Tell the query not to timeout.
  #
  # _@return_ — The cloned optional.
  #
  # Tell the query not to timeout.
  # ```ruby
  # optional.no_timeout
  # ```
  def no_timeout: () -> Optional

  # Adds sorting criterion to the options.
  #
  # _@param_ `spec` — The sorting specification.
  #
  # _@return_ — The cloned optional.
  #
  # Add sorting options via a hash with integer directions.
  # ```ruby
  # optional.order_by(name: 1, dob: -1)
  # ```
  #
  # Add sorting options via a hash with symbol directions.
  # ```ruby
  # optional.order_by(name: :asc, dob: :desc)
  # ```
  #
  # Add sorting options via a hash with string directions.
  # ```ruby
  # optional.order_by(name: "asc", dob: "desc")
  # ```
  #
  # Add sorting options via an array with integer directions.
  # ```ruby
  # optional.order_by([[ name, 1 ], [ dob, -1 ]])
  # ```
  #
  # Add sorting options via an array with symbol directions.
  # ```ruby
  # optional.order_by([[ :name, :asc ], [ :dob, :desc ]])
  # ```
  #
  # Add sorting options via an array with string directions.
  # ```ruby
  # optional.order_by([[ "name", "asc" ], [ "dob", "desc" ]])
  # ```
  #
  # Add sorting options with keys.
  # ```ruby
  # optional.order_by(:name.asc, :dob.desc)
  # ```
  #
  # Add sorting options via a string.
  # ```ruby
  # optional.order_by("name ASC, dob DESC")
  # ```
  def order_by: (*::Array[untyped] | ::Hash[untyped, untyped] | String spec) -> Optional

  # Instead of merging the order criteria, use this method to completely
  # replace the existing ordering with the provided.
  #
  # _@param_ `spec` — The sorting specification.
  #
  # _@return_ — The cloned optional.
  #
  # Replace the ordering.
  # ```ruby
  # optional.reorder(name: :asc)
  # ```
  def reorder: (*::Array[untyped] | ::Hash[untyped, untyped] | String spec) -> Optional

  # Add the number of documents to skip.
  #
  # _@param_ `value` — The number to skip.
  #
  # _@return_ — The cloned optional.
  #
  # Add the number to skip.
  # ```ruby
  # optional.skip(100)
  # ```
  def skip: (?Integer? value) -> Optional

  # Limit the returned results via slicing embedded arrays.
  #
  # _@param_ `criterion` — The slice options.
  #
  # _@return_ — The cloned optional.
  #
  # Slice the returned results.
  # ```ruby
  # optional.slice(aliases: [ 0, 5 ])
  # ```
  def slice: (?::Hash[untyped, untyped]? criterion) -> Optional

  # Tell the query to operate in snapshot mode.
  #
  # _@return_ — The cloned optional.
  #
  # Add the snapshot option.
  # ```ruby
  # optional.snapshot
  # ```
  def snapshot: () -> Optional

  # Associate a comment with the query.
  #
  # _@param_ `comment` — The comment to be associated with the query.
  #
  # _@return_ — The cloned optional.
  #
  # Add a comment.
  # ```ruby
  # optional.comment('slow query')
  # ```
  #
  # _@note_ — Set profilingLevel to 2 and the comment will be logged in the profile
  # collection along with the query.
  def comment: (?String? comment) -> Optional

  # Set the cursor type.
  #
  # _@param_ `type` — The type of cursor to create.
  #
  # _@return_ — The cloned optional.
  #
  # Set the cursor type.
  # ```ruby
  # optional.cursor_type(:tailable)
  # optional.cursor_type(:tailable_await)
  # ```
  #
  # _@note_ — The cursor can be type :tailable or :tailable_await.
  def cursor_type: (Symbol `type`) -> Optional

  # Set the collation.
  #
  # _@param_ `collation_doc` — The document describing the collation to use.
  #
  # _@return_ — The cloned optional.
  #
  # Set the collation.
  # ```ruby
  # optional.collation(locale: 'fr', strength: 2)
  # ```
  def collation: (::Hash[untyped, untyped] collation_doc) -> Optional

  # Add a single sort option.
  #
  # _@param_ `options` — The options.
  #
  # _@param_ `field` — The field name.
  #
  # _@param_ `direction` — The sort direction.
  #
  # _@return_ — The cloned optional.
  #
  # Add a single sort option.
  # ```ruby
  # optional.add_sort_option({}, :name, 1)
  # ```
  def add_sort_option: (::Hash[untyped, untyped] options, String field, Integer direction) -> Optional

  # Take the provided criterion and store it as an option in the query
  # options.
  #
  # _@param_ `args` — The options.
  #
  # _@return_ — The cloned queryable.
  #
  # Store the option.
  # ```ruby
  # optional.option({ skip: 10 })
  # ```
  def option: (*::Array[untyped] args) -> Queryable

  # Add multiple sort options at once.
  #
  # _@param_ `fields` — The field names.
  #
  # _@param_ `direction` — The sort direction.
  #
  # _@return_ — The cloned optional.
  #
  # Add multiple sort options.
  # ```ruby
  # optional.sort_with_list(:name, :dob, 1)
  # ```
  def sort_with_list: (*::Array[String] fields, Integer direction) -> Optional

  # Get the atomic selector for the document. This is a hash in the simplest
  # case { "_id" => id }, but can become more complex for embedded documents
  # and documents that use a shard key.
  #
  # _@return_ — The document's selector.
  #
  # Get the document's atomic selector.
  # ```ruby
  # document.atomic_selector
  # ```
  def atomic_selector: () -> ::Hash[untyped, untyped]

  # Get the atomic selector for an embedded document.
  #
  # _@return_ — The embedded document selector.
  #
  # Get the embedded atomic selector.
  # ```ruby
  # document.embedded_atomic_selector
  # ```
  def embedded_atomic_selector: () -> ::Hash[untyped, untyped]

  # Get the atomic selector for a root document.
  #
  # _@return_ — The root document selector.
  #
  # Get the root atomic selector.
  # ```ruby
  # document.root_atomic_selector
  # ```
  def root_atomic_selector: () -> ::Hash[untyped, untyped]

  # Has the aggregable enter an aggregation state. Ie, are only aggregation
  # operations allowed at this point on.
  #
  # _@return_ — If the aggregable is aggregating.
  #
  # Is the aggregable aggregating?
  # ```ruby
  # aggregable.aggregating?
  # ```
  def aggregating?: () -> bool

  # Add a group ($group) operation to the aggregation pipeline.
  #
  # _@param_ `operation` — The group operation.
  #
  # _@return_ — The aggregable.
  #
  # Add a group operation being verbose.
  # ```ruby
  # aggregable.group(count: { "$sum" => 1 }, max: { "$max" => "likes" })
  # ```
  #
  # Add a group operation using symbol shortcuts.
  # ```ruby
  # aggregable.group(:count.sum => 1, :max.max => "likes")
  # ```
  def group: (::Hash[untyped, untyped] operation) -> Aggregable

  # Add a projection ($project) to the aggregation pipeline.
  #
  # _@param_ `operation` — The projection to make.
  #
  # _@return_ — The aggregable.
  #
  # Add a projection to the pipeline.
  # ```ruby
  # aggregable.project(author: 1, name: 0)
  # ```
  def project: (?::Hash[untyped, untyped]? operation) -> Aggregable

  # Add an unwind ($unwind) to the aggregation pipeline.
  #
  # _@param_ `field` — The name of the field to unwind.
  #
  # _@return_ — The aggregable.
  #
  # Add an unwind to the pipeline.
  # ```ruby
  # aggregable.unwind(:field)
  # ```
  def unwind: (String | Symbol field) -> Aggregable

  # Add the aggregation operation.
  #
  # _@param_ `operation` — The operation for the pipeline.
  #
  # _@return_ — The cloned aggregable.
  #
  # Aggregate on the operation.
  # ```ruby
  # aggregation(operation) do |pipeline|
  #   pipeline.push("$project" => operation)
  # end
  # ```
  def aggregation: (::Hash[untyped, untyped] operation) -> Aggregable

  # Instruct the next mergeable call to use intersection.
  #
  # _@return_ — The intersect flagged mergeable.
  #
  # Use intersection on the next call.
  # ```ruby
  # mergeable.intersect.in(field: [ 1, 2, 3 ])
  # ```
  def intersect: () -> Mergeable

  # Instruct the next mergeable call to use override.
  #
  # _@return_ — The override flagged mergeable.
  #
  # Use override on the next call.
  # ```ruby
  # mergeable.override.in(field: [ 1, 2, 3 ])
  # ```
  def override: () -> Mergeable

  # Instruct the next mergeable call to use union.
  #
  # _@return_ — The union flagged mergeable.
  #
  # Use union on the next call.
  # ```ruby
  # mergeable.union.in(field: [ 1, 2, 3 ])
  # ```
  def union: () -> Mergeable

  # Clear the current strategy and negating flag, used after cloning.
  #
  # _@return_ — self.
  #
  # Reset the strategies.
  # ```ruby
  # mergeable.reset_strategies!
  # ```
  def reset_strategies!: () -> Criteria

  # Adds the criterion to the existing selection.
  #
  # _@param_ `criterion` — The criteria.
  #
  # _@param_ `operator` — The MongoDB operator.
  #
  # _@return_ — The new mergeable.
  #
  # Add the criterion.
  # ```ruby
  # mergeable.__add__({ name: 1 }, "$in")
  # ```
  def __add__: (::Hash[untyped, untyped] criterion, String operator) -> Mergeable

  # Adds the criterion to the existing selection.
  #
  # _@param_ `criterion` — The criteria.
  #
  # _@param_ `outer` — The outer MongoDB operator.
  #
  # _@param_ `inner` — The inner MongoDB operator.
  #
  # _@return_ — The new mergeable.
  #
  # Add the criterion.
  # ```ruby
  # mergeable.__expanded__([ 1, 10 ], "$within", "$center")
  # ```
  def __expanded__: (::Hash[untyped, untyped] criterion, String outer, String inner) -> Mergeable

  # Perform a straight merge of the criterion into the selection and let the
  # symbol overrides do all the work.
  #
  # _@param_ `criterion` — The criteria.
  #
  # _@return_ — The cloned object.
  #
  # Straight merge the expanded criterion.
  # ```ruby
  # mergeable.__merge__(location: [ 1, 10 ])
  # ```
  def __merge__: (::Hash[untyped, untyped] criterion) -> Mergeable

  # Adds the criterion to the existing selection.
  #
  # _@param_ `criterion` — The criteria.
  #
  # _@param_ `operator` — The MongoDB operator.
  #
  # _@return_ — The new mergeable.
  #
  # Add the criterion.
  # ```ruby
  # mergeable.__intersect__([ 1, 2 ], "$in")
  # ```
  def __intersect__: (::Hash[untyped, untyped] criterion, String operator) -> Mergeable

  # Adds $and/$or/$nor criteria to a copy of this selection.
  #
  # Each of the criteria can be a Hash of key/value pairs or MongoDB
  # operators (keys beginning with $), or a Selectable object
  # (which typically will be a Criteria instance).
  #
  # _@param_ `criteria` — Multiple key/value pair matches or Criteria objects.
  #
  # _@param_ `operator` — The MongoDB operator.
  #
  # _@return_ — The new mergeable.
  #
  # Add the criterion.
  # ```ruby
  # mergeable.__multi__([ 1, 2 ], "$in")
  # ```
  def __multi__: (::Array[::Hash[untyped, untyped] | Criteria] criteria, String operator) -> Mergeable

  # Combines criteria into a MongoDB selector.
  #
  # Criteria is an array of criterions which will be flattened.
  #
  # Each criterion can be:
  # - A hash
  # - A Criteria instance
  # - nil, in which case it is ignored
  def _mongoid_add_top_level_operation: (untyped operator, untyped criteria) -> untyped

  # Calling .flatten on an array which includes a Criteria instance
  # evaluates the criteria, which we do not want. Hence this method
  # explicitly only expands Array objects and Array subclasses.
  def _mongoid_flatten_arrays: (untyped array) -> untyped

  # Takes a criteria hash and expands Key objects into hashes containing
  # MQL corresponding to said key objects. Also converts the input to
  # BSON::Document to permit indifferent access.
  #
  # The argument must be a hash containing key-value pairs of the
  # following forms:
  # - {field_name: value}
  # - {'field_name' => value}
  # - {key_instance: value}
  # - {:$operator => operator_value_expression}
  # - {'$operator' => operator_value_expression}
  #
  # Ruby does not permit multiple symbol operators. For example,
  # {:foo.gt => 1, :foo.gt => 2} is collapsed to {:foo.gt => 2} by the
  # language. Therefore this method never has to deal with multiple
  # identical operators.
  #
  # Similarly, this method should never need to expand a literal value
  # and an operator at the same time.
  #
  # This method effectively converts symbol keys to string keys in
  # the input +expr+, such that the downstream code can assume that
  # conditions always contain string keys.
  #
  # _@param_ `expr` — Criteria including Key instances.
  #
  # _@return_ — The expanded criteria.
  def _mongoid_expand_keys: (::Hash[untyped, untyped] expr) -> BSON::Document

  # Adds the criterion to the existing selection.
  #
  # _@param_ `criterion` — The criteria.
  #
  # _@param_ `operator` — The MongoDB operator.
  #
  # _@return_ — The new mergeable.
  #
  # Add the criterion.
  # ```ruby
  # mergeable.__override__([ 1, 2 ], "$in")
  # ```
  def __override__: (::Hash[untyped, untyped] | Criteria criterion, String operator) -> Mergeable

  # Adds the criterion to the existing selection.
  #
  # _@param_ `criterion` — The criteria.
  #
  # _@param_ `operator` — The MongoDB operator.
  #
  # _@return_ — The new mergeable.
  #
  # Add the criterion.
  # ```ruby
  # mergeable.__union__([ 1, 2 ], "$in")
  # ```
  def __union__: (::Hash[untyped, untyped] criterion, String operator) -> Mergeable

  # Use the named strategy for the next operation.
  #
  # _@param_ `strategy` — The strategy to use.
  #
  # _@return_ — The existing mergeable.
  #
  # Use intersection.
  # ```ruby
  # mergeable.use(:__intersect__)
  # ```
  def use: (Symbol strategy) -> Mergeable

  # Add criterion to the selection with the named strategy.
  #
  # _@param_ `strategy` — The name of the strategy method.
  #
  # _@param_ `criterion` — The criterion to add.
  #
  # _@param_ `operator` — The MongoDB operator.
  #
  # _@return_ — The cloned query.
  #
  # Add criterion with a strategy.
  # ```ruby
  # mergeable.with_strategy(:__union__, {field_name: [ 1, 2, 3 ]}, "$in")
  # ```
  def with_strategy: (Symbol strategy, Object criterion, String operator) -> Mergeable

  # Prepare the value for merging.
  #
  # _@param_ `field` — The name of the field.
  #
  # _@param_ `value` — The value.
  #
  # _@return_ — The serialized value.
  #
  # Prepare the value.
  # ```ruby
  # mergeable.prepare("field", "$gt", 10)
  # ```
  def prepare: (String field, untyped operator, Object value) -> Object

  # Expands the specified condition to MongoDB syntax.
  #
  # This method is meant to be called when processing the items of
  # a condition hash and the key and the value of each item are
  # already available separately.
  #
  # The following parameter forms are accepted:
  #
  # - field is a string or symbol; value is the field query expresision
  # - field is a Key instance; value is the field query expression
  # - field is a string corresponding to a MongoDB operator; value is
  #   the operator value expression.
  #
  # This method expands the field-value combination to the MongoDB
  # selector syntax and returns an array of
  # [expanded key, expanded value]. The expanded key is converted to
  # a string if it wasn't already a string.
  #
  # _@param_ `field` — The field to expand.
  #
  # _@param_ `value` — The field's value.
  #
  # _@return_ — The expanded field and value.
  def expand_one_condition: (String | Symbol | Key field, Object value) -> ::Array[String | Object]

  # Expand criterion values to arrays, to be used with operators that
  # take an array as argument such as $in.
  #
  # _@param_ `criterion` — The criterion.
  #
  # _@return_ — The $in friendly criterion with array values.
  #
  # Convert all the values to arrays.
  # ```ruby
  # selectable.with_array_values({ key: 1...4 })
  # ```
  def expand_condition_to_array_values: (::Hash[untyped, untyped] criterion) -> ::Hash[untyped, untyped]

  # Adds a field expression to the query.
  #
  # +field+ must be a field name, and it must be a string. The upstream
  # code must have converted other field/key types to the simple string
  # form by the time this method is invoked.
  #
  # +value+ can be of any type, it is written into the selector unchanged.
  #
  # This method performs no processing on the provided field value.
  #
  # Mutates the receiver.
  #
  # _@param_ `field` — The field name.
  #
  # _@param_ `value` — The field value.
  #
  # _@return_ — self.
  def add_field_expression: (String field, Object value) -> Storable

  # Adds a logical operator expression to the selector.
  #
  # This method only handles logical operators ($and, $nor and $or).
  # It raises ArgumentError if called with another operator. Note that
  # in MQL, $not is a field-level operator and not a query-level one,
  # and therefore $not is not handled by this method.
  #
  # This method takes the operator and the operator value expression
  # separately for callers' convenience. It can be considered to
  # handle storing the hash +{operator => op_expr}+.
  #
  # If the selector consists of a single condition which is the specified
  # operator (on the top level), the new condition given in op_expr is
  # added to the existing conditions for the specified operator.
  # For example, if the selector is currently:
  #
  #     {'$or' => [{'hello' => 'world'}]}
  #
  # ... and operator is '$or' and op_expr is `[{'test' => 123'}]`,
  # the resulting selector will be:
  #
  #     {'$or' => [{'hello' => 'world'}, {'test' => 123}]}
  #
  # This method always adds the new conditions as additional requirements;
  # in other words, it does not implement the ActiveRecord or/nor behavior
  # where the receiver becomes one of the operands. It is expected that
  # code upstream of this method implements such behavior.
  #
  # This method does not simplify values (i.e. if the selector is
  # currently empty and operator is $and, op_expr is written to the
  # selector with $and even if the $and can in principle be elided).
  # Such simplification is also expected to have already been performed
  # by the upstream code.
  #
  # This method mutates the receiver.
  #
  # _@param_ `operator` — The operator to add.
  #
  # _@param_ `op_expr` — Operator value to add.
  #
  # _@return_ — self.
  def add_logical_operator_expression: (String operator, ::Array[::Hash[untyped, untyped]] op_expr) -> Storable

  # Adds an operator expression to the selector.
  #
  # This method takes the operator and the operator value expression
  # separately for callers' convenience. It can be considered to
  # handle storing the hash +{operator => op_expr}+.
  #
  # The operator value can be of any type.
  #
  # If the selector already has the specified operator in it (on the
  # top level), the new condition given in op_expr is added to the
  # existing conditions for the specified operator. This is
  # straightforward for $and; for other logical operators, the behavior
  # of this method is to add the new conditions to the existing operator.
  # For example, if the selector is currently:
  #
  #     {'foo' => 'bar', '$or' => [{'hello' => 'world'}]}
  #
  # ... and operator is '$or' and op_expr is `{'test' => 123'}`,
  # the resulting selector will be:
  #
  #     {'foo' => 'bar', '$or' => [{'hello' => 'world'}, {'test' => 123}]}
  #
  # This does not implement an OR between the existing selector and the
  # new operator expression - handling this is the job of upstream
  # methods. This method simply stores op_expr into the selector on the
  # assumption that the existing selector is the correct left hand side
  # of the operation already.
  #
  # For non-logical query-level operators like $where and $text, if
  # there already is a top-level operator with the same name, the
  # op_expr is added to the selector via a top-level $and operator,
  # thus producing a selector having both operator values.
  #
  # This method does not simplify values (i.e. if the selector is
  # currently empty and operator is $and, op_expr is written to the
  # selector with $and even if the $and can in principle be elided).
  #
  # This method mutates the receiver.
  #
  # _@param_ `operator` — The operator to add.
  #
  # _@param_ `op_expr` — Operator value to add.
  #
  # _@return_ — self.
  def add_operator_expression: (String operator, Object op_expr) -> Storable

  # Adds an arbitrary expression to the query.
  #
  # Field can either be a field name or an operator.
  #
  # Mutates the receiver.
  #
  # _@param_ `field` — Field name or operator name.
  #
  # _@param_ `value` — Field value or operator expression.
  #
  # _@return_ — self.
  def add_one_expression: (String field, Object value) -> Storable

  # Get the context in which criteria queries should execute. This is either
  # in memory (for embedded documents) or mongo (for root level documents.)
  #
  # _@return_ — The context.
  #
  # Get the context.
  # ```ruby
  # criteria.context
  # ```
  def context: () -> (Memory | Mongo)

  # Create the context for the queries to execute. Will be memory for
  # embedded documents and mongo for root documents.
  #
  # _@return_ — The context.
  #
  # Create the context.
  # ```ruby
  # contextual.create_context
  # ```
  def create_context: () -> (Mongo | Memory)
end

Mongoid::Criteria::CHECK: untyped

# Module containing functionality for getting options on a Criteria object.
#
# @since 6.0.0
module Mongoid::Criteria::Options
  # Returns the value of attribute embedded.
  #
  # Returns the value of attribute klass.
  #
  # Returns the value of attribute parent_document.
  #
  # Returns the value of attribute association.
  def persistence_context: () -> untyped
                         | () -> untyped
                         | () -> untyped
                         | () -> untyped
                         | () -> untyped

  def set_persistence_context: (untyped options) -> untyped

  def clear_persistence_context: (untyped original_cluster, untyped original_context) -> untyped
end

module Mongoid::Criteria::Findable
  # Execute the criteria or raise an error if no documents found.
  #
  # _@param_ `ids` — The arguments passed.
  #
  # _@param_ `multi` — Whether there arguments were a list.
  #
  # _@return_ — The document(s).
  #
  # Execute or raise
  # ```ruby
  # criteria.execute_or_raise(id)
  # ```
  def execute_or_raise: (Object ids, bool multi) -> (Document | ::Array[Document])

  # Find the matchind document(s) in the criteria for the provided ids.
  #
  # _@param_ `args` — The ids to search for.
  #
  # _@return_ — The matching document(s).
  #
  # Find by an id.
  # ```ruby
  # criteria.find(BSON::ObjectId.new)
  # ```
  #
  # Find by multiple ids.
  # ```ruby
  # criteria.find([ BSON::ObjectId.new, BSON::ObjectId.new ])
  # ```
  def find: (*::Array[BSON::ObjectId] args) -> (::Array[Document] | Document)

  # Adds a criterion to the +Criteria+ that specifies an id that must be matched.
  #
  # _@param_ `ids` — The array of ids.
  #
  # _@return_ — The cloned criteria.
  #
  # Add a single id criteria.
  # ```ruby
  # criteria.for_ids([ 1 ])
  # ```
  #
  # Add multiple id criteria.
  # ```ruby
  # criteria.for_ids([ 1, 2 ])
  # ```
  def for_ids: (::Array[untyped] ids) -> Criteria

  # Get the documents from the identity map, and if not found hit the
  # database.
  #
  # _@param_ `ids` — The searched ids.
  #
  # _@return_ — The found documents.
  #
  # Get the documents from the map or criteria.
  # ```ruby
  # criteria.multiple_from_map_or_db(ids)
  # ```
  def multiple_from_db: (::Array[Object] ids) -> ::Array[Document]

  # Get the finder used to generate the id query.
  #
  # _@return_ — The name of the finder method.
  #
  # Get the id finder.
  # ```ruby
  # criteria.id_finder
  # ```
  def id_finder: () -> Symbol

  # Get documents from the database only.
  #
  # _@param_ `ids` — The ids to fetch with.
  #
  # _@return_ — The matching documents.
  #
  # Get documents from the database.
  # ```ruby
  # criteria.from_database(ids)
  # ```
  def from_database: (::Array[Object] ids) -> ::Array[Document]

  def from_database_selector: (untyped ids) -> untyped

  # Convert all the ids to their proper types.
  #
  # _@param_ `ids` — The ids to convert.
  #
  # _@return_ — The converted ids.
  #
  # Convert the ids.
  # ```ruby
  # criteria.mongoize_ids(ids)
  # ```
  def mongoize_ids: (::Array[Object] ids) -> ::Array[Object]

  # Convenience method of raising an invalid options error.
  #
  # Raise the error.
  # ```ruby
  # criteria.raise_invalid
  # ```
  def raise_invalid: () -> untyped
end

module Mongoid::Criteria::Scopable
  # Applies the default scope to the criteria.
  #
  # _@return_ — The criteria.
  #
  # Apply the default scope.
  # ```ruby
  # criteria.apply_default_scope
  # ```
  def apply_default_scope: () -> Criteria

  # Given another criteria, remove the other criteria's scoping from this
  # criteria.
  #
  # _@param_ `other` — The other criteria.
  #
  # _@return_ — The criteria with scoping removed.
  #
  # Remove the scoping.
  # ```ruby
  # criteria.remove_scoping(other)
  # ```
  def remove_scoping: (Criteria other) -> Criteria

  # Forces the criteria to be scoped, unless its inside an unscoped block.
  #
  # _@param_ `options` — Additional query options.
  #
  # _@return_ — The scoped criteria.
  #
  # Force the criteria to be scoped.
  # ```ruby
  # criteria.scoped(skip: 10)
  # ```
  def scoped: (?::Hash[untyped, untyped]? options) -> Criteria

  # Has the criteria had the default scope applied?
  #
  # _@return_ — If the default scope is applied.
  #
  # Is the default scope applied?
  # ```ruby
  # criteria.scoped?
  # ```
  def scoped?: () -> bool

  # Clears all scoping from the criteria.
  #
  # _@return_ — The unscoped criteria.
  #
  # Clear all scoping from the criteria.
  # ```ruby
  # criteria.unscoped
  # ```
  def unscoped: () -> Criteria

  # Is the criteria unscoped?
  #
  # _@return_ — If the criteria is force unscoped.
  #
  # Is the criteria unscoped?
  # ```ruby
  # criteria.unscoped?
  # ```
  def unscoped?: () -> bool

  # Get the criteria scoping options, as a pair (scoped, unscoped).
  #
  # _@return_ — Scoped, unscoped.
  #
  # Get the scoping options.
  # ```ruby
  # criteria.scoping_options
  # ```
  def scoping_options: () -> ::Array[untyped]

  # Set the criteria scoping options, as a pair (scoped, unscoped).
  #
  # _@param_ `options` — Scoped, unscoped.
  #
  # _@return_ — The new scoping options.
  #
  # Set the scoping options.
  # ```ruby
  # criteria.scoping_options = true, false
  # ```
  def scoping_options=: (::Array[untyped] options) -> ::Array[untyped]

  # Get the criteria with the default scope applied, if the default scope
  # is able to be applied. Cases in which it cannot are: If we are in an
  # unscoped block, if the criteria is already forced unscoped, or the
  # default scope has already been applied.
  #
  # _@return_ — The criteria.
  #
  # Get the criteria with the default scope.
  # ```ruby
  # criteria.with_default_scope
  # ```
  def with_default_scope: () -> Criteria

  def reject_matching: (untyped other, *untyped methods) -> untyped
end

# A queryable is any object that needs queryable's dsl injected into it to build
# MongoDB queries. For example, a Mongoid::Criteria is an Queryable.
#
# @example Include queryable functionality.
#   class Criteria
#     include Queryable
#   end
module Mongoid::Criteria::Queryable
  include Mongoid::Criteria::Queryable::Storable

  include Mongoid::Criteria::Queryable::Expandable

  include Mongoid::Criteria::Queryable::Mergeable

  include Mongoid::Criteria::Queryable::Aggregable

  include Mongoid::Selectable

  include Mongoid::Criteria::Queryable::Optional

  # Is this queryable equal to another object? Is true if the selector and
  # options are equal.
  #
  # _@param_ `other` — The object to compare against.
  #
  # _@return_ — If the objects are equal.
  #
  # Are the objects equal?
  # ```ruby
  # queryable == criteria
  # ```
  def ==: (Object other) -> bool

  # Initialize the new queryable. Will yield itself to the block if a block
  # is provided for objects that need additional behavior.
  #
  # _@param_ `aliases` — The optional field aliases.
  #
  # _@param_ `serializers` — The optional field serializers.
  #
  # _@param_ `driver` — The driver being used.
  #
  # Initialize the queryable.
  # ```ruby
  # Queryable.new
  # ```
  def initialize: (?::Hash[untyped, untyped] aliases, ?::Hash[untyped, untyped] serializers, ?Symbol driver) -> void

  # Handle the creation of a copy via #clone or #dup.
  #
  # _@param_ `other` — The original copy.
  #
  # Handle copy initialization.
  # ```ruby
  # queryable.initialize_copy(criteria)
  # ```
  def initialize_copy: (Queryable other) -> untyped

  # Add ascending sorting options for all the provided fields.
  #
  # _@param_ `fields` — The fields to sort.
  #
  # _@return_ — The cloned optional.
  #
  # Add ascending sorting.
  # ```ruby
  # optional.ascending(:first_name, :last_name)
  # ```
  def ascending: (*::Array[Symbol] fields) -> Optional

  # Adds the option for telling MongoDB how many documents to retrieve in
  # it's batching.
  #
  # _@param_ `value` — The batch size.
  #
  # _@return_ — The cloned optional.
  #
  # Apply the batch size options.
  # ```ruby
  # optional.batch_size(500)
  # ```
  def batch_size: (?Integer? value) -> Optional

  # Add descending sorting options for all the provided fields.
  #
  # _@param_ `fields` — The fields to sort.
  #
  # _@return_ — The cloned optional.
  #
  # Add descending sorting.
  # ```ruby
  # optional.descending(:first_name, :last_name)
  # ```
  def descending: (*::Array[Symbol] fields) -> Optional

  # Add an index hint to the query options.
  #
  # _@param_ `value` — The index hint.
  #
  # _@return_ — The cloned optional.
  #
  # Add an index hint.
  # ```ruby
  # optional.hint("$natural" => 1)
  # ```
  def hint: (?::Hash[untyped, untyped]? value) -> Optional

  # Add the number of documents to limit in the returned results.
  #
  # _@param_ `value` — The number of documents to return.
  #
  # _@return_ — The cloned optional.
  #
  # Limit the number of returned documents.
  # ```ruby
  # optional.limit(20)
  # ```
  def limit: (?Integer? value) -> Optional

  # Adds the option to limit the number of documents scanned in the
  # collection.
  #
  # _@param_ `value` — The max number of documents to scan.
  #
  # _@return_ — The cloned optional.
  #
  # Add the max scan limit.
  # ```ruby
  # optional.max_scan(1000)
  # ```
  def max_scan: (?Integer? value) -> Optional

  # Adds a cumulative time limit in milliseconds for processing operations on a cursor.
  #
  # _@param_ `value` — The max time in milliseconds for processing operations on a cursor.
  #
  # _@return_ — The cloned optional.
  #
  # Add the max time ms option.
  # ```ruby
  # optional.max_time_ms(200)
  # ```
  def max_time_ms: (?Integer? value) -> Optional

  # Tell the query not to timeout.
  #
  # _@return_ — The cloned optional.
  #
  # Tell the query not to timeout.
  # ```ruby
  # optional.no_timeout
  # ```
  def no_timeout: () -> Optional

  # Limits the results to only contain the fields provided.
  #
  # _@param_ `args` — The fields to return.
  #
  # _@return_ — The cloned optional.
  #
  # Limit the results to the provided fields.
  # ```ruby
  # optional.only(:name, :dob)
  # ```
  def only: (*::Array[Symbol] args) -> Optional

  # Adds sorting criterion to the options.
  #
  # _@param_ `spec` — The sorting specification.
  #
  # _@return_ — The cloned optional.
  #
  # Add sorting options via a hash with integer directions.
  # ```ruby
  # optional.order_by(name: 1, dob: -1)
  # ```
  #
  # Add sorting options via a hash with symbol directions.
  # ```ruby
  # optional.order_by(name: :asc, dob: :desc)
  # ```
  #
  # Add sorting options via a hash with string directions.
  # ```ruby
  # optional.order_by(name: "asc", dob: "desc")
  # ```
  #
  # Add sorting options via an array with integer directions.
  # ```ruby
  # optional.order_by([[ name, 1 ], [ dob, -1 ]])
  # ```
  #
  # Add sorting options via an array with symbol directions.
  # ```ruby
  # optional.order_by([[ :name, :asc ], [ :dob, :desc ]])
  # ```
  #
  # Add sorting options via an array with string directions.
  # ```ruby
  # optional.order_by([[ "name", "asc" ], [ "dob", "desc" ]])
  # ```
  #
  # Add sorting options with keys.
  # ```ruby
  # optional.order_by(:name.asc, :dob.desc)
  # ```
  #
  # Add sorting options via a string.
  # ```ruby
  # optional.order_by("name ASC, dob DESC")
  # ```
  def order_by: (*::Array[untyped] | ::Hash[untyped, untyped] | String spec) -> Optional

  # Instead of merging the order criteria, use this method to completely
  # replace the existing ordering with the provided.
  #
  # _@param_ `spec` — The sorting specification.
  #
  # _@return_ — The cloned optional.
  #
  # Replace the ordering.
  # ```ruby
  # optional.reorder(name: :asc)
  # ```
  def reorder: (*::Array[untyped] | ::Hash[untyped, untyped] | String spec) -> Optional

  # Add the number of documents to skip.
  #
  # _@param_ `value` — The number to skip.
  #
  # _@return_ — The cloned optional.
  #
  # Add the number to skip.
  # ```ruby
  # optional.skip(100)
  # ```
  def skip: (?Integer? value) -> Optional

  # Limit the returned results via slicing embedded arrays.
  #
  # _@param_ `criterion` — The slice options.
  #
  # _@return_ — The cloned optional.
  #
  # Slice the returned results.
  # ```ruby
  # optional.slice(aliases: [ 0, 5 ])
  # ```
  def slice: (?::Hash[untyped, untyped]? criterion) -> Optional

  # Tell the query to operate in snapshot mode.
  #
  # _@return_ — The cloned optional.
  #
  # Add the snapshot option.
  # ```ruby
  # optional.snapshot
  # ```
  def snapshot: () -> Optional

  # Limits the results to only contain the fields not provided.
  #
  # _@param_ `args` — The fields to ignore.
  #
  # _@return_ — The cloned optional.
  #
  # Limit the results to the fields not provided.
  # ```ruby
  # optional.without(:name, :dob)
  # ```
  def without: (*::Array[Symbol] args) -> Optional

  # Associate a comment with the query.
  #
  # _@param_ `comment` — The comment to be associated with the query.
  #
  # _@return_ — The cloned optional.
  #
  # Add a comment.
  # ```ruby
  # optional.comment('slow query')
  # ```
  #
  # _@note_ — Set profilingLevel to 2 and the comment will be logged in the profile
  # collection along with the query.
  def comment: (?String? comment) -> Optional

  # Set the cursor type.
  #
  # _@param_ `type` — The type of cursor to create.
  #
  # _@return_ — The cloned optional.
  #
  # Set the cursor type.
  # ```ruby
  # optional.cursor_type(:tailable)
  # optional.cursor_type(:tailable_await)
  # ```
  #
  # _@note_ — The cursor can be type :tailable or :tailable_await.
  def cursor_type: (Symbol `type`) -> Optional

  # Set the collation.
  #
  # _@param_ `collation_doc` — The document describing the collation to use.
  #
  # _@return_ — The cloned optional.
  #
  # Set the collation.
  # ```ruby
  # optional.collation(locale: 'fr', strength: 2)
  # ```
  def collation: (::Hash[untyped, untyped] collation_doc) -> Optional

  # Add a single sort option.
  #
  # _@param_ `options` — The options.
  #
  # _@param_ `field` — The field name.
  #
  # _@param_ `direction` — The sort direction.
  #
  # _@return_ — The cloned optional.
  #
  # Add a single sort option.
  # ```ruby
  # optional.add_sort_option({}, :name, 1)
  # ```
  def add_sort_option: (::Hash[untyped, untyped] options, String field, Integer direction) -> Optional

  # Take the provided criterion and store it as an option in the query
  # options.
  #
  # _@param_ `args` — The options.
  #
  # _@return_ — The cloned queryable.
  #
  # Store the option.
  # ```ruby
  # optional.option({ skip: 10 })
  # ```
  def option: (*::Array[untyped] args) -> Queryable

  # Add multiple sort options at once.
  #
  # _@param_ `fields` — The field names.
  #
  # _@param_ `direction` — The sort direction.
  #
  # _@return_ — The cloned optional.
  #
  # Add multiple sort options.
  # ```ruby
  # optional.sort_with_list(:name, :dob, 1)
  # ```
  def sort_with_list: (*::Array[String] fields, Integer direction) -> Optional

  # Get the atomic selector for the document. This is a hash in the simplest
  # case { "_id" => id }, but can become more complex for embedded documents
  # and documents that use a shard key.
  #
  # _@return_ — The document's selector.
  #
  # Get the document's atomic selector.
  # ```ruby
  # document.atomic_selector
  # ```
  def atomic_selector: () -> ::Hash[untyped, untyped]

  # Get the atomic selector for an embedded document.
  #
  # _@return_ — The embedded document selector.
  #
  # Get the embedded atomic selector.
  # ```ruby
  # document.embedded_atomic_selector
  # ```
  def embedded_atomic_selector: () -> ::Hash[untyped, untyped]

  # Get the atomic selector for a root document.
  #
  # _@return_ — The root document selector.
  #
  # Get the root atomic selector.
  # ```ruby
  # document.root_atomic_selector
  # ```
  def root_atomic_selector: () -> ::Hash[untyped, untyped]

  # Has the aggregable enter an aggregation state. Ie, are only aggregation
  # operations allowed at this point on.
  #
  # _@return_ — If the aggregable is aggregating.
  #
  # Is the aggregable aggregating?
  # ```ruby
  # aggregable.aggregating?
  # ```
  def aggregating?: () -> bool

  # Add a group ($group) operation to the aggregation pipeline.
  #
  # _@param_ `operation` — The group operation.
  #
  # _@return_ — The aggregable.
  #
  # Add a group operation being verbose.
  # ```ruby
  # aggregable.group(count: { "$sum" => 1 }, max: { "$max" => "likes" })
  # ```
  #
  # Add a group operation using symbol shortcuts.
  # ```ruby
  # aggregable.group(:count.sum => 1, :max.max => "likes")
  # ```
  def group: (::Hash[untyped, untyped] operation) -> Aggregable

  # Add a projection ($project) to the aggregation pipeline.
  #
  # _@param_ `operation` — The projection to make.
  #
  # _@return_ — The aggregable.
  #
  # Add a projection to the pipeline.
  # ```ruby
  # aggregable.project(author: 1, name: 0)
  # ```
  def project: (?::Hash[untyped, untyped]? operation) -> Aggregable

  # Add an unwind ($unwind) to the aggregation pipeline.
  #
  # _@param_ `field` — The name of the field to unwind.
  #
  # _@return_ — The aggregable.
  #
  # Add an unwind to the pipeline.
  # ```ruby
  # aggregable.unwind(:field)
  # ```
  def unwind: (String | Symbol field) -> Aggregable

  # Add the aggregation operation.
  #
  # _@param_ `operation` — The operation for the pipeline.
  #
  # _@return_ — The cloned aggregable.
  #
  # Aggregate on the operation.
  # ```ruby
  # aggregation(operation) do |pipeline|
  #   pipeline.push("$project" => operation)
  # end
  # ```
  def aggregation: (::Hash[untyped, untyped] operation) -> Aggregable

  # Instruct the next mergeable call to use intersection.
  #
  # _@return_ — The intersect flagged mergeable.
  #
  # Use intersection on the next call.
  # ```ruby
  # mergeable.intersect.in(field: [ 1, 2, 3 ])
  # ```
  def intersect: () -> Mergeable

  # Instruct the next mergeable call to use override.
  #
  # _@return_ — The override flagged mergeable.
  #
  # Use override on the next call.
  # ```ruby
  # mergeable.override.in(field: [ 1, 2, 3 ])
  # ```
  def override: () -> Mergeable

  # Instruct the next mergeable call to use union.
  #
  # _@return_ — The union flagged mergeable.
  #
  # Use union on the next call.
  # ```ruby
  # mergeable.union.in(field: [ 1, 2, 3 ])
  # ```
  def union: () -> Mergeable

  # Clear the current strategy and negating flag, used after cloning.
  #
  # _@return_ — self.
  #
  # Reset the strategies.
  # ```ruby
  # mergeable.reset_strategies!
  # ```
  def reset_strategies!: () -> Criteria

  # Adds the criterion to the existing selection.
  #
  # _@param_ `criterion` — The criteria.
  #
  # _@param_ `operator` — The MongoDB operator.
  #
  # _@return_ — The new mergeable.
  #
  # Add the criterion.
  # ```ruby
  # mergeable.__add__({ name: 1 }, "$in")
  # ```
  def __add__: (::Hash[untyped, untyped] criterion, String operator) -> Mergeable

  # Adds the criterion to the existing selection.
  #
  # _@param_ `criterion` — The criteria.
  #
  # _@param_ `outer` — The outer MongoDB operator.
  #
  # _@param_ `inner` — The inner MongoDB operator.
  #
  # _@return_ — The new mergeable.
  #
  # Add the criterion.
  # ```ruby
  # mergeable.__expanded__([ 1, 10 ], "$within", "$center")
  # ```
  def __expanded__: (::Hash[untyped, untyped] criterion, String outer, String inner) -> Mergeable

  # Perform a straight merge of the criterion into the selection and let the
  # symbol overrides do all the work.
  #
  # _@param_ `criterion` — The criteria.
  #
  # _@return_ — The cloned object.
  #
  # Straight merge the expanded criterion.
  # ```ruby
  # mergeable.__merge__(location: [ 1, 10 ])
  # ```
  def __merge__: (::Hash[untyped, untyped] criterion) -> Mergeable

  # Adds the criterion to the existing selection.
  #
  # _@param_ `criterion` — The criteria.
  #
  # _@param_ `operator` — The MongoDB operator.
  #
  # _@return_ — The new mergeable.
  #
  # Add the criterion.
  # ```ruby
  # mergeable.__intersect__([ 1, 2 ], "$in")
  # ```
  def __intersect__: (::Hash[untyped, untyped] criterion, String operator) -> Mergeable

  # Adds $and/$or/$nor criteria to a copy of this selection.
  #
  # Each of the criteria can be a Hash of key/value pairs or MongoDB
  # operators (keys beginning with $), or a Selectable object
  # (which typically will be a Criteria instance).
  #
  # _@param_ `criteria` — Multiple key/value pair matches or Criteria objects.
  #
  # _@param_ `operator` — The MongoDB operator.
  #
  # _@return_ — The new mergeable.
  #
  # Add the criterion.
  # ```ruby
  # mergeable.__multi__([ 1, 2 ], "$in")
  # ```
  def __multi__: (::Array[::Hash[untyped, untyped] | Criteria] criteria, String operator) -> Mergeable

  # Combines criteria into a MongoDB selector.
  #
  # Criteria is an array of criterions which will be flattened.
  #
  # Each criterion can be:
  # - A hash
  # - A Criteria instance
  # - nil, in which case it is ignored
  def _mongoid_add_top_level_operation: (untyped operator, untyped criteria) -> untyped

  # Calling .flatten on an array which includes a Criteria instance
  # evaluates the criteria, which we do not want. Hence this method
  # explicitly only expands Array objects and Array subclasses.
  def _mongoid_flatten_arrays: (untyped array) -> untyped

  # Takes a criteria hash and expands Key objects into hashes containing
  # MQL corresponding to said key objects. Also converts the input to
  # BSON::Document to permit indifferent access.
  #
  # The argument must be a hash containing key-value pairs of the
  # following forms:
  # - {field_name: value}
  # - {'field_name' => value}
  # - {key_instance: value}
  # - {:$operator => operator_value_expression}
  # - {'$operator' => operator_value_expression}
  #
  # Ruby does not permit multiple symbol operators. For example,
  # {:foo.gt => 1, :foo.gt => 2} is collapsed to {:foo.gt => 2} by the
  # language. Therefore this method never has to deal with multiple
  # identical operators.
  #
  # Similarly, this method should never need to expand a literal value
  # and an operator at the same time.
  #
  # This method effectively converts symbol keys to string keys in
  # the input +expr+, such that the downstream code can assume that
  # conditions always contain string keys.
  #
  # _@param_ `expr` — Criteria including Key instances.
  #
  # _@return_ — The expanded criteria.
  def _mongoid_expand_keys: (::Hash[untyped, untyped] expr) -> BSON::Document

  # Adds the criterion to the existing selection.
  #
  # _@param_ `criterion` — The criteria.
  #
  # _@param_ `operator` — The MongoDB operator.
  #
  # _@return_ — The new mergeable.
  #
  # Add the criterion.
  # ```ruby
  # mergeable.__override__([ 1, 2 ], "$in")
  # ```
  def __override__: (::Hash[untyped, untyped] | Criteria criterion, String operator) -> Mergeable

  # Adds the criterion to the existing selection.
  #
  # _@param_ `criterion` — The criteria.
  #
  # _@param_ `operator` — The MongoDB operator.
  #
  # _@return_ — The new mergeable.
  #
  # Add the criterion.
  # ```ruby
  # mergeable.__union__([ 1, 2 ], "$in")
  # ```
  def __union__: (::Hash[untyped, untyped] criterion, String operator) -> Mergeable

  # Use the named strategy for the next operation.
  #
  # _@param_ `strategy` — The strategy to use.
  #
  # _@return_ — The existing mergeable.
  #
  # Use intersection.
  # ```ruby
  # mergeable.use(:__intersect__)
  # ```
  def use: (Symbol strategy) -> Mergeable

  # Add criterion to the selection with the named strategy.
  #
  # _@param_ `strategy` — The name of the strategy method.
  #
  # _@param_ `criterion` — The criterion to add.
  #
  # _@param_ `operator` — The MongoDB operator.
  #
  # _@return_ — The cloned query.
  #
  # Add criterion with a strategy.
  # ```ruby
  # mergeable.with_strategy(:__union__, {field_name: [ 1, 2, 3 ]}, "$in")
  # ```
  def with_strategy: (Symbol strategy, Object criterion, String operator) -> Mergeable

  # Prepare the value for merging.
  #
  # _@param_ `field` — The name of the field.
  #
  # _@param_ `value` — The value.
  #
  # _@return_ — The serialized value.
  #
  # Prepare the value.
  # ```ruby
  # mergeable.prepare("field", "$gt", 10)
  # ```
  def prepare: (String field, untyped operator, Object value) -> Object

  # Expands the specified condition to MongoDB syntax.
  #
  # This method is meant to be called when processing the items of
  # a condition hash and the key and the value of each item are
  # already available separately.
  #
  # The following parameter forms are accepted:
  #
  # - field is a string or symbol; value is the field query expresision
  # - field is a Key instance; value is the field query expression
  # - field is a string corresponding to a MongoDB operator; value is
  #   the operator value expression.
  #
  # This method expands the field-value combination to the MongoDB
  # selector syntax and returns an array of
  # [expanded key, expanded value]. The expanded key is converted to
  # a string if it wasn't already a string.
  #
  # _@param_ `field` — The field to expand.
  #
  # _@param_ `value` — The field's value.
  #
  # _@return_ — The expanded field and value.
  def expand_one_condition: (String | Symbol | Key field, Object value) -> ::Array[String | Object]

  # Expand criterion values to arrays, to be used with operators that
  # take an array as argument such as $in.
  #
  # _@param_ `criterion` — The criterion.
  #
  # _@return_ — The $in friendly criterion with array values.
  #
  # Convert all the values to arrays.
  # ```ruby
  # selectable.with_array_values({ key: 1...4 })
  # ```
  def expand_condition_to_array_values: (::Hash[untyped, untyped] criterion) -> ::Hash[untyped, untyped]

  # Adds a field expression to the query.
  #
  # +field+ must be a field name, and it must be a string. The upstream
  # code must have converted other field/key types to the simple string
  # form by the time this method is invoked.
  #
  # +value+ can be of any type, it is written into the selector unchanged.
  #
  # This method performs no processing on the provided field value.
  #
  # Mutates the receiver.
  #
  # _@param_ `field` — The field name.
  #
  # _@param_ `value` — The field value.
  #
  # _@return_ — self.
  def add_field_expression: (String field, Object value) -> Storable

  # Adds a logical operator expression to the selector.
  #
  # This method only handles logical operators ($and, $nor and $or).
  # It raises ArgumentError if called with another operator. Note that
  # in MQL, $not is a field-level operator and not a query-level one,
  # and therefore $not is not handled by this method.
  #
  # This method takes the operator and the operator value expression
  # separately for callers' convenience. It can be considered to
  # handle storing the hash +{operator => op_expr}+.
  #
  # If the selector consists of a single condition which is the specified
  # operator (on the top level), the new condition given in op_expr is
  # added to the existing conditions for the specified operator.
  # For example, if the selector is currently:
  #
  #     {'$or' => [{'hello' => 'world'}]}
  #
  # ... and operator is '$or' and op_expr is `[{'test' => 123'}]`,
  # the resulting selector will be:
  #
  #     {'$or' => [{'hello' => 'world'}, {'test' => 123}]}
  #
  # This method always adds the new conditions as additional requirements;
  # in other words, it does not implement the ActiveRecord or/nor behavior
  # where the receiver becomes one of the operands. It is expected that
  # code upstream of this method implements such behavior.
  #
  # This method does not simplify values (i.e. if the selector is
  # currently empty and operator is $and, op_expr is written to the
  # selector with $and even if the $and can in principle be elided).
  # Such simplification is also expected to have already been performed
  # by the upstream code.
  #
  # This method mutates the receiver.
  #
  # _@param_ `operator` — The operator to add.
  #
  # _@param_ `op_expr` — Operator value to add.
  #
  # _@return_ — self.
  def add_logical_operator_expression: (String operator, ::Array[::Hash[untyped, untyped]] op_expr) -> Storable

  # Adds an operator expression to the selector.
  #
  # This method takes the operator and the operator value expression
  # separately for callers' convenience. It can be considered to
  # handle storing the hash +{operator => op_expr}+.
  #
  # The operator value can be of any type.
  #
  # If the selector already has the specified operator in it (on the
  # top level), the new condition given in op_expr is added to the
  # existing conditions for the specified operator. This is
  # straightforward for $and; for other logical operators, the behavior
  # of this method is to add the new conditions to the existing operator.
  # For example, if the selector is currently:
  #
  #     {'foo' => 'bar', '$or' => [{'hello' => 'world'}]}
  #
  # ... and operator is '$or' and op_expr is `{'test' => 123'}`,
  # the resulting selector will be:
  #
  #     {'foo' => 'bar', '$or' => [{'hello' => 'world'}, {'test' => 123}]}
  #
  # This does not implement an OR between the existing selector and the
  # new operator expression - handling this is the job of upstream
  # methods. This method simply stores op_expr into the selector on the
  # assumption that the existing selector is the correct left hand side
  # of the operation already.
  #
  # For non-logical query-level operators like $where and $text, if
  # there already is a top-level operator with the same name, the
  # op_expr is added to the selector via a top-level $and operator,
  # thus producing a selector having both operator values.
  #
  # This method does not simplify values (i.e. if the selector is
  # currently empty and operator is $and, op_expr is written to the
  # selector with $and even if the $and can in principle be elided).
  #
  # This method mutates the receiver.
  #
  # _@param_ `operator` — The operator to add.
  #
  # _@param_ `op_expr` — Operator value to add.
  #
  # _@return_ — self.
  def add_operator_expression: (String operator, Object op_expr) -> Storable

  # Adds an arbitrary expression to the query.
  #
  # Field can either be a field name or an operator.
  #
  # Mutates the receiver.
  #
  # _@param_ `field` — Field name or operator name.
  #
  # _@param_ `value` — Field value or operator expression.
  #
  # _@return_ — self.
  def add_one_expression: (String field, Object value) -> Storable
end

# Key objects represent specifications for building query expressions
# utilizing MongoDB selectors.
#
# Simple key-value conditions are translated directly into expression
# hashes by Mongoid without utilizing Key objects. For example, the
# following condition:
#
#   Foo.where(price: 1)
#
# ... is translated to the following simple expression:
#
#   {price: 1}
#
# More complex conditions would start involving Key objects. For example:
#
#   Foo.where(:price.gt => 1)
#
# ... causes a Key instance to be created thusly:
#
#   Key.new(:price, :__override__, '$gt')
#
# This Key instance utilizes +operator+ but not +expanded+ nor +block+.
# The corresponding MongoDB query expression is:
#
#    {price: {'$gt' => 1}}
#
# A yet more more complex example is the following condition:
#
#   Foo.geo_spatial(:boundary.intersects_point => [1, 10])
#
# Processing this condition will cause a Key instance to be created as
# follows:
#
#   Key.new(:location, :__override__, '$geoIntersects', '$geometry') do |value|
#     { "type" => POINT, "coordinates" => value }
#   end
#
# ... eventually producing the following MongoDB query expression:
#
# {
#   boundary: {
#     '$geoIntersects' => {
#       '$geometry' => {
#         type: "Point" ,
#         coordinates: [ 1, 10 ]
#       }
#     }
#   }
# }
#
# Key instances can be thought of as procs that map a value to the
# MongoDB query expression required to obtain the key's condition,
# given the value.
class Mongoid::Criteria::Mongoid::Criteria::Queryable::Key
  # Returns the value of attribute aliases.
  #
  # Returns the value of attribute driver.
  #
  # Returns the value of attribute serializers.
  #
  # Does the key equal another object?
  #
  # _@param_ `other` — The object to compare to.
  #
  # _@return_ — If the objects are equal.
  #
  # Is the key equal to another?
  # ```ruby
  # key == other
  # key.eql? other
  # ```
  def ==: () -> untyped
        | () -> untyped
        | () -> untyped
        | () -> untyped
        | () -> untyped
        | () -> untyped
        | (Object other) -> bool

  # Calculate the hash code for a key.
  #
  # _@return_ — The hash code for the key.
  def hash: () -> Fixnum

  def initialize: (String | Symbol name, Symbol strategy, String | Integer operator, ?String? expanded) { () -> untyped } -> void

  # Gets the raw selector that would be passed to Mongo from this key.
  #
  # _@param_ `object` — The value to be included.
  #
  # _@param_ `negating` — If the selection should be negated.
  #
  # _@return_ — The raw MongoDB selector.
  #
  # Specify the raw selector.
  # ```ruby
  # key.__expr_part__(50)
  # ```
  def __expr_part__: (Object object, ?bool negating) -> ::Hash[untyped, untyped]

  def transform_value: (untyped value, ?untyped negating) -> untyped

  # Get the key as raw Mongo sorting options.
  #
  # _@return_ — The field/direction pair.
  #
  # Get the key as a sort.
  # ```ruby
  # key.__sort_option__
  # ```
  def __sort_option__: () -> ::Hash[untyped, untyped]

  # Convert the key to a string.
  #
  # _@return_ — The key as a string.
  #
  # Convert the key to a string.
  # ```ruby
  # key.to_s
  # ```
  def to_s: () -> String
end

# This is a smart hash for use with options and selectors.
class Mongoid::Criteria::Mongoid::Criteria::Queryable::Smash < Hash
  # _@return_ — The name of the field.
  #
  # _@return_ — The MongoDB query operator.
  #
  # _@return_ — The MongoDB expanded query operator.
  #
  # _@return_ — The name of the merge strategy.
  #
  # _@return_ — The optional block to transform values.
  #
  # Perform a deep copy of the smash.
  #
  # _@return_ — The copied hash.
  #
  # Perform a deep copy.
  # ```ruby
  # smash.__deep_copy__
  # ```
  def __deep_copy__: () -> (String | Symbol)
                   | () -> String
                   | () -> String
                   | () -> Symbol
                   | () -> Proc
                   | () -> Smash

  # Initialize the new selector.
  #
  # _@param_ `aliases` — A hash of mappings from aliases to the actual field names in the database.
  #
  # _@param_ `serializers` — An optional hash of objects that are responsible for serializing values. The keys of the hash must be strings that match the field name, and the values must respond to #localized? and #evolve(object).
  #
  # Initialize the new selector.
  # ```ruby
  # Queryable::Smash.new(aliases, serializers)
  # ```
  def initialize: (?::Hash[untyped, untyped] aliases, ?::Hash[untyped, untyped] serializers) -> void

  # Get an item from the smart hash by the provided key.
  #
  # _@param_ `key` — The key.
  #
  # _@return_ — The found object.
  #
  # Get an item by the key.
  # ```ruby
  # smash["test"]
  # ```
  def []: (K key) -> V

  # Get the localized value for the key if needed. If the field uses
  # localization the current locale will be appended to the key in
  # MongoDB dot notation.
  #
  # _@param_ `name` — The name of the field.
  #
  # _@param_ `serializer` — The optional field serializer.
  #
  # _@return_ — The normalized key.
  #
  # Get the normalized key name.
  # ```ruby
  # smash.localized_key("field", serializer)
  # ```
  def localized_key: (String name, Object serializer) -> String

  # Get the pair of objects needed to store the value in a hash by the
  # provided key. This is the database field name and the serializer.
  #
  # _@param_ `key` — The key provided to the selection.
  #
  # _@return_ — The name of the db field and
  # serializer.
  #
  # Get the name and serializer.
  # ```ruby
  # smash.storage_pair("id")
  # ```
  def storage_pair: (Symbol | String key) -> ::Array[[ K, V ]]
end

Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Smash::K: untyped

Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Smash::V: untyped

Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Smash::Elem: untyped

# The options is a hash representation of options passed to MongoDB queries,
# such as skip, limit, and sorting criteria.
class Mongoid::Criteria::Mongoid::Criteria::Queryable::Options < Mongoid::Criteria::Queryable::Smash
  # Returns the value of attribute aliases.
  #
  # Returns the value of attribute serializers.
  #
  # Convenience method for getting the field options.
  #
  # _@return_ — The fields options.
  #
  # Get the fields options.
  # ```ruby
  # options.fields
  # ```
  def fields: () -> untyped
            | () -> untyped
            | () -> untyped
            | () -> untyped
            | () -> ::Hash[untyped, untyped]

  # Convenience method for getting the limit option.
  #
  # _@return_ — The limit option.
  #
  # Get the limit option.
  # ```ruby
  # options.limit
  # ```
  def limit: () -> Integer

  # Convenience method for getting the skip option.
  #
  # _@return_ — The skip option.
  #
  # Get the skip option.
  # ```ruby
  # options.skip
  # ```
  def skip: () -> Integer

  # Convenience method for getting the sort options.
  #
  # _@return_ — The sort options.
  #
  # Get the sort options.
  # ```ruby
  # options.sort
  # ```
  def sort: () -> ::Hash[untyped, untyped]

  # Store the value in the options for the provided key. The options will
  # handle all necessary serialization and localization in this step.
  #
  # _@param_ `key` — The name of the attribute.
  #
  # _@param_ `value` — The value to add.
  #
  # _@return_ — The stored object.
  #
  # Store a value in the options.
  # ```ruby
  # options.store(:key, "testing")
  # ```
  def store: (String | Symbol key, Object value, ?untyped localize) -> Object

  # Convert the options to aggregation pipeline friendly options.
  #
  # _@return_ — The options in pipeline form.
  #
  # Convert the options to a pipeline.
  # ```ruby
  # options.to_pipeline
  # ```
  def to_pipeline: () -> ::Array[::Hash[untyped, untyped]]

  # Perform a deep copy of the options.
  #
  # _@return_ — The copied options.
  #
  # Perform a deep copy.
  # ```ruby
  # options.__deep_copy__
  # ```
  def __deep_copy__: () -> Options

  # Evolve a single key selection with various types of values.
  #
  # _@param_ `value` — The value to serialize.
  #
  # _@return_ — The serialized object.
  #
  # Evolve a simple selection.
  # ```ruby
  # options.evolve(field, 5)
  # ```
  def evolve: (Object value, ?untyped localize) -> Object

  # Evolve a single key selection with hash values.
  #
  # _@param_ `value` — The hash to serialize.
  #
  # _@return_ — The serialized hash.
  #
  # Evolve a simple selection.
  # ```ruby
  # options.evolve(field, { "$gt" => 5 })
  # ```
  def evolve_hash: (::Hash[untyped, untyped] value, ?untyped localize) -> Object
end

# The optional module includes all behavior that has to do with extra
# options surrounding queries, like skip, limit, sorting, etc.
module Mongoid::Criteria::Mongoid::Criteria::Queryable::Optional
  extend Mongoid::Criteria::Queryable::Macroable

  # Add ascending sorting options for all the provided fields.
  #
  # _@param_ `fields` — The fields to sort.
  #
  # _@return_ — The cloned optional.
  #
  # Add ascending sorting.
  # ```ruby
  # optional.ascending(:first_name, :last_name)
  # ```
  def ascending: (*::Array[Symbol] fields) -> Optional

  # Adds the option for telling MongoDB how many documents to retrieve in
  # it's batching.
  #
  # _@param_ `value` — The batch size.
  #
  # _@return_ — The cloned optional.
  #
  # Apply the batch size options.
  # ```ruby
  # optional.batch_size(500)
  # ```
  def batch_size: (?Integer? value) -> Optional

  # Add descending sorting options for all the provided fields.
  #
  # _@param_ `fields` — The fields to sort.
  #
  # _@return_ — The cloned optional.
  #
  # Add descending sorting.
  # ```ruby
  # optional.descending(:first_name, :last_name)
  # ```
  def descending: (*::Array[Symbol] fields) -> Optional

  # Add an index hint to the query options.
  #
  # _@param_ `value` — The index hint.
  #
  # _@return_ — The cloned optional.
  #
  # Add an index hint.
  # ```ruby
  # optional.hint("$natural" => 1)
  # ```
  def hint: (?::Hash[untyped, untyped]? value) -> Optional

  # Add the number of documents to limit in the returned results.
  #
  # _@param_ `value` — The number of documents to return.
  #
  # _@return_ — The cloned optional.
  #
  # Limit the number of returned documents.
  # ```ruby
  # optional.limit(20)
  # ```
  def limit: (?Integer? value) -> Optional

  # Adds the option to limit the number of documents scanned in the
  # collection.
  #
  # _@param_ `value` — The max number of documents to scan.
  #
  # _@return_ — The cloned optional.
  #
  # Add the max scan limit.
  # ```ruby
  # optional.max_scan(1000)
  # ```
  def max_scan: (?Integer? value) -> Optional

  # Adds a cumulative time limit in milliseconds for processing operations on a cursor.
  #
  # _@param_ `value` — The max time in milliseconds for processing operations on a cursor.
  #
  # _@return_ — The cloned optional.
  #
  # Add the max time ms option.
  # ```ruby
  # optional.max_time_ms(200)
  # ```
  def max_time_ms: (?Integer? value) -> Optional

  # Tell the query not to timeout.
  #
  # _@return_ — The cloned optional.
  #
  # Tell the query not to timeout.
  # ```ruby
  # optional.no_timeout
  # ```
  def no_timeout: () -> Optional

  # Limits the results to only contain the fields provided.
  #
  # _@param_ `args` — The fields to return.
  #
  # _@return_ — The cloned optional.
  #
  # Limit the results to the provided fields.
  # ```ruby
  # optional.only(:name, :dob)
  # ```
  def only: (*::Array[Symbol] args) -> Optional

  # Adds sorting criterion to the options.
  #
  # _@param_ `spec` — The sorting specification.
  #
  # _@return_ — The cloned optional.
  #
  # Add sorting options via a hash with integer directions.
  # ```ruby
  # optional.order_by(name: 1, dob: -1)
  # ```
  #
  # Add sorting options via a hash with symbol directions.
  # ```ruby
  # optional.order_by(name: :asc, dob: :desc)
  # ```
  #
  # Add sorting options via a hash with string directions.
  # ```ruby
  # optional.order_by(name: "asc", dob: "desc")
  # ```
  #
  # Add sorting options via an array with integer directions.
  # ```ruby
  # optional.order_by([[ name, 1 ], [ dob, -1 ]])
  # ```
  #
  # Add sorting options via an array with symbol directions.
  # ```ruby
  # optional.order_by([[ :name, :asc ], [ :dob, :desc ]])
  # ```
  #
  # Add sorting options via an array with string directions.
  # ```ruby
  # optional.order_by([[ "name", "asc" ], [ "dob", "desc" ]])
  # ```
  #
  # Add sorting options with keys.
  # ```ruby
  # optional.order_by(:name.asc, :dob.desc)
  # ```
  #
  # Add sorting options via a string.
  # ```ruby
  # optional.order_by("name ASC, dob DESC")
  # ```
  def order_by: (*::Array[untyped] | ::Hash[untyped, untyped] | String spec) -> Optional

  # Instead of merging the order criteria, use this method to completely
  # replace the existing ordering with the provided.
  #
  # _@param_ `spec` — The sorting specification.
  #
  # _@return_ — The cloned optional.
  #
  # Replace the ordering.
  # ```ruby
  # optional.reorder(name: :asc)
  # ```
  def reorder: (*::Array[untyped] | ::Hash[untyped, untyped] | String spec) -> Optional

  # Add the number of documents to skip.
  #
  # _@param_ `value` — The number to skip.
  #
  # _@return_ — The cloned optional.
  #
  # Add the number to skip.
  # ```ruby
  # optional.skip(100)
  # ```
  def skip: (?Integer? value) -> Optional

  # Limit the returned results via slicing embedded arrays.
  #
  # _@param_ `criterion` — The slice options.
  #
  # _@return_ — The cloned optional.
  #
  # Slice the returned results.
  # ```ruby
  # optional.slice(aliases: [ 0, 5 ])
  # ```
  def slice: (?::Hash[untyped, untyped]? criterion) -> Optional

  # Tell the query to operate in snapshot mode.
  #
  # _@return_ — The cloned optional.
  #
  # Add the snapshot option.
  # ```ruby
  # optional.snapshot
  # ```
  def snapshot: () -> Optional

  # Limits the results to only contain the fields not provided.
  #
  # _@param_ `args` — The fields to ignore.
  #
  # _@return_ — The cloned optional.
  #
  # Limit the results to the fields not provided.
  # ```ruby
  # optional.without(:name, :dob)
  # ```
  def without: (*::Array[Symbol] args) -> Optional

  # Associate a comment with the query.
  #
  # _@param_ `comment` — The comment to be associated with the query.
  #
  # _@return_ — The cloned optional.
  #
  # Add a comment.
  # ```ruby
  # optional.comment('slow query')
  # ```
  #
  # _@note_ — Set profilingLevel to 2 and the comment will be logged in the profile
  # collection along with the query.
  def comment: (?String? comment) -> Optional

  # Set the cursor type.
  #
  # _@param_ `type` — The type of cursor to create.
  #
  # _@return_ — The cloned optional.
  #
  # Set the cursor type.
  # ```ruby
  # optional.cursor_type(:tailable)
  # optional.cursor_type(:tailable_await)
  # ```
  #
  # _@note_ — The cursor can be type :tailable or :tailable_await.
  def cursor_type: (Symbol `type`) -> Optional

  # Set the collation.
  #
  # _@param_ `collation_doc` — The document describing the collation to use.
  #
  # _@return_ — The cloned optional.
  #
  # Set the collation.
  # ```ruby
  # optional.collation(locale: 'fr', strength: 2)
  # ```
  def collation: (::Hash[untyped, untyped] collation_doc) -> Optional

  # Add a single sort option.
  #
  # _@param_ `options` — The options.
  #
  # _@param_ `field` — The field name.
  #
  # _@param_ `direction` — The sort direction.
  #
  # _@return_ — The cloned optional.
  #
  # Add a single sort option.
  # ```ruby
  # optional.add_sort_option({}, :name, 1)
  # ```
  def add_sort_option: (::Hash[untyped, untyped] options, String field, Integer direction) -> Optional

  # Take the provided criterion and store it as an option in the query
  # options.
  #
  # _@param_ `args` — The options.
  #
  # _@return_ — The cloned queryable.
  #
  # Store the option.
  # ```ruby
  # optional.option({ skip: 10 })
  # ```
  def option: (*::Array[untyped] args) -> Queryable

  # Add multiple sort options at once.
  #
  # _@param_ `fields` — The field names.
  #
  # _@param_ `direction` — The sort direction.
  #
  # _@return_ — The cloned optional.
  #
  # Add multiple sort options.
  # ```ruby
  # optional.sort_with_list(:name, :dob, 1)
  # ```
  def sort_with_list: (*::Array[String] fields, Integer direction) -> Optional

  # Get the methods on the optional that can be forwarded to from a model.
  #
  # _@return_ — The names of the forwardable methods.
  #
  # Get the forwardable methods.
  # ```ruby
  # Optional.forwardables
  # ```
  def self.forwardables: () -> ::Array[Symbol]

  def self.key: (Symbol name, Symbol strategy, String operator, ?String? additional) { () -> untyped } -> untyped
end

# Represents an aggregation pipeline.
#
# @since 2.0.0
class Mongoid::Criteria::Mongoid::Criteria::Queryable::Pipeline < Array
  # Returns the value of attribute options.
  #
  # Deep copy the aggregation pipeline. Will clone all the values in the
  # pipeline as well as the pipeline itself.
  #
  # _@return_ — The cloned pipeline.
  #
  # Deep copy the pipeline.
  # ```ruby
  # pipeline.__deep_copy__
  # ```
  def __deep_copy__: () -> untyped
                   | () -> untyped
                   | () -> Pipeline

  # Add a group operation to the aggregation pipeline.
  #
  # _@param_ `entry` — The group entry.
  #
  # _@return_ — The pipeline.
  #
  # Add a group operation.
  # ```ruby
  # pipeline.group(:_id => "foo", :count.sum => 1, :max.max => "likes")
  # ```
  def group: (::Hash[untyped, untyped] entry) -> Pipeline

  # Initialize the new pipeline.
  #
  # _@param_ `aliases` — A hash of mappings from aliases to the actual field names in the database.
  #
  # Initialize the new pipeline.
  # ```ruby
  # Queryable::Pipeline.new(aliases)
  # ```
  def initialize: (?::Hash[untyped, untyped] aliases) -> void

  # Adds a $project entry to the aggregation pipeline.
  #
  # _@param_ `entry` — The projection.
  #
  # _@return_ — The pipeline.
  #
  # Add the projection.
  # ```ruby
  # pipeline.project(name: 1)
  # ```
  def project: (::Hash[untyped, untyped] entry) -> Pipeline

  # Add the $unwind entry to the pipeline.
  #
  # _@param_ `field_or_doc` — A field name or a document.
  #
  # _@return_ — The pipeline.
  #
  # Add the unwind.
  # ```ruby
  # pipeline.unwind(:field)
  # pipeline.unwind(document)
  # ```
  def unwind: (String | Symbol | ::Hash[untyped, untyped] field_or_doc) -> Pipeline

  # Evolve the entry using the aliases.
  #
  # _@param_ `entry` — The entry to evolve.
  #
  # _@return_ — The evolved entry.
  #
  # Evolve the entry.
  # ```ruby
  # pipeline.evolve(name: 1)
  # ```
  def evolve: (::Hash[untyped, untyped] entry) -> ::Hash[untyped, untyped]
end

# The selector is a special kind of hash that knows how to serialize values
# coming into it as well as being alias and locale aware for key names.
class Mongoid::Criteria::Mongoid::Criteria::Queryable::Selector < Mongoid::Criteria::Queryable::Smash
  # Merges another selector into this one.
  #
  # _@param_ `other` — The object to merge in.
  #
  # _@return_ — The selector.
  #
  # Merge in another selector.
  # ```ruby
  # selector.merge!(name: "test")
  # ```
  def merge!: () -> untyped
            | () -> untyped
            | (::Hash[untyped, untyped] | Selector other) -> Selector

  # Store the value in the selector for the provided key. The selector will
  # handle all necessary serialization and localization in this step.
  #
  # _@param_ `key` — The name of the attribute.
  #
  # _@param_ `value` — The value to add.
  #
  # _@return_ — The stored object.
  #
  # Store a value in the selector.
  # ```ruby
  # selector.store(:key, "testing")
  # ```
  def store: (String | Symbol key, Object value) -> Object

  # Convert the selector to an aggregation pipeline entry.
  #
  # _@return_ — The pipeline entry for the selector.
  #
  # Convert the selector to a pipeline.
  # ```ruby
  # selector.to_pipeline
  # ```
  def to_pipeline: () -> ::Array[::Hash[untyped, untyped]]

  # Evolves a multi-list selection, like an $and or $or criterion, and
  # performs the necessary serialization.
  #
  # _@param_ `specs` — The multi-selection.
  #
  # _@return_ — The serialized values.
  #
  # Evolve the multi-selection.
  # ```ruby
  # selector.evolve_multi([{ field: "value" }])
  # ```
  def evolve_multi: (::Array[::Hash[untyped, untyped]] specs) -> ::Array[::Hash[untyped, untyped]]

  # Evolve a single key selection with various types of values.
  #
  # _@param_ `serializer` — The optional serializer for the field.
  #
  # _@param_ `value` — The value to serialize.
  #
  # _@return_ — The serialized object.
  #
  # Evolve a simple selection.
  # ```ruby
  # selector.evolve(field, 5)
  # ```
  def evolve: (Object serializer, Object value) -> Object

  # Evolve a single key selection with array values.
  #
  # _@param_ `serializer` — The optional serializer for the field.
  #
  # _@param_ `value` — The array to serialize.
  #
  # _@return_ — The serialized array.
  #
  # Evolve a simple selection.
  # ```ruby
  # selector.evolve(field, [ 1, 2, 3 ])
  # ```
  def evolve_array: (Object serializer, ::Array[Object] value) -> Object

  # Evolve a single key selection with hash values.
  #
  # _@param_ `serializer` — The optional serializer for the field.
  #
  # _@param_ `value` — The hash to serialize.
  #
  # _@return_ — The serialized hash.
  #
  # Evolve a simple selection.
  # ```ruby
  # selector.evolve(field, { "$gt" => 5 })
  # ```
  def evolve_hash: (Object serializer, ::Hash[untyped, untyped] value) -> Object

  # Determines if the selection is a multi-select, like an $and or $or or $nor
  # selection.
  #
  # _@param_ `key` — The key to check.
  #
  # _@return_ — If the key is for a multi-select.
  #
  # Is the selection a multi-select?
  # ```ruby
  # selector.multi_selection?("$and")
  # ```
  def multi_selection?: (String key) -> bool
end

# This module encapsulates methods that write query expressions into
# the Criteria's selector.
#
# The query expressions must have already been expanded as necessary.
# The methods of this module do not perform processing on expression
# values.
#
# Methods in this module do not handle negation - if negation is needed,
# it must have already been handled upstream of these methods.
#
# @api private
module Mongoid::Criteria::Mongoid::Criteria::Queryable::Storable
  # Adds a field expression to the query.
  #
  # +field+ must be a field name, and it must be a string. The upstream
  # code must have converted other field/key types to the simple string
  # form by the time this method is invoked.
  #
  # +value+ can be of any type, it is written into the selector unchanged.
  #
  # This method performs no processing on the provided field value.
  #
  # Mutates the receiver.
  #
  # _@param_ `field` — The field name.
  #
  # _@param_ `value` — The field value.
  #
  # _@return_ — self.
  def add_field_expression: (String field, Object value) -> Storable

  # Adds a logical operator expression to the selector.
  #
  # This method only handles logical operators ($and, $nor and $or).
  # It raises ArgumentError if called with another operator. Note that
  # in MQL, $not is a field-level operator and not a query-level one,
  # and therefore $not is not handled by this method.
  #
  # This method takes the operator and the operator value expression
  # separately for callers' convenience. It can be considered to
  # handle storing the hash +{operator => op_expr}+.
  #
  # If the selector consists of a single condition which is the specified
  # operator (on the top level), the new condition given in op_expr is
  # added to the existing conditions for the specified operator.
  # For example, if the selector is currently:
  #
  #     {'$or' => [{'hello' => 'world'}]}
  #
  # ... and operator is '$or' and op_expr is `[{'test' => 123'}]`,
  # the resulting selector will be:
  #
  #     {'$or' => [{'hello' => 'world'}, {'test' => 123}]}
  #
  # This method always adds the new conditions as additional requirements;
  # in other words, it does not implement the ActiveRecord or/nor behavior
  # where the receiver becomes one of the operands. It is expected that
  # code upstream of this method implements such behavior.
  #
  # This method does not simplify values (i.e. if the selector is
  # currently empty and operator is $and, op_expr is written to the
  # selector with $and even if the $and can in principle be elided).
  # Such simplification is also expected to have already been performed
  # by the upstream code.
  #
  # This method mutates the receiver.
  #
  # _@param_ `operator` — The operator to add.
  #
  # _@param_ `op_expr` — Operator value to add.
  #
  # _@return_ — self.
  def add_logical_operator_expression: (String operator, ::Array[::Hash[untyped, untyped]] op_expr) -> Storable

  # Adds an operator expression to the selector.
  #
  # This method takes the operator and the operator value expression
  # separately for callers' convenience. It can be considered to
  # handle storing the hash +{operator => op_expr}+.
  #
  # The operator value can be of any type.
  #
  # If the selector already has the specified operator in it (on the
  # top level), the new condition given in op_expr is added to the
  # existing conditions for the specified operator. This is
  # straightforward for $and; for other logical operators, the behavior
  # of this method is to add the new conditions to the existing operator.
  # For example, if the selector is currently:
  #
  #     {'foo' => 'bar', '$or' => [{'hello' => 'world'}]}
  #
  # ... and operator is '$or' and op_expr is `{'test' => 123'}`,
  # the resulting selector will be:
  #
  #     {'foo' => 'bar', '$or' => [{'hello' => 'world'}, {'test' => 123}]}
  #
  # This does not implement an OR between the existing selector and the
  # new operator expression - handling this is the job of upstream
  # methods. This method simply stores op_expr into the selector on the
  # assumption that the existing selector is the correct left hand side
  # of the operation already.
  #
  # For non-logical query-level operators like $where and $text, if
  # there already is a top-level operator with the same name, the
  # op_expr is added to the selector via a top-level $and operator,
  # thus producing a selector having both operator values.
  #
  # This method does not simplify values (i.e. if the selector is
  # currently empty and operator is $and, op_expr is written to the
  # selector with $and even if the $and can in principle be elided).
  #
  # This method mutates the receiver.
  #
  # _@param_ `operator` — The operator to add.
  #
  # _@param_ `op_expr` — Operator value to add.
  #
  # _@return_ — self.
  def add_operator_expression: (String operator, Object op_expr) -> Storable

  # Adds an arbitrary expression to the query.
  #
  # Field can either be a field name or an operator.
  #
  # Mutates the receiver.
  #
  # _@param_ `field` — Field name or operator name.
  #
  # _@param_ `value` — Field value or operator expression.
  #
  # _@return_ — self.
  def add_one_expression: (String field, Object value) -> Storable
end

# Adds macro behavior for adding symbol methods.
module Mongoid::Criteria::Mongoid::Criteria::Queryable::Macroable
  def key: (Symbol name, Symbol strategy, String operator, ?String? additional) { () -> untyped } -> untyped
end

# Contains behavior for merging existing selection with new selection.
module Mongoid::Criteria::Mongoid::Criteria::Queryable::Mergeable
  # Instruct the next mergeable call to use intersection.
  #
  # _@return_ — The intersect flagged mergeable.
  #
  # Use intersection on the next call.
  # ```ruby
  # mergeable.intersect.in(field: [ 1, 2, 3 ])
  # ```
  def intersect: () -> Mergeable

  # Instruct the next mergeable call to use override.
  #
  # _@return_ — The override flagged mergeable.
  #
  # Use override on the next call.
  # ```ruby
  # mergeable.override.in(field: [ 1, 2, 3 ])
  # ```
  def override: () -> Mergeable

  # Instruct the next mergeable call to use union.
  #
  # _@return_ — The union flagged mergeable.
  #
  # Use union on the next call.
  # ```ruby
  # mergeable.union.in(field: [ 1, 2, 3 ])
  # ```
  def union: () -> Mergeable

  # Clear the current strategy and negating flag, used after cloning.
  #
  # _@return_ — self.
  #
  # Reset the strategies.
  # ```ruby
  # mergeable.reset_strategies!
  # ```
  def reset_strategies!: () -> Criteria

  # Adds the criterion to the existing selection.
  #
  # _@param_ `criterion` — The criteria.
  #
  # _@param_ `operator` — The MongoDB operator.
  #
  # _@return_ — The new mergeable.
  #
  # Add the criterion.
  # ```ruby
  # mergeable.__add__({ name: 1 }, "$in")
  # ```
  def __add__: (::Hash[untyped, untyped] criterion, String operator) -> Mergeable

  # Adds the criterion to the existing selection.
  #
  # _@param_ `criterion` — The criteria.
  #
  # _@param_ `outer` — The outer MongoDB operator.
  #
  # _@param_ `inner` — The inner MongoDB operator.
  #
  # _@return_ — The new mergeable.
  #
  # Add the criterion.
  # ```ruby
  # mergeable.__expanded__([ 1, 10 ], "$within", "$center")
  # ```
  def __expanded__: (::Hash[untyped, untyped] criterion, String outer, String inner) -> Mergeable

  # Perform a straight merge of the criterion into the selection and let the
  # symbol overrides do all the work.
  #
  # _@param_ `criterion` — The criteria.
  #
  # _@return_ — The cloned object.
  #
  # Straight merge the expanded criterion.
  # ```ruby
  # mergeable.__merge__(location: [ 1, 10 ])
  # ```
  def __merge__: (::Hash[untyped, untyped] criterion) -> Mergeable

  # Adds the criterion to the existing selection.
  #
  # _@param_ `criterion` — The criteria.
  #
  # _@param_ `operator` — The MongoDB operator.
  #
  # _@return_ — The new mergeable.
  #
  # Add the criterion.
  # ```ruby
  # mergeable.__intersect__([ 1, 2 ], "$in")
  # ```
  def __intersect__: (::Hash[untyped, untyped] criterion, String operator) -> Mergeable

  # Adds $and/$or/$nor criteria to a copy of this selection.
  #
  # Each of the criteria can be a Hash of key/value pairs or MongoDB
  # operators (keys beginning with $), or a Selectable object
  # (which typically will be a Criteria instance).
  #
  # _@param_ `criteria` — Multiple key/value pair matches or Criteria objects.
  #
  # _@param_ `operator` — The MongoDB operator.
  #
  # _@return_ — The new mergeable.
  #
  # Add the criterion.
  # ```ruby
  # mergeable.__multi__([ 1, 2 ], "$in")
  # ```
  def __multi__: (::Array[::Hash[untyped, untyped] | Criteria] criteria, String operator) -> Mergeable

  # Combines criteria into a MongoDB selector.
  #
  # Criteria is an array of criterions which will be flattened.
  #
  # Each criterion can be:
  # - A hash
  # - A Criteria instance
  # - nil, in which case it is ignored
  def _mongoid_add_top_level_operation: (untyped operator, untyped criteria) -> untyped

  # Calling .flatten on an array which includes a Criteria instance
  # evaluates the criteria, which we do not want. Hence this method
  # explicitly only expands Array objects and Array subclasses.
  def _mongoid_flatten_arrays: (untyped array) -> untyped

  # Takes a criteria hash and expands Key objects into hashes containing
  # MQL corresponding to said key objects. Also converts the input to
  # BSON::Document to permit indifferent access.
  #
  # The argument must be a hash containing key-value pairs of the
  # following forms:
  # - {field_name: value}
  # - {'field_name' => value}
  # - {key_instance: value}
  # - {:$operator => operator_value_expression}
  # - {'$operator' => operator_value_expression}
  #
  # Ruby does not permit multiple symbol operators. For example,
  # {:foo.gt => 1, :foo.gt => 2} is collapsed to {:foo.gt => 2} by the
  # language. Therefore this method never has to deal with multiple
  # identical operators.
  #
  # Similarly, this method should never need to expand a literal value
  # and an operator at the same time.
  #
  # This method effectively converts symbol keys to string keys in
  # the input +expr+, such that the downstream code can assume that
  # conditions always contain string keys.
  #
  # _@param_ `expr` — Criteria including Key instances.
  #
  # _@return_ — The expanded criteria.
  def _mongoid_expand_keys: (::Hash[untyped, untyped] expr) -> BSON::Document

  # Adds the criterion to the existing selection.
  #
  # _@param_ `criterion` — The criteria.
  #
  # _@param_ `operator` — The MongoDB operator.
  #
  # _@return_ — The new mergeable.
  #
  # Add the criterion.
  # ```ruby
  # mergeable.__override__([ 1, 2 ], "$in")
  # ```
  def __override__: (::Hash[untyped, untyped] | Criteria criterion, String operator) -> Mergeable

  # Adds the criterion to the existing selection.
  #
  # _@param_ `criterion` — The criteria.
  #
  # _@param_ `operator` — The MongoDB operator.
  #
  # _@return_ — The new mergeable.
  #
  # Add the criterion.
  # ```ruby
  # mergeable.__union__([ 1, 2 ], "$in")
  # ```
  def __union__: (::Hash[untyped, untyped] criterion, String operator) -> Mergeable

  # Use the named strategy for the next operation.
  #
  # _@param_ `strategy` — The strategy to use.
  #
  # _@return_ — The existing mergeable.
  #
  # Use intersection.
  # ```ruby
  # mergeable.use(:__intersect__)
  # ```
  def use: (Symbol strategy) -> Mergeable

  # Add criterion to the selection with the named strategy.
  #
  # _@param_ `strategy` — The name of the strategy method.
  #
  # _@param_ `criterion` — The criterion to add.
  #
  # _@param_ `operator` — The MongoDB operator.
  #
  # _@return_ — The cloned query.
  #
  # Add criterion with a strategy.
  # ```ruby
  # mergeable.with_strategy(:__union__, {field_name: [ 1, 2, 3 ]}, "$in")
  # ```
  def with_strategy: (Symbol strategy, Object criterion, String operator) -> Mergeable

  # Prepare the value for merging.
  #
  # _@param_ `field` — The name of the field.
  #
  # _@param_ `value` — The value.
  #
  # _@return_ — The serialized value.
  #
  # Prepare the value.
  # ```ruby
  # mergeable.prepare("field", "$gt", 10)
  # ```
  def prepare: (String field, untyped operator, Object value) -> Object
end

# Provides a DSL around crafting aggregation framework commands.
#
# @since 2.0.0
module Mongoid::Criteria::Mongoid::Criteria::Queryable::Aggregable
  extend Mongoid::Criteria::Queryable::Macroable

  # Returns the value of attribute strategy.
  #
  # Has the aggregable enter an aggregation state. Ie, are only aggregation
  # operations allowed at this point on.
  #
  # _@return_ — If the aggregable is aggregating.
  #
  # Is the aggregable aggregating?
  # ```ruby
  # aggregable.aggregating?
  # ```
  def aggregating?: () -> untyped
                  | () -> untyped
                  | () -> bool

  # Add a group ($group) operation to the aggregation pipeline.
  #
  # _@param_ `operation` — The group operation.
  #
  # _@return_ — The aggregable.
  #
  # Add a group operation being verbose.
  # ```ruby
  # aggregable.group(count: { "$sum" => 1 }, max: { "$max" => "likes" })
  # ```
  #
  # Add a group operation using symbol shortcuts.
  # ```ruby
  # aggregable.group(:count.sum => 1, :max.max => "likes")
  # ```
  def group: (::Hash[untyped, untyped] operation) -> Aggregable

  # Add a projection ($project) to the aggregation pipeline.
  #
  # _@param_ `operation` — The projection to make.
  #
  # _@return_ — The aggregable.
  #
  # Add a projection to the pipeline.
  # ```ruby
  # aggregable.project(author: 1, name: 0)
  # ```
  def project: (?::Hash[untyped, untyped]? operation) -> Aggregable

  # Add an unwind ($unwind) to the aggregation pipeline.
  #
  # _@param_ `field` — The name of the field to unwind.
  #
  # _@return_ — The aggregable.
  #
  # Add an unwind to the pipeline.
  # ```ruby
  # aggregable.unwind(:field)
  # ```
  def unwind: (String | Symbol field) -> Aggregable

  # Add the aggregation operation.
  #
  # _@param_ `operation` — The operation for the pipeline.
  #
  # _@return_ — The cloned aggregable.
  #
  # Aggregate on the operation.
  # ```ruby
  # aggregation(operation) do |pipeline|
  #   pipeline.push("$project" => operation)
  # end
  # ```
  def aggregation: (::Hash[untyped, untyped] operation) -> Aggregable

  def self.key: (Symbol name, Symbol strategy, String operator, ?String? additional) { () -> untyped } -> untyped
end

# This module encapsulates methods that expand various high level
# query forms to the MongoDB hash condition selector syntax.
#
# @example Example high level form.
#   Band.where(:foo.gt => 5)
#
# @api private
module Mongoid::Criteria::Mongoid::Criteria::Queryable::Expandable
  # Expands the specified condition to MongoDB syntax.
  #
  # This method is meant to be called when processing the items of
  # a condition hash and the key and the value of each item are
  # already available separately.
  #
  # The following parameter forms are accepted:
  #
  # - field is a string or symbol; value is the field query expresision
  # - field is a Key instance; value is the field query expression
  # - field is a string corresponding to a MongoDB operator; value is
  #   the operator value expression.
  #
  # This method expands the field-value combination to the MongoDB
  # selector syntax and returns an array of
  # [expanded key, expanded value]. The expanded key is converted to
  # a string if it wasn't already a string.
  #
  # _@param_ `field` — The field to expand.
  #
  # _@param_ `value` — The field's value.
  #
  # _@return_ — The expanded field and value.
  def expand_one_condition: () -> untyped
                          | () -> untyped
                          | (untyped field, untyped value) -> untyped
                          | () -> untyped
                          | (String | Symbol | Key field, Object value) -> ::Array[String | Object]

  # Expand criterion values to arrays, to be used with operators that
  # take an array as argument such as $in.
  #
  # _@param_ `criterion` — The criterion.
  #
  # _@return_ — The $in friendly criterion with array values.
  #
  # Convert all the values to arrays.
  # ```ruby
  # selectable.with_array_values({ key: 1...4 })
  # ```
  def expand_condition_to_array_values: (::Hash[untyped, untyped] criterion) -> ::Hash[untyped, untyped]
end

# An queryable selectable is selectable, in that it has the ability to select
# document from the database. The selectable module brings all functionality
# to the selectable that has to do with building MongoDB selectors.
module Mongoid::Criteria::Mongoid::Criteria::Queryable::Selectable
  extend Mongoid::Criteria::Queryable::Macroable

  # sord infer - argument name in single @param inferred as "*criteria"
  # Add the $all criterion.
  #
  # _@param_ `criterion` — The key value pairs for $all matching.
  #
  # _@return_ — The cloned selectable.
  #
  # Add the criterion.
  # ```ruby
  # selectable.all(field: [ 1, 2 ])
  # ```
  #
  # Execute an $all in a where query.
  # ```ruby
  # selectable.where(:field.all => [ 1, 2 ])
  # ```
  def all: (*::Hash[untyped, untyped] criteria) -> Selectable

  # Add the $and criterion.
  #
  # _@param_ `criteria` — Multiple key/value pair matches or Criteria objects that all must match to return results.
  #
  # _@return_ — The new selectable.
  #
  # Add the criterion.
  # ```ruby
  # selectable.and({ field: value }, { other: value })
  # ```
  def and: (*::Array[::Hash[untyped, untyped] | Criteria] criteria) -> Selectable

  # Add the range selection.
  #
  # _@param_ `criterion` — Multiple key/range pairs.
  #
  # _@return_ — The cloned selectable.
  #
  # Match on results within a single range.
  # ```ruby
  # selectable.between(field: 1..2)
  # ```
  #
  # Match on results between multiple ranges.
  # ```ruby
  # selectable.between(field: 1..2, other: 5..7)
  # ```
  def between: (::Hash[untyped, untyped] criterion) -> Selectable

  # Select with an $elemMatch.
  #
  # _@param_ `criterion` — The field/match pairs.
  #
  # _@return_ — The cloned selectable.
  #
  # Add criterion for a single match.
  # ```ruby
  # selectable.elem_match(field: { name: "value" })
  # ```
  #
  # Add criterion for multiple matches.
  # ```ruby
  # selectable.elem_match(
  #   field: { name: "value" },
  #   other: { name: "value"}
  # )
  # ```
  #
  # Execute an $elemMatch in a where query.
  # ```ruby
  # selectable.where(:field.elem_match => { name: "value" })
  # ```
  def elem_match: (::Hash[untyped, untyped] criterion) -> Selectable

  # Add the $exists selection.
  #
  # _@param_ `criterion` — The field/boolean existence checks.
  #
  # _@return_ — The cloned selectable.
  #
  # Add a single selection.
  # ```ruby
  # selectable.exists(field: true)
  # ```
  #
  # Add multiple selections.
  # ```ruby
  # selectable.exists(field: true, other: false)
  # ```
  #
  # Execute an $exists in a where query.
  # ```ruby
  # selectable.where(:field.exists => true)
  # ```
  def exists: (::Hash[untyped, untyped] criterion) -> Selectable

  # Add a $geoIntersects or $geoWithin selection. Symbol operators must
  # be used as shown in the examples to expand the criteria.
  #
  # _@param_ `criterion` — The criterion.
  #
  # _@return_ — The cloned selectable.
  #
  # Add a geo intersect criterion for a line.
  # ```ruby
  # query.geo_spatial(:location.intersects_line => [[ 1, 10 ], [ 2, 10 ]])
  # ```
  #
  # Add a geo intersect criterion for a point.
  # ```ruby
  # query.geo_spatial(:location.intersects_point => [[ 1, 10 ]])
  # ```
  #
  # Add a geo intersect criterion for a polygon.
  # ```ruby
  # query.geo_spatial(:location.intersects_polygon => [[ 1, 10 ], [ 2, 10 ], [ 1, 10 ]])
  # ```
  #
  # Add a geo within criterion for a polygon.
  # ```ruby
  # query.geo_spatial(:location.within_polygon => [[ 1, 10 ], [ 2, 10 ], [ 1, 10 ]])
  # ```
  #
  # Add a geo within criterion for a box.
  # ```ruby
  # query.geo_spatial(:location.within_box => [[ 1, 10 ], [ 2, 10 ])
  # ```
  #
  # _@note_ — The only valid geometry shapes for a $geoIntersects are:
  # :intersects_line, :intersects_point, and :intersects_polygon.
  #
  # _@note_ — The only valid options for a $geoWithin query are the geometry
  # shape :within_polygon and the operator :within_box.
  #
  # _@note_ — The :within_box operator for the $geoWithin query expects the
  # lower left (south west) coordinate pair as the first argument and
  # the upper right (north east) as the second argument.
  # Important: When latitude and longitude are passed, longitude is
  # expected as the first element of the coordinate pair.
  # Source: https://docs.mongodb.com/manual/reference/operator/query/box/
  def geo_spatial: (::Hash[untyped, untyped] criterion) -> Selectable

  # Alias for +geo_spatial+.
  #
  # _@deprecated_ — 
  def geo_spacial: (untyped criterion) -> untyped

  # Add the $gt criterion to the selector.
  #
  # _@param_ `criterion` — The field/value pairs to check.
  #
  # _@return_ — The cloned selectable.
  #
  # Add the $gt criterion.
  # ```ruby
  # selectable.gt(age: 60)
  # ```
  #
  # Execute an $gt in a where query.
  # ```ruby
  # selectable.where(:field.gt => 10)
  # ```
  def gt: (::Hash[untyped, untyped] criterion) -> Selectable

  # Add the $gte criterion to the selector.
  #
  # _@param_ `criterion` — The field/value pairs to check.
  #
  # _@return_ — The cloned selectable.
  #
  # Add the $gte criterion.
  # ```ruby
  # selectable.gte(age: 60)
  # ```
  #
  # Execute an $gte in a where query.
  # ```ruby
  # selectable.where(:field.gte => 10)
  # ```
  def gte: (::Hash[untyped, untyped] criterion) -> Selectable

  # Adds the $in selection to the selectable.
  #
  # _@param_ `condition` — The field/value criterion pairs.
  #
  # _@return_ — The cloned selectable.
  #
  # Add $in selection on an array.
  # ```ruby
  # selectable.in(age: [ 1, 2, 3 ])
  # ```
  #
  # Add $in selection on a range.
  # ```ruby
  # selectable.in(age: 18..24)
  # ```
  #
  # Execute an $in in a where query.
  # ```ruby
  # selectable.where(:field.in => [ 1, 2, 3 ])
  # ```
  def in: (::Hash[untyped, untyped] condition) -> Selectable

  # Add the $lt criterion to the selector.
  #
  # _@param_ `criterion` — The field/value pairs to check.
  #
  # _@return_ — The cloned selectable.
  #
  # Add the $lt criterion.
  # ```ruby
  # selectable.lt(age: 60)
  # ```
  #
  # Execute an $lt in a where query.
  # ```ruby
  # selectable.where(:field.lt => 10)
  # ```
  def lt: (::Hash[untyped, untyped] criterion) -> Selectable

  # Add the $lte criterion to the selector.
  #
  # _@param_ `criterion` — The field/value pairs to check.
  #
  # _@return_ — The cloned selectable.
  #
  # Add the $lte criterion.
  # ```ruby
  # selectable.lte(age: 60)
  # ```
  #
  # Execute an $lte in a where query.
  # ```ruby
  # selectable.where(:field.lte => 10)
  # ```
  def lte: (::Hash[untyped, untyped] criterion) -> Selectable

  # Add a $maxDistance selection to the selectable.
  #
  # _@param_ `criterion` — The field/distance pairs.
  #
  # _@return_ — The cloned selectable.
  #
  # Add the $maxDistance selection.
  # ```ruby
  # selectable.max_distance(location: 10)
  # ```
  def max_distance: (::Hash[untyped, untyped] criterion) -> Selectable

  # Adds $mod selection to the selectable.
  #
  # _@param_ `criterion` — The field/mod selections.
  #
  # _@return_ — The cloned selectable.
  #
  # Add the $mod selection.
  # ```ruby
  # selectable.mod(field: [ 10, 1 ])
  # ```
  #
  # Execute an $mod in a where query.
  # ```ruby
  # selectable.where(:field.mod => [ 10, 1 ])
  # ```
  def mod: (::Hash[untyped, untyped] criterion) -> Selectable

  # Adds $ne selection to the selectable.
  #
  # _@param_ `criterion` — The field/ne selections.
  #
  # _@return_ — The cloned selectable.
  #
  # Query for a value $ne to something.
  # ```ruby
  # selectable.ne(field: 10)
  # ```
  #
  # Execute an $ne in a where query.
  # ```ruby
  # selectable.where(:field.ne => "value")
  # ```
  def ne: (::Hash[untyped, untyped] criterion) -> Selectable

  # Adds a $near criterion to a geo selection.
  #
  # _@param_ `criterion` — The field/location pair.
  #
  # _@return_ — The cloned selectable.
  #
  # Add the $near selection.
  # ```ruby
  # selectable.near(location: [ 23.1, 12.1 ])
  # ```
  #
  # Execute an $near in a where query.
  # ```ruby
  # selectable.where(:field.near => [ 23.2, 12.1 ])
  # ```
  def near: (::Hash[untyped, untyped] criterion) -> Selectable

  # Adds a $nearSphere criterion to a geo selection.
  #
  # _@param_ `criterion` — The field/location pair.
  #
  # _@return_ — The cloned selectable.
  #
  # Add the $nearSphere selection.
  # ```ruby
  # selectable.near_sphere(location: [ 23.1, 12.1 ])
  # ```
  #
  # Execute an $nearSphere in a where query.
  # ```ruby
  # selectable.where(:field.near_sphere => [ 10.11, 3.22 ])
  # ```
  def near_sphere: (::Hash[untyped, untyped] criterion) -> Selectable

  # Adds the $nin selection to the selectable.
  #
  # _@param_ `condition` — The field/value criterion pairs.
  #
  # _@return_ — The cloned selectable.
  #
  # Add $nin selection on an array.
  # ```ruby
  # selectable.nin(age: [ 1, 2, 3 ])
  # ```
  #
  # Add $nin selection on a range.
  # ```ruby
  # selectable.nin(age: 18..24)
  # ```
  #
  # Execute an $nin in a where query.
  # ```ruby
  # selectable.where(:field.nin => [ 1, 2, 3 ])
  # ```
  def nin: (::Hash[untyped, untyped] condition) -> Selectable

  # Adds $nor selection to the selectable.
  #
  # _@param_ `criteria` — Multiple key/value pair matches or Criteria objects.
  #
  # _@return_ — The new selectable.
  #
  # Add the $nor selection.
  # ```ruby
  # selectable.nor(field: 1, field: 2)
  # ```
  def nor: (*::Array[::Hash[untyped, untyped] | Criteria] criteria) -> Selectable

  # Is the current selectable negating the next selection?
  #
  # _@return_ — If the selectable is negating.
  #
  # Is the selectable negating?
  # ```ruby
  # selectable.negating?
  # ```
  def negating?: () -> bool

  # Negate the arguments, or the next selection if no arguments are given.
  #
  # _@param_ `criteria` — Multiple key/value pair matches or Criteria objects to negate.
  #
  # _@return_ — The new selectable.
  #
  # Negate the next selection.
  # ```ruby
  # selectable.not.in(field: [ 1, 2 ])
  # ```
  #
  # Add the $not criterion.
  # ```ruby
  # selectable.not(name: /Bob/)
  # ```
  #
  # Execute a $not in a where query.
  # ```ruby
  # selectable.where(:field.not => /Bob/)
  # ```
  def not: (*::Array[::Hash[untyped, untyped] | Criteria] criteria) -> Selectable

  # Creates a disjunction using $or from the existing criteria in the
  # receiver and the provided arguments.
  #
  # This behavior (receiver becoming one of the disjunction operands)
  # matches ActiveRecord's +or+ behavior.
  #
  # Use +any_of+ to add a disjunction of the arguments as an additional
  # constraint to the criteria already existing in the receiver.
  #
  # Each argument can be a Hash, a Criteria object, an array of
  # Hash or Criteria objects, or a nested array. Nested arrays will be
  # flattened and can be of any depth. Passing arrays is deprecated.
  #
  # _@param_ `criteria` — Multiple key/value pair matches or Criteria objects, or arrays thereof. Passing arrays is deprecated.
  #
  # _@return_ — The new selectable.
  #
  # Add the $or selection where both fields must have the specified values.
  # ```ruby
  # selectable.or(field: 1, field: 2)
  # ```
  #
  # Add the $or selection where either value match is sufficient.
  # ```ruby
  # selectable.or({field: 1}, {field: 2})
  # ```
  #
  # Same as previous example but using the deprecated array wrap.
  # ```ruby
  # selectable.or([{field: 1}, {field: 2}])
  # ```
  #
  # Same as previous example, also deprecated.
  # ```ruby
  # selectable.or([{field: 1}], [{field: 2}])
  # ```
  def or: (*::Hash[untyped, untyped] | Criteria | ::Array[::Hash[untyped, untyped] | Criteria] criteria) -> Selectable

  # Adds a disjunction of the arguments as an additional constraint
  # to the criteria already existing in the receiver.
  #
  # Use +or+ to make the receiver one of the disjunction operands.
  #
  # Each argument can be a Hash, a Criteria object, an array of
  # Hash or Criteria objects, or a nested array. Nested arrays will be
  # flattened and can be of any depth. Passing arrays is deprecated.
  #
  # _@param_ `criteria` — Multiple key/value pair matches or Criteria objects, or arrays thereof. Passing arrays is deprecated.
  #
  # _@return_ — The new selectable.
  #
  # Add the $or selection where both fields must have the specified values.
  # ```ruby
  # selectable.any_of(field: 1, field: 2)
  # ```
  #
  # Add the $or selection where either value match is sufficient.
  # ```ruby
  # selectable.any_of({field: 1}, {field: 2})
  # ```
  #
  # Same as previous example but using the deprecated array wrap.
  # ```ruby
  # selectable.any_of([{field: 1}, {field: 2}])
  # ```
  #
  # Same as previous example, also deprecated.
  # ```ruby
  # selectable.any_of([{field: 1}], [{field: 2}])
  # ```
  def any_of: (*::Hash[untyped, untyped] | Criteria | ::Array[::Hash[untyped, untyped] | Criteria] criteria) -> Selectable

  # Add a $size selection for array fields.
  #
  # _@param_ `criterion` — The field/size pairs criterion.
  #
  # _@return_ — The cloned selectable.
  #
  # Add the $size selection.
  # ```ruby
  # selectable.with_size(field: 5)
  # ```
  #
  # Execute an $size in a where query.
  # ```ruby
  # selectable.where(:field.with_size => 10)
  # ```
  #
  # _@note_ — This method is named #with_size not to conflict with any existing
  # #size method on enumerables or symbols.
  def with_size: (::Hash[untyped, untyped] criterion) -> Selectable

  # Adds a $type selection to the selectable.
  #
  # _@param_ `criterion` — The field/type pairs.
  #
  # _@return_ — The cloned selectable.
  #
  # Add the $type selection.
  # ```ruby
  # selectable.with_type(field: 15)
  # ```
  #
  # Execute an $type in a where query.
  # ```ruby
  # selectable.where(:field.with_type => 15)
  # ```
  #
  # _@note_ — http://vurl.me/PGOU contains a list of all types.
  def with_type: (::Hash[untyped, untyped] criterion) -> Selectable

  # Construct a text search selector.
  #
  # _@param_ `terms` — A string of terms that MongoDB parses and uses to query the text index.
  #
  # _@param_ `opts` — Text search options. See MongoDB documentation for options.
  #
  # _@return_ — The cloned selectable.
  #
  # Construct a text search selector.
  # ```ruby
  # selectable.text_search("testing")
  # ```
  #
  # Construct a text search selector with options.
  # ```ruby
  # selectable.text_search("testing", :$language => "fr")
  # ```
  #
  # _@note_ — Per https://docs.mongodb.com/manual/reference/operator/query/text/
  # it is not currently possible to supply multiple text search
  # conditions in a query. Mongoid will build such a query but the
  # server will return an error when trying to execute it.
  def text_search: (String | Symbol terms, ?::Hash[untyped, untyped]? opts) -> Selectable

  # sord infer - argument name in single @param inferred as "*criteria"
  # This is the general entry point for most MongoDB queries. This either
  # creates a standard field: value selection, and expanded selection with
  # the use of hash methods, or a $where selection if a string is provided.
  #
  # _@param_ `criterion` — The javascript or standard selection.
  #
  # _@return_ — The cloned selectable.
  #
  # Add a standard selection.
  # ```ruby
  # selectable.where(name: "syd")
  # ```
  #
  # Add a javascript selection.
  # ```ruby
  # selectable.where("this.name == 'syd'")
  # ```
  def where: (*String | ::Hash[untyped, untyped] criteria) -> Selectable

  # Adds the specified expression to the query.
  #
  # Criterion must be a hash in one of the following forms:
  # - {field_name: value}
  # - {'field_name' => value}
  # - {key_instance: value}
  # - {'$operator' => operator_value_expression}
  #
  # Field name and operator may be given as either strings or symbols.
  #
  # _@param_ `criterion` — The field/value pairs.
  #
  # _@return_ — The cloned selectable.
  #
  # Create the selection.
  # ```ruby
  # selectable.expr_query(age: 50)
  # ```
  def expr_query: (::Hash[untyped, untyped] criterion) -> Selectable

  # Force the values of the criterion to be evolved.
  #
  # _@param_ `criterion` — The criterion.
  #
  # Force values to booleans.
  # ```ruby
  # selectable.force_typing(criterion) do |val|
  #   Boolean.evolve(val)
  # end
  # ```
  def typed_override: (::Hash[untyped, untyped] criterion, untyped operator) -> untyped

  # Create a javascript selection.
  #
  # _@param_ `criterion` — The javascript as a string.
  #
  # _@return_ — The cloned selectable
  #
  # Create the javascript selection.
  # ```ruby
  # selectable.js_query("this.age == 50")
  # ```
  def js_query: (String criterion) -> Selectable

  # Take the provided criterion and store it as a selection in the query
  # selector.
  #
  # _@param_ `criterion` — The selection to store.
  #
  # _@return_ — The cloned selectable.
  #
  # Store the selection.
  # ```ruby
  # selectable.selection({ field: "value" })
  # ```
  def selection: (?::Hash[untyped, untyped]? criterion) -> Selectable

  # Get the methods on the selectable that can be forwarded to from a model.
  #
  # _@return_ — The names of the forwardable methods.
  #
  # Get the forwardable methods.
  # ```ruby
  # Selectable.forwardables
  # ```
  def self.forwardables: () -> ::Array[Symbol]

  def self.key: (Symbol name, Symbol strategy, String operator, ?String? additional) { () -> untyped } -> untyped
end

Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Selectable::LINE_STRING: untyped

Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Selectable::POINT: untyped

Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Selectable::POLYGON: untyped

module Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions
end

# This module contains additional object behavior.
module Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::Set
end

module Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::Set::ClassMethods
  # Returns the value of attribute negating.
  #
  # Returns the value of attribute selector.
  #
  # Evolve the set, casting all its elements.
  #
  # _@param_ `object` — The object to evolve.
  #
  # _@return_ — The evolved set.
  #
  # Evolve the set.
  # ```ruby
  # Set.evolve(set)
  # ```
  def evolve: () -> untyped
            | () -> untyped
            | () -> untyped
            | () -> untyped
            | (::Set[untyped] | Object object) -> ::Array[untyped]
end

# This module contains additional date behavior.
module Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::Date
  # Evolve the date into a mongo friendly time, UTC midnight.
  #
  # _@return_ — The date as a UTC time at midnight.
  #
  # Evolve the date.
  # ```ruby
  # date.__evolve_date__
  # ```
  def __evolve_date__: () -> Time

  # Evolve the date into a time, which is always in the local timezone.
  #
  # _@return_ — The date as a local time.
  #
  # Evolve the date.
  # ```ruby
  # date.__evolve_time__
  # ```
  def __evolve_time__: () -> Time
end

module Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::Date::ClassMethods
  # Evolve the object to an date.
  #
  # _@param_ `object` — The object to evolve.
  #
  # _@return_ — The evolved date.
  #
  # Evolve dates.
  # ```ruby
  # Date.evolve(Date.new(1990, 1, 1))
  # ```
  #
  # Evolve string dates.
  # ```ruby
  # Date.evolve("1990-1-1")
  # ```
  #
  # Evolve date ranges.
  # ```ruby
  # Date.evolve(Date.new(1990, 1, 1)..Date.new(1990, 1, 4))
  # ```
  def evolve: (Object object) -> Time
end

# This module contains additional hash behavior.
module Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::Hash
  # Add an object to a hash using the merge strategies.
  #
  # _@param_ `object` — The other hash to add.
  #
  # _@return_ — The hash with object added.
  #
  # Add an object to a hash.
  # ```ruby
  # { field: value }.__add__({ field: other_value })
  # ```
  def __add__: (::Hash[untyped, untyped] object) -> ::Hash[untyped, untyped]

  # Merge this hash into the provided array.
  #
  # _@param_ `array` — The array to add to.
  #
  # _@return_ — The merged hash.
  #
  # Merge the hash into the array.
  # ```ruby
  # { field: value }.__add_from_array__([ 1, 2 ])
  # ```
  def __add_from_array__: (::Array[untyped] array) -> ::Hash[untyped, untyped]

  # Add an object to a hash using the merge strategies.
  #
  # _@param_ `object` — The other hash to intersect.
  #
  # _@return_ — The hash with object intersected.
  #
  # Add an object to a hash.
  # ```ruby
  # { field: value }.__intersect__({ field: other_value })
  # ```
  def __intersect__: (::Hash[untyped, untyped] object) -> ::Hash[untyped, untyped]

  # Merge this hash into the provided array.
  #
  # _@param_ `array` — The array to intersect to.
  #
  # _@return_ — The merged hash.
  #
  # Merge the hash into the array.
  # ```ruby
  # { field: value }.__intersect_from_array__([ 1, 2 ])
  # ```
  def __intersect_from_array__: (::Array[untyped] array) -> ::Hash[untyped, untyped]

  # Merge this hash into the provided object.
  #
  # _@param_ `object` — The object to intersect to.
  #
  # _@return_ — The merged hash.
  #
  # Merge the hash into the object.
  # ```ruby
  # { field: value }.__intersect_from_object__([ 1, 2 ])
  # ```
  def __intersect_from_object__: (Object object) -> ::Hash[untyped, untyped]

  # Add an object to a hash using the merge strategies.
  #
  # _@param_ `object` — The other hash to union.
  #
  # _@return_ — The hash with object unioned.
  #
  # Add an object to a hash.
  # ```ruby
  # { field: value }.__union__({ field: other_value })
  # ```
  def __union__: (::Hash[untyped, untyped] object) -> ::Hash[untyped, untyped]

  # Merge this hash into the provided object.
  #
  # _@param_ `object` — The object to union to.
  #
  # _@return_ — The merged hash.
  #
  # Merge the hash into the object.
  # ```ruby
  # { field: value }.__union_from_object__([ 1, 2 ])
  # ```
  def __union_from_object__: (Object object) -> ::Hash[untyped, untyped]

  # Make a deep copy of this hash.
  #
  # _@return_ — The copied hash.
  #
  # Make a deep copy of the hash.
  # ```ruby
  # { field: value }.__deep_copy__
  # ```
  def __deep_copy__: () -> ::Hash[untyped, untyped]

  # Get the hash as a sort option.
  #
  # _@return_ — The hash as sort option.
  #
  # Get the hash as a sort option.
  # ```ruby
  # { field: 1 }.__sort_option__
  # ```
  def __sort_option__: () -> ::Hash[untyped, untyped]

  # Get the object as expanded.
  #
  # _@return_ — The expanded hash.
  #
  # Get the object expanded.
  # ```ruby
  # obj.__expand_complex__
  # ```
  def __expand_complex__: () -> ::Hash[untyped, untyped]

  # Update all the values in the hash with the provided block.
  #
  # _@param_ `block` — The block to execute on each value.
  #
  # _@return_ — the hash.
  #
  # Update the values in place.
  # ```ruby
  # { field: "1" }.update_values(&:to_i)
  # ```
  def update_values: () { () -> untyped } -> ::Hash[untyped, untyped]

  # Apply the provided strategy for the hash with the given object.
  #
  # _@param_ `strategy` — The strategy to apply.
  #
  # _@param_ `object` — The object to merge.
  #
  # _@return_ — The merged hash.
  #
  # Apply the strategy.
  # ```ruby
  # { field: value }.apply_strategy(:__add__, 1)
  # ```
  def apply_strategy: (Symbol strategy, Object object) -> ::Hash[untyped, untyped]
end

# This module contains additional time behavior.
module Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::Time
  # Evolve the time as a date, UTC midnight.
  #
  # _@return_ — The date at midnight UTC.
  #
  # Evolve the time to a date query format.
  # ```ruby
  # time.__evolve_date__
  # ```
  def __evolve_date__: () -> Time

  # Evolve the time into a utc time.
  #
  # _@return_ — The time in UTC.
  #
  # Evolve the time.
  # ```ruby
  # time.__evolve_time__
  # ```
  def __evolve_time__: () -> Time
end

module Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::Time::ClassMethods
  # Evolve the object to an date.
  #
  # _@param_ `object` — The object to evolve.
  #
  # _@return_ — The evolved date time.
  #
  # Evolve dates.
  # ```ruby
  # ```
  #
  # Evolve string dates.
  # ```ruby
  # ```
  #
  # Evolve date ranges.
  # ```ruby
  # ```
  def evolve: (Object object) -> Time
end

# The array module adds custom behavior for Origin onto the Array class.
module Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::Array
  # Combine the two objects using the add strategy.
  #
  # _@param_ `object` — The object to add.
  #
  # _@return_ — The result of the add.
  #
  # Add the object to the array.
  # ```ruby
  # [ 1, 2, 3 ].__add__(4)
  # ```
  def __add__: (Object object) -> Object

  # Return the object as an array.
  #
  # _@return_ — self
  #
  # Get the array.
  # ```ruby
  # [ 1, 2 ].__array__
  # ```
  def __array__: () -> ::Array[untyped]

  # Makes a deep copy of the array, deep copying every element inside the
  # array.
  #
  # _@return_ — The deep copy of the array.
  #
  # Get a deep copy of the array.
  # ```ruby
  # [ 1, 2, 3 ].__deep_copy__
  # ```
  def __deep_copy__: () -> ::Array[untyped]

  # Evolve the array into an array of mongo friendly dates. (Times at
  # midnight).
  #
  # _@return_ — The array as times at midnight UTC.
  #
  # Evolve the array to dates.
  # ```ruby
  # [ Date.new(2010, 1, 1) ].__evolve_date__
  # ```
  def __evolve_date__: () -> ::Array[Time]

  # Get the object as expanded.
  #
  # _@return_ — The expanded array.
  #
  # Get the object expanded.
  # ```ruby
  # obj.__expand_complex__
  # ```
  def __expand_complex__: () -> ::Array[untyped]

  # Evolve the array to an array of times.
  #
  # _@return_ — The array as times.
  #
  # Evolve the array to times.
  # ```ruby
  # [ 1231231231 ].__evolve_time__
  # ```
  def __evolve_time__: () -> ::Array[Time]

  # Combine the two objects using an intersection strategy.
  #
  # _@param_ `object` — The object to intersect with.
  #
  # _@return_ — The result of the intersection.
  #
  # Interset with the object.
  # ```ruby
  # [ 1, 2 ].__intersect__(3)
  # ```
  def __intersect__: (Object object) -> Object

  # Gets the array as options in the proper format to pass as MongoDB sort
  # criteria.
  #
  # _@return_ — The array as sort criterion.
  #
  # Get the array as sorting options.
  # ```ruby
  # [ :field, 1 ].__sort_option__
  # ```
  def __sort_option__: () -> ::Hash[untyped, untyped]

  # Get the array as a sort pair.
  #
  # _@return_ — The field/direction pair.
  #
  # Get the array as field/direction pair.
  # ```ruby
  # [ field, 1 ].__sort_pair__
  # ```
  def __sort_pair__: () -> ::Hash[untyped, untyped]

  # Update all the values in the hash with the provided block.
  #
  # _@param_ `block` — The block to execute on each value.
  #
  # _@return_ — the array.
  #
  # Update the values in place.
  # ```ruby
  # [ 1, 2, 3 ].update_values(&:to_s)
  # ```
  def update_values: () { () -> untyped } -> ::Array[untyped]

  # Converts the array to a multi-dimensional array.
  #
  # _@return_ — The multi-dimensional array.
  #
  # Convert to multi-dimensional.
  # ```ruby
  # [ 1, 2, 3 ].multi
  # ```
  def multi: () -> ::Array[untyped]
end

module Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::Array::ClassMethods
  # Evolve the object when the serializer is defined as an array.
  #
  # _@param_ `object` — The object to evolve.
  #
  # _@return_ — The evolved object.
  #
  # Evolve the object.
  # ```ruby
  # Array.evolve(1)
  # ```
  def evolve: (Object object) -> Object
end

# This module contains additional range behavior.
module Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::Range
  # Get the range as an array.
  #
  # _@return_ — The range as an array.
  #
  # Get the range as an array.
  # ```ruby
  # 1...3.__array__
  # ```
  def __array__: () -> ::Array[untyped]

  # Convert the range to a min/max mongo friendly query for dates.
  #
  # _@return_ — The min/max range query with times at midnight.
  #
  # Evolve the range.
  # ```ruby
  # (11231312..213123131).__evolve_date__
  # ```
  def __evolve_date__: () -> ::Hash[untyped, untyped]

  # Convert the range to a min/max mongo friendly query for times.
  #
  # _@return_ — The min/max range query with times.
  #
  # Evolve the range.
  # ```ruby
  # (11231312..213123131).__evolve_date__
  # ```
  def __evolve_time__: () -> ::Hash[untyped, untyped]
end

module Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::Range::ClassMethods
  # Evolve the range. This will transform it into a $gte/$lte selection.
  #
  # _@param_ `object` — The range to evolve.
  #
  # _@return_ — The range as a gte/lte criteria.
  #
  # Evolve the range.
  # ```ruby
  # Range.evolve(1..3)
  # ```
  def evolve: (::Range[untyped] object) -> ::Hash[untyped, untyped]
end

# This module contains additional object behavior.
module Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::Object
  # Combine the two objects using the add strategy.
  #
  # _@param_ `object` — The object to add.
  #
  # _@return_ — The result of the add.
  #
  # Add the object to the array.
  # ```ruby
  # [ 1, 2, 3 ].__add__(4)
  # ```
  def __add__: (Object object) -> Object

  # Merge this object into the provided array.
  #
  # _@param_ `array` — The array to add to.
  #
  # _@return_ — The merged object.
  #
  # Merge the object into the array.
  # ```ruby
  # 4.__add_from_array__([ 1, 2 ])
  # ```
  def __add_from_array__: (::Array[untyped] array) -> ::Array[untyped]

  # Combine the two objects using the intersect strategy.
  #
  # _@param_ `object` — The object to intersect.
  #
  # _@return_ — The result of the intersect.
  #
  # Add the object to the array.
  # ```ruby
  # [ 1, 2, 3 ].__intersect__(4)
  # ```
  def __intersect__: (Object object) -> ::Array[untyped]

  # Merge this object into the provided array.
  #
  # _@param_ `array` — The array to intersect to.
  #
  # _@return_ — The merged object.
  #
  # Merge the object into the array.
  # ```ruby
  # 4.__intersect_from_array__([ 1, 2 ])
  # ```
  def __intersect_from_array__: (::Array[untyped] array) -> ::Array[untyped]

  # Merge this object into the provided array.
  #
  # _@param_ `object` — The value to intersect to.
  #
  # _@return_ — The merged object.
  #
  # Merge the object into the array.
  # ```ruby
  # 4.__intersect_from_object__([ 1, 2 ])
  # ```
  def __intersect_from_object__: (Object object) -> ::Array[untyped]

  # Combine the two objects using the union strategy.
  #
  # _@param_ `object` — The object to union.
  #
  # _@return_ — The result of the union.
  #
  # Add the object to the array.
  # ```ruby
  # [ 1, 2, 3 ].__union__(4)
  # ```
  def __union__: (Object object) -> ::Array[untyped]

  # Merge this object into the provided array.
  #
  # _@param_ `object` — The value to union to.
  #
  # _@return_ — The merged object.
  #
  # Merge the object into the array.
  # ```ruby
  # 4.__union_from_object__([ 1, 2 ])
  # ```
  def __union_from_object__: (Object object) -> ::Array[untyped]

  # Deep copy the object. This is for API compatibility, but needs to be
  # overridden.
  #
  # _@return_ — self.
  #
  # Deep copy the object.
  # ```ruby
  # 1.__deep_copy__
  # ```
  def __deep_copy__: () -> Object

  # Get the object as an array.
  #
  # _@return_ — The wrapped object.
  #
  # Get the object as an array.
  # ```ruby
  # 4.__array__
  # ```
  def __array__: () -> ::Array[untyped]

  # Get the object as expanded.
  #
  # _@return_ — self.
  #
  # Get the object expanded.
  # ```ruby
  # obj.__expand_complex__
  # ```
  def __expand_complex__: () -> Object

  # Is the object a regex.
  #
  # _@return_ — Always false.
  #
  # Is the object a regex?
  # ```ruby
  # obj.regexp?
  # ```
  def regexp?: () -> bool
end

module Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::Object::ClassMethods
  # Evolve the object.
  #
  # _@return_ — The provided object.
  #
  # Evolve an object.
  # ```ruby
  # Object.evolve("test")
  # ```
  #
  # _@note_ — This is here for API compatibility.
  def evolve: (untyped object) -> Object

  # Evolve the object.
  #
  # _@return_ — The evolved object.
  #
  # Evolve an object and yield.
  # ```ruby
  # Object.evolve("test") do |obj|
  #   obj.to_s
  # end
  # ```
  def __evolve__: (untyped object) -> Object
end

# This module contains additional regex behavior.
module Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::Regexp
  # Is the object a regexp?
  #
  # _@return_ — Always true.
  #
  # Is the object a regex?
  # ```ruby
  # /\A[123]/.regexp?
  # ```
  def regexp?: () -> bool
end

module Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::Regexp::ClassMethods
  # Evolve the object into a regex.
  #
  # _@param_ `object` — The object to evolve.
  #
  # _@return_ — The evolved regex.
  #
  # Evolve the object to a regex.
  # ```ruby
  # Regexp.evolve("\A[123]")
  # ```
  def evolve: (Regexp | String object) -> Regexp
end

module Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::Regexp::Raw_
  # Is the object a regexp?
  #
  # _@return_ — Always true.
  #
  # Is the object a regex?
  # ```ruby
  # bson_raw_regexp.regexp?
  # ```
  def regexp?: () -> bool
end

module Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::Regexp::Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::Regexp::Raw_::ClassMethods
  # sord warn - BSON::Regexp::Raw wasn't able to be resolved to a constant in this project
  # sord warn - BSON::Regexp::Raw wasn't able to be resolved to a constant in this project
  # Evolve the object into a raw bson regex.
  #
  # _@param_ `object` — The object to evolve.
  #
  # _@return_ — The evolved raw regex.
  #
  # Evolve the object to a regex.
  # ```ruby
  # BSON::Regexp::Raw.evolve("\\A[123]")
  # ```
  def evolve: (BSON::Regexp::Raw | String object) -> BSON::Regexp::Raw
end

# This module contains additional object behavior.
module Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::String
  # Evolve the string into a mongodb friendly date.
  #
  # _@return_ — The time at UTC midnight.
  #
  # Evolve the string.
  # ```ruby
  # "2012-1-1".__evolve_date__
  # ```
  def __evolve_date__: () -> Time

  # Evolve the string into a mongodb friendly time.
  #
  # _@return_ — The string as a time.
  #
  # Evolve the string.
  # ```ruby
  # "2012-1-1".__evolve_time__
  # ```
  def __evolve_time__: () -> Time

  # Get the string as a mongo expression, adding $ to the front.
  #
  # _@return_ — The string with $ at the front.
  #
  # Get the string as an expression.
  # ```ruby
  # "test".__mongo_expression__
  # ```
  def __mongo_expression__: () -> String

  # Get the string as a sort option.
  #
  # _@return_ — The string as a sort option hash.
  #
  # Get the string as a sort option.
  # ```ruby
  # "field ASC".__sort_option__
  # ```
  def __sort_option__: () -> ::Hash[untyped, untyped]

  # Get the string as a specification.
  #
  # _@param_ `value` — The value of the criteria.
  #
  # _@param_ `negating` — If the selection should be negated.
  #
  # _@return_ — The selection.
  #
  # Get the string as a criteria.
  # ```ruby
  # "field".__expr_part__(value)
  # ```
  def __expr_part__: (Object value, ?bool negating) -> ::Hash[untyped, untyped]

  # Get the string as a sort direction.
  #
  # _@return_ — The direction.
  #
  # Get the string as a sort direction.
  # ```ruby
  # "1".to_direction
  # ```
  def to_direction: () -> Integer
end

module Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::String::ClassMethods
  # Get the value as a expression.
  #
  # _@param_ `key` — The field key.
  #
  # _@param_ `value` — The value of the criteria.
  #
  # _@param_ `negating` — If the selection should be negated.
  #
  # _@return_ — The selection.
  #
  # Get the value as an expression.
  # ```ruby
  # String.__expr_part__("field", value)
  # ```
  def __expr_part__: (String | Symbol key, Object value, ?bool negating) -> ::Hash[untyped, untyped]

  # Evolves the string into a MongoDB friendly value - in this case
  # a string.
  #
  # _@param_ `object` — The object to convert.
  #
  # _@return_ — The value as a string.
  #
  # Evolve the string
  # ```ruby
  # String.evolve(1)
  # ```
  def evolve: (Object object) -> String
end

# This module contains additional symbol behavior.
module Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::Symbol
  # Get the symbol as a specification.
  #
  # _@param_ `value` — The value of the criteria.
  #
  # _@param_ `negating` — If the selection should be negated.
  #
  # _@return_ — The selection.
  #
  # Get the symbol as a criteria.
  # ```ruby
  # :field.__expr_part__(value)
  # ```
  def __expr_part__: (Object value, ?bool negating) -> ::Hash[untyped, untyped]

  # Get the symbol as a sort direction.
  #
  # _@return_ — The direction.
  #
  # Get the symbol as a sort direction.
  # ```ruby
  # "1".to_direction
  # ```
  def to_direction: () -> Integer
end

module Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::Symbol::ClassMethods
  def add_key: (Symbol name, Symbol strategy, String operator, ?String? additional) { () -> untyped } -> untyped

  # Evolves the symbol into a MongoDB friendly value - in this case
  # a symbol.
  #
  # _@param_ `object` — The object to convert.
  #
  # _@return_ — The value as a symbol.
  #
  # Evolve the symbol
  # ```ruby
  # Symbol.evolve("test")
  # ```
  def evolve: (Object object) -> Symbol
end

# This module contains extensions for boolean selection.
module Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::Boolean
end

module Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::Boolean::ClassMethods
  # Evolve the value into a boolean value stored in MongoDB. Will return
  # true for any of these values: true, t, yes, y, 1, 1.0.
  #
  # _@param_ `object` — The object to evolve.
  #
  # _@return_ — The boolean value.
  #
  # Evolve the value to a boolean.
  # ```ruby
  # Boolean.evolve(true)
  # ```
  def evolve: (Object object) -> bool
end

# This module contains additional numeric behavior.
module Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::Numeric
  # Evolve the numeric value into a mongo friendly date, aka UTC time at
  # midnight.
  #
  # _@return_ — The time representation at UTC midnight.
  #
  # Evolve to a date.
  # ```ruby
  # 125214512412.1123.__evolve_date__
  # ```
  def __evolve_date__: () -> Time

  # Evolve the numeric value into a mongo friendly time.
  #
  # _@return_ — The time representation.
  #
  # Evolve to a time.
  # ```ruby
  # 125214512412.1123.__evolve_time__
  # ```
  def __evolve_time__: () -> Time

  # Get the integer as a sort direction.
  #
  # _@return_ — self.
  #
  # Get the integer as a sort direction.
  # ```ruby
  # 1.to_direction
  # ```
  def to_direction: () -> Integer
end

module Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::Numeric::ClassMethods
  # Get the object as a numeric.
  #
  # _@param_ `object` — The object to convert.
  #
  # _@return_ — The converted number.
  #
  # Get the object as numeric.
  # ```ruby
  # Object.__numeric__("1.442")
  # ```
  def __numeric__: (Object object) -> Object

  # Evolve the object to an integer.
  #
  # _@param_ `object` — The object to evolve.
  #
  # _@return_ — The evolved object.
  #
  # Evolve to integers.
  # ```ruby
  # Integer.evolve("1")
  # ```
  def evolve: (Object object) -> Integer
end

# This module contains additional datetime behavior.
module Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::DateTime
  # Evolve the date time into a mongo friendly UTC time.
  #
  # _@return_ — The converted time in UTC.
  #
  # Evolve the date time.
  # ```ruby
  # date_time.__evolve_time__
  # ```
  def __evolve_time__: () -> Time
end

module Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::DateTime::ClassMethods
  # Evolve the object to an date.
  #
  # _@param_ `object` — The object to evolve.
  #
  # _@return_ — The evolved date time.
  #
  # Evolve dates.
  # ```ruby
  # ```
  #
  # Evolve string dates.
  # ```ruby
  # ```
  #
  # Evolve date ranges.
  # ```ruby
  # ```
  def evolve: (Object object) -> Time
end

# This module contains additional nil behavior.
module Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::NilClass
  # Add this object to nil.
  #
  # _@param_ `object` — The object to add.
  #
  # _@return_ — The provided object.
  #
  # Add the object to a nil value.
  # ```ruby
  # nil.__add__([ 1, 2, 3 ])
  # ```
  def __add__: (Object object) -> Object

  # Add this object to nil.
  #
  # _@param_ `object` — The object to expanded.
  #
  # _@return_ — The provided object.
  #
  # Add the object to a nil value.
  # ```ruby
  # nil.__expanded__([ 1, 2, 3 ])
  # ```
  def __expanded__: (Object object) -> Object

  # Evolve the nil into a date or time.
  #
  # _@return_ — nil.
  #
  # Evolve the nil.
  # ```ruby
  # nil.__evolve_time__
  # ```
  def __evolve_time__: () -> nil

  # Add this object to nil.
  #
  # _@param_ `object` — The object to intersect.
  #
  # _@return_ — The provided object.
  #
  # Add the object to a nil value.
  # ```ruby
  # nil.__intersect__([ 1, 2, 3 ])
  # ```
  def __intersect__: (Object object) -> Object

  # Add this object to nil.
  #
  # _@param_ `object` — The object to override.
  #
  # _@return_ — The provided object.
  #
  # Add the object to a nil value.
  # ```ruby
  # nil.__override__([ 1, 2, 3 ])
  # ```
  def __override__: (Object object) -> Object

  # Add this object to nil.
  #
  # _@param_ `object` — The object to union.
  #
  # _@return_ — The provided object.
  #
  # Add the object to a nil value.
  # ```ruby
  # nil.__union__([ 1, 2, 3 ])
  # ```
  def __union__: (Object object) -> Object
end

# The big decimal module adds custom behavior for Origin onto the
# BigDecimal class.
module Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::BigDecimal
end

module Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::BigDecimal::ClassMethods
  # Evolves the big decimal into a MongoDB friendly value - in this case
  # a string.
  #
  # _@param_ `object` — The object to convert.
  #
  # _@return_ — The big decimal as a string.
  #
  # Evolve the big decimal
  # ```ruby
  # BigDecimal.evolve(decimal)
  # ```
  def evolve: (BigDecimal object) -> String
end

# This module contains additional time with zone behavior.
module Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::TimeWithZone
  # Evolve the time as a date, UTC midnight.
  #
  # _@return_ — The date at midnight UTC.
  #
  # Evolve the time to a date query format.
  # ```ruby
  # time.__evolve_date__
  # ```
  def __evolve_date__: () -> Time

  # Evolve the time into a utc time.
  #
  # _@return_ — The time in UTC.
  #
  # Evolve the time.
  # ```ruby
  # time.__evolve_time__
  # ```
  def __evolve_time__: () -> Time
end

module Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::Mongoid::Criteria::Mongoid::Criteria::Queryable::Mongoid::Criteria::Mongoid::Criteria::Queryable::Extensions::TimeWithZone::ClassMethods
  # Evolve the object to an date.
  #
  # _@param_ `object` — The object to evolve.
  #
  # _@return_ — The evolved date time.
  #
  # Evolve dates.
  # ```ruby
  # ```
  #
  # Evolve string dates.
  # ```ruby
  # ```
  #
  # Evolve date ranges.
  # ```ruby
  # ```
  def evolve: (Object object) -> Time
end

# Module providing functionality for parsing (nested) inclusion definitions.
module Mongoid::Criteria::Includable
  # Eager loads all the provided associations. Will load all the documents
  # into the identity map whose ids match based on the extra query for the
  # ids.
  #
  # _@param_ `relations` — The names of the associations to eager load.
  #
  # _@return_ — The cloned criteria.
  #
  # Eager load the provided associations.
  # ```ruby
  # Person.includes(:posts, :game)
  # ```
  #
  # _@note_ — This will work for embedded associations that reference another
  # collection via belongs_to as well.
  #
  # _@note_ — Eager loading brings all the documents into memory, so there is a
  # sweet spot on the performance gains. Internal benchmarks show that
  # eager loading becomes slower around 100k documents, but this will
  # naturally depend on the specific application.
  def includes: (*::Array[Symbol] | ::Array[::Hash[untyped, untyped]] relations) -> Criteria

  # Get a list of criteria that are to be executed for eager loading.
  #
  # _@return_ — The inclusions.
  #
  # Get the eager loading inclusions.
  # ```ruby
  # Person.includes(:game).inclusions
  # ```
  def inclusions: () -> ::Array[Association]

  # Set the inclusions for the criteria.
  #
  # _@param_ `value` — The inclusions.
  #
  # _@return_ — The new inclusions.
  #
  # Set the inclusions.
  # ```ruby
  # criteria.inclusions = [ association ]
  # ```
  def inclusions=: (::Array[Association] value) -> ::Array[Association]

  # Add an inclusion definition to the list of inclusions for the criteria.
  #
  # _@param_ `_klass` — The class or string/symbol of the class name.
  #
  # _@param_ `association` — The association.
  #
  # Add an inclusion.
  # ```ruby
  # criteria.add_inclusion(Person, :posts)
  # ```
  def add_inclusion: (Class | String | Symbol _klass, Symbol association) -> untyped

  def extract_includes_list: (untyped _parent_class, *untyped relations_list) -> untyped
end

module Mongoid::Criteria::Modifiable
  # Build a document given the selector and return it.
  # Complex criteria, such as $in and $or operations will get ignored.
  #
  # _@return_ — A non-persisted document.
  #
  # build the document.
  # ```ruby
  # Person.where(:title => "Sir").build
  # ```
  #
  # Build with selectors getting ignored.
  # ```ruby
  # Person.where(:age.gt => 5).build
  # ```
  def build: (?untyped attrs) { () -> untyped } -> Document

  # Create a document in the database given the selector and return it.
  # Complex criteria, such as $in and $or operations will get ignored.
  #
  # _@return_ — A newly created document.
  #
  # Create the document.
  # ```ruby
  # Person.where(:title => "Sir").create
  # ```
  #
  # Create with selectors getting ignored.
  # ```ruby
  # Person.where(:age.gt => 5).create
  # ```
  def create: (?untyped attrs) { () -> untyped } -> Document

  # Create a document in the database given the selector and return it.
  # Complex criteria, such as $in and $or operations will get ignored.
  # If validation fails, an error will be raised.
  #
  # _@return_ — A newly created document.
  #
  # Create the document.
  # ```ruby
  # Person.where(:title => "Sir").create
  # ```
  #
  # Create with selectors getting ignored.
  # ```ruby
  # Person.where(:age.gt => 5).create
  # ```
  def create!: (?untyped attrs) { () -> untyped } -> Document

  # Define attributes with which new documents will be created.
  #
  # Note that if `find_or_create_by` is called after this in a method chain, the attributes in
  # the query will override those from this method.
  #
  # _@return_ — A criteria.
  #
  # Define attributes to be used when a new document is created.
  # ```ruby
  # Person.create_with(job: 'Engineer').find_or_create_by(employer: 'MongoDB')
  # ```
  def create_with: (?untyped attrs) -> Mongoid::Criteria

  # Find the first +Document+ given the conditions, or creates a new document
  # with the conditions that were supplied.
  #
  # _@param_ `attrs` — The attributes to check.
  #
  # _@return_ — A matching or newly created document.
  #
  # Find or create the document.
  # ```ruby
  # Person.find_or_create_by(:attribute => "value")
  # ```
  def find_or_create_by: (?::Hash[untyped, untyped] attrs) { () -> untyped } -> Document

  # Find the first +Document+ given the conditions, or creates a new document
  # with the conditions that were supplied. If validation fails an
  # exception will be raised.
  #
  # _@param_ `attrs` — The attributes to check.
  #
  # _@return_ — A matching or newly created document.
  #
  # Find or create the document.
  # ```ruby
  # Person.find_or_create_by!(:attribute => "value")
  # ```
  def find_or_create_by!: (?::Hash[untyped, untyped] attrs) { () -> untyped } -> Document

  # Find the first +Document+ given the conditions, or initializes a new document
  # with the conditions that were supplied.
  #
  # _@param_ `attrs` — The attributes to check.
  #
  # _@return_ — A matching or newly initialized document.
  #
  # Find or initialize the document.
  # ```ruby
  # Person.find_or_initialize_by(:attribute => "value")
  # ```
  def find_or_initialize_by: (?::Hash[untyped, untyped] attrs) { () -> untyped } -> Document

  # Find the first +Document+, or creates a new document
  # with the conditions that were supplied plus attributes.
  #
  # _@param_ `attrs` — The additional attributes to add.
  #
  # _@return_ — A matching or newly created document.
  #
  # First or create the document.
  # ```ruby
  # Person.where(name: "Jon").first_or_create(attribute: "value")
  # ```
  def first_or_create: (?::Hash[untyped, untyped]? attrs) { () -> untyped } -> Document

  # Find the first +Document+, or creates a new document
  # with the conditions that were supplied plus attributes and will
  # raise an error if validation fails.
  #
  # _@param_ `attrs` — The additional attributes to add.
  #
  # _@return_ — A matching or newly created document.
  #
  # First or create the document.
  # ```ruby
  # Person.where(name: "Jon").first_or_create!(attribute: "value")
  # ```
  def first_or_create!: (?::Hash[untyped, untyped]? attrs) { () -> untyped } -> Document

  # Find the first +Document+, or initializes a new document
  # with the conditions that were supplied plus attributes.
  #
  # _@param_ `attrs` — The additional attributes to add.
  #
  # _@return_ — A matching or newly initialized document.
  #
  # First or initialize the document.
  # ```ruby
  # Person.where(name: "Jon").first_or_initialize(attribute: "value")
  # ```
  def first_or_initialize: (?::Hash[untyped, untyped]? attrs) { () -> untyped } -> Document

  # Create a document given the provided method and attributes from the
  # existing selector.
  #
  # _@param_ `method` — Either :new or :create.
  #
  # _@param_ `attrs` — Additional attributes to use.
  #
  # _@return_ — The new or saved document.
  #
  # Create a new document.
  # ```ruby
  # criteria.create_document(:new, {})
  # ```
  def create_document: (Symbol method, ?::Hash[untyped, untyped]? attrs) { () -> untyped } -> Document

  # Find the first object or create/initialize it.
  #
  # _@param_ `method` — The method to invoke.
  #
  # _@param_ `attrs` — The attributes to query or set.
  #
  # _@return_ — The first or new document.
  #
  # Find or perform an action.
  # ```ruby
  # Person.find_or(:create, :name => "Dev")
  # ```
  def find_or: (Symbol method, ?::Hash[untyped, untyped] attrs) { () -> untyped } -> Document

  # Find the first document or create/initialize it.
  #
  # _@param_ `method` — The method to invoke.
  #
  # _@param_ `attrs` — The attributes to query or set.
  #
  # _@return_ — The first or new document.
  #
  # First or perform an action.
  # ```ruby
  # Person.first_or(:create, :name => "Dev")
  # ```
  def first_or: (Symbol method, ?::Hash[untyped, untyped] attrs) { () -> untyped } -> Document

  def invalid_key?: (untyped hash, untyped key) -> bool

  def invalid_embedded_doc?: (untyped value) -> bool
end

module Mongoid::Criteria::Permission
  # Ensure that the criteria are permitted.
  #
  # _@param_ `criteria`
  #
  # _@return_ — if should permit
  #
  # Ignoring ActionController::Parameters
  # ```ruby
  # should_permit?({_id: ActionController::Parameters.new("$size" => 1)})
  # ```
  def should_permit?: () -> untyped
                    | () -> untyped
                    | (Object criteria) -> bool
end

module Mongoid::Criteria::Marshalable
  # Provides the data needed to Marshal.dump a criteria.
  #
  # _@return_ — The dumped data.
  #
  # Dump the criteria.
  # ```ruby
  # Marshal.dump(criteria)
  # ```
  def marshal_dump: () -> ::Array[Object]

  # Resets the criteria object after a Marshal.load
  #
  # _@param_ `data` — The raw data.
  #
  # Load the criteria.
  # ```ruby
  # Marshal.load(criteria)
  # ```
  def marshal_load: (::Array[untyped] data) -> untyped

  def dump_hash: (untyped name) -> untyped

  def load_hash: (untyped hash_class, untyped raw) -> untyped
end

# This is the base module for all domain objects that need to be persisted to
# the database as documents.
module Mongoid::Document
  include Mongoid::Composable

  include Mongoid::Touchable::InstanceMethods

  extend ActiveSupport::Concern

  # Freezes the internal attributes of the document.
  #
  # _@return_ — The document.
  #
  # Freeze the document
  # ```ruby
  # document.freeze
  # ```
  def freeze: () -> Document

  # Checks if the document is frozen
  #
  # _@return_ — True if frozen, else false.
  #
  # Check if frozen
  # ```ruby
  # document.frozen?
  # ```
  def frozen?: () -> bool

  # Delegates to identity in order to allow two records of the same identity
  # to work with something like:
  #
  #   [ Person.find(1), Person.find(2), Person.find(3) ] &
  #   [ Person.find(1), Person.find(4) ] # => [ Person.find(1) ]
  #
  # _@return_ — The hash of the document's identity.
  #
  # Get the hash.
  # ```ruby
  # document.hash
  # ```
  def hash: () -> Integer

  # A Document's is identified absolutely by its class and database id:
  #
  # Person.first.identity #=> [Person, BSON::ObjectId('4f775130a04745933a000003')]
  #
  # _@return_ — An array containing [document.class, document._id]
  #
  # Get the identity
  # ```ruby
  # document.identity
  # ```
  def identity: () -> ::Array[untyped]

  # Instantiate a new +Document+, setting the Document's attributes if
  # given. If no attributes are provided, they will be initialized with
  # an empty +Hash+.
  #
  # If a primary key is defined, the document's id will be set to that key,
  # otherwise it will be set to a fresh +BSON::ObjectId+ string.
  #
  # _@param_ `attrs` — The attributes to set up the document with.
  #
  # _@return_ — A new document.
  #
  # Create a new document.
  # ```ruby
  # Person.new(:title => "Sir")
  # ```
  def initialize: (?::Hash[untyped, untyped]? attrs) -> void

  # Return the model name of the document.
  #
  # _@return_ — The model name.
  #
  # Return the model name.
  # ```ruby
  # document.model_name
  # ```
  def model_name: () -> String

  # Return the key value for the document.
  #
  # _@return_ — The id of the document or nil if new.
  #
  # Return the key.
  # ```ruby
  # document.to_key
  # ```
  def to_key: () -> String

  # Return an array with this +Document+ only in it.
  #
  # _@return_ — An array with the document as its only item.
  #
  # Return the document in an array.
  # ```ruby
  # document.to_a
  # ```
  def to_a: () -> ::Array[Document]

  # Return a hash of the entire document hierarchy from this document and
  # below. Used when the attributes are needed for everything and not just
  # the current document.
  #
  # _@return_ — A hash of all attributes in the hierarchy.
  #
  # Get the full hierarchy.
  # ```ruby
  # person.as_document
  # ```
  def as_document: () -> ::Hash[untyped, untyped]

  # Calls #as_json on the document with additional, Mongoid-specific options.
  #
  # _@param_ `options` — The options.
  #
  # _@return_ — The document as json.
  #
  # Get the document as json.
  # ```ruby
  # document.as_json(compact: true)
  # ```
  #
  # _@note_ — Rails 6 changes return value of as_json for non-primitive types
  # such as BSON::ObjectId. In Rails <= 5, as_json returned these as
  # instances of the class. In Rails 6, these are returned serialized to
  # primitive types (e.g. {"$oid"=>"5bcfc40bde340b37feda98e9"}).
  # See https://github.com/rails/rails/commit/2e5cb980a448e7f4ab00df6e9ad4c1cc456616aa
  # for more information.
  def as_json: (?::Hash[untyped, untyped]? options) -> ::Hash[untyped, untyped]

  # Returns an instance of the specified class with the attributes,
  # errors, and embedded documents of the current document.
  #
  # _@param_ `klass` — The class to become.
  #
  # _@return_ — An instance of the specified class.
  #
  # Return a subclass document as a superclass instance.
  # ```ruby
  # manager.becomes(Person)
  # ```
  def becomes: (Class klass) -> Document

  # Implement this for calls to flatten on array.
  #
  # _@return_ — Always nil.
  #
  # Get the document as an array.
  # ```ruby
  # document.to_ary
  # ```
  def to_ary: () -> nil

  # Returns the logger
  #
  # _@return_ — The configured logger or a default Logger instance.
  def logger: () -> Logger

  # Get the name of the model used in caching.
  #
  # _@return_ — The model key.
  #
  # Get the model key.
  # ```ruby
  # model.model_key
  # ```
  def model_key: () -> String

  def as_attributes: () -> untyped

  # Touch the document, in effect updating its updated_at timestamp and
  # optionally the provided field to the current time. If any belongs_to
  # associations exist with a touch option, they will be updated as well.
  #
  # _@param_ `field` — The name of an additional field to update.
  #
  # _@return_ — false if record is new_record otherwise true.
  #
  # Update the updated_at timestamp.
  # ```ruby
  # document.touch
  # ```
  #
  # Update the updated_at and provided timestamps.
  # ```ruby
  # document.touch(:audited)
  # ```
  #
  # _@note_ — This will not autobuild associations if those options are set.
  def touch: (?Symbol? field) -> bool

  # Default comparison is via the string version of the id.
  #
  # _@param_ `other` — The document to compare with.
  #
  # _@return_ — -1, 0, 1.
  #
  # Compare two documents.
  # ```ruby
  # person <=> other_person
  # ```
  def <=>: (Document other) -> Integer

  # Performs equality checking on the document ids. For more robust
  # equality checking please override this method.
  #
  # _@param_ `other` — The other object to compare with.
  #
  # _@return_ — True if the ids are equal, false if not.
  #
  # Compare for equality.
  # ```ruby
  # document == other
  # ```
  def ==: (Document | Object other) -> bool

  # Performs class equality checking.
  #
  # _@param_ `other` — The other object to compare with.
  #
  # _@return_ — True if the classes are equal, false if not.
  #
  # Compare the classes.
  # ```ruby
  # document === other
  # ```
  def ===: (Document | Object other) -> bool

  # Delegates to ==. Used when needing checks in hashes.
  #
  # _@param_ `other` — The object to check against.
  #
  # _@return_ — True if equal, false if not.
  #
  # Perform equality checking.
  # ```ruby
  # document.eql?(other)
  # ```
  def eql?: (Document | Object other) -> bool

  # Clone or dup the current +Document+. This will return all attributes with
  # the exception of the document's id, and will reset all the
  # instance variables.
  #
  # This clone also includes embedded documents.
  #
  # _@return_ — The new document.
  #
  # Clone the document.
  # ```ruby
  # document.clone
  # ```
  def clone: () -> Document

  # Clone the document attributes
  #
  # clone document
  # ```ruby
  # model.clone_document
  # ```
  def clone_document: () -> untyped

  # When cloning, if the document has localized fields we need to ensure they
  # are properly processed in the clone.
  #
  # _@param_ `attrs` — The attributes.
  #
  # Process localized attributes.
  # ```ruby
  # model.process_localized_attributes(attributes)
  # ```
  def process_localized_attributes: (untyped klass, ::Hash[untyped, untyped] attrs) -> untyped

  # Is the provided type of callback executable by this document?
  #
  # _@param_ `kind` — The type of callback.
  #
  # _@return_ — If the callback can be executed.
  #
  # Is the callback executable?
  # ```ruby
  # document.callback_executable?(:save)
  # ```
  def callback_executable?: (Symbol kind) -> bool

  # Is the document currently in a state that could potentially require
  # callbacks to be executed?
  #
  # _@param_ `kind` — The callback kind.
  #
  # _@return_ — If the document is in a callback state.
  #
  # Is the document in a callback state?
  # ```ruby
  # document.in_callback_state?(:update)
  # ```
  def in_callback_state?: (Symbol kind) -> bool

  # Run only the after callbacks for the specific event.
  #
  # _@param_ `kinds` — The events that are occurring.
  #
  # _@return_ — The result of the chain executing.
  #
  # Run only the after save callbacks.
  # ```ruby
  # model.run_after_callbacks(:save)
  # ```
  #
  # _@note_ — ActiveSupport does not allow this type of behavior by default, so
  # Mongoid has to get around it and implement itself.
  def run_after_callbacks: (*::Array[Symbol] kinds) -> Object

  # Run only the before callbacks for the specific event.
  #
  # _@param_ `kinds` — The events that are occurring.
  #
  # _@return_ — The result of the chain executing.
  #
  # Run only the before save callbacks.
  # ```ruby
  # model.run_before_callbacks(:save, :create)
  # ```
  #
  # _@note_ — ActiveSupport does not allow this type of behavior by default, so
  # Mongoid has to get around it and implement itself.
  def run_before_callbacks: (*::Array[Symbol] kinds) -> Object

  # Run the callbacks for the document. This overrides active support's
  # functionality to cascade callbacks to embedded documents that have been
  # flagged as such.
  #
  # _@param_ `kind` — The type of callback to execute.
  #
  # _@param_ `args` — Any options.
  #
  # _@return_ — The document
  #
  # Run the callbacks.
  # ```ruby
  # run_callbacks :save do
  #   save!
  # end
  # ```
  def run_callbacks: (Symbol kind, *::Array[untyped] args) { () -> untyped } -> Document

  # We need to hook into this for autosave, since we don't want it firing if
  # the before callbacks were halted.
  #
  # _@return_ — If a before callback was halted.
  #
  # Was a before callback halted?
  # ```ruby
  # document.before_callback_halted?
  # ```
  def before_callback_halted?: () -> bool

  # Get all the child embedded documents that are flagged as cascadable.
  #
  # _@param_ `kind` — The type of callback.
  #
  # _@return_ — The children.
  #
  # Get all the cascading children.
  # ```ruby
  # document.cascadable_children(:update)
  # ```
  def cascadable_children: (Symbol kind, ?untyped children) -> ::Array[Document]

  # Determine if the child should fire the callback.
  #
  # _@param_ `kind` — The type of callback.
  #
  # _@param_ `child` — The child document.
  #
  # _@return_ — If the child should fire the callback.
  #
  # Should the child fire the callback?
  # ```ruby
  # document.cascadable_child?(:update, doc)
  # ```
  def cascadable_child?: (Symbol kind, Document child, untyped association) -> bool

  # Get the name of the callback that the child should fire. This changes
  # depending on whether or not the child is new. A persisted parent with a
  # new child would fire :update from the parent, but needs to fire :create
  # on the child.
  #
  # _@param_ `kind` — The type of callback.
  #
  # _@param_ `child` — The child document
  #
  # _@return_ — The name of the callback.
  #
  # Get the callback type.
  # ```ruby
  # document.child_callback_type(:update, doc)
  # ```
  def child_callback_type: (Symbol kind, Document child) -> Symbol

  # We need to hook into this for autosave, since we don't want it firing if
  # the before callbacks were halted.
  #
  # _@param_ `filter` — The callback that halted.
  #
  # _@param_ `name` — The name of the callback that was halted (requires Rails 6.1+)
  #
  # Hook into the halt.
  # ```ruby
  # document.halted_callback_hook(filter)
  # ```
  def halted_callback_hook: (Symbol filter, ?Symbol? name) -> untyped

  # Run only the callbacks for the target location (before, after, around)
  # and kind (save, update, create).
  #
  # _@param_ `place` — The time to run, :before, :after, :around.
  #
  # _@param_ `kind` — The type of callback, :save, :create, :update.
  #
  # _@return_ — The result of the chain execution.
  #
  # Run the targeted callbacks.
  # ```ruby
  # model.run_targeted_callbacks(:before, :save)
  # ```
  def run_targeted_callbacks: (Symbol place, Symbol kind) -> Object

  # Begin the associated validation.
  #
  # Begin validation.
  # ```ruby
  # document.begin_validate
  # ```
  def begin_validate: () -> untyped

  # Exit the associated validation.
  #
  # Exit validation.
  # ```ruby
  # document.exit_validate
  # ```
  def exit_validate: () -> untyped

  # Given the provided options, are we performing validations?
  #
  # _@param_ `options` — The options to check.
  #
  # _@return_ — If we are validating.
  #
  # Are we performing validations?
  # ```ruby
  # document.performing_validations?(validate: true)
  # ```
  def performing_validations?: (?::Hash[untyped, untyped] options) -> bool

  # Overrides the default ActiveModel behavior since we need to handle
  # validations of associations slightly different than just calling the
  # getter.
  #
  # _@param_ `attr` — The name of the field or association.
  #
  # _@return_ — The value of the field or the association.
  #
  # Read the value.
  # ```ruby
  # person.read_attribute_for_validation(:addresses)
  # ```
  def read_attribute_for_validation: (Symbol attr) -> Object

  # Determine if the document is valid.
  #
  # _@param_ `context` — The optional validation context.
  #
  # _@return_ — True if valid, false if not.
  #
  # Is the document valid?
  # ```ruby
  # person.valid?
  # ```
  #
  # Is the document valid in a context?
  # ```ruby
  # person.valid?(:create)
  # ```
  def valid?: (?Symbol? context) -> bool

  # Used to prevent infinite loops in associated validations.
  #
  # _@return_ — Has the document already been validated?
  #
  # Is the document validated?
  # ```ruby
  # document.validated?
  # ```
  def validated?: () -> bool

  # Are we currently performing a validation that has a query?
  #
  # _@return_ — If we are validating with a query.
  #
  # Are we validating with a query?
  # ```ruby
  # document.validating_with_query?
  # ```
  def validating_with_query?: () -> bool

  def _parent: () -> untyped

  def _parent=: (untyped p) -> untyped

  # Get all child +Documents+ to this +Document+, going n levels deep if
  # necessary. This is used when calling update persistence operations from
  # the root document, where changes in the entire tree need to be
  # determined. Note that persistence from the embedded documents will
  # always be preferred, since they are optimized calls... This operation
  # can get expensive in domains with large hierarchies.
  #
  # _@return_ — All child documents in the hierarchy.
  #
  # Get all the document's children.
  # ```ruby
  # person._children
  # ```
  def _children: () -> ::Array[Document]

  # Collect all the children of this document.
  #
  # _@return_ — The children.
  #
  # Collect all the children.
  # ```ruby
  # document.collect_children
  # ```
  def collect_children: () -> ::Array[Document]

  # Marks all children as being persisted.
  #
  # _@return_ — The flagged children.
  #
  # Flag all the children.
  # ```ruby
  # document.flag_children_persisted
  # ```
  def flag_children_persisted: () -> ::Array[Document]

  # Determines if the document is a subclass of another document.
  #
  # _@return_ — True if hereditary, false if not.
  #
  # Check if the document is a subclass
  # ```ruby
  # Square.new.hereditary?
  # ```
  def hereditary?: () -> bool

  # Sets up a child/parent association. This is used for newly created
  # objects so they can be properly added to the graph.
  #
  # _@param_ `document` — The parent document.
  #
  # _@return_ — The parent document.
  #
  # Set the parent document.
  # ```ruby
  # document.parentize(parent)
  # ```
  def parentize: (Document document) -> Document

  # Remove a child document from this parent. If an embeds one then set to
  # nil, otherwise remove from the embeds many.
  #
  # This is called from the +RemoveEmbedded+ persistence command.
  #
  # _@param_ `child` — The child (embedded) document to remove.
  #
  # Remove the child.
  # ```ruby
  # document.remove_child(child)
  # ```
  def remove_child: (Document child) -> untyped

  # After children are persisted we can call this to move all their changes
  # and flag them as persisted in one call.
  #
  # _@return_ — The children.
  #
  # Reset the children.
  # ```ruby
  # document.reset_persisted_children
  # ```
  def reset_persisted_children: () -> ::Array[Document]

  # Resets the memoized children on the object. Called internally when an
  # embedded array changes size.
  #
  # _@return_ — nil.
  #
  # Reset the memoized children.
  # ```ruby
  # document._reset_memoized_children!
  # ```
  def _reset_memoized_children!: () -> nil

  # Return the root document in the object graph. If the current document
  # is the root object in the graph it will return self.
  #
  # _@return_ — The root document in the hierarchy.
  #
  # Get the root document in the hierarchy.
  # ```ruby
  # document._root
  # ```
  def _root: () -> Document

  # Is this document the root document of the hierarchy?
  #
  # _@return_ — If the document is the root.
  #
  # Is the document the root?
  # ```ruby
  # document._root?
  # ```
  def _root?: () -> bool

  # Begin the assignment of attributes. While in this block embedded
  # documents will not autosave themselves in order to allow the document to
  # be in a valid state.
  #
  # _@return_ — The yielded value.
  #
  # Execute the assignment.
  # ```ruby
  # _assigning do
  #   person.attributes = { :addresses => [ address ] }
  # end
  # ```
  def _assigning: () -> Object

  # Is the current thread in assigning mode?
  #
  # _@return_ — If the thread is assigning.
  #
  # Is the current thread in assigning mode?
  # ```ruby
  # proxy._assigning?
  # ```
  def _assigning?: () -> bool

  # Execute a block in binding mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in binding mode.
  # ```ruby
  # binding do
  #   relation.push(doc)
  # end
  # ```
  def _binding: () -> Object

  # Is the current thread in binding mode?
  #
  # _@return_ — If the thread is binding.
  #
  # Is the current thread in binding mode?
  # ```ruby
  # proxy.binding?
  # ```
  def _binding?: () -> bool

  # Execute a block in building mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in building mode.
  # ```ruby
  # _building do
  #   relation.push(doc)
  # end
  # ```
  def _building: () -> Object

  # Is the current thread in building mode?
  #
  # _@return_ — If the thread is building.
  #
  # Is the current thread in building mode?
  # ```ruby
  # proxy._building?
  # ```
  def _building?: () -> bool

  # Is the current thread in creating mode?
  #
  # _@return_ — If the thread is creating.
  #
  # Is the current thread in creating mode?
  # ```ruby
  # proxy.creating?
  # ```
  def _creating?: () -> bool

  # Execute a block in loading mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in loading mode.
  # ```ruby
  # _loading do
  #   relation.push(doc)
  # end
  # ```
  def _loading: () -> Object

  # Is the current thread in loading mode?
  #
  # _@return_ — If the thread is loading.
  #
  # Is the current thread in loading mode?
  # ```ruby
  # proxy._loading?
  # ```
  def _loading?: () -> bool

  # Print out the cache key. This will append different values on the
  # plural model name.
  #
  # If new_record?     - will append /new
  # If not             - will append /id-updated_at.to_s(cache_timestamp_format)
  # Without updated_at - will append /id
  #
  # This is usually called insode a cache() block
  #
  # _@return_ — the string with or without updated_at
  #
  # Returns the cache key
  # ```ruby
  # document.cache_key
  # ```
  def cache_key: () -> String

  # Returns true if the +Document+ has not been persisted to the database,
  # false if it has. This is determined by the variable @new_record
  # and NOT if the object has an id.
  #
  # _@return_ — True if new, false if not.
  #
  # Is the document new?
  # ```ruby
  # person.new_record?
  # ```
  def new_record?: () -> bool

  # Checks if the document has been saved to the database. Returns false
  # if the document has been destroyed.
  #
  # _@return_ — True if persisted, false if not.
  #
  # Is the document persisted?
  # ```ruby
  # person.persisted?
  # ```
  def persisted?: () -> bool

  # Returns whether or not the document has been flagged for deletion, but
  # not destroyed yet. Used for atomic pulls of child documents.
  #
  # _@return_ — If the document is flagged.
  #
  # Is the document flagged?
  # ```ruby
  # document.flagged_for_destroy?
  # ```
  def flagged_for_destroy?: () -> bool

  # Returns true if the +Document+ has been succesfully destroyed, and false
  # if it hasn't. This is determined by the variable @destroyed and NOT
  # by checking the database.
  #
  # _@return_ — True if destroyed, false if not.
  #
  # Is the document destroyed?
  # ```ruby
  # person.destroyed?
  # ```
  def destroyed?: () -> bool

  # Determine if the document can be pushed.
  #
  # _@return_ — Is the document new and embedded?
  #
  # Is this pushable?
  # ```ruby
  # person.pushable?
  # ```
  def pushable?: () -> bool

  # Is the document readonly?
  #
  # _@return_ — If the document is readonly.
  #
  # Is the document readonly?
  # ```ruby
  # document.readonly?
  # ```
  def readonly?: () -> bool

  # Determine if the document can be set.
  #
  # _@return_ — Is this document a new embeds one?
  #
  # Is this settable?
  # ```ruby
  # person.settable?
  # ```
  def settable?: () -> bool

  # Is the document updateable?
  #
  # _@return_ — If the document is changed and persisted.
  #
  # Is the document updateable?
  # ```ruby
  # person.updateable?
  # ```
  def updateable?: () -> bool

  def reset_readonly: () -> untyped

  # Get the shard key fields.
  #
  # _@return_ — The shard key field names.
  #
  # Get the shard key fields.
  # ```ruby
  # model.shard_key_fields
  # ```
  #
  # _@note_ — Refactored from using delegate for class load performance.
  def shard_key_fields: () -> ::Array[String]

  # Get the document selector with the defined shard keys.
  #
  # _@return_ — The shard key selector.
  #
  # Get the selector for the shard keys.
  # ```ruby
  # person.shard_key_selector
  # ```
  def shard_key_selector: () -> ::Hash[untyped, untyped]

  # Gets the document as a serializable hash, used by ActiveModel's JSON
  # serializer.
  #
  # _@param_ `options` — The options to pass.
  #
  # _@return_ — The document, ready to be serialized.
  #
  # Get the serializable hash.
  # ```ruby
  # document.serializable_hash
  # ```
  #
  # Get the serializable hash with options.
  # ```ruby
  # document.serializable_hash(:include => :addresses)
  # ```
  def serializable_hash: (?::Hash[untyped, untyped]? options) -> ::Hash[untyped, untyped]

  # Get the names of all fields that will be serialized.
  #
  # _@return_ — The names of the fields.
  #
  # Get all the field names.
  # ```ruby
  # document.send(:field_names)
  # ```
  def field_names: (untyped options) -> ::Array[String]

  def serialize_attribute: (::Hash[untyped, untyped] attrs, String name, ::Array[String] names, ::Hash[untyped, untyped] options) -> Object

  # For each of the provided include options, get the association needed and
  # provide it in the hash.
  #
  # _@param_ `attributes` — The attributes to serialize.
  #
  # _@param_ `options` — The serialization options.
  #
  # Serialize the included associations.
  # ```ruby
  # document.serialize_relations({}, :include => :addresses)
  # ```
  def serialize_relations: (?::Hash[untyped, untyped] attributes, ?::Hash[untyped, untyped] options) -> untyped

  # Since the inclusions can be a hash, symbol, or array of symbols, this is
  # provided as a convenience to parse out the names.
  #
  # _@param_ `inclusions` — The inclusions.
  #
  # _@return_ — The names of the included associations.
  #
  # Get the association names.
  # ```ruby
  # document.relation_names(:include => [ :addresses ])
  # ```
  def relation_names: (::Hash[untyped, untyped] | Symbol | ::Array[Symbol] inclusions) -> ::Array[Symbol]

  # Since the inclusions can be a hash, symbol, or array of symbols, this is
  # provided as a convenience to parse out the options.
  #
  # _@param_ `inclusions` — The inclusions.
  #
  # _@param_ `options` — The options.
  #
  # _@param_ `name` — The name of the association.
  #
  # _@return_ — The options for the association.
  #
  # Get the association options.
  # ```ruby
  # document.relation_names(:include => [ :addresses ])
  # ```
  def relation_options: (::Hash[untyped, untyped] | Symbol | ::Array[Symbol] inclusions, ::Hash[untyped, untyped] options, Symbol name) -> ::Hash[untyped, untyped]

  # Get the atomic selector for the document. This is a hash in the simplest
  # case { "_id" => id }, but can become more complex for embedded documents
  # and documents that use a shard key.
  #
  # _@return_ — The document's selector.
  #
  # Get the document's atomic selector.
  # ```ruby
  # document.atomic_selector
  # ```
  def atomic_selector: () -> ::Hash[untyped, untyped]

  # Get the atomic selector for an embedded document.
  #
  # _@return_ — The embedded document selector.
  #
  # Get the embedded atomic selector.
  # ```ruby
  # document.embedded_atomic_selector
  # ```
  def embedded_atomic_selector: () -> ::Hash[untyped, untyped]

  # Get the atomic selector for a root document.
  #
  # _@return_ — The root document selector.
  #
  # Get the root atomic selector.
  # ```ruby
  # document.root_atomic_selector
  # ```
  def root_atomic_selector: () -> ::Hash[untyped, untyped]

  # Apply the default scoping to the attributes of the document, as long as
  # they are not complex queries.
  #
  # _@return_ — If default scoping was applied.
  #
  # Apply the default scoping.
  # ```ruby
  # document.apply_default_scoping
  # ```
  def apply_default_scoping: () -> bool

  # Reloads the +Document+ attributes from the database. If the document has
  # not been saved then an error will get raised if the configuration option
  # was set. This can reload root documents or embedded documents.
  #
  # _@return_ — The document, reloaded.
  #
  # Reload the document.
  # ```ruby
  # person.reload
  # ```
  def reload: () -> Document

  # Reload the document, determining if it's embedded or not and what
  # behavior to use.
  #
  # _@return_ — The reloaded attributes.
  #
  # Reload the document.
  # ```ruby
  # document._reload
  # ```
  def _reload: () -> ::Hash[untyped, untyped]

  # Reload the root document.
  #
  # _@return_ — The reloaded attributes.
  #
  # Reload the document.
  # ```ruby
  # document.reload_root_document
  # ```
  def reload_root_document: () -> ::Hash[untyped, untyped]

  # Reload the embedded document.
  #
  # _@return_ — The reloaded attributes.
  #
  # Reload the document.
  # ```ruby
  # document.reload_embedded_document
  # ```
  def reload_embedded_document: () -> ::Hash[untyped, untyped]

  # Extract only the desired embedded document from the attributes.
  #
  # _@param_ `attributes` — The document in the db.
  #
  # _@return_ — The document's extracted attributes.
  #
  # Extract the embedded document.
  # ```ruby
  # document.extract_embedded_attributes(attributes)
  # ```
  def extract_embedded_attributes: (::Hash[untyped, untyped] attributes) -> ::Hash[untyped, untyped]

  # Determine if the document itself is embedded in another document via the
  # proper channels. (If it has a parent document.)
  #
  # _@return_ — True if the document has a parent document.
  #
  # Is the document embedded?
  # ```ruby
  # address.embedded?
  # ```
  def embedded?: () -> bool

  # Determine if the document is part of an embeds_many association.
  #
  # _@return_ — True if in an embeds many.
  #
  # Is the document in an embeds many?
  # ```ruby
  # address.embedded_many?
  # ```
  def embedded_many?: () -> bool

  # Determine if the document is part of an embeds_one association.
  #
  # _@return_ — True if in an embeds one.
  #
  # Is the document in an embeds one?
  # ```ruby
  # address.embedded_one?
  # ```
  def embedded_one?: () -> bool

  # Get the association name for this document. If no association was defined
  #   an error will be raised.
  #
  # _@return_ — The association name.
  #
  # Get the association name.
  # ```ruby
  # document.association_name
  # ```
  def association_name: () -> Symbol

  # Determine if the document is part of an references_many association.
  #
  # _@return_ — True if in a references many.
  #
  # Is the document in a references many?
  # ```ruby
  # post.referenced_many?
  # ```
  def referenced_many?: () -> bool

  # Determine if the document is part of an references_one association.
  #
  # _@return_ — True if in a references one.
  #
  # Is the document in a references one?
  # ```ruby
  # address.referenced_one?
  # ```
  def referenced_one?: () -> bool

  # Convenience method for iterating through the loaded associations and
  # reloading them.
  #
  # _@return_ — The association metadata.
  #
  # Reload the associations.
  # ```ruby
  # document.reload_relations
  # ```
  def reload_relations: () -> ::Hash[untyped, untyped]

  # Returns the association metadata for the supplied name.
  #
  # _@param_ `name` — The name of the association to find.
  #
  # _@return_ — The matching association metadata.
  #
  # Find association metadata by name.
  # ```ruby
  # person.reflect_on_association(:addresses)
  # ```
  def reflect_on_association: (String | Symbol name) -> Association

  # Returns all association metadata for the supplied macros.
  #
  # _@param_ `macros` — The association macros.
  #
  # _@return_ — The matching association metadata.
  #
  # Find multiple association metadata by macro.
  # ```ruby
  # person.reflect_on_all_associations(:embeds_many)
  # ```
  def reflect_on_all_association: (*::Array[Symbol] macros) -> ::Array[Association]

  # This is convenience for libraries still on the old API.
  #
  # _@return_ — The associations.
  #
  # Get the associations.
  # ```ruby
  # person.associations
  # ```
  def associations: () -> ::Hash[untyped, untyped]

  # Parse out the attributes and the options from the args passed to a
  # build_ or create_ methods.
  #
  # _@param_ `args` — The arguments.
  #
  # _@return_ — The attributes and options.
  #
  # Parse the args.
  # ```ruby
  # doc.parse_args(:name => "Joe")
  # ```
  def parse_args: (*::Array[untyped] args) -> ::Array[::Hash[untyped, untyped]]

  # Perform all cascading deletes, destroys, or nullifies. Will delegate to
  # the appropriate strategy to perform the operation.
  #
  # Execute cascades.
  # ```ruby
  # document.apply_delete_dependencies!
  # ```
  def apply_delete_dependencies!: () -> untyped

  def _dependent_delete_all!: (untyped association) -> untyped

  def _dependent_destroy!: (untyped association) -> untyped

  def _dependent_nullify!: (untyped association) -> untyped

  def _dependent_restrict_with_exception!: (untyped association) -> untyped

  def _dependent_restrict_with_error!: (untyped association) -> untyped

  def __build__: (String | Symbol name, ::Hash[untyped, untyped] | BSON::ObjectId object, Association association, ?::Hash[untyped, untyped]? selected_fields) -> Proxy

  # Create an association from an object and association metadata.
  #
  # _@param_ `object` — The association target.
  #
  # _@param_ `association` — The association metadata.
  #
  # _@param_ `selected_fields` — Fields which were retrieved via #only. If selected_fields is specified, fields not listed in it will not be accessible in the created association document.
  #
  # _@return_ — The association.
  #
  # Create the association.
  # ```ruby
  # person.create_relation(document, association)
  # ```
  def create_relation: (Document | ::Array[Document] object, Association association, ?::Hash[untyped, untyped]? selected_fields) -> Proxy

  # Resets the criteria inside the association proxy. Used by many-to-many
  # associations to keep the underlying ids array in sync.
  #
  # _@param_ `name` — The name of the association.
  #
  # Reset the association criteria.
  # ```ruby
  # person.reset_relation_criteria(:preferences)
  # ```
  def reset_relation_criteria: (Symbol name) -> untyped

  # Set the supplied association to an instance variable on the class with the
  # provided name. Used as a helper just for code cleanliness.
  #
  # _@param_ `name` — The name of the association.
  #
  # _@param_ `relation` — The association to set.
  #
  # _@return_ — The association.
  #
  # Set the proxy on the document.
  # ```ruby
  # person.set(:addresses, addresses)
  # ```
  def set_relation: (String | Symbol name, Proxy relation) -> Proxy

  def get_relation: (Symbol name, Association association, Object object, ?bool reload) -> Proxy

  # Returns a subset of __selected_fields attribute applicable to the
  # (embedded) association with the given key, or nil if no projection
  # is to be performed.
  #
  # For example, if __selected_fields is {'a' => 1, 'b.c' => 2, 'b.c.f' => 3},
  # and assoc_key is 'b', return value would be {'c' => 2, 'c.f' => 3}.
  #
  # _@param_ `assoc_key`
  def _mongoid_filter_selected_fields: (String assoc_key) -> ::Hash[untyped, untyped]?

  def needs_no_database_query?: (untyped object, untyped association) -> bool

  # Is the current code executing without autobuild functionality?
  #
  # _@return_ — If autobuild is disabled.
  #
  # Is autobuild disabled?
  # ```ruby
  # document.without_autobuild?
  # ```
  def without_autobuild?: () -> bool

  # Yield to the block with autobuild functionality turned off.
  #
  # _@return_ — The result of the yield.
  #
  # Execute without autobuild.
  # ```ruby
  # document.without_autobuild do
  #   document.name
  # end
  # ```
  def without_autobuild: () -> Object

  # Is the document able to be synced on the inverse side? This is only if
  # the key has changed and the association bindings have not been run.
  #
  # _@param_ `association` — The association metadata.
  #
  # _@return_ — If we can sync.
  #
  # Are the foreign keys syncable?
  # ```ruby
  # document._syncable?(association)
  # ```
  def _syncable?: (Association association) -> bool

  # Get the synced foreign keys.
  #
  # _@return_ — The synced foreign keys.
  #
  # Get the synced foreign keys.
  # ```ruby
  # document._synced
  # ```
  def _synced: () -> ::Hash[untyped, untyped]

  # Has the document been synced for the foreign key?
  #
  # _@param_ `foreign_key` — The foreign key.
  #
  # _@return_ — If we can sync.
  #
  # Has the document been synced?
  # ```ruby
  # document._synced?
  # ```
  def _synced?: (String foreign_key) -> bool

  # Update the inverse keys on destroy.
  #
  # _@param_ `association` — The association.
  #
  # _@return_ — The updated values.
  #
  # Update the inverse keys.
  # ```ruby
  # document.remove_inverse_keys(association)
  # ```
  def remove_inverse_keys: (Association association) -> Object

  # Update the inverse keys for the association.
  #
  # _@param_ `association` — The document association.
  #
  # _@return_ — The updated values.
  #
  # Update the inverse keys
  # ```ruby
  # document.update_inverse_keys(association)
  # ```
  def update_inverse_keys: (Association association) -> Object

  # Reset the given counter using the .count() query from the
  # db. This method is usuful in case that a counter got
  # corrupted, or a new counter was added to the collection.
  #
  # _@param_ `counters` — One or more counter caches to reset
  #
  # Reset the given counter cache
  # ```ruby
  # post.reset_counters(:comments)
  # ```
  def reset_counters: (*Symbol | ::Array[untyped] counters) -> untyped

  # Used to prevent infinite loops in associated autosaves.
  #
  # _@return_ — Has the document already been autosaved?
  #
  # Is the document autosaved?
  # ```ruby
  # document.autosaved?
  # ```
  def autosaved?: () -> bool

  # Begin the associated autosave.
  #
  # Begin autosave.
  # ```ruby
  # document.__autosaving__
  # ```
  def __autosaving__: () -> untyped

  # Check if there is changes for auto-saving
  #
  #   document.changed_for_autosave?
  #
  # Return true if there is changes on self or in
  # ```ruby
  # autosaved associations.
  # ```
  def changed_for_autosave?: (untyped doc) -> bool

  # Execute operations atomically (in a single database call) for everything
  # that would happen inside the block. This method supports nesting further
  # calls to atomically, which will behave according to the options described
  # below.
  #
  # An option join_context can be given which, when true, will merge the
  # operations declared by the given block with the atomically block wrapping
  # the current invocation for the same document, if one exists. If this
  # block or any other block sharing the same context raises before
  # persisting, then all the operations of that context will not be
  # persisted, and will also be reset in memory.
  #
  # When join_context is false, the given block of operations will be
  # persisted independently of other contexts. Failures in other contexts will
  # not affect this one, so long as this block was able to run and persist
  # changes.
  #
  # The default value of join_context is set by the global configuration
  # option join_contexts, whose own default is false.
  #
  # _@param_ `join_context` — Join the context (i.e. merge declared atomic operations) of the atomically block wrapping this one for the same document, if one exists.
  #
  # _@return_ — If the operation succeeded.
  #
  # Execute the operations atomically.
  # ```ruby
  # document.atomically do
  #   document.set(name: "Tool").inc(likes: 10)
  # end
  # ```
  #
  # Execute some inner operations atomically, but independently from the outer operations.
  # ```ruby
  #
  # document.atomically do
  #   document.inc likes: 10
  #   document.atomically join_context: false do
  #     # The following is persisted to the database independently.
  #     document.unset :origin
  #   end
  #   document.atomically join_context: true do
  #     # The following is persisted along with the other outer operations.
  #     document.inc member_count: 3
  #   end
  #   document.set name: "Tool"
  # end
  # ```
  def atomically: (?join_context: bool? join_context) -> bool

  # Raise an error if validation failed.
  #
  # Raise the validation error.
  # ```ruby
  # Person.fail_due_to_validation!(person)
  # ```
  def fail_due_to_validation!: () -> untyped

  # Raise an error if a callback failed.
  #
  # _@param_ `method` — The method being called.
  #
  # Raise the callback error.
  # ```ruby
  # Person.fail_due_to_callback!(person, :create!)
  # ```
  def fail_due_to_callback!: (Symbol method) -> untyped

  # Are we executing an atomically block on the current document?
  #
  # _@return_ — If we are current executing atomically.
  #
  # Are we executing atomically?
  # ```ruby
  # document.executing_atomically?
  # ```
  def executing_atomically?: () -> bool

  # Post process the persistence operation.
  #
  # _@param_ `result` — The result of the operation.
  #
  # _@param_ `options` — The options.
  #
  # _@return_ — true.
  #
  # Post process the persistence operation.
  # ```ruby
  # document.post_process_persist(true)
  # ```
  def post_process_persist: (Object result, ?::Hash[untyped, untyped] options) -> bool

  # Prepare an atomic persistence operation. Yields an empty hash to be sent
  # to the update.
  #
  # _@return_ — The result of the operation.
  #
  # Prepare the atomic operation.
  # ```ruby
  # document.prepare_atomic_operation do |coll, selector, opts|
  #   ...
  # end
  # ```
  def prepare_atomic_operation: () -> Object

  # Process the atomic operations - this handles the common behavior of
  # iterating through each op, getting the aliased field name, and removing
  # appropriate dirty changes.
  #
  # _@param_ `operations` — The atomic operations.
  #
  # _@return_ — The operations.
  #
  # Process the atomic operations.
  # ```ruby
  # document.process_atomic_operations(pulls) do |field, value|
  #   ...
  # end
  # ```
  def process_atomic_operations: (::Hash[untyped, untyped] operations) -> ::Hash[untyped, untyped]

  # Remove the dirty changes for all fields changed in the current atomic
  # context.
  #
  # Remove the current atomic context's dirty changes.
  # ```ruby
  # document._mongoid_remove_atomic_context_changes
  # ```
  def _mongoid_remove_atomic_context_changes: () -> untyped

  # Reset the attributes for all fields changed in the current atomic
  # context.
  #
  # Reset the current atomic context's changed attributes.
  # ```ruby
  # document._mongoid_reset_atomic_context_changes!
  # ```
  def _mongoid_reset_atomic_context_changes!: () -> untyped

  # Push a new atomic context onto the stack.
  #
  # Push a new atomic context onto the stack.
  # ```ruby
  # document._mongoid_push_atomic_context
  # ```
  def _mongoid_push_atomic_context: () -> untyped

  # Pop an atomic context off the stack.
  #
  # Pop an atomic context off the stack.
  # ```ruby
  # document._mongoid_pop_atomic_context
  # ```
  def _mongoid_pop_atomic_context: () -> untyped

  # Return the current atomic context's changed fields.
  #
  # _@return_ — The changed fields.
  #
  # Return the current atomic context's changed fields.
  # ```ruby
  # document._mongoid_atomic_context_changed_fields
  # ```
  def _mongoid_atomic_context_changed_fields: () -> ::Array[untyped]

  # If we are in an atomically block, add the operations to the delayed group,
  # otherwise persist immediately.
  #
  # _@param_ `operation` — The operation.
  #
  # Persist immediately or delay the operations.
  # ```ruby
  # document.persist_or_delay_atomic_operation(ops)
  # ```
  def persist_or_delay_atomic_operation: (::Hash[untyped, untyped] operation) -> untyped

  # Persist the atomic operations.
  #
  # _@param_ `operations` — The atomic operations.
  #
  # Persist the atomic operations.
  # ```ruby
  # persist_atomic_operations(ops)
  # ```
  def persist_atomic_operations: (::Hash[untyped, untyped] operations) -> untyped

  # Perform an $unset operation on the provided fields and in the
  # values in the document in memory.
  #
  # _@param_ `fields` — The names of the fields to unset.
  #
  # _@return_ — The document.
  #
  # Unset the values.
  # ```ruby
  # document.unset(:first_name, :last_name, :middle)
  # ```
  def unset: (*::Array[String | Symbol] fields) -> Document

  # Perform an upsert of the document. If the document does not exist in the
  # database, then Mongo will insert a new one, otherwise the fields will get
  # overwritten with new values on the existing document.
  #
  # _@param_ `options` — The validation options.
  #
  # _@return_ — True.
  #
  # Upsert the document.
  # ```ruby
  # document.upsert
  # ```
  def upsert: (?::Hash[untyped, untyped] options) -> bool

  # Prepare the upsert for execution.
  #
  # _@param_ `options` — The options hash.
  #
  # _@return_ — If the operation succeeded.
  #
  # Prepare the upsert
  # ```ruby
  # document.prepare_upsert do
  #   collection.find(selector).update(as_document)
  # end
  # ```
  def prepare_upsert: (?::Hash[untyped, untyped] options) -> bool

  # Update a single attribute and persist the entire document.
  # This skips validation but fires the callbacks.
  #
  # _@param_ `name` — The name of the attribute.
  #
  # _@param_ `value` — The new value of the attribute.a
  #
  # _@return_ — True if save was successfull, false if not.
  #
  # Update the attribute.
  # ```ruby
  # person.update_attribute(:title, "Sir")
  # ```
  def update_attribute: (Symbol | String name, Object value) -> bool

  # Update the document attributes in the database.
  #
  # _@param_ `attributes` — The attributes to update.
  #
  # _@return_ — True if validation passed, false if not.
  #
  # Update the document's attributes
  # ```ruby
  # document.update(:title => "Sir")
  # ```
  def update: (?::Hash[untyped, untyped] attributes) -> bool

  # Update the document attributes in the database and raise an error if
  # validation failed.
  #
  # _@param_ `attributes` — The attributes to update.
  #
  # _@return_ — True if validation passed.
  #
  # Update the document's attributes.
  # ```ruby
  # document.update!(:title => "Sir")
  # ```
  def update!: (?::Hash[untyped, untyped] attributes) -> bool

  # Initialize the atomic updates.
  #
  # _@return_ — The updates and conflicts.
  #
  # Initialize the atomic updates.
  # ```ruby
  # document.init_atomic_updates
  # ```
  def init_atomic_updates: () -> ::Array[::Hash[untyped, untyped]]

  # Prepare the update for execution. Validates and runs callbacks, etc.
  #
  # _@param_ `options` — The options.
  #
  # _@return_ — The result of the update.
  #
  # Prepare for update.
  # ```ruby
  # document.prepare_update do
  #   collection.update(atomic_selector)
  # end
  # ```
  def prepare_update: (?::Hash[untyped, untyped] options) -> bool

  # Update the document in the database.
  #
  # _@param_ `options` — Options to pass to update.
  #
  # _@return_ — True if succeeded, false if not.
  #
  # Update an existing document.
  # ```ruby
  # document.update
  # ```
  def update_document: (?::Hash[untyped, untyped] options) -> bool

  # Perform a $set operation on the provided field/value pairs and set the
  # values in the document in memory.
  #
  # The key can be a dotted sequence of keys, in which case the
  # top level field is treated as a nested hash and any missing keys
  # are created automatically:
  #
  # Performing a nested set like this merges values of intermediate keys:
  #
  # If the top level field was not a hash, its original value is discarded
  # and the field is replaced with a hash.
  #
  # Note that unlike MongoDB's $set, Mongoid's set writes out the entire
  # field even when setting a subset of the field via the nested hash
  # semantics. This means performing a $set with nested hash semantics
  # can overwrite other hash keys within the top level field in the database.
  #
  # _@param_ `setters` — The field/value pairs to set.
  #
  # _@return_ — The document.
  #
  # Set the values.
  # ```ruby
  # document.set(title: "sir", dob: Date.new(1970, 1, 1))
  # ```
  #
  # Set the values using nested hash semantics.
  # ```ruby
  # document.set('author.title' => 'Sir')
  # # => document.author == {'title' => 'Sir'}
  # ```
  #
  # Nested hash value merging.
  # ```ruby
  # document.set('author.title' => 'Sir')
  # document.set('author.name' => 'Linus Torvalds')
  # # => document.author == {'title' => 'Sir', 'name' => 'Linus Torvalds'}
  # ```
  #
  # Nested hash overwriting a non-hash value.
  # ```ruby
  # document.set('author' => 'John Doe')
  # document.set('author.title' => 'Sir')
  # # => document.author == {'title' => 'Sir'}
  # ```
  def set: (::Hash[untyped, untyped] setters) -> Document

  # Save the document - will perform an insert if the document is new, and
  # update if not.
  #
  # _@param_ `options` — Options to pass to the save.
  #
  # _@return_ — True is success, false if not.
  #
  # Save the document.
  # ```ruby
  # document.save
  # ```
  def save: (?::Hash[untyped, untyped] options) -> bool

  # Save the document - will perform an insert if the document is new, and
  # update if not. If a validation error occurs an error will get raised.
  #
  # _@param_ `options` — Options to pass to the save.
  #
  # _@return_ — True if validation passed.
  #
  # Save the document.
  # ```ruby
  # document.save!
  # ```
  def save!: (?::Hash[untyped, untyped] options) -> bool

  # Rename fields from one value to another via $rename.
  #
  # _@param_ `renames` — The rename pairs of old name/new name.
  #
  # _@return_ — The document.
  #
  # Rename the fields.
  # ```ruby
  # document.rename(title: "salutation", name: "nombre")
  # ```
  #
  # _@note_ — This does not work for fields in embeds many associations.
  def rename: (::Hash[untyped, untyped] renames) -> Document

  # Add the single values to the arrays only if the value does not already
  # exist in the array.
  #
  # _@param_ `adds` — The field/value pairs to add.
  #
  # _@return_ — The document.
  #
  # Add the values to the sets.
  # ```ruby
  # document.add_to_set(names: "James", aliases: "Bond")
  # ```
  def add_to_set: (::Hash[untyped, untyped] adds) -> Document

  # Push a single value or multiple values onto arrays.
  #
  # _@param_ `pushes` — The $push operations.
  #
  # _@return_ — The document.
  #
  # Push a single value onto arrays.
  # ```ruby
  # document.push(names: "James", aliases: "007")
  # ```
  #
  # Push multiple values onto arrays.
  # ```ruby
  # document.push(names: [ "James", "Bond" ])
  # ```
  def push: (::Hash[untyped, untyped] pushes) -> Document

  # Pull single values from the provided arrays.
  #
  # _@param_ `pulls` — The field/value pull pairs.
  #
  # _@return_ — The document.
  #
  # Pull a value from the array.
  # ```ruby
  # document.pull(names: "Jeff", levels: 5)
  # ```
  #
  # _@note_ — If duplicate values are found they will all be pulled.
  def pull: (::Hash[untyped, untyped] pulls) -> Document

  # Pull multiple values from the provided array fields.
  #
  # _@param_ `pulls` — The pull all operations.
  #
  # _@return_ — The document.
  #
  # Pull values from the arrays.
  # ```ruby
  # document.pull_all(names: [ "Jeff", "Bob" ], levels: [ 5, 6 ])
  # ```
  def pull_all: (::Hash[untyped, untyped] pulls) -> Document

  # Takes the provided selector and atomic operations and replaces the
  # indexes of the embedded documents with the positional operator when
  # needed.
  #
  # _@param_ `selector` — The selector.
  #
  # _@param_ `operations` — The update operations.
  #
  # _@param_ `processed` — The processed update operations.
  #
  # _@return_ — The new operations.
  #
  # Process the operations.
  # ```ruby
  # positionally(
  #   { "_id" => 1, "addresses._id" => 2 },
  #   { "$set" => { "addresses.0.street" => "hobrecht" }}
  # )
  # ```
  #
  # _@note_ — The only time we can accurately know when to use the positional
  # operator is at the exact time we are going to persist something. So
  # we can tell by the selector that we are sending if it is actually
  # possible to use the positional operator at all. For example, if the
  # selector is: { "_id" => 1 }, then we could not use the positional
  # operator for updating embedded documents since there would never be a
  # match - we base whether we can based on the number of levels deep the
  # selector goes, and if the id values are not nil.
  def positionally: (::Hash[untyped, untyped] selector, ::Hash[untyped, untyped] operations, ?::Hash[untyped, untyped] processed) -> ::Hash[untyped, untyped]

  def process_operations: (untyped keys, untyped operations, untyped processed) -> untyped

  def process_updates: (untyped keys, untyped update, ?untyped updates) -> untyped

  def replace_index: (untyped keys, untyped position) -> untyped

  # Pop or shift items from arrays using the $pop operator.
  #
  # _@param_ `pops` — The field/value pop operations.
  #
  # _@return_ — The document.
  #
  # Pop items from an array.
  # ```ruby
  # document.pop(aliases: 1)
  # ```
  #
  # Shift items in the array.
  # ```ruby
  # document.pop(aliases: -1)
  # ```
  #
  # Multiple pops in one call.
  # ```ruby
  # document.pop(names: 1, aliases: 1)
  # ```
  def pop: (::Hash[untyped, untyped] pops) -> Document

  # Performs an atomic $bit operation on the field with the provided hash
  # of bitwise ops to execute in order.
  #
  # _@param_ `operations` — The bitwise operations.
  #
  # _@return_ — The document.
  #
  # Execute the bitwise operations.
  # ```ruby
  # person.bit(age: { :and => 12 }, val: { and: 10, or: 12 })
  # ```
  def bit: (::Hash[untyped, untyped] operations) -> Document

  # Increment the provided fields by the corresponding values. Values can
  # be positive or negative, and if no value exists for the field it will
  # be set with the provided value.
  #
  # _@param_ `increments` — The field/inc increment pairs.
  #
  # _@return_ — The document.
  #
  # Increment the fields.
  # ```ruby
  # document.inc(score: 10, place: 1, lives: -10)
  # ```
  def inc: (::Hash[untyped, untyped] increments) -> Document

  # Remove the document from the database with callbacks.
  #
  # _@param_ `options` — Options to pass to destroy.
  #
  # _@return_ — True if successful, false if not.
  #
  # Destroy a document.
  # ```ruby
  # document.destroy
  # ```
  def destroy: (?::Hash[untyped, untyped]? options) -> bool

  def destroy!: (?untyped options) -> untyped

  # Remove the document from the database.
  #
  # _@param_ `options` — Options to pass to remove.
  #
  # _@return_ — True.
  #
  # Remove the document.
  # ```ruby
  # document.remove
  # ```
  def delete: (?::Hash[untyped, untyped] options) -> TrueClass

  # Get the atomic deletes for the operation.
  #
  # _@return_ — The atomic deletes.
  #
  # Get the atomic deletes.
  # ```ruby
  # document.atomic_deletes
  # ```
  def atomic_deletes: () -> ::Hash[untyped, untyped]

  # Delete the embedded document.
  #
  # _@param_ `options` — The deletion options.
  #
  # _@return_ — If the operation succeeded.
  #
  # Delete the embedded document.
  # ```ruby
  # document.delete_as_embedded
  # ```
  def delete_as_embedded: (?::Hash[untyped, untyped] options) -> bool

  # Delete the root document.
  #
  # _@return_ — If the document was removed.
  #
  # Delete the root document.
  # ```ruby
  # document.delete_as_root
  # ```
  def delete_as_root: () -> bool

  # Are we needing to notify the parent document of the deletion.
  #
  # _@param_ `options` — The delete options.
  #
  # _@return_ — If the parent should be notified.
  #
  # Are we notifying the parent.
  # ```ruby
  # document.notifying_parent?(suppress: true)
  # ```
  def notifying_parent?: (?::Hash[untyped, untyped] options) -> bool

  # Prepare the delete operation.
  #
  # _@return_ — The result of the block.
  #
  # Prepare the delete operation.
  # ```ruby
  # document.prepare_delete do
  #   collection.find(atomic_selector).remove
  # end
  # ```
  def prepare_delete: () -> Object

  # Insert a new document into the database. Will return the document
  # itself whether or not the save was successful.
  #
  # _@param_ `options` — Options to pass to insert.
  #
  # _@return_ — The persisted document.
  #
  # Insert a document.
  # ```ruby
  # document.insert
  # ```
  def insert: (?::Hash[untyped, untyped] options) -> Document

  # Get the atomic insert for embedded documents, either a push or set.
  #
  # _@return_ — The insert ops.
  #
  # Get the inserts.
  # ```ruby
  # document.inserts
  # ```
  def atomic_inserts: () -> ::Hash[untyped, untyped]

  # Insert the embedded document.
  #
  # _@return_ — The document.
  #
  # Insert the document as embedded.
  # ```ruby
  # document.insert_as_embedded
  # ```
  def insert_as_embedded: () -> Document

  # Insert the root document.
  #
  # _@return_ — The document.
  #
  # Insert the document as root.
  # ```ruby
  # document.insert_as_root
  # ```
  def insert_as_root: () -> Document

  # Post process an insert, which sets the new record attribute to false
  # and flags all the children as persisted.
  #
  # _@return_ — true.
  #
  # Post process the insert.
  # ```ruby
  # document.post_process_insert
  # ```
  def post_process_insert: () -> bool

  # Prepare the insert for execution. Validates and runs callbacks, etc.
  #
  # _@param_ `options` — The options.
  #
  # _@return_ — The document.
  #
  # Prepare for insertion.
  # ```ruby
  # document.prepare_insert do
  #   collection.insert(as_document)
  # end
  # ```
  def prepare_insert: (?::Hash[untyped, untyped] options) -> Document

  # Determines if this document has the attributes to match the supplied
  # MongoDB selector. Used for matching on embedded associations.
  #
  # _@param_ `selector` — The MongoDB selector.
  #
  # _@return_ — True if matches, false if not.
  #
  # Does the document match?
  # ```ruby
  # document._matches?(:title => { "$in" => [ "test" ] })
  # ```
  def _matches?: (::Hash[untyped, untyped] selector) -> bool

  # Apply all default values to the document which are not procs.
  #
  # _@return_ — The names of the non-proc defaults.
  #
  # Apply all the non-proc defaults.
  # ```ruby
  # model.apply_pre_processed_defaults
  # ```
  def apply_pre_processed_defaults: () -> ::Array[String]

  # Apply all default values to the document which are procs.
  #
  # _@return_ — The names of the proc defaults.
  #
  # Apply all the proc defaults.
  # ```ruby
  # model.apply_post_processed_defaults
  # ```
  def apply_post_processed_defaults: () -> ::Array[String]

  # Applies a single default value for the given name.
  #
  # _@param_ `name` — The name of the field.
  #
  # Apply a single default.
  # ```ruby
  # model.apply_default("name")
  # ```
  def apply_default: (String name) -> untyped

  # Apply all the defaults at once.
  #
  # Apply all the defaults.
  # ```ruby
  # model.apply_defaults
  # ```
  def apply_defaults: () -> untyped

  # Returns an array of names for the attributes available on this object.
  #
  # Provides the field names in an ORM-agnostic way. Rails v3.1+ uses this
  # method to automatically wrap params in JSON requests.
  #
  # _@return_ — The field names
  #
  # Get the field names
  # ```ruby
  # docment.attribute_names
  # ```
  def attribute_names: () -> ::Array[String]

  # Get the name of the provided field as it is stored in the database.
  # Used in determining if the field is aliased or not.
  #
  # _@param_ `name` — The name to get.
  #
  # _@return_ — The name of the field as it's stored in the db.
  #
  # Get the database field name.
  # ```ruby
  # model.database_field_name(:authorization)
  # ```
  def database_field_name: (String | Symbol name) -> String

  # Is the provided field a lazy evaluation?
  #
  # _@param_ `field` — The field.
  #
  # _@param_ `value` — The current value.
  #
  # _@return_ — If we set the field lazily.
  #
  # If the field is lazy settable.
  # ```ruby
  # doc.lazy_settable?(field, nil)
  # ```
  def lazy_settable?: (Standard | ForeignKey field, Object value) -> bool

  # Is the document using object ids?
  #
  # _@return_ — Using object ids.
  #
  # Is the document using object ids?
  # ```ruby
  # model.using_object_ids?
  # ```
  #
  # _@note_ — Refactored from using delegate for class load performance.
  def using_object_ids?: () -> bool

  # Evolve the document into an object id.
  #
  # _@return_ — The document's id.
  #
  # Evolve the document.
  # ```ruby
  # document.__evolve_object_id__
  # ```
  def __evolve_object_id__: () -> Object

  # Determine if an attribute is present.
  #
  # _@param_ `name` — The name of the attribute.
  #
  # _@return_ — True if present, false if not.
  #
  # Is the attribute present?
  # ```ruby
  # person.attribute_present?("title")
  # ```
  def attribute_present?: (String | Symbol name) -> bool

  # Get the attributes that have not been cast.
  #
  # _@return_ — The uncast attributes.
  #
  # Get the attributes before type cast.
  # ```ruby
  # document.attributes_before_type_cast
  # ```
  def attributes_before_type_cast: () -> ::Hash[untyped, untyped]

  # Does the document have the provided attribute?
  #
  # _@param_ `name` — The name of the attribute.
  #
  # _@return_ — If the key is present in the attributes.
  #
  # Does the document have the attribute?
  # ```ruby
  # model.has_attribute?(:name)
  # ```
  def has_attribute?: (String | Symbol name) -> bool

  # Does the document have the provided attribute before it was assigned
  # and type cast?
  #
  # _@param_ `name` — The name of the attribute.
  #
  # _@return_ — If the key is present in the
  # attributes_before_type_cast.
  #
  # Does the document have the attribute before it was assigned?
  # ```ruby
  # model.has_attribute_before_type_cast?(:name)
  # ```
  def has_attribute_before_type_cast?: (String | Symbol name) -> bool

  # Read a value from the document attributes. If the value does not exist
  # it will return nil.
  #
  # _@param_ `name` — The name of the attribute to get.
  #
  # _@return_ — The value of the attribute.
  #
  # Read an attribute.
  # ```ruby
  # person.read_attribute(:title)
  # ```
  #
  # Read an attribute (alternate syntax.)
  # ```ruby
  # person[:title]
  # ```
  def read_attribute: (String | Symbol name) -> Object

  # Read a value from the attributes before type cast. If the value has not
  # yet been assigned then this will return the attribute's existing value
  # using read_raw_attribute.
  #
  # _@param_ `name` — The name of the attribute to get.
  #
  # _@return_ — The value of the attribute before type cast, if
  # available. Otherwise, the value of the attribute.
  #
  # Read an attribute before type cast.
  # ```ruby
  # person.read_attribute_before_type_cast(:price)
  # ```
  def read_attribute_before_type_cast: (String | Symbol name) -> Object

  # Remove a value from the +Document+ attributes. If the value does not exist
  # it will fail gracefully.
  #
  # _@param_ `name` — The name of the attribute to remove.
  #
  # Remove the attribute.
  # ```ruby
  # person.remove_attribute(:title)
  # ```
  def remove_attribute: (String | Symbol name) -> untyped

  # Write a single attribute to the document attribute hash. This will
  # also fire the before and after update callbacks, and perform any
  # necessary typecasting.
  #
  # _@param_ `name` — The name of the attribute to update.
  #
  # _@param_ `value` — The value to set for the attribute.
  #
  # Write the attribute.
  # ```ruby
  # person.write_attribute(:title, "Mr.")
  # ```
  #
  # Write the attribute (alternate syntax.)
  # ```ruby
  # person[:title] = "Mr."
  # ```
  def write_attribute: (String | Symbol name, Object value) -> untyped

  # Allows you to set all the attributes for a particular mass-assignment security role
  # by passing in a hash of attributes with keys matching the attribute names
  # (which again matches the column names)  and the role name using the :as option.
  # To bypass mass-assignment security you can use the :without_protection => true option.
  #
  # _@param_ `attrs` — The new attributes to set.
  #
  # Assign the attributes.
  # ```ruby
  # person.assign_attributes(:title => "Mr.")
  # ```
  #
  # Assign the attributes (with a role).
  # ```ruby
  # person.assign_attributes({ :title => "Mr." }, :as => :admin)
  # ```
  def assign_attributes: (?::Hash[untyped, untyped]? attrs) -> untyped

  # Writes the supplied attributes hash to the document. This will only
  # overwrite existing attributes if they are present in the new +Hash+, all
  # others will be preserved.
  #
  # _@param_ `attrs` — The new attributes to set.
  #
  # Write the attributes.
  # ```ruby
  # person.write_attributes(:title => "Mr.")
  # ```
  #
  # Write the attributes (alternate syntax.)
  # ```ruby
  # person.attributes = { :title => "Mr." }
  # ```
  def write_attributes: (?::Hash[untyped, untyped]? attrs) -> untyped

  # Determine if the attribute is missing from the document, due to loading
  # it from the database with missing fields.
  #
  # _@param_ `name` — The name of the attribute.
  #
  # _@return_ — If the attribute is missing.
  #
  # Is the attribute missing?
  # ```ruby
  # document.attribute_missing?("test")
  # ```
  def attribute_missing?: (String name) -> bool

  # Return type-casted attributes.
  #
  # _@return_ — The hash with keys and values of the type-casted attributes.
  #
  # Type-casted attributes.
  # ```ruby
  # document.typed_attributes
  # ```
  def typed_attributes: () -> Object

  def selection_excluded?: (untyped name, untyped selection, untyped field) -> bool

  def selection_included?: (untyped name, untyped selection, untyped field) -> bool

  # Does the string contain dot syntax for accessing hashes?
  #
  # _@return_ — If the string contains a "."
  #
  # Is the string in dot syntax.
  # ```ruby
  # model.hash_dot_syntax?
  # ```
  def hash_dot_syntax?: (untyped string) -> bool

  # Return the typecasted value for a field.
  #
  # _@param_ `key` — The field name.
  #
  # _@param_ `value` — The uncast value.
  #
  # _@return_ — The cast value.
  #
  # Get the value typecasted.
  # ```ruby
  # person.typed_value_for(:title, :sir)
  # ```
  def typed_value_for: (String | Symbol key, Object value) -> Object

  def read_raw_attribute: (untyped name) -> untyped

  # Validates an attribute value as being assignable to the specified field.
  #
  # For now, only Hash and Array fields are validated, and the value is
  # being checked to be of an appropriate type (i.e. either Hash or Array,
  # respectively, or nil).
  #
  # This method takes the name of the field as stored in the document
  # in the database, not (necessarily) the Ruby method name used to read/write
  # the said field.
  #
  # _@param_ `field_name` — The name of the field.
  #
  # _@param_ `value` — The value to be validated.
  def validate_attribute_value: (String | Symbol field_name, Object value) -> untyped

  def lookup_attribute_presence: (untyped name, untyped value) -> untyped

  # Are we able to write the attribute with the provided name?
  #
  # _@param_ `name` — The name of the field.
  #
  # _@return_ — If the document is new, or if the field is not
  # readonly.
  #
  # Can we write the attribute?
  # ```ruby
  # model.attribute_writable?(:title)
  # ```
  def attribute_writable?: (String | Symbol name) -> bool

  def as_writable_attribute!: (untyped name, ?untyped value) -> untyped

  def _loaded?: (untyped name) -> bool

  def projected_field?: (untyped name) -> bool

  # Process the provided attributes casting them to their proper values if a
  # field exists for them on the document. This will be limited to only the
  # attributes provided in the suppied +Hash+ so that no extra nil values get
  # put into the document's attributes.
  #
  # _@param_ `attrs` — The attributes to set.
  #
  # Process the attributes.
  # ```ruby
  # person.process_attributes(:title => "sir", :age => 40)
  # ```
  def process_attributes: (?::Hash[untyped, untyped]? attrs) -> untyped

  # If the key provided is the name of an association or a nested attribute, we
  # need to wait until all other attributes are set before processing
  # these.
  #
  # _@param_ `key` — The name of the attribute.
  #
  # _@param_ `value` — The value of the attribute.
  #
  # _@return_ — True if pending, false if not.
  #
  # Is the attribute pending?
  # ```ruby
  # document.pending_attribute?(:name, "Durran")
  # ```
  def pending_attribute?: (Symbol key, Object value) -> bool

  # Get all the pending associations that need to be set.
  #
  # _@return_ — The pending associations in key/value pairs.
  #
  # Get the pending associations.
  # ```ruby
  # document.pending_relations
  # ```
  def pending_relations: () -> ::Hash[untyped, untyped]

  # Get all the pending nested attributes that need to be set.
  #
  # _@return_ — The pending nested attributes in key/value pairs.
  #
  # Get the pending nested attributes.
  # ```ruby
  # document.pending_nested
  # ```
  def pending_nested: () -> ::Hash[untyped, untyped]

  # If the attribute is dynamic, add a field for it with a type of object
  # and then either way set the value.
  #
  # _@param_ `name` — The name of the field.
  #
  # _@param_ `value` — The value of the field.
  #
  # Process the attribute.
  # ```ruby
  # document.process_attribute(name, value)
  # ```
  def process_attribute: (Symbol name, Object value) -> untyped

  # Process all the pending nested attributes that needed to wait until
  # ids were set to fire off.
  #
  # Process the nested attributes.
  # ```ruby
  # document.process_nested
  # ```
  def process_nested: () -> untyped

  # Process all the pending items, then clear them out.
  #
  # Process the pending items.
  # ```ruby
  # document.process_pending
  # ```
  def process_pending: () -> untyped

  # Process all the pending associations that needed to wait until ids were set
  # to fire off.
  #
  # Process the associations.
  # ```ruby
  # document.process_relations
  # ```
  def process_relations: () -> untyped

  # Execute a block within the context of a session.
  #
  # _@param_ `options` — The session options. Please see the driver documentation for the available session options.
  #
  # _@return_ — The result of calling the block.
  #
  # Execute some operations in the context of a session.
  # ```ruby
  # band.with_session(causal_consistency: true) do
  #   band.records << Record.create
  #   band.name = 'FKA Twigs'
  #   band.save
  #   band.reload
  # end
  # ```
  #
  # _@note_ — You cannot do any operations in the block using models or objects
  # that use a different client; the block will execute all operations
  # in the context of the implicit session and operations on any models using
  # another client will fail. For example, if you set a client using store_in on a
  # particular model and execute an operation on it in the session context block,
  # that operation can't use the block's session and an error will be raised.
  # An error will also be raised if sessions are nested.
  def with_session: (?::Hash[untyped, untyped] options) -> Object

  def _session: () -> untyped

  # Change the persistence context for this object during the block.
  #
  # _@param_ `options_or_context` — The storage options or a persistence context.
  #
  # Save the current document to a different collection.
  # ```ruby
  # model.with(collection: "bands") do |m|
  #   m.save
  # end
  # ```
  def with: (::Hash[untyped, untyped] | Mongoid::PersistenceContext options_or_context) { () -> untyped } -> untyped

  def collection: (?untyped parent) -> untyped

  def collection_name: () -> untyped

  def mongo_client: () -> untyped

  def persistence_context: () -> untyped

  def set_persistence_context: (untyped options_or_context) -> untyped

  def clear_persistence_context: (?untyped original_cluster, ?untyped context) -> untyped

  # Get the changed attributes for the document.
  #
  # _@return_ — The changed attributes.
  #
  # Get the changed attributes.
  # ```ruby
  # model.changed
  # ```
  def changed: () -> ::Array[String]

  # Has the document changed?
  #
  # _@return_ — If the document is changed.
  #
  # Has the document changed?
  # ```ruby
  # model.changed?
  # ```
  def changed?: () -> bool

  # Have any children (embedded documents) of this document changed?
  #
  # _@return_ — If any children have changed.
  #
  # Have any children changed?
  # ```ruby
  # model.children_changed?
  # ```
  def children_changed?: () -> bool

  # Get the attribute changes.
  #
  # _@return_ — The attribute changes.
  #
  # Get the attribute changes.
  # ```ruby
  # model.changed_attributes
  # ```
  def changed_attributes: () -> ::Hash[String, Object]

  # Get all the changes for the document.
  #
  # _@return_ — The changes.
  #
  # Get all the changes.
  # ```ruby
  # model.changes
  # ```
  def changes: () -> ::Hash[String, ::Array[Object | Object]]

  # Call this method after save, so the changes can be properly switched.
  #
  # This will unset the memoized children array, set new record to
  # false, set the document as validated, and move the dirty changes.
  #
  # Move the changes to previous.
  # ```ruby
  # person.move_changes
  # ```
  def move_changes: () -> untyped

  # Things that need to execute after a document has been persisted.
  #
  # Handle post persistence.
  # ```ruby
  # document.post_persist
  # ```
  def post_persist: () -> untyped

  # Get the previous changes on the document.
  #
  # _@return_ — The previous changes.
  #
  # Get the previous changes.
  # ```ruby
  # model.previous_changes
  # ```
  def previous_changes: () -> ::Hash[String, ::Array[Object | Object]]

  # Remove a change from the dirty attributes hash. Used by the single field
  # atomic updators.
  #
  # _@param_ `name` — The name of the field.
  #
  # Remove a flagged change.
  # ```ruby
  # model.remove_change(:field)
  # ```
  def remove_change: (Symbol | String name) -> untyped

  # Gets all the new values for each of the changed fields, to be passed to
  # a MongoDB $set modifier.
  #
  # _@return_ — A +Hash+ of atomic setters.
  #
  # Get the setters for the atomic updates.
  # ```ruby
  # person = Person.new(:title => "Sir")
  # person.title = "Madam"
  # person.setters # returns { "title" => "Madam" }
  # ```
  def setters: () -> ::Hash[untyped, untyped]

  # Get the old and new value for the provided attribute.
  #
  # _@param_ `attr` — The name of the attribute.
  #
  # _@return_ — The old and new values.
  #
  # Get the attribute change.
  # ```ruby
  # model.attribute_change("name")
  # ```
  def attribute_change: (String attr) -> ::Array[Object]

  # Determine if a specific attribute has changed.
  #
  # _@param_ `attr` — The name of the attribute.
  #
  # _@return_ — Whether the attribute has changed.
  #
  # Has the attribute changed?
  # ```ruby
  # model.attribute_changed?("name")
  # ```
  def attribute_changed?: (String attr) -> bool

  # Get whether or not the field has a different value from the default.
  #
  # _@param_ `attr` — The name of the attribute.
  #
  # _@return_ — If the attribute differs.
  #
  # Is the field different from the default?
  # ```ruby
  # model.attribute_changed_from_default?
  # ```
  def attribute_changed_from_default?: (String attr) -> bool

  # Get the previous value for the attribute.
  #
  # _@param_ `attr` — The attribute name.
  #
  # Get the previous value.
  # ```ruby
  # model.attribute_was("name")
  # ```
  def attribute_was: (String attr) -> untyped

  # Flag an attribute as going to change.
  #
  # _@param_ `attr` — The name of the attribute.
  #
  # _@return_ — The old value.
  #
  # Flag the attribute.
  # ```ruby
  # model.attribute_will_change!("name")
  # ```
  def attribute_will_change!: (String attr) -> Object

  # Set the attribute back to its old value.
  #
  # _@param_ `attr` — The name of the attribute.
  #
  # _@return_ — The old value.
  #
  # Reset the attribute.
  # ```ruby
  # model.reset_attribute!("name")
  # ```
  def reset_attribute!: (String attr) -> Object

  def reset_attribute_to_default!: (untyped attr) -> untyped

  # Add the document as an atomic pull.
  #
  # _@param_ `document` — The embedded document to pull.
  #
  # Add the atomic pull.
  # ```ruby
  # person.add_atomic_pull(address)
  # ```
  def add_atomic_pull: (Document document) -> untyped

  # Add an atomic unset for the document.
  #
  # _@param_ `document` — The child document.
  #
  # _@return_ — The children.
  #
  # Add an atomic unset.
  # ```ruby
  # document.add_atomic_unset(doc)
  # ```
  def add_atomic_unset: (Document document) -> ::Array[Document]

  # Returns path of the attribute for modification
  #
  # _@return_ — The path to the document attribute in the database
  #
  # Get path of the attribute
  # ```ruby
  # address.atomic_attribute_name(:city)
  # ```
  def atomic_attribute_name: (untyped name) -> String

  # For array fields these are the pushes that need to happen.
  #
  # _@return_ — The array pushes.
  #
  # Get the array pushes.
  # ```ruby
  # person.atomic_array_pushes
  # ```
  def atomic_array_pushes: () -> ::Hash[untyped, untyped]

  # For array fields these are the pulls that need to happen.
  #
  # _@return_ — The array pulls.
  #
  # Get the array pulls.
  # ```ruby
  # person.atomic_array_pulls
  # ```
  def atomic_array_pulls: () -> ::Hash[untyped, untyped]

  # For array fields these are the unique adds that need to happen.
  #
  # _@return_ — The array add_to_sets.
  #
  # Get the array unique adds.
  # ```ruby
  # person.atomic_array_add_to_sets
  # ```
  def atomic_array_add_to_sets: () -> ::Hash[untyped, untyped]

  # Get all the atomic updates that need to happen for the current
  # +Document+. This includes all changes that need to happen in the
  # entire hierarchy that exists below where the save call was made.
  #
  # _@return_ — The updates and their modifiers.
  #
  # Get the updates that need to occur.
  # ```ruby
  # person.atomic_updates(children)
  # ```
  #
  # _@note_ — MongoDB does not allow "conflicting modifications" to be
  # performed in a single operation. Conflicting modifications are
  # detected by the 'haveConflictingMod' function in MongoDB.
  # Examination of the code suggests that two modifications (a $set
  # and a $push with $each, for example) conflict if:
  #   (1) the key paths being modified are equal.
  #   (2) one key path is a prefix of the other.
  # So a $set of 'addresses.0.street' will conflict with a $push and $each
  # to 'addresses', and we will need to split our update into two
  # pieces. We do not, however, attempt to match MongoDB's logic
  # exactly. Instead, we assume that two updates conflict if the
  # first component of the two key paths matches.
  def atomic_updates: (?untyped _use_indexes) -> ::Hash[untyped, untyped]

  # Get the removal modifier for the document. Will be nil on root
  # documents, $unset on embeds_one, $set on embeds_many.
  #
  # _@return_ — The pull or unset operation.
  #
  # Get the removal operator.
  # ```ruby
  # name.atomic_delete_modifier
  # ```
  def atomic_delete_modifier: () -> String

  # Get the insertion modifier for the document. Will be nil on root
  # documents, $set on embeds_one, $push on embeds_many.
  #
  # _@return_ — The pull or set operator.
  #
  # Get the insert operation.
  # ```ruby
  # name.atomic_insert_modifier
  # ```
  def atomic_insert_modifier: () -> String

  # Return the path to this +Document+ in JSON notation, used for atomic
  # updates via $set in MongoDB.
  #
  # _@return_ — The path to the document in the database.
  #
  # Get the path to this document.
  # ```ruby
  # address.atomic_path
  # ```
  def atomic_path: () -> String

  # Returns the positional operator of this document for modification.
  #
  # _@return_ — The positional operator with indexes.
  #
  # Get the positional operator.
  # ```ruby
  # address.atomic_position
  # ```
  def atomic_position: () -> String

  # Get the atomic paths utility for this document.
  #
  # _@return_ — The associated path.
  #
  # Get the atomic paths.
  # ```ruby
  # document.atomic_paths
  # ```
  def atomic_paths: () -> Object

  # Get all the attributes that need to be pulled.
  #
  # _@return_ — The $pullAll operations.
  #
  # Get the pulls.
  # ```ruby
  # person.atomic_pulls
  # ```
  def atomic_pulls: () -> ::Array[::Hash[untyped, untyped]]

  # Get all the push attributes that need to occur.
  #
  # _@return_ — The $push and $each operations.
  #
  # Get the pushes.
  # ```ruby
  # person.atomic_pushes
  # ```
  def atomic_pushes: () -> ::Hash[untyped, untyped]

  # Get all the attributes that need to be set.
  #
  # _@return_ — The $set operations.
  #
  # Get the sets.
  # ```ruby
  # person.atomic_sets
  # ```
  def atomic_sets: () -> ::Hash[untyped, untyped]

  # Get all the attributes that need to be unset.
  #
  # _@return_ — The $unset operations.
  #
  # Get the unsets.
  # ```ruby
  # person.atomic_unsets
  # ```
  def atomic_unsets: () -> ::Array[::Hash[untyped, untyped]]

  # Get all the atomic sets that have had their saves delayed.
  #
  # _@return_ — The delayed $sets.
  #
  # Get the delayed atomic sets.
  # ```ruby
  # person.delayed_atomic_sets
  # ```
  def delayed_atomic_sets: () -> ::Hash[untyped, untyped]

  # Get a hash of atomic pulls that are pending.
  #
  # _@return_ — name/document pairs.
  #
  # Get the atomic pulls.
  # ```ruby
  # document.delayed_atomic_pulls
  # ```
  def delayed_atomic_pulls: () -> ::Hash[untyped, untyped]

  # Get the delayed atomic unsets.
  #
  # _@return_ — The atomic unsets
  #
  # Get the delayed atomic unsets.
  # ```ruby
  # document.delayed_atomic_unsets
  # ```
  def delayed_atomic_unsets: () -> ::Hash[untyped, untyped]

  # Flag the document as destroyed and return the atomic path.
  #
  # _@return_ — The atomic path.
  #
  # Flag destroyed and return path.
  # ```ruby
  # document.flag_as_destroyed
  # ```
  def flag_as_destroyed: () -> String

  # Get the flagged destroys.
  #
  # _@return_ — The flagged destroys.
  #
  # Get the flagged destroy.
  # ```ruby
  # document.flagged_destroys
  # ```
  def flagged_destroys: () -> ::Array[Proc]

  # Process all the pending flagged destroys from nested attributes.
  #
  # _@return_ — The cleared array.
  #
  # Process all the pending flagged destroys.
  # ```ruby
  # document.process_flagged_destroys
  # ```
  def process_flagged_destroys: () -> ::Array[untyped]

  # Generates the atomic updates in the correct order.
  #
  # _@param_ `mods` — The atomic modifications.
  #
  # _@param_ `doc` — The document to update for.
  #
  # Generate the updates.
  # ```ruby
  # model.generate_atomic_updates(mods, doc)
  # ```
  def generate_atomic_updates: (Modifiers mods, Document doc) -> untyped

  # Get the atomic updates for a touch operation. Should only include the
  # updated_at field and the optional extra field.
  #
  # _@param_ `field` — The optional field.
  #
  # _@return_ — The atomic updates.
  #
  # Get the touch atomic updates.
  # ```ruby
  # document.touch_atomic_updates
  # ```
  def touch_atomic_updates: (?Symbol? field) -> ::Hash[untyped, untyped]
end

Mongoid::Document::ILLEGAL_KEY: untyped

Mongoid::Document::MODULES: untyped

Mongoid::Document::RESERVED_METHOD_NAMES: untyped

Mongoid::Document::CALLBACKS: untyped

Mongoid::Document::MACRO_MAPPING: untyped

Mongoid::Document::STRATEGIES: untyped

Mongoid::Document::LIST_OPERATIONS: untyped

Mongoid::Document::StringifiedSymbol: untyped

Mongoid::Document::Boolean: untyped

Mongoid::Document::TYPE_MAPPINGS: untyped

Mongoid::Document::IDS: untyped

Mongoid::Document::CREATE_LOCK: untyped

Mongoid::Document::UPDATES: untyped

module Mongoid::Document::ClassMethods
  # Returns the value of attribute __selected_fields.
  #
  # Returns the value of attribute new_record.
  #
  # Performs class equality checking.
  #
  # _@param_ `other` — The other object to compare with.
  #
  # _@return_ — True if the classes are equal, false if not.
  #
  # Compare the classes.
  # ```ruby
  # document === other
  # ```
  def ===: () -> untyped
         | () -> untyped
         | (Document | Object other) -> bool

  # Instantiate a new object, only when loaded from the database or when
  # the attributes have already been typecast.
  #
  # _@param_ `attrs` — The hash of attributes to instantiate with.
  #
  # _@param_ `selected_fields` — The selected fields from the criteria.
  #
  # _@return_ — A new document.
  #
  # Create the document.
  # ```ruby
  # Person.instantiate(:title => "Sir", :age => 30)
  # ```
  def instantiate: (?::Hash[untyped, untyped]? attrs, ?Integer? selected_fields) -> Document

  # Returns all types to query for when using this class as the base.
  #
  # _@return_ — All subclasses of the current document.
  #
  # Get the types.
  # ```ruby
  # document._types
  # ```
  def _types: () -> ::Array[Class]

  # Clear the @_type cache. This is generally called when changing the discriminator
  # key/value on a class.
  #
  # Get the types.
  # ```ruby
  # document._mongoid_clear_types
  # ```
  def _mongoid_clear_types: () -> untyped

  # Set the i18n scope to overwrite ActiveModel.
  #
  # _@return_ — :mongoid
  def i18n_scope: () -> Symbol

  # Returns the logger
  #
  # _@return_ — The configured logger or a default Logger instance.
  #
  # Get the logger.
  # ```ruby
  # Person.logger
  # ```
  def logger: () -> Logger
end

# This module contains the behavior of Mongoid's clone/dup of documents.
module Mongoid::Equality
  # Default comparison is via the string version of the id.
  #
  # _@param_ `other` — The document to compare with.
  #
  # _@return_ — -1, 0, 1.
  #
  # Compare two documents.
  # ```ruby
  # person <=> other_person
  # ```
  def <=>: (Document other) -> Integer

  # Performs equality checking on the document ids. For more robust
  # equality checking please override this method.
  #
  # _@param_ `other` — The other object to compare with.
  #
  # _@return_ — True if the ids are equal, false if not.
  #
  # Compare for equality.
  # ```ruby
  # document == other
  # ```
  def ==: (Document | Object other) -> bool

  # Performs class equality checking.
  #
  # _@param_ `other` — The other object to compare with.
  #
  # _@return_ — True if the classes are equal, false if not.
  #
  # Compare the classes.
  # ```ruby
  # document === other
  # ```
  def ===: (Document | Object other) -> bool

  # Delegates to ==. Used when needing checks in hashes.
  #
  # _@param_ `other` — The object to check against.
  #
  # _@return_ — True if equal, false if not.
  #
  # Perform equality checking.
  # ```ruby
  # document.eql?(other)
  # ```
  def eql?: (Document | Object other) -> bool
end

# This module defines the finder methods that hang off the document at the
# class level.
#
# @since 4.0.0
module Mongoid::Findable
  extend Forwardable

  # Returns a count of records in the database.
  # If you want to specify conditions use where.
  #
  # _@return_ — The number of matching documents.
  #
  # Get the count of matching documents.
  # ```ruby
  # Person.count
  # Person.where(title: "Sir").count
  # ```
  def count: () -> Integer

  # Returns an estimated count of records in the database.
  #
  # _@return_ — The number of matching documents.
  #
  # Get the count of matching documents.
  # ```ruby
  # Person.estimated_count
  # ```
  def estimated_count: () -> Integer

  # Returns true if count is zero
  #
  # _@return_ — If the collection is empty.
  #
  # Are there no saved documents for this model?
  # ```ruby
  # Person.empty?
  # ```
  def empty?: () -> bool

  # Returns true if there are on document in database based on the
  # provided arguments.
  #
  # _@return_ — If any documents exist for the conditions.
  #
  # Do any documents exist for the conditions?
  # ```ruby
  # Person.exists?
  # ```
  def exists?: () -> bool

  # Finds a +Document+ or multiple documents by their _id values.
  #
  # If a single non-Array argument is given, this argument is interpreted
  # as the _id value of a document to find. If there is a matching document
  # in the database, this document is returned; otherwise, if the
  # +raise_not_found_error+ Mongoid configuration option is truthy
  # (which is the default), +Errors::DocumentNotFound+ is raised, and if
  # +raise_not_found_error+ is falsy, +find+ returns +nil+.
  #
  # If multiple arguments are given, or an Array argument is given, the
  # array is flattened and each array element is interpreted as the _id
  # value of the document to find. Mongoid then attempts to retrieve all
  # documents with the provided _id values. The return value is an array
  # of found documents. Each document appears one time in the returned array,
  # even if its _id is given multiple times in the argument to +find+.
  # If the +raise_not_found_error+ Mongoid configuration option is truthy,
  # +Errors::DocumentNotFound+ exception is raised if any of the specified
  # _ids were not found in the database. If the ++raise_not_found_error+
  # Mongoid configuration option is falsy, only those documents which are
  # found are returned; if no documents are found, the return value is an
  # empty array.
  #
  # Note that MongoDB does not allow the _id field to be an array.
  #
  # The argument undergoes customary Mongoid type conversions based on
  # the type declared for the _id field. By default the _id field is a
  # +BSON::ObjectId+; this allows strings to be passed to +find+ and the
  # strings will be transparently converted to +BSON::ObjectId+ instances
  # during query construction.
  #
  # The +find+ method takes into account the default scope defined on the
  # model class, if any.
  #
  # _@param_ `args` — The _id values to find or an array thereof.
  #
  # _@return_ — A document or matching documents.
  def find: (*Object | ::Array[Object] args) -> (Document | ::Array[Document])?

  # Find the first +Document+ given the conditions.
  # If a matching Document is not found and
  # Mongoid.raise_not_found_error is true it raises
  # Mongoid::Errors::DocumentNotFound, return null nil elsewise.
  #
  # and Mongoid.raise_not_found_error is true.
  #
  # _@param_ `attrs` — The attributes to check.
  #
  # _@return_ — A matching document.
  #
  # Find the document by attribute other than id
  # ```ruby
  # Person.find_by(:username => "superuser")
  # ```
  def find_by: (?::Hash[untyped, untyped] attrs) -> Document?

  # Find the first +Document+ given the conditions, or raises
  # Mongoid::Errors::DocumentNotFound
  #
  # _@param_ `attrs` — The attributes to check.
  #
  # _@return_ — A matching document.
  #
  # Find the document by attribute other than id
  # ```ruby
  # Person.find_by(:username => "superuser")
  # ```
  def find_by!: (?::Hash[untyped, untyped] attrs) -> Document

  # Find the first +Document+ given the conditions.
  #
  # _@return_ — The first matching document.
  #
  # Find the first document.
  # ```ruby
  # Person.first
  # ```
  def first: () -> Document

  # Find the last +Document+ given the conditions.
  #
  # _@return_ — The last matching document.
  #
  # Find the last document.
  # ```ruby
  # Person.last
  # ```
  def last: () -> Document
end

# Contains logging behavior.
module Mongoid::Loggable
  # Get the logger.
  #
  # _@return_ — The logger.
  #
  # Get the logger.
  # ```ruby
  # Loggable.logger
  # ```
  #
  # _@note_ — Will try to grab Rails' logger first before creating a new logger
  # with stderr.
  def logger: () -> Logger

  # Set the logger.
  #
  # _@param_ `logger` — The logger to set.
  #
  # _@return_ — The new logger.
  #
  # Set the logger.
  # ```ruby
  # Loggable.logger = Logger.new(STDERR)
  # ```
  def logger=: (Logger logger) -> Logger

  # Gets the default Mongoid logger - stderr.
  #
  # _@return_ — The default logger.
  #
  # Get the default logger.
  # ```ruby
  # Loggable.default_logger
  # ```
  def default_logger: () -> Logger

  # Get the Rails logger if loaded in a Rails application, otherwise nil.
  #
  # _@return_ — The Rails logger.
  #
  # Get Rails' logger.
  # ```ruby
  # Loggable.rails_logger
  # ```
  def rails_logger: () -> Logger
end

# This module contains behavior for all Mongoid scoping - named scopes,
# default scopes, and criteria accessors via scoped and unscoped.
#
# @since 4.0.0
module Mongoid::Scopable
  extend ActiveSupport::Concern

  # Apply the default scoping to the attributes of the document, as long as
  # they are not complex queries.
  #
  # _@return_ — If default scoping was applied.
  #
  # Apply the default scoping.
  # ```ruby
  # document.apply_default_scoping
  # ```
  def apply_default_scoping: () -> bool
end

module Mongoid::Scopable::ClassMethods
  # Returns a hash of all the scopes defined for this class, including
  # scopes defined on ancestor classes.
  #
  # _@return_ — The scopes defined for this class
  #
  # Get the defined scopes for a class
  # ```ruby
  # class Band
  #   include Mongoid::Document
  #   field :active, type: Boolean
  #
  #   scope :active, -> { where(active: true) }
  # end
  # Band.scopes
  # ```
  def scopes: () -> ::Hash[untyped, untyped]

  # Add a default scope to the model. This scope will be applied to all
  # criteria unless #unscoped is specified.
  #
  # _@param_ `value` — The default scope.
  #
  # _@return_ — The default scope.
  #
  # Define a default scope with a criteria.
  # ```ruby
  # class Band
  #   include Mongoid::Document
  #   field :active, type: Boolean
  #   default_scope where(active: true)
  # end
  # ```
  #
  # Define a default scope with a proc.
  # ```ruby
  # class Band
  #   include Mongoid::Document
  #   field :active, type: Boolean
  #   default_scope ->{ where(active: true) }
  # end
  # ```
  def default_scope: (?(Proc | Criteria)? value) -> Proc

  # Is the class able to have the default scope applied?
  #
  # _@return_ — If the default scope can be applied.
  #
  # Can the default scope be applied?
  # ```ruby
  # Band.default_scopable?
  # ```
  def default_scopable?: () -> bool

  # Get a queryable, either the last one on the scope stack or a fresh one.
  #
  # _@return_ — The queryable.
  #
  # Get a queryable.
  # ```ruby
  # Model.queryable
  # ```
  def queryable: () -> Criteria

  # Create a scope that can be accessed from the class level or chained to
  # criteria by the provided name.
  #
  # _@param_ `name` — The name of the scope.
  #
  # _@param_ `value` — The conditions of the scope.
  #
  # Create named scopes.
  # ```ruby
  #
  # class Person
  #   include Mongoid::Document
  #   field :active, type: Boolean
  #   field :count, type: Integer
  #
  #   scope :active, -> { where(active: true) }
  #   scope :at_least, ->(count){ where(:count.gt => count) }
  # end
  # ```
  def scope: (Symbol name, Proc value) { () -> untyped } -> untyped

  # Get a criteria for the document with normal scoping.
  #
  # _@param_ `options` — Query options for the criteria.
  #
  # _@return_ — A scoped criteria.
  #
  # Get the criteria.
  # ```ruby
  # Band.scoped(skip: 10)
  # ```
  #
  # _@note_ — This will force the default scope to be applied.
  def scoped: (?::Hash[untyped, untyped]? options) -> Criteria

  # Get the criteria without the default scoping applied.
  #
  # _@return_ — The unscoped criteria or result of the
  # block.
  #
  # Get the unscoped criteria.
  # ```ruby
  # Band.unscoped
  # ```
  #
  # Yield to block with no default scoping.
  # ```ruby
  # Band.unscoped do
  #   Band.where(name: "Depeche Mode")
  # end
  # ```
  #
  # _@note_ — This will force the default scope to be removed.
  def unscoped: () -> (Criteria | Object)

  # Get a criteria with the default scope applied, if possible.
  #
  # _@return_ — The criteria.
  #
  # Get a criteria with the default scope.
  # ```ruby
  # Model.with_default_scope
  # ```
  def with_default_scope: () -> Criteria

  # Pushes the provided criteria onto the scope stack, and removes it after the
  # provided block is yielded.
  #
  # _@param_ `criteria` — The criteria to apply.
  #
  # _@return_ — The yielded criteria.
  #
  # Yield to the criteria.
  # ```ruby
  # Person.with_scope(criteria)
  # ```
  def with_scope: (Criteria criteria) -> Criteria

  # Execute the block without applying the default scope.
  #
  # _@return_ — The result of the block.
  #
  # Execute without the default scope.
  # ```ruby
  # Band.without_default_scope do
  #   Band.where(name: "Depeche Mode")
  # end
  # ```
  def without_default_scope: () -> Object

  # Warns or raises exception if overriding another scope or method.
  #
  # _@param_ `name` — The name of the scope.
  #
  # Warn or raise error if name exists.
  # ```ruby
  # Model.valid_scope_name?("test")
  # ```
  def check_scope_name: (String | Symbol name) -> untyped

  # Checks if the intended scope is a valid object, either a criteria or
  # proc with a criteria.
  #
  # _@param_ `value` — The intended scope.
  #
  # Check if the scope is valid.
  # ```ruby
  # Model.check_scope_validity({})
  # ```
  def check_scope_validity: (Object value) -> untyped

  # Defines the actual class method that will execute the scope when
  # called.
  #
  # _@param_ `name` — The method/scope name.
  #
  # _@return_ — The defined method.
  #
  # Define the scope class method.
  # ```ruby
  # Model.define_scope_method(:active)
  # ```
  def define_scope_method: (Symbol name) -> Method

  # Process the default scope value. If one already exists, we merge the
  # new one into the old one.
  #
  # _@param_ `value` — The default scope value.
  #
  # Process the default scope.
  # ```ruby
  # Model.process_default_scope(value)
  # ```
  def process_default_scope: (Criteria | Proc value) -> untyped
end

# This module contains the behavior for getting the various states a
# document can transition through.
module Mongoid::Stateful
  # Returns true if the +Document+ has not been persisted to the database,
  # false if it has. This is determined by the variable @new_record
  # and NOT if the object has an id.
  #
  # _@return_ — True if new, false if not.
  #
  # Is the document new?
  # ```ruby
  # person.new_record?
  # ```
  def new_record?: () -> bool

  # Checks if the document has been saved to the database. Returns false
  # if the document has been destroyed.
  #
  # _@return_ — True if persisted, false if not.
  #
  # Is the document persisted?
  # ```ruby
  # person.persisted?
  # ```
  def persisted?: () -> bool

  # Returns whether or not the document has been flagged for deletion, but
  # not destroyed yet. Used for atomic pulls of child documents.
  #
  # _@return_ — If the document is flagged.
  #
  # Is the document flagged?
  # ```ruby
  # document.flagged_for_destroy?
  # ```
  def flagged_for_destroy?: () -> bool

  # Returns true if the +Document+ has been succesfully destroyed, and false
  # if it hasn't. This is determined by the variable @destroyed and NOT
  # by checking the database.
  #
  # _@return_ — True if destroyed, false if not.
  #
  # Is the document destroyed?
  # ```ruby
  # person.destroyed?
  # ```
  def destroyed?: () -> bool

  # Determine if the document can be pushed.
  #
  # _@return_ — Is the document new and embedded?
  #
  # Is this pushable?
  # ```ruby
  # person.pushable?
  # ```
  def pushable?: () -> bool

  # Is the document readonly?
  #
  # _@return_ — If the document is readonly.
  #
  # Is the document readonly?
  # ```ruby
  # document.readonly?
  # ```
  def readonly?: () -> bool

  # Determine if the document can be set.
  #
  # _@return_ — Is this document a new embeds one?
  #
  # Is this settable?
  # ```ruby
  # person.settable?
  # ```
  def settable?: () -> bool

  # Is the document updateable?
  #
  # _@return_ — If the document is changed and persisted.
  #
  # Is the document updateable?
  # ```ruby
  # person.updateable?
  # ```
  def updateable?: () -> bool

  def reset_readonly: () -> untyped
end

# This module contains logic for easy access to objects that have a lifecycle
# on the current thread.
module Mongoid::Threaded
  extend Mongoid::Threaded

  # Sets the attribute destroyed
  #
  # _@param_ `value` — the value to set the attribute destroyed to.
  #
  # Sets the attribute flagged_for_destroy
  #
  # _@param_ `value` — the value to set the attribute flagged_for_destroy to.
  #
  # Sets the attribute new_record
  #
  # _@param_ `value` — the value to set the attribute new_record to.
  #
  # Begin entry into a named thread local stack.
  #
  # _@param_ `name` — The name of the stack
  #
  # _@return_ — True.
  #
  # Begin entry into the stack.
  # ```ruby
  # Threaded.begin_execution(:create)
  # ```
  def begin_execution: (untyped name) -> untyped
                     | (untyped name) -> untyped
                     | (untyped name) -> untyped
                     | (String name) -> bool

  # Get the global database override.
  #
  # _@return_ — The override.
  #
  # Get the global database override.
  # ```ruby
  # Threaded.database_override
  # ```
  def database_override: () -> (String | Symbol)

  # Set the global database override.
  #
  # _@param_ `name` — The global override name.
  #
  # _@return_ — The override.
  #
  # Set the global database override.
  # ```ruby
  # Threaded.database_override = :testing
  # ```
  def database_override=: (String | Symbol name) -> (String | Symbol)

  # Are in the middle of executing the named stack
  #
  # _@param_ `name` — The name of the stack
  #
  # _@return_ — If the stack is being executed.
  #
  # Are we in the stack execution?
  # ```ruby
  # Threaded.executing?(:create)
  # ```
  def executing?: (Symbol name) -> bool

  # Exit from a named thread local stack.
  #
  # _@param_ `name` — The name of the stack
  #
  # _@return_ — True.
  #
  # Exit from the stack.
  # ```ruby
  # Threaded.exit_execution(:create)
  # ```
  def exit_execution: (Symbol name) -> bool

  # Get the named stack.
  #
  # _@param_ `name` — The name of the stack
  #
  # _@return_ — The stack.
  #
  # Get a stack by name
  # ```ruby
  # Threaded.stack(:create)
  # ```
  def stack: (Symbol name) -> ::Array[untyped]

  # Begin autosaving a document on the current thread.
  #
  # _@param_ `document` — The document to autosave.
  #
  # Begin autosave.
  # ```ruby
  # Threaded.begin_autosave(doc)
  # ```
  def begin_autosave: (Document document) -> untyped

  # Begin validating a document on the current thread.
  #
  # _@param_ `document` — The document to validate.
  #
  # Begin validation.
  # ```ruby
  # Threaded.begin_validate(doc)
  # ```
  def begin_validate: (Document document) -> untyped

  # Exit autosaving a document on the current thread.
  #
  # _@param_ `document` — The document to autosave.
  #
  # Exit autosave.
  # ```ruby
  # Threaded.exit_autosave(doc)
  # ```
  def exit_autosave: (Document document) -> untyped

  # Exit validating a document on the current thread.
  #
  # _@param_ `document` — The document to validate.
  #
  # Exit validation.
  # ```ruby
  # Threaded.exit_validate(doc)
  # ```
  def exit_validate: (Document document) -> untyped

  # Begin suppressing default scopes for given model on the current thread.
  #
  # _@param_ `klass` — The model to suppress default scoping on.
  #
  # Begin without default scope stack.
  # ```ruby
  # Threaded.begin_without_default_scope(klass)
  # ```
  def begin_without_default_scope: (Class klass) -> untyped

  # Exit suppressing default scopes for given model on the current thread.
  #
  # _@param_ `klass` — The model to unsuppress default scoping on.
  #
  # Exit without default scope stack.
  # ```ruby
  # Threaded.exit_without_default_scope(klass)
  # ```
  def exit_without_default_scope: (Class klass) -> untyped

  # Get the global client override.
  #
  # _@return_ — The override.
  #
  # Get the global client override.
  # ```ruby
  # Threaded.client_override
  # ```
  def client_override: () -> (String | Symbol)

  # Set the global client override.
  #
  # _@param_ `name` — The global override name.
  #
  # _@return_ — The override.
  #
  # Set the global client override.
  # ```ruby
  # Threaded.client_override = :testing
  # ```
  def client_override=: (String | Symbol name) -> (String | Symbol)

  # Get the current Mongoid scope.
  #
  # _@param_ `klass` — The class type of the scope.
  #
  # _@return_ — The scope.
  #
  # Get the scope.
  # ```ruby
  # Threaded.current_scope(klass)
  # Threaded.current_scope
  # ```
  def current_scope: (?Class? klass) -> Criteria

  # Set the current Mongoid scope.
  #
  # _@param_ `scope` — The current scope.
  #
  # _@return_ — The scope.
  #
  # Set the scope.
  # ```ruby
  # Threaded.current_scope = scope
  # ```
  def current_scope=: (Criteria scope) -> Criteria

  # Set the current Mongoid scope. Safe for multi-model scope chaining.
  #
  # _@param_ `scope` — The current scope.
  #
  # _@param_ `klass` — The current model class.
  #
  # _@return_ — The scope.
  #
  # Set the scope.
  # ```ruby
  # Threaded.current_scope(scope, klass)
  # ```
  def set_current_scope: (Criteria scope, Class klass) -> Criteria

  # Is the given klass' default scope suppressed on the current thread?
  #
  # _@param_ `klass` — The model to check for default scope suppression.
  #
  # Is the given klass' default scope suppressed?
  # ```ruby
  # Threaded.without_default_scope?(klass)
  # ```
  def without_default_scope?: (Class klass) -> bool

  # Is the document autosaved on the current thread?
  #
  # _@param_ `document` — The document to check.
  #
  # _@return_ — If the document is autosaved.
  #
  # Is the document autosaved?
  # ```ruby
  # Threaded.autosaved?(doc)
  # ```
  def autosaved?: (Document document) -> bool

  # Is the document validated on the current thread?
  #
  # _@param_ `document` — The document to check.
  #
  # _@return_ — If the document is validated.
  #
  # Is the document validated?
  # ```ruby
  # Threaded.validated?(doc)
  # ```
  def validated?: (Document document) -> bool

  # Get all autosaves on the current thread.
  #
  # _@return_ — The current autosaves.
  #
  # Get all autosaves.
  # ```ruby
  # Threaded.autosaves
  # ```
  def autosaves: () -> ::Hash[untyped, untyped]

  # Get all validations on the current thread.
  #
  # _@return_ — The current validations.
  #
  # Get all validations.
  # ```ruby
  # Threaded.validations
  # ```
  def validations: () -> ::Hash[untyped, untyped]

  # Get all autosaves on the current thread for the class.
  #
  # _@param_ `klass` — The class to check.
  #
  # _@return_ — The current autosaves.
  #
  # Get all autosaves.
  # ```ruby
  # Threaded.autosaves_for(Person)
  # ```
  def autosaves_for: (Class klass) -> ::Array[untyped]

  # Get all validations on the current thread for the class.
  #
  # _@param_ `klass` — The class to check.
  #
  # _@return_ — The current validations.
  #
  # Get all validations.
  # ```ruby
  # Threaded.validations_for(Person)
  # ```
  def validations_for: (Class klass) -> ::Array[untyped]

  # sord warn - Mongo::Session wasn't able to be resolved to a constant in this project
  # Cache a session for this thread.
  #
  # _@param_ `session` — The session to save.
  #
  # Save a session for this thread.
  # ```ruby
  # Threaded.set_session(session)
  # ```
  def set_session: (Mongo::Session session) -> untyped

  # sord warn - Mongo::Session wasn't able to be resolved to a constant in this project
  # Get the cached session for this thread.
  #
  # _@return_ — The session cached on this thread or nil.
  #
  # Get the session for this thread.
  # ```ruby
  # Threaded.get_session
  # ```
  def get_session: () -> Mongo::Session?

  # Clear the cached session for this thread.
  #
  # Clear this thread's session.
  # ```ruby
  # Threaded.clear_session
  # ```
  def clear_session: () -> nil

  # Begin entry into a named thread local stack.
  #
  # _@param_ `name` — The name of the stack
  #
  # _@return_ — True.
  #
  # Begin entry into the stack.
  # ```ruby
  # Threaded.begin_execution(:create)
  # ```
  def self.begin_execution: (String name) -> bool

  # Get the global database override.
  #
  # _@return_ — The override.
  #
  # Get the global database override.
  # ```ruby
  # Threaded.database_override
  # ```
  def self.database_override: () -> (String | Symbol)

  # Set the global database override.
  #
  # _@param_ `name` — The global override name.
  #
  # _@return_ — The override.
  #
  # Set the global database override.
  # ```ruby
  # Threaded.database_override = :testing
  # ```
  def self.database_override=: (String | Symbol name) -> (String | Symbol)

  # Are in the middle of executing the named stack
  #
  # _@param_ `name` — The name of the stack
  #
  # _@return_ — If the stack is being executed.
  #
  # Are we in the stack execution?
  # ```ruby
  # Threaded.executing?(:create)
  # ```
  def self.executing?: (Symbol name) -> bool

  # Exit from a named thread local stack.
  #
  # _@param_ `name` — The name of the stack
  #
  # _@return_ — True.
  #
  # Exit from the stack.
  # ```ruby
  # Threaded.exit_execution(:create)
  # ```
  def self.exit_execution: (Symbol name) -> bool

  # Get the named stack.
  #
  # _@param_ `name` — The name of the stack
  #
  # _@return_ — The stack.
  #
  # Get a stack by name
  # ```ruby
  # Threaded.stack(:create)
  # ```
  def self.stack: (Symbol name) -> ::Array[untyped]

  # Begin autosaving a document on the current thread.
  #
  # _@param_ `document` — The document to autosave.
  #
  # Begin autosave.
  # ```ruby
  # Threaded.begin_autosave(doc)
  # ```
  def self.begin_autosave: (Document document) -> untyped

  # Begin validating a document on the current thread.
  #
  # _@param_ `document` — The document to validate.
  #
  # Begin validation.
  # ```ruby
  # Threaded.begin_validate(doc)
  # ```
  def self.begin_validate: (Document document) -> untyped

  # Exit autosaving a document on the current thread.
  #
  # _@param_ `document` — The document to autosave.
  #
  # Exit autosave.
  # ```ruby
  # Threaded.exit_autosave(doc)
  # ```
  def self.exit_autosave: (Document document) -> untyped

  # Exit validating a document on the current thread.
  #
  # _@param_ `document` — The document to validate.
  #
  # Exit validation.
  # ```ruby
  # Threaded.exit_validate(doc)
  # ```
  def self.exit_validate: (Document document) -> untyped

  # Begin suppressing default scopes for given model on the current thread.
  #
  # _@param_ `klass` — The model to suppress default scoping on.
  #
  # Begin without default scope stack.
  # ```ruby
  # Threaded.begin_without_default_scope(klass)
  # ```
  def self.begin_without_default_scope: (Class klass) -> untyped

  # Exit suppressing default scopes for given model on the current thread.
  #
  # _@param_ `klass` — The model to unsuppress default scoping on.
  #
  # Exit without default scope stack.
  # ```ruby
  # Threaded.exit_without_default_scope(klass)
  # ```
  def self.exit_without_default_scope: (Class klass) -> untyped

  # Get the global client override.
  #
  # _@return_ — The override.
  #
  # Get the global client override.
  # ```ruby
  # Threaded.client_override
  # ```
  def self.client_override: () -> (String | Symbol)

  # Set the global client override.
  #
  # _@param_ `name` — The global override name.
  #
  # _@return_ — The override.
  #
  # Set the global client override.
  # ```ruby
  # Threaded.client_override = :testing
  # ```
  def self.client_override=: (String | Symbol name) -> (String | Symbol)

  # Get the current Mongoid scope.
  #
  # _@param_ `klass` — The class type of the scope.
  #
  # _@return_ — The scope.
  #
  # Get the scope.
  # ```ruby
  # Threaded.current_scope(klass)
  # Threaded.current_scope
  # ```
  def self.current_scope: (?Class? klass) -> Criteria

  # Set the current Mongoid scope.
  #
  # _@param_ `scope` — The current scope.
  #
  # _@return_ — The scope.
  #
  # Set the scope.
  # ```ruby
  # Threaded.current_scope = scope
  # ```
  def self.current_scope=: (Criteria scope) -> Criteria

  # Set the current Mongoid scope. Safe for multi-model scope chaining.
  #
  # _@param_ `scope` — The current scope.
  #
  # _@param_ `klass` — The current model class.
  #
  # _@return_ — The scope.
  #
  # Set the scope.
  # ```ruby
  # Threaded.current_scope(scope, klass)
  # ```
  def self.set_current_scope: (Criteria scope, Class klass) -> Criteria

  # Is the given klass' default scope suppressed on the current thread?
  #
  # _@param_ `klass` — The model to check for default scope suppression.
  #
  # Is the given klass' default scope suppressed?
  # ```ruby
  # Threaded.without_default_scope?(klass)
  # ```
  def self.without_default_scope?: (Class klass) -> bool

  # Is the document autosaved on the current thread?
  #
  # _@param_ `document` — The document to check.
  #
  # _@return_ — If the document is autosaved.
  #
  # Is the document autosaved?
  # ```ruby
  # Threaded.autosaved?(doc)
  # ```
  def self.autosaved?: (Document document) -> bool

  # Is the document validated on the current thread?
  #
  # _@param_ `document` — The document to check.
  #
  # _@return_ — If the document is validated.
  #
  # Is the document validated?
  # ```ruby
  # Threaded.validated?(doc)
  # ```
  def self.validated?: (Document document) -> bool

  # Get all autosaves on the current thread.
  #
  # _@return_ — The current autosaves.
  #
  # Get all autosaves.
  # ```ruby
  # Threaded.autosaves
  # ```
  def self.autosaves: () -> ::Hash[untyped, untyped]

  # Get all validations on the current thread.
  #
  # _@return_ — The current validations.
  #
  # Get all validations.
  # ```ruby
  # Threaded.validations
  # ```
  def self.validations: () -> ::Hash[untyped, untyped]

  # Get all autosaves on the current thread for the class.
  #
  # _@param_ `klass` — The class to check.
  #
  # _@return_ — The current autosaves.
  #
  # Get all autosaves.
  # ```ruby
  # Threaded.autosaves_for(Person)
  # ```
  def self.autosaves_for: (Class klass) -> ::Array[untyped]

  # Get all validations on the current thread for the class.
  #
  # _@param_ `klass` — The class to check.
  #
  # _@return_ — The current validations.
  #
  # Get all validations.
  # ```ruby
  # Threaded.validations_for(Person)
  # ```
  def self.validations_for: (Class klass) -> ::Array[untyped]

  # sord warn - Mongo::Session wasn't able to be resolved to a constant in this project
  # Cache a session for this thread.
  #
  # _@param_ `session` — The session to save.
  #
  # Save a session for this thread.
  # ```ruby
  # Threaded.set_session(session)
  # ```
  def self.set_session: (Mongo::Session session) -> untyped

  # sord warn - Mongo::Session wasn't able to be resolved to a constant in this project
  # Get the cached session for this thread.
  #
  # _@return_ — The session cached on this thread or nil.
  #
  # Get the session for this thread.
  # ```ruby
  # Threaded.get_session
  # ```
  def self.get_session: () -> Mongo::Session?

  # Clear the cached session for this thread.
  #
  # Clear this thread's session.
  # ```ruby
  # Threaded.clear_session
  # ```
  def self.clear_session: () -> nil
end

Mongoid::Threaded::DATABASE_OVERRIDE_KEY: untyped

Mongoid::Threaded::CLIENTS_KEY: untyped

Mongoid::Threaded::CLIENT_OVERRIDE_KEY: untyped

Mongoid::Threaded::CURRENT_SCOPE_KEY: untyped

Mongoid::Threaded::AUTOSAVES_KEY: untyped

Mongoid::Threaded::VALIDATIONS_KEY: untyped

Mongoid::Threaded::STACK_KEYS: untyped

Mongoid::Threaded::BIND: untyped

Mongoid::Threaded::ASSIGN: untyped

Mongoid::Threaded::BUILD: untyped

Mongoid::Threaded::LOAD: untyped

Mongoid::Threaded::CREATE: untyped

# This module contains convenience methods for document lifecycle that
# resides on thread locals.
module Mongoid::Threaded::Lifecycle
  extend ActiveSupport::Concern

  # Begin the assignment of attributes. While in this block embedded
  # documents will not autosave themselves in order to allow the document to
  # be in a valid state.
  #
  # _@return_ — The yielded value.
  #
  # Execute the assignment.
  # ```ruby
  # _assigning do
  #   person.attributes = { :addresses => [ address ] }
  # end
  # ```
  def _assigning: () -> Object

  # Is the current thread in assigning mode?
  #
  # _@return_ — If the thread is assigning.
  #
  # Is the current thread in assigning mode?
  # ```ruby
  # proxy._assigning?
  # ```
  def _assigning?: () -> bool

  # Execute a block in binding mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in binding mode.
  # ```ruby
  # binding do
  #   relation.push(doc)
  # end
  # ```
  def _binding: () -> Object

  # Is the current thread in binding mode?
  #
  # _@return_ — If the thread is binding.
  #
  # Is the current thread in binding mode?
  # ```ruby
  # proxy.binding?
  # ```
  def _binding?: () -> bool

  # Execute a block in building mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in building mode.
  # ```ruby
  # _building do
  #   relation.push(doc)
  # end
  # ```
  def _building: () -> Object

  # Is the current thread in building mode?
  #
  # _@return_ — If the thread is building.
  #
  # Is the current thread in building mode?
  # ```ruby
  # proxy._building?
  # ```
  def _building?: () -> bool

  # Is the current thread in creating mode?
  #
  # _@return_ — If the thread is creating.
  #
  # Is the current thread in creating mode?
  # ```ruby
  # proxy.creating?
  # ```
  def _creating?: () -> bool

  # Execute a block in loading mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in loading mode.
  # ```ruby
  # _loading do
  #   relation.push(doc)
  # end
  # ```
  def _loading: () -> Object

  # Is the current thread in loading mode?
  #
  # _@return_ — If the thread is loading.
  #
  # Is the current thread in loading mode?
  # ```ruby
  # proxy._loading?
  # ```
  def _loading?: () -> bool
end

module Mongoid::Threaded::Mongoid::Threaded::Lifecycle::ClassMethods
  # Execute a block in creating mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in creating mode.
  # ```ruby
  # creating do
  #   relation.push(doc)
  # end
  # ```
  def _creating: () -> Object
end

# Encapsulates behavior around caching.
#
# @since 6.0.0
module Mongoid::Cacheable
  extend ActiveSupport::Concern

  # Print out the cache key. This will append different values on the
  # plural model name.
  #
  # If new_record?     - will append /new
  # If not             - will append /id-updated_at.to_s(cache_timestamp_format)
  # Without updated_at - will append /id
  #
  # This is usually called insode a cache() block
  #
  # _@return_ — the string with or without updated_at
  #
  # Returns the cache key
  # ```ruby
  # document.cache_key
  # ```
  def cache_key: () -> String
end

# Contains behavior specific to evolving for queryable queries.
module Mongoid::Evolvable
  # Evolve the document into an object id.
  #
  # _@return_ — The document's id.
  #
  # Evolve the document.
  # ```ruby
  # document.__evolve_object_id__
  # ```
  def __evolve_object_id__: () -> Object
end

# Encapsulates behavior around defining indexes.
#
# @since 4.0.0
module Mongoid::Indexable
  extend ActiveSupport::Concern
end

module Mongoid::Indexable::ClassMethods
  # Send the actual index creation comments to the MongoDB driver
  #
  # _@return_ — If the operation succeeded.
  #
  # Create the indexes for the class.
  # ```ruby
  # Person.create_indexes
  # ```
  def create_indexes: () -> bool

  # Send the actual index removal comments to the MongoDB driver,
  # but lets _id untouched.
  #
  # _@return_ — If the operation succeeded.
  #
  # Remove the indexes for the class.
  # ```ruby
  # Person.remove_indexes
  # ```
  def remove_indexes: () -> bool

  # Add the default indexes to the root document if they do not already
  # exist. Currently this is only _type.
  #
  # _@return_ — If the operation succeeded.
  #
  # Add Mongoid internal indexes.
  # ```ruby
  # Person.add_indexes
  # ```
  def add_indexes: () -> bool

  # Adds an index definition for the provided single or compound keys.
  #
  # _@param_ `spec` — The index spec.
  #
  # _@param_ `options` — The index options.
  #
  # _@return_ — The index options.
  #
  # Create a basic index.
  # ```ruby
  # class Person
  #   include Mongoid::Document
  #   field :name, type: String
  #   index({ name: 1 }, { background: true })
  # end
  # ```
  def index: (Symbol spec, ?::Hash[untyped, untyped]? options) -> ::Hash[untyped, untyped]

  # sord warn - Mongoid::Indexable::Specification wasn't able to be resolved to a constant in this project
  # Get an index specification for the provided key.
  #
  # _@param_ `index_hash` — The index key/direction pair.
  #
  # _@param_ `index_name` — The index name.
  #
  # _@return_ — The found specification.
  #
  # Get the index specification.
  # ```ruby
  # Model.index_specification(name: 1)
  # ```
  def index_specification: (::Hash[untyped, untyped] index_hash, ?String? index_name) -> untyped

  # Get the names of all databases for this model that have index
  # definitions.
  #
  # _@return_ — The names.
  #
  # Get the indexed database names.
  # ```ruby
  # Model.indexed_database_names
  # ```
  def indexed_database_names: () -> ::Array[String]

  # Gets a list of index specification keys.
  #
  # _@return_ — The specification keys.
  #
  # Get the specification key list.
  # ```ruby
  # Model.index_keys
  # ```
  def index_keys: () -> ::Array[::Hash[untyped, untyped]]
end

module Mongoid::Indexable::Validators
end

# Validates the options passed to the index macro.
module Mongoid::Indexable::Mongoid::Indexable::Validators::Options
  extend Mongoid::Indexable::Validators::Options

  # Validate the index specification.
  #
  # _@param_ `klass` — The model class.
  #
  # _@param_ `spec` — The index specification.
  #
  # _@param_ `options` — The index options.
  #
  # Validate the index spec.
  # ```ruby
  # Options.validate(Band, name: 1)
  # ```
  def validate: (Class klass, ::Hash[untyped, untyped] spec, ::Hash[untyped, untyped] options) -> untyped

  # Validates the options of the index spec.
  #
  # _@param_ `klass` — The model class.
  #
  # _@param_ `spec` — The index specification.
  #
  # _@param_ `options` — The index options.
  #
  # Validate the options.
  # ```ruby
  # Options.validate_options(Band, name: 1)
  # ```
  def validate_options: (Class klass, ::Hash[untyped, untyped] spec, ::Hash[untyped, untyped] options) -> untyped

  # Validates the index spec.
  #
  # _@param_ `klass` — The model class.
  #
  # _@param_ `spec` — The index specification.
  #
  # _@param_ `options` — The index options.
  #
  # Validate the spec.
  # ```ruby
  # Options.validate_spec(Band, name: 1)
  # ```
  def validate_spec: (Class klass, ::Hash[untyped, untyped] spec, ::Hash[untyped, untyped] options) -> untyped

  # Validate the index specification.
  #
  # _@param_ `klass` — The model class.
  #
  # _@param_ `spec` — The index specification.
  #
  # _@param_ `options` — The index options.
  #
  # Validate the index spec.
  # ```ruby
  # Options.validate(Band, name: 1)
  # ```
  def self.validate: (Class klass, ::Hash[untyped, untyped] spec, ::Hash[untyped, untyped] options) -> untyped

  # Validates the options of the index spec.
  #
  # _@param_ `klass` — The model class.
  #
  # _@param_ `spec` — The index specification.
  #
  # _@param_ `options` — The index options.
  #
  # Validate the options.
  # ```ruby
  # Options.validate_options(Band, name: 1)
  # ```
  def self.validate_options: (Class klass, ::Hash[untyped, untyped] spec, ::Hash[untyped, untyped] options) -> untyped

  # Validates the index spec.
  #
  # _@param_ `klass` — The model class.
  #
  # _@param_ `spec` — The index specification.
  #
  # _@param_ `options` — The index options.
  #
  # Validate the spec.
  # ```ruby
  # Options.validate_spec(Band, name: 1)
  # ```
  def self.validate_spec: (Class klass, ::Hash[untyped, untyped] spec, ::Hash[untyped, untyped] options) -> untyped
end

Mongoid::Indexable::Mongoid::Indexable::Validators::Mongoid::Indexable::Mongoid::Indexable::Validators::Options::VALID_OPTIONS: untyped

Mongoid::Indexable::Mongoid::Indexable::Validators::Mongoid::Indexable::Mongoid::Indexable::Validators::Options::VALID_TYPES: untyped

# This module contains all the behavior for Ruby implementations of MongoDB
# selectors.
#
# @since 4.0.0
module Mongoid::Matchable
  extend ActiveSupport::Concern

  # Determines if this document has the attributes to match the supplied
  # MongoDB selector. Used for matching on embedded associations.
  #
  # _@param_ `selector` — The MongoDB selector.
  #
  # _@return_ — True if matches, false if not.
  #
  # Does the document match?
  # ```ruby
  # document._matches?(:title => { "$in" => [ "test" ] })
  # ```
  def _matches?: (::Hash[untyped, untyped] selector) -> bool
end

# This module contains behavior for adding shard key fields to updates.
#
# @since 4.0.0
module Mongoid::Shardable
  extend ActiveSupport::Concern

  # Get the shard key fields.
  #
  # _@return_ — The shard key field names.
  #
  # Get the shard key fields.
  # ```ruby
  # model.shard_key_fields
  # ```
  #
  # _@note_ — Refactored from using delegate for class load performance.
  def shard_key_fields: () -> ::Array[String]

  # Get the document selector with the defined shard keys.
  #
  # _@return_ — The shard key selector.
  #
  # Get the selector for the shard keys.
  # ```ruby
  # person.shard_key_selector
  # ```
  def shard_key_selector: () -> ::Hash[untyped, untyped]
end

module Mongoid::Shardable::ClassMethods
  # Specifies a shard key with the field(s) specified.
  #
  # Specify the shard key.
  # ```ruby
  #
  # class Person
  #   include Mongoid::Document
  #   field :first_name, :type => String
  #   field :last_name, :type => String
  #
  #   shard_key first_name: 1, last_name: 1
  # end
  # ```
  def shard_key: (*untyped args) -> untyped
end

module Mongoid::Touchable
  extend Mongoid::Touchable

  # Add the association to the touchable associations if the touch option was
  # provided.
  #
  # _@param_ `association` — The association metadata.
  #
  # _@return_ — The model class.
  #
  # Add the touchable.
  # ```ruby
  # Model.define_touchable!(assoc)
  # ```
  def define_touchable!: (Association association) -> Class

  # Define the method that will get called for touching belongs_to
  # associations.
  #
  # _@param_ `name` — The name of the association.
  #
  # _@param_ `association` — The association metadata.
  #
  # _@return_ — The method name.
  #
  # Define the touch association.
  # ```ruby
  # Model.define_relation_touch_method(:band)
  # Model.define_relation_touch_method(:band, :band_updated_at)
  # ```
  def define_relation_touch_method: (Symbol name, Association association) -> Symbol

  # Add the association to the touchable associations if the touch option was
  # provided.
  #
  # _@param_ `association` — The association metadata.
  #
  # _@return_ — The model class.
  #
  # Add the touchable.
  # ```ruby
  # Model.define_touchable!(assoc)
  # ```
  def self.define_touchable!: (Association association) -> Class

  # Define the method that will get called for touching belongs_to
  # associations.
  #
  # _@param_ `name` — The name of the association.
  #
  # _@param_ `association` — The association metadata.
  #
  # _@return_ — The method name.
  #
  # Define the touch association.
  # ```ruby
  # Model.define_relation_touch_method(:band)
  # Model.define_relation_touch_method(:band, :band_updated_at)
  # ```
  def self.define_relation_touch_method: (Symbol name, Association association) -> Symbol
end

module Mongoid::Touchable::InstanceMethods
  # Touch the document, in effect updating its updated_at timestamp and
  # optionally the provided field to the current time. If any belongs_to
  # associations exist with a touch option, they will be updated as well.
  #
  # _@param_ `field` — The name of an additional field to update.
  #
  # _@return_ — false if record is new_record otherwise true.
  #
  # Update the updated_at timestamp.
  # ```ruby
  # document.touch
  # ```
  #
  # Update the updated_at and provided timestamps.
  # ```ruby
  # document.touch(:audited)
  # ```
  #
  # _@note_ — This will not autobuild associations if those options are set.
  def touch: (?Symbol? field) -> bool
end

# This module contains the logic for handling the internal attributes hash,
# and how to get and set values.
module Mongoid::Attributes
  include Mongoid::Attributes::Nested

  include Mongoid::Attributes::Processing

  include Mongoid::Attributes::Readonly

  extend ActiveSupport::Concern

  # Determine if an attribute is present.
  #
  # _@param_ `name` — The name of the attribute.
  #
  # _@return_ — True if present, false if not.
  #
  # Is the attribute present?
  # ```ruby
  # person.attribute_present?("title")
  # ```
  def attribute_present?: (String | Symbol name) -> bool

  # Get the attributes that have not been cast.
  #
  # _@return_ — The uncast attributes.
  #
  # Get the attributes before type cast.
  # ```ruby
  # document.attributes_before_type_cast
  # ```
  def attributes_before_type_cast: () -> ::Hash[untyped, untyped]

  # Does the document have the provided attribute?
  #
  # _@param_ `name` — The name of the attribute.
  #
  # _@return_ — If the key is present in the attributes.
  #
  # Does the document have the attribute?
  # ```ruby
  # model.has_attribute?(:name)
  # ```
  def has_attribute?: (String | Symbol name) -> bool

  # Does the document have the provided attribute before it was assigned
  # and type cast?
  #
  # _@param_ `name` — The name of the attribute.
  #
  # _@return_ — If the key is present in the
  # attributes_before_type_cast.
  #
  # Does the document have the attribute before it was assigned?
  # ```ruby
  # model.has_attribute_before_type_cast?(:name)
  # ```
  def has_attribute_before_type_cast?: (String | Symbol name) -> bool

  # Read a value from the document attributes. If the value does not exist
  # it will return nil.
  #
  # _@param_ `name` — The name of the attribute to get.
  #
  # _@return_ — The value of the attribute.
  #
  # Read an attribute.
  # ```ruby
  # person.read_attribute(:title)
  # ```
  #
  # Read an attribute (alternate syntax.)
  # ```ruby
  # person[:title]
  # ```
  def read_attribute: (String | Symbol name) -> Object

  # Read a value from the attributes before type cast. If the value has not
  # yet been assigned then this will return the attribute's existing value
  # using read_raw_attribute.
  #
  # _@param_ `name` — The name of the attribute to get.
  #
  # _@return_ — The value of the attribute before type cast, if
  # available. Otherwise, the value of the attribute.
  #
  # Read an attribute before type cast.
  # ```ruby
  # person.read_attribute_before_type_cast(:price)
  # ```
  def read_attribute_before_type_cast: (String | Symbol name) -> Object

  # Remove a value from the +Document+ attributes. If the value does not exist
  # it will fail gracefully.
  #
  # _@param_ `name` — The name of the attribute to remove.
  #
  # Remove the attribute.
  # ```ruby
  # person.remove_attribute(:title)
  # ```
  def remove_attribute: (String | Symbol name) -> untyped

  # Write a single attribute to the document attribute hash. This will
  # also fire the before and after update callbacks, and perform any
  # necessary typecasting.
  #
  # _@param_ `name` — The name of the attribute to update.
  #
  # _@param_ `value` — The value to set for the attribute.
  #
  # Write the attribute.
  # ```ruby
  # person.write_attribute(:title, "Mr.")
  # ```
  #
  # Write the attribute (alternate syntax.)
  # ```ruby
  # person[:title] = "Mr."
  # ```
  def write_attribute: (String | Symbol name, Object value) -> untyped

  # Allows you to set all the attributes for a particular mass-assignment security role
  # by passing in a hash of attributes with keys matching the attribute names
  # (which again matches the column names)  and the role name using the :as option.
  # To bypass mass-assignment security you can use the :without_protection => true option.
  #
  # _@param_ `attrs` — The new attributes to set.
  #
  # Assign the attributes.
  # ```ruby
  # person.assign_attributes(:title => "Mr.")
  # ```
  #
  # Assign the attributes (with a role).
  # ```ruby
  # person.assign_attributes({ :title => "Mr." }, :as => :admin)
  # ```
  def assign_attributes: (?::Hash[untyped, untyped]? attrs) -> untyped

  # Writes the supplied attributes hash to the document. This will only
  # overwrite existing attributes if they are present in the new +Hash+, all
  # others will be preserved.
  #
  # _@param_ `attrs` — The new attributes to set.
  #
  # Write the attributes.
  # ```ruby
  # person.write_attributes(:title => "Mr.")
  # ```
  #
  # Write the attributes (alternate syntax.)
  # ```ruby
  # person.attributes = { :title => "Mr." }
  # ```
  def write_attributes: (?::Hash[untyped, untyped]? attrs) -> untyped

  # Determine if the attribute is missing from the document, due to loading
  # it from the database with missing fields.
  #
  # _@param_ `name` — The name of the attribute.
  #
  # _@return_ — If the attribute is missing.
  #
  # Is the attribute missing?
  # ```ruby
  # document.attribute_missing?("test")
  # ```
  def attribute_missing?: (String name) -> bool

  # Return type-casted attributes.
  #
  # _@return_ — The hash with keys and values of the type-casted attributes.
  #
  # Type-casted attributes.
  # ```ruby
  # document.typed_attributes
  # ```
  def typed_attributes: () -> Object

  def selection_excluded?: (untyped name, untyped selection, untyped field) -> bool

  def selection_included?: (untyped name, untyped selection, untyped field) -> bool

  # Does the string contain dot syntax for accessing hashes?
  #
  # _@return_ — If the string contains a "."
  #
  # Is the string in dot syntax.
  # ```ruby
  # model.hash_dot_syntax?
  # ```
  def hash_dot_syntax?: (untyped string) -> bool

  # Return the typecasted value for a field.
  #
  # _@param_ `key` — The field name.
  #
  # _@param_ `value` — The uncast value.
  #
  # _@return_ — The cast value.
  #
  # Get the value typecasted.
  # ```ruby
  # person.typed_value_for(:title, :sir)
  # ```
  def typed_value_for: (String | Symbol key, Object value) -> Object

  def read_raw_attribute: (untyped name) -> untyped

  # Validates an attribute value as being assignable to the specified field.
  #
  # For now, only Hash and Array fields are validated, and the value is
  # being checked to be of an appropriate type (i.e. either Hash or Array,
  # respectively, or nil).
  #
  # This method takes the name of the field as stored in the document
  # in the database, not (necessarily) the Ruby method name used to read/write
  # the said field.
  #
  # _@param_ `field_name` — The name of the field.
  #
  # _@param_ `value` — The value to be validated.
  def validate_attribute_value: (String | Symbol field_name, Object value) -> untyped

  def lookup_attribute_presence: (untyped name, untyped value) -> untyped

  # Are we able to write the attribute with the provided name?
  #
  # _@param_ `name` — The name of the field.
  #
  # _@return_ — If the document is new, or if the field is not
  # readonly.
  #
  # Can we write the attribute?
  # ```ruby
  # model.attribute_writable?(:title)
  # ```
  def attribute_writable?: (String | Symbol name) -> bool

  def as_writable_attribute!: (untyped name, ?untyped value) -> untyped

  def _loaded?: (untyped name) -> bool

  def projected_field?: (untyped name) -> bool

  # Process the provided attributes casting them to their proper values if a
  # field exists for them on the document. This will be limited to only the
  # attributes provided in the suppied +Hash+ so that no extra nil values get
  # put into the document's attributes.
  #
  # _@param_ `attrs` — The attributes to set.
  #
  # Process the attributes.
  # ```ruby
  # person.process_attributes(:title => "sir", :age => 40)
  # ```
  def process_attributes: (?::Hash[untyped, untyped]? attrs) -> untyped

  # If the key provided is the name of an association or a nested attribute, we
  # need to wait until all other attributes are set before processing
  # these.
  #
  # _@param_ `key` — The name of the attribute.
  #
  # _@param_ `value` — The value of the attribute.
  #
  # _@return_ — True if pending, false if not.
  #
  # Is the attribute pending?
  # ```ruby
  # document.pending_attribute?(:name, "Durran")
  # ```
  def pending_attribute?: (Symbol key, Object value) -> bool

  # Get all the pending associations that need to be set.
  #
  # _@return_ — The pending associations in key/value pairs.
  #
  # Get the pending associations.
  # ```ruby
  # document.pending_relations
  # ```
  def pending_relations: () -> ::Hash[untyped, untyped]

  # Get all the pending nested attributes that need to be set.
  #
  # _@return_ — The pending nested attributes in key/value pairs.
  #
  # Get the pending nested attributes.
  # ```ruby
  # document.pending_nested
  # ```
  def pending_nested: () -> ::Hash[untyped, untyped]

  # If the attribute is dynamic, add a field for it with a type of object
  # and then either way set the value.
  #
  # _@param_ `name` — The name of the field.
  #
  # _@param_ `value` — The value of the field.
  #
  # Process the attribute.
  # ```ruby
  # document.process_attribute(name, value)
  # ```
  def process_attribute: (Symbol name, Object value) -> untyped

  # Process all the pending nested attributes that needed to wait until
  # ids were set to fire off.
  #
  # Process the nested attributes.
  # ```ruby
  # document.process_nested
  # ```
  def process_nested: () -> untyped

  # Process all the pending items, then clear them out.
  #
  # Process the pending items.
  # ```ruby
  # document.process_pending
  # ```
  def process_pending: () -> untyped

  # Process all the pending associations that needed to wait until ids were set
  # to fire off.
  #
  # Process the associations.
  # ```ruby
  # document.process_relations
  # ```
  def process_relations: () -> untyped
end

module Mongoid::Attributes::ClassMethods
  # Returns the value of attribute attributes.
  #
  # Alias the provided name to the original field. This will provide an
  # aliased getter, setter, existence check, and all dirty attribute
  # methods.
  #
  # _@param_ `name` — The new name.
  #
  # _@param_ `original` — The original name.
  #
  # Alias the attribute.
  # ```ruby
  # class Product
  #   include Mongoid::Document
  #   field :price, :type => Float
  #   alias_attribute :cost, :price
  # end
  # ```
  def alias_attribute: () -> untyped
                     | (Symbol name, Symbol original) -> untyped

  # Removes a field alias.
  #
  # _@param_ `name` — The aliased field name to remove.
  def unalias_attribute: (Symbol name) -> untyped
end

# Defines behavior around that lovel Rails feature nested attributes.
#
# @since 1.0.0
module Mongoid::Attributes::Nested
  extend ActiveSupport::Concern
end

module Mongoid::Attributes::Mongoid::Attributes::Nested::ClassMethods
  # Used when needing to update related models from a parent association. Can
  # be used on embedded or referenced associations.
  #
  # _@param_ `args` — A list of association names, followed by a hash of options.
  #
  # Defining nested attributes.
  # ```ruby
  #
  # class Person
  #   include Mongoid::Document
  #
  #   embeds_many :addresses
  #   embeds_one :game
  #   references_many :posts
  #
  #   accepts_nested_attributes_for :addresses, :game, :posts
  # end
  # ```
  def accepts_nested_attributes_for: (*::Array[Symbol] | ::Hash[untyped, untyped] args) -> untyped

  # Add the autosave information for the nested association.
  #
  # _@param_ `association` — The existing association metadata.
  #
  # Add the autosave if appropriate.
  # ```ruby
  # Person.autosave_nested_attributes(metadata)
  # ```
  def autosave_nested_attributes: (Association association) -> untyped
end

Mongoid::Attributes::Mongoid::Attributes::Nested::Mongoid::Attributes::Mongoid::Attributes::Nested::ClassMethods::REJECT_ALL_BLANK_PROC: untyped

# This module contains the behavior for dynamic attributes.
#
# @since 4.0.0
module Mongoid::Attributes::Dynamic
  extend ActiveSupport::Concern

  # Override respond_to? so it responds properly for dynamic attributes.
  #
  # _@param_ `name` — The name of the method.
  #
  # _@param_ `include_private`
  #
  # _@return_ — True if it does, false if not.
  #
  # Does this object respond to the method?
  # ```ruby
  # person.respond_to?(:title)
  # ```
  def respond_to?: (::Array[untyped] name, ?bool include_private) -> bool

  # Define a reader method for a dynamic attribute.
  #
  # _@param_ `name` — The name of the field.
  #
  # Define a reader method.
  # ```ruby
  # model.define_dynamic_reader(:field)
  # ```
  def define_dynamic_reader: (String name) -> untyped

  # Define a reader method for a dynamic attribute before type cast.
  #
  # _@param_ `name` — The name of the field.
  #
  # Define a reader method for an attribute.
  # ```ruby
  # model.define_dynamic_before_type_cast_reader(:field)
  # ```
  def define_dynamic_before_type_cast_reader: (String name) -> untyped

  # Define a writer method for a dynamic attribute.
  #
  # _@param_ `name` — The name of the field.
  #
  # Define a writer method.
  # ```ruby
  # model.define_dynamic_writer(:field)
  # ```
  def define_dynamic_writer: (String name) -> untyped

  # If the attribute is dynamic, add a field for it with a type of object
  # and set the value.
  #
  # _@param_ `name` — The name of the field.
  #
  # _@param_ `value` — The value of the field.
  #
  # Process the attribute.
  # ```ruby
  # document.process_attribute(name, value)
  # ```
  def process_attribute: (Symbol name, Object value) -> untyped

  # Get an array of inspected dynamic fields for the document.
  #
  # _@return_ — An array of pretty printed dynamic field values.
  #
  # Inspect the dynamic fields.
  # ```ruby
  # document.inspect_dynamic_fields
  # ```
  def inspect_dynamic_fields: () -> String

  # Used for allowing accessor methods for dynamic attributes.
  #
  # _@param_ `name` — The name of the method.
  #
  # _@param_ `args` — The arguments to the method.
  #
  # _@return_ — The result of the method call.
  #
  # Call through method_missing.
  # ```ruby
  # document.method_missing(:test)
  # ```
  def method_missing: (String | Symbol name, *::Array[untyped] args) -> Object
end

# This module defines behavior for readonly attributes.
module Mongoid::Attributes::Readonly
  extend ActiveSupport::Concern

  # Are we able to write the attribute with the provided name?
  #
  # _@param_ `name` — The name of the field.
  #
  # _@return_ — If the document is new, or if the field is not
  # readonly.
  #
  # Can we write the attribute?
  # ```ruby
  # model.attribute_writable?(:title)
  # ```
  def attribute_writable?: (String | Symbol name) -> bool

  def as_writable_attribute!: (untyped name, ?untyped value) -> untyped

  def _loaded?: (untyped name) -> bool

  def projected_field?: (untyped name) -> bool
end

module Mongoid::Attributes::Mongoid::Attributes::Readonly::ClassMethods
  # Defines an attribute as readonly. This will ensure that the value for
  # the attribute is only set when the document is new or we are
  # creating. In other cases, the field write will be ignored with the
  # exception of #remove_attribute and #update_attribute, where an error
  # will get raised.
  #
  # _@param_ `names` — The names of the fields.
  #
  # Flag fields as readonly.
  # ```ruby
  # class Band
  #   include Mongoid::Document
  #   field :name, type: String
  #   field :genre, type: String
  #   attr_readonly :name, :genre
  # end
  # ```
  def attr_readonly: (*::Array[Symbol] names) -> untyped
end

# This module contains the behavior for processing attributes.
module Mongoid::Attributes::Processing
  # Process the provided attributes casting them to their proper values if a
  # field exists for them on the document. This will be limited to only the
  # attributes provided in the suppied +Hash+ so that no extra nil values get
  # put into the document's attributes.
  #
  # _@param_ `attrs` — The attributes to set.
  #
  # Process the attributes.
  # ```ruby
  # person.process_attributes(:title => "sir", :age => 40)
  # ```
  def process_attributes: (?::Hash[untyped, untyped]? attrs) -> untyped

  # If the key provided is the name of an association or a nested attribute, we
  # need to wait until all other attributes are set before processing
  # these.
  #
  # _@param_ `key` — The name of the attribute.
  #
  # _@param_ `value` — The value of the attribute.
  #
  # _@return_ — True if pending, false if not.
  #
  # Is the attribute pending?
  # ```ruby
  # document.pending_attribute?(:name, "Durran")
  # ```
  def pending_attribute?: (Symbol key, Object value) -> bool

  # Get all the pending associations that need to be set.
  #
  # _@return_ — The pending associations in key/value pairs.
  #
  # Get the pending associations.
  # ```ruby
  # document.pending_relations
  # ```
  def pending_relations: () -> ::Hash[untyped, untyped]

  # Get all the pending nested attributes that need to be set.
  #
  # _@return_ — The pending nested attributes in key/value pairs.
  #
  # Get the pending nested attributes.
  # ```ruby
  # document.pending_nested
  # ```
  def pending_nested: () -> ::Hash[untyped, untyped]

  # If the attribute is dynamic, add a field for it with a type of object
  # and then either way set the value.
  #
  # _@param_ `name` — The name of the field.
  #
  # _@param_ `value` — The value of the field.
  #
  # Process the attribute.
  # ```ruby
  # document.process_attribute(name, value)
  # ```
  def process_attribute: (Symbol name, Object value) -> untyped

  # Process all the pending nested attributes that needed to wait until
  # ids were set to fire off.
  #
  # Process the nested attributes.
  # ```ruby
  # document.process_nested
  # ```
  def process_nested: () -> untyped

  # Process all the pending items, then clear them out.
  #
  # Process the pending items.
  # ```ruby
  # document.process_pending
  # ```
  def process_pending: () -> untyped

  # Process all the pending associations that needed to wait until ids were set
  # to fire off.
  #
  # Process the associations.
  # ```ruby
  # document.process_relations
  # ```
  def process_relations: () -> untyped
end

# Defines behavior for dirty tracking.
#
# @since 4.0.0
module Mongoid::Changeable
  extend ActiveSupport::Concern

  # Get the changed attributes for the document.
  #
  # _@return_ — The changed attributes.
  #
  # Get the changed attributes.
  # ```ruby
  # model.changed
  # ```
  def changed: () -> ::Array[String]

  # Has the document changed?
  #
  # _@return_ — If the document is changed.
  #
  # Has the document changed?
  # ```ruby
  # model.changed?
  # ```
  def changed?: () -> bool

  # Have any children (embedded documents) of this document changed?
  #
  # _@return_ — If any children have changed.
  #
  # Have any children changed?
  # ```ruby
  # model.children_changed?
  # ```
  def children_changed?: () -> bool

  # Get the attribute changes.
  #
  # _@return_ — The attribute changes.
  #
  # Get the attribute changes.
  # ```ruby
  # model.changed_attributes
  # ```
  def changed_attributes: () -> ::Hash[String, Object]

  # Get all the changes for the document.
  #
  # _@return_ — The changes.
  #
  # Get all the changes.
  # ```ruby
  # model.changes
  # ```
  def changes: () -> ::Hash[String, ::Array[Object | Object]]

  # Call this method after save, so the changes can be properly switched.
  #
  # This will unset the memoized children array, set new record to
  # false, set the document as validated, and move the dirty changes.
  #
  # Move the changes to previous.
  # ```ruby
  # person.move_changes
  # ```
  def move_changes: () -> untyped

  # Things that need to execute after a document has been persisted.
  #
  # Handle post persistence.
  # ```ruby
  # document.post_persist
  # ```
  def post_persist: () -> untyped

  # Get the previous changes on the document.
  #
  # _@return_ — The previous changes.
  #
  # Get the previous changes.
  # ```ruby
  # model.previous_changes
  # ```
  def previous_changes: () -> ::Hash[String, ::Array[Object | Object]]

  # Remove a change from the dirty attributes hash. Used by the single field
  # atomic updators.
  #
  # _@param_ `name` — The name of the field.
  #
  # Remove a flagged change.
  # ```ruby
  # model.remove_change(:field)
  # ```
  def remove_change: (Symbol | String name) -> untyped

  # Gets all the new values for each of the changed fields, to be passed to
  # a MongoDB $set modifier.
  #
  # _@return_ — A +Hash+ of atomic setters.
  #
  # Get the setters for the atomic updates.
  # ```ruby
  # person = Person.new(:title => "Sir")
  # person.title = "Madam"
  # person.setters # returns { "title" => "Madam" }
  # ```
  def setters: () -> ::Hash[untyped, untyped]

  # Get the old and new value for the provided attribute.
  #
  # _@param_ `attr` — The name of the attribute.
  #
  # _@return_ — The old and new values.
  #
  # Get the attribute change.
  # ```ruby
  # model.attribute_change("name")
  # ```
  def attribute_change: (String attr) -> ::Array[Object]

  # Determine if a specific attribute has changed.
  #
  # _@param_ `attr` — The name of the attribute.
  #
  # _@return_ — Whether the attribute has changed.
  #
  # Has the attribute changed?
  # ```ruby
  # model.attribute_changed?("name")
  # ```
  def attribute_changed?: (String attr) -> bool

  # Get whether or not the field has a different value from the default.
  #
  # _@param_ `attr` — The name of the attribute.
  #
  # _@return_ — If the attribute differs.
  #
  # Is the field different from the default?
  # ```ruby
  # model.attribute_changed_from_default?
  # ```
  def attribute_changed_from_default?: (String attr) -> bool

  # Get the previous value for the attribute.
  #
  # _@param_ `attr` — The attribute name.
  #
  # Get the previous value.
  # ```ruby
  # model.attribute_was("name")
  # ```
  def attribute_was: (String attr) -> untyped

  # Flag an attribute as going to change.
  #
  # _@param_ `attr` — The name of the attribute.
  #
  # _@return_ — The old value.
  #
  # Flag the attribute.
  # ```ruby
  # model.attribute_will_change!("name")
  # ```
  def attribute_will_change!: (String attr) -> Object

  # Set the attribute back to its old value.
  #
  # _@param_ `attr` — The name of the attribute.
  #
  # _@return_ — The old value.
  #
  # Reset the attribute.
  # ```ruby
  # model.reset_attribute!("name")
  # ```
  def reset_attribute!: (String attr) -> Object

  def reset_attribute_to_default!: (untyped attr) -> untyped
end

module Mongoid::Changeable::ClassMethods
  # Generate all the dirty methods needed for the attribute.
  #
  # _@param_ `name` — The name of the field.
  #
  # _@param_ `meth` — The name of the accessor.
  #
  # _@return_ — The fields module.
  #
  # Generate the dirty methods.
  # ```ruby
  # Model.create_dirty_methods("name", "name")
  # ```
  def create_dirty_methods: (String name, String meth) -> Module

  # Creates the dirty change accessor.
  #
  # _@param_ `name` — The attribute name.
  #
  # _@param_ `meth` — The name of the accessor.
  #
  # Create the accessor.
  # ```ruby
  # Model.create_dirty_change_accessor("name", "alias")
  # ```
  def create_dirty_change_accessor: (String name, String meth) -> untyped

  # Creates the dirty change check.
  #
  # _@param_ `name` — The attribute name.
  #
  # _@param_ `meth` — The name of the accessor.
  #
  # Create the check.
  # ```ruby
  # Model.create_dirty_change_check("name", "alias")
  # ```
  def create_dirty_change_check: (String name, String meth) -> untyped

  # Creates the dirty default change check.
  #
  # _@param_ `name` — The attribute name.
  #
  # _@param_ `meth` — The name of the accessor.
  #
  # Create the check.
  # ```ruby
  # Model.create_dirty_default_change_check("name", "alias")
  # ```
  def create_dirty_default_change_check: (String name, String meth) -> untyped

  # Creates the dirty change previous value accessor.
  #
  # _@param_ `name` — The attribute name.
  #
  # _@param_ `meth` — The name of the accessor.
  #
  # Create the accessor.
  # ```ruby
  # Model.create_dirty_previous_value_accessor("name", "alias")
  # ```
  def create_dirty_previous_value_accessor: (String name, String meth) -> untyped

  # Creates the dirty change flag.
  #
  # _@param_ `name` — The attribute name.
  #
  # _@param_ `meth` — The name of the accessor.
  #
  # Create the flag.
  # ```ruby
  # Model.create_dirty_change_flag("name", "alias")
  # ```
  def create_dirty_change_flag: (String name, String meth) -> untyped

  # Creates the dirty change reset.
  #
  # _@param_ `name` — The attribute name.
  #
  # _@param_ `meth` — The name of the accessor.
  #
  # Create the reset.
  # ```ruby
  # Model.create_dirty_reset("name", "alias")
  # ```
  def create_dirty_reset: (String name, String meth) -> untyped

  # Creates the dirty change reset to default.
  #
  # _@param_ `name` — The attribute name.
  #
  # _@param_ `meth` — The name of the accessor.
  #
  # Create the reset.
  # ```ruby
  # Model.create_dirty_reset_to_default("name", "alias")
  # ```
  def create_dirty_reset_to_default: (String name, String meth) -> untyped

  # Creates the dirty change check.
  #
  # _@param_ `name` — The attribute name.
  #
  # _@param_ `meth` — The name of the accessor.
  #
  # Create the dirty change check.
  # ```ruby
  # Model.create_dirty_previously_changed?("name", "alias")
  # ```
  def create_dirty_previously_changed?: (String name, String meth) -> bool

  # Creates the dirty change accessor.
  #
  # _@param_ `name` — The attribute name.
  #
  # _@param_ `meth` — The name of the accessor.
  #
  # Create the dirty change accessor.
  # ```ruby
  # Model.create_dirty_previous_change("name", "alias")
  # ```
  def create_dirty_previous_change: (String name, String meth) -> untyped
end

# This module provides inclusions of all behavior in a Mongoid document.
#
# @since 4.0.0
module Mongoid::Composable
  include ActiveModel::Model

  include ActiveModel::ForbiddenAttributesProtection

  include ActiveModel::Serializers::JSON

  include Mongoid::Atomic

  include Mongoid::Changeable

  include Mongoid::Clients

  include Mongoid::Attributes

  include Mongoid::Evolvable

  include Mongoid::Fields

  include Mongoid::Indexable

  include Mongoid::Matchable

  include Mongoid::Persistable

  include Mongoid::Association

  include Mongoid::Reloadable

  include Mongoid::Scopable

  include Mongoid::Selectable

  include Mongoid::Serializable

  include Mongoid::Shardable

  include Mongoid::Stateful

  include Mongoid::Cacheable

  include Mongoid::Threaded::Lifecycle

  include Mongoid::Traversable

  include Mongoid::Validatable

  include Mongoid::Interceptable

  include Mongoid::Copyable

  include Mongoid::Equality

  extend ActiveSupport::Concern

  # Get a list of methods that would be a bad idea to define as field names
  # or override when including Mongoid::Document.
  #
  # Bad thing!
  # ```ruby
  # Mongoid::Components.prohibited_methods
  # ```
  def self.prohibited_methods: () -> ::Array[Symbol]

  # Default comparison is via the string version of the id.
  #
  # _@param_ `other` — The document to compare with.
  #
  # _@return_ — -1, 0, 1.
  #
  # Compare two documents.
  # ```ruby
  # person <=> other_person
  # ```
  def <=>: (Document other) -> Integer

  # Performs equality checking on the document ids. For more robust
  # equality checking please override this method.
  #
  # _@param_ `other` — The other object to compare with.
  #
  # _@return_ — True if the ids are equal, false if not.
  #
  # Compare for equality.
  # ```ruby
  # document == other
  # ```
  def ==: (Document | Object other) -> bool

  # Performs class equality checking.
  #
  # _@param_ `other` — The other object to compare with.
  #
  # _@return_ — True if the classes are equal, false if not.
  #
  # Compare the classes.
  # ```ruby
  # document === other
  # ```
  def ===: (Document | Object other) -> bool

  # Delegates to ==. Used when needing checks in hashes.
  #
  # _@param_ `other` — The object to check against.
  #
  # _@return_ — True if equal, false if not.
  #
  # Perform equality checking.
  # ```ruby
  # document.eql?(other)
  # ```
  def eql?: (Document | Object other) -> bool

  # Clone or dup the current +Document+. This will return all attributes with
  # the exception of the document's id, and will reset all the
  # instance variables.
  #
  # This clone also includes embedded documents.
  #
  # _@return_ — The new document.
  #
  # Clone the document.
  # ```ruby
  # document.clone
  # ```
  def clone: () -> Document

  # Clone the document attributes
  #
  # clone document
  # ```ruby
  # model.clone_document
  # ```
  def clone_document: () -> untyped

  # When cloning, if the document has localized fields we need to ensure they
  # are properly processed in the clone.
  #
  # _@param_ `attrs` — The attributes.
  #
  # Process localized attributes.
  # ```ruby
  # model.process_localized_attributes(attributes)
  # ```
  def process_localized_attributes: (untyped klass, ::Hash[untyped, untyped] attrs) -> untyped

  # Is the provided type of callback executable by this document?
  #
  # _@param_ `kind` — The type of callback.
  #
  # _@return_ — If the callback can be executed.
  #
  # Is the callback executable?
  # ```ruby
  # document.callback_executable?(:save)
  # ```
  def callback_executable?: (Symbol kind) -> bool

  # Is the document currently in a state that could potentially require
  # callbacks to be executed?
  #
  # _@param_ `kind` — The callback kind.
  #
  # _@return_ — If the document is in a callback state.
  #
  # Is the document in a callback state?
  # ```ruby
  # document.in_callback_state?(:update)
  # ```
  def in_callback_state?: (Symbol kind) -> bool

  # Run only the after callbacks for the specific event.
  #
  # _@param_ `kinds` — The events that are occurring.
  #
  # _@return_ — The result of the chain executing.
  #
  # Run only the after save callbacks.
  # ```ruby
  # model.run_after_callbacks(:save)
  # ```
  #
  # _@note_ — ActiveSupport does not allow this type of behavior by default, so
  # Mongoid has to get around it and implement itself.
  def run_after_callbacks: (*::Array[Symbol] kinds) -> Object

  # Run only the before callbacks for the specific event.
  #
  # _@param_ `kinds` — The events that are occurring.
  #
  # _@return_ — The result of the chain executing.
  #
  # Run only the before save callbacks.
  # ```ruby
  # model.run_before_callbacks(:save, :create)
  # ```
  #
  # _@note_ — ActiveSupport does not allow this type of behavior by default, so
  # Mongoid has to get around it and implement itself.
  def run_before_callbacks: (*::Array[Symbol] kinds) -> Object

  # Run the callbacks for the document. This overrides active support's
  # functionality to cascade callbacks to embedded documents that have been
  # flagged as such.
  #
  # _@param_ `kind` — The type of callback to execute.
  #
  # _@param_ `args` — Any options.
  #
  # _@return_ — The document
  #
  # Run the callbacks.
  # ```ruby
  # run_callbacks :save do
  #   save!
  # end
  # ```
  def run_callbacks: (Symbol kind, *::Array[untyped] args) { () -> untyped } -> Document

  # We need to hook into this for autosave, since we don't want it firing if
  # the before callbacks were halted.
  #
  # _@return_ — If a before callback was halted.
  #
  # Was a before callback halted?
  # ```ruby
  # document.before_callback_halted?
  # ```
  def before_callback_halted?: () -> bool

  # Get all the child embedded documents that are flagged as cascadable.
  #
  # _@param_ `kind` — The type of callback.
  #
  # _@return_ — The children.
  #
  # Get all the cascading children.
  # ```ruby
  # document.cascadable_children(:update)
  # ```
  def cascadable_children: (Symbol kind, ?untyped children) -> ::Array[Document]

  # Determine if the child should fire the callback.
  #
  # _@param_ `kind` — The type of callback.
  #
  # _@param_ `child` — The child document.
  #
  # _@return_ — If the child should fire the callback.
  #
  # Should the child fire the callback?
  # ```ruby
  # document.cascadable_child?(:update, doc)
  # ```
  def cascadable_child?: (Symbol kind, Document child, untyped association) -> bool

  # Get the name of the callback that the child should fire. This changes
  # depending on whether or not the child is new. A persisted parent with a
  # new child would fire :update from the parent, but needs to fire :create
  # on the child.
  #
  # _@param_ `kind` — The type of callback.
  #
  # _@param_ `child` — The child document
  #
  # _@return_ — The name of the callback.
  #
  # Get the callback type.
  # ```ruby
  # document.child_callback_type(:update, doc)
  # ```
  def child_callback_type: (Symbol kind, Document child) -> Symbol

  # We need to hook into this for autosave, since we don't want it firing if
  # the before callbacks were halted.
  #
  # _@param_ `filter` — The callback that halted.
  #
  # _@param_ `name` — The name of the callback that was halted (requires Rails 6.1+)
  #
  # Hook into the halt.
  # ```ruby
  # document.halted_callback_hook(filter)
  # ```
  def halted_callback_hook: (Symbol filter, ?Symbol? name) -> untyped

  # Run only the callbacks for the target location (before, after, around)
  # and kind (save, update, create).
  #
  # _@param_ `place` — The time to run, :before, :after, :around.
  #
  # _@param_ `kind` — The type of callback, :save, :create, :update.
  #
  # _@return_ — The result of the chain execution.
  #
  # Run the targeted callbacks.
  # ```ruby
  # model.run_targeted_callbacks(:before, :save)
  # ```
  def run_targeted_callbacks: (Symbol place, Symbol kind) -> Object

  # Begin the associated validation.
  #
  # Begin validation.
  # ```ruby
  # document.begin_validate
  # ```
  def begin_validate: () -> untyped

  # Exit the associated validation.
  #
  # Exit validation.
  # ```ruby
  # document.exit_validate
  # ```
  def exit_validate: () -> untyped

  # Given the provided options, are we performing validations?
  #
  # _@param_ `options` — The options to check.
  #
  # _@return_ — If we are validating.
  #
  # Are we performing validations?
  # ```ruby
  # document.performing_validations?(validate: true)
  # ```
  def performing_validations?: (?::Hash[untyped, untyped] options) -> bool

  # Overrides the default ActiveModel behavior since we need to handle
  # validations of associations slightly different than just calling the
  # getter.
  #
  # _@param_ `attr` — The name of the field or association.
  #
  # _@return_ — The value of the field or the association.
  #
  # Read the value.
  # ```ruby
  # person.read_attribute_for_validation(:addresses)
  # ```
  def read_attribute_for_validation: (Symbol attr) -> Object

  # Determine if the document is valid.
  #
  # _@param_ `context` — The optional validation context.
  #
  # _@return_ — True if valid, false if not.
  #
  # Is the document valid?
  # ```ruby
  # person.valid?
  # ```
  #
  # Is the document valid in a context?
  # ```ruby
  # person.valid?(:create)
  # ```
  def valid?: (?Symbol? context) -> bool

  # Used to prevent infinite loops in associated validations.
  #
  # _@return_ — Has the document already been validated?
  #
  # Is the document validated?
  # ```ruby
  # document.validated?
  # ```
  def validated?: () -> bool

  # Are we currently performing a validation that has a query?
  #
  # _@return_ — If we are validating with a query.
  #
  # Are we validating with a query?
  # ```ruby
  # document.validating_with_query?
  # ```
  def validating_with_query?: () -> bool

  def _parent: () -> untyped

  def _parent=: (untyped p) -> untyped

  # Get all child +Documents+ to this +Document+, going n levels deep if
  # necessary. This is used when calling update persistence operations from
  # the root document, where changes in the entire tree need to be
  # determined. Note that persistence from the embedded documents will
  # always be preferred, since they are optimized calls... This operation
  # can get expensive in domains with large hierarchies.
  #
  # _@return_ — All child documents in the hierarchy.
  #
  # Get all the document's children.
  # ```ruby
  # person._children
  # ```
  def _children: () -> ::Array[Document]

  # Collect all the children of this document.
  #
  # _@return_ — The children.
  #
  # Collect all the children.
  # ```ruby
  # document.collect_children
  # ```
  def collect_children: () -> ::Array[Document]

  # Marks all children as being persisted.
  #
  # _@return_ — The flagged children.
  #
  # Flag all the children.
  # ```ruby
  # document.flag_children_persisted
  # ```
  def flag_children_persisted: () -> ::Array[Document]

  # Determines if the document is a subclass of another document.
  #
  # _@return_ — True if hereditary, false if not.
  #
  # Check if the document is a subclass
  # ```ruby
  # Square.new.hereditary?
  # ```
  def hereditary?: () -> bool

  # Sets up a child/parent association. This is used for newly created
  # objects so they can be properly added to the graph.
  #
  # _@param_ `document` — The parent document.
  #
  # _@return_ — The parent document.
  #
  # Set the parent document.
  # ```ruby
  # document.parentize(parent)
  # ```
  def parentize: (Document document) -> Document

  # Remove a child document from this parent. If an embeds one then set to
  # nil, otherwise remove from the embeds many.
  #
  # This is called from the +RemoveEmbedded+ persistence command.
  #
  # _@param_ `child` — The child (embedded) document to remove.
  #
  # Remove the child.
  # ```ruby
  # document.remove_child(child)
  # ```
  def remove_child: (Document child) -> untyped

  # After children are persisted we can call this to move all their changes
  # and flag them as persisted in one call.
  #
  # _@return_ — The children.
  #
  # Reset the children.
  # ```ruby
  # document.reset_persisted_children
  # ```
  def reset_persisted_children: () -> ::Array[Document]

  # Resets the memoized children on the object. Called internally when an
  # embedded array changes size.
  #
  # _@return_ — nil.
  #
  # Reset the memoized children.
  # ```ruby
  # document._reset_memoized_children!
  # ```
  def _reset_memoized_children!: () -> nil

  # Return the root document in the object graph. If the current document
  # is the root object in the graph it will return self.
  #
  # _@return_ — The root document in the hierarchy.
  #
  # Get the root document in the hierarchy.
  # ```ruby
  # document._root
  # ```
  def _root: () -> Document

  # Is this document the root document of the hierarchy?
  #
  # _@return_ — If the document is the root.
  #
  # Is the document the root?
  # ```ruby
  # document._root?
  # ```
  def _root?: () -> bool

  # Begin the assignment of attributes. While in this block embedded
  # documents will not autosave themselves in order to allow the document to
  # be in a valid state.
  #
  # _@return_ — The yielded value.
  #
  # Execute the assignment.
  # ```ruby
  # _assigning do
  #   person.attributes = { :addresses => [ address ] }
  # end
  # ```
  def _assigning: () -> Object

  # Is the current thread in assigning mode?
  #
  # _@return_ — If the thread is assigning.
  #
  # Is the current thread in assigning mode?
  # ```ruby
  # proxy._assigning?
  # ```
  def _assigning?: () -> bool

  # Execute a block in binding mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in binding mode.
  # ```ruby
  # binding do
  #   relation.push(doc)
  # end
  # ```
  def _binding: () -> Object

  # Is the current thread in binding mode?
  #
  # _@return_ — If the thread is binding.
  #
  # Is the current thread in binding mode?
  # ```ruby
  # proxy.binding?
  # ```
  def _binding?: () -> bool

  # Execute a block in building mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in building mode.
  # ```ruby
  # _building do
  #   relation.push(doc)
  # end
  # ```
  def _building: () -> Object

  # Is the current thread in building mode?
  #
  # _@return_ — If the thread is building.
  #
  # Is the current thread in building mode?
  # ```ruby
  # proxy._building?
  # ```
  def _building?: () -> bool

  # Is the current thread in creating mode?
  #
  # _@return_ — If the thread is creating.
  #
  # Is the current thread in creating mode?
  # ```ruby
  # proxy.creating?
  # ```
  def _creating?: () -> bool

  # Execute a block in loading mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in loading mode.
  # ```ruby
  # _loading do
  #   relation.push(doc)
  # end
  # ```
  def _loading: () -> Object

  # Is the current thread in loading mode?
  #
  # _@return_ — If the thread is loading.
  #
  # Is the current thread in loading mode?
  # ```ruby
  # proxy._loading?
  # ```
  def _loading?: () -> bool

  # Print out the cache key. This will append different values on the
  # plural model name.
  #
  # If new_record?     - will append /new
  # If not             - will append /id-updated_at.to_s(cache_timestamp_format)
  # Without updated_at - will append /id
  #
  # This is usually called insode a cache() block
  #
  # _@return_ — the string with or without updated_at
  #
  # Returns the cache key
  # ```ruby
  # document.cache_key
  # ```
  def cache_key: () -> String

  # Returns true if the +Document+ has not been persisted to the database,
  # false if it has. This is determined by the variable @new_record
  # and NOT if the object has an id.
  #
  # _@return_ — True if new, false if not.
  #
  # Is the document new?
  # ```ruby
  # person.new_record?
  # ```
  def new_record?: () -> bool

  # Checks if the document has been saved to the database. Returns false
  # if the document has been destroyed.
  #
  # _@return_ — True if persisted, false if not.
  #
  # Is the document persisted?
  # ```ruby
  # person.persisted?
  # ```
  def persisted?: () -> bool

  # Returns whether or not the document has been flagged for deletion, but
  # not destroyed yet. Used for atomic pulls of child documents.
  #
  # _@return_ — If the document is flagged.
  #
  # Is the document flagged?
  # ```ruby
  # document.flagged_for_destroy?
  # ```
  def flagged_for_destroy?: () -> bool

  # Returns true if the +Document+ has been succesfully destroyed, and false
  # if it hasn't. This is determined by the variable @destroyed and NOT
  # by checking the database.
  #
  # _@return_ — True if destroyed, false if not.
  #
  # Is the document destroyed?
  # ```ruby
  # person.destroyed?
  # ```
  def destroyed?: () -> bool

  # Determine if the document can be pushed.
  #
  # _@return_ — Is the document new and embedded?
  #
  # Is this pushable?
  # ```ruby
  # person.pushable?
  # ```
  def pushable?: () -> bool

  # Is the document readonly?
  #
  # _@return_ — If the document is readonly.
  #
  # Is the document readonly?
  # ```ruby
  # document.readonly?
  # ```
  def readonly?: () -> bool

  # Determine if the document can be set.
  #
  # _@return_ — Is this document a new embeds one?
  #
  # Is this settable?
  # ```ruby
  # person.settable?
  # ```
  def settable?: () -> bool

  # Is the document updateable?
  #
  # _@return_ — If the document is changed and persisted.
  #
  # Is the document updateable?
  # ```ruby
  # person.updateable?
  # ```
  def updateable?: () -> bool

  def reset_readonly: () -> untyped

  # Get the shard key fields.
  #
  # _@return_ — The shard key field names.
  #
  # Get the shard key fields.
  # ```ruby
  # model.shard_key_fields
  # ```
  #
  # _@note_ — Refactored from using delegate for class load performance.
  def shard_key_fields: () -> ::Array[String]

  # Get the document selector with the defined shard keys.
  #
  # _@return_ — The shard key selector.
  #
  # Get the selector for the shard keys.
  # ```ruby
  # person.shard_key_selector
  # ```
  def shard_key_selector: () -> ::Hash[untyped, untyped]

  # Gets the document as a serializable hash, used by ActiveModel's JSON
  # serializer.
  #
  # _@param_ `options` — The options to pass.
  #
  # _@return_ — The document, ready to be serialized.
  #
  # Get the serializable hash.
  # ```ruby
  # document.serializable_hash
  # ```
  #
  # Get the serializable hash with options.
  # ```ruby
  # document.serializable_hash(:include => :addresses)
  # ```
  def serializable_hash: (?::Hash[untyped, untyped]? options) -> ::Hash[untyped, untyped]

  # Get the names of all fields that will be serialized.
  #
  # _@return_ — The names of the fields.
  #
  # Get all the field names.
  # ```ruby
  # document.send(:field_names)
  # ```
  def field_names: (untyped options) -> ::Array[String]

  def serialize_attribute: (::Hash[untyped, untyped] attrs, String name, ::Array[String] names, ::Hash[untyped, untyped] options) -> Object

  # For each of the provided include options, get the association needed and
  # provide it in the hash.
  #
  # _@param_ `attributes` — The attributes to serialize.
  #
  # _@param_ `options` — The serialization options.
  #
  # Serialize the included associations.
  # ```ruby
  # document.serialize_relations({}, :include => :addresses)
  # ```
  def serialize_relations: (?::Hash[untyped, untyped] attributes, ?::Hash[untyped, untyped] options) -> untyped

  # Since the inclusions can be a hash, symbol, or array of symbols, this is
  # provided as a convenience to parse out the names.
  #
  # _@param_ `inclusions` — The inclusions.
  #
  # _@return_ — The names of the included associations.
  #
  # Get the association names.
  # ```ruby
  # document.relation_names(:include => [ :addresses ])
  # ```
  def relation_names: (::Hash[untyped, untyped] | Symbol | ::Array[Symbol] inclusions) -> ::Array[Symbol]

  # Since the inclusions can be a hash, symbol, or array of symbols, this is
  # provided as a convenience to parse out the options.
  #
  # _@param_ `inclusions` — The inclusions.
  #
  # _@param_ `options` — The options.
  #
  # _@param_ `name` — The name of the association.
  #
  # _@return_ — The options for the association.
  #
  # Get the association options.
  # ```ruby
  # document.relation_names(:include => [ :addresses ])
  # ```
  def relation_options: (::Hash[untyped, untyped] | Symbol | ::Array[Symbol] inclusions, ::Hash[untyped, untyped] options, Symbol name) -> ::Hash[untyped, untyped]

  # Get the atomic selector for the document. This is a hash in the simplest
  # case { "_id" => id }, but can become more complex for embedded documents
  # and documents that use a shard key.
  #
  # _@return_ — The document's selector.
  #
  # Get the document's atomic selector.
  # ```ruby
  # document.atomic_selector
  # ```
  def atomic_selector: () -> ::Hash[untyped, untyped]

  # Get the atomic selector for an embedded document.
  #
  # _@return_ — The embedded document selector.
  #
  # Get the embedded atomic selector.
  # ```ruby
  # document.embedded_atomic_selector
  # ```
  def embedded_atomic_selector: () -> ::Hash[untyped, untyped]

  # Get the atomic selector for a root document.
  #
  # _@return_ — The root document selector.
  #
  # Get the root atomic selector.
  # ```ruby
  # document.root_atomic_selector
  # ```
  def root_atomic_selector: () -> ::Hash[untyped, untyped]

  # Apply the default scoping to the attributes of the document, as long as
  # they are not complex queries.
  #
  # _@return_ — If default scoping was applied.
  #
  # Apply the default scoping.
  # ```ruby
  # document.apply_default_scoping
  # ```
  def apply_default_scoping: () -> bool

  # Reloads the +Document+ attributes from the database. If the document has
  # not been saved then an error will get raised if the configuration option
  # was set. This can reload root documents or embedded documents.
  #
  # _@return_ — The document, reloaded.
  #
  # Reload the document.
  # ```ruby
  # person.reload
  # ```
  def reload: () -> Document

  # Reload the document, determining if it's embedded or not and what
  # behavior to use.
  #
  # _@return_ — The reloaded attributes.
  #
  # Reload the document.
  # ```ruby
  # document._reload
  # ```
  def _reload: () -> ::Hash[untyped, untyped]

  # Reload the root document.
  #
  # _@return_ — The reloaded attributes.
  #
  # Reload the document.
  # ```ruby
  # document.reload_root_document
  # ```
  def reload_root_document: () -> ::Hash[untyped, untyped]

  # Reload the embedded document.
  #
  # _@return_ — The reloaded attributes.
  #
  # Reload the document.
  # ```ruby
  # document.reload_embedded_document
  # ```
  def reload_embedded_document: () -> ::Hash[untyped, untyped]

  # Extract only the desired embedded document from the attributes.
  #
  # _@param_ `attributes` — The document in the db.
  #
  # _@return_ — The document's extracted attributes.
  #
  # Extract the embedded document.
  # ```ruby
  # document.extract_embedded_attributes(attributes)
  # ```
  def extract_embedded_attributes: (::Hash[untyped, untyped] attributes) -> ::Hash[untyped, untyped]

  # Determine if the document itself is embedded in another document via the
  # proper channels. (If it has a parent document.)
  #
  # _@return_ — True if the document has a parent document.
  #
  # Is the document embedded?
  # ```ruby
  # address.embedded?
  # ```
  def embedded?: () -> bool

  # Determine if the document is part of an embeds_many association.
  #
  # _@return_ — True if in an embeds many.
  #
  # Is the document in an embeds many?
  # ```ruby
  # address.embedded_many?
  # ```
  def embedded_many?: () -> bool

  # Determine if the document is part of an embeds_one association.
  #
  # _@return_ — True if in an embeds one.
  #
  # Is the document in an embeds one?
  # ```ruby
  # address.embedded_one?
  # ```
  def embedded_one?: () -> bool

  # Get the association name for this document. If no association was defined
  #   an error will be raised.
  #
  # _@return_ — The association name.
  #
  # Get the association name.
  # ```ruby
  # document.association_name
  # ```
  def association_name: () -> Symbol

  # Determine if the document is part of an references_many association.
  #
  # _@return_ — True if in a references many.
  #
  # Is the document in a references many?
  # ```ruby
  # post.referenced_many?
  # ```
  def referenced_many?: () -> bool

  # Determine if the document is part of an references_one association.
  #
  # _@return_ — True if in a references one.
  #
  # Is the document in a references one?
  # ```ruby
  # address.referenced_one?
  # ```
  def referenced_one?: () -> bool

  # Convenience method for iterating through the loaded associations and
  # reloading them.
  #
  # _@return_ — The association metadata.
  #
  # Reload the associations.
  # ```ruby
  # document.reload_relations
  # ```
  def reload_relations: () -> ::Hash[untyped, untyped]

  # Returns the association metadata for the supplied name.
  #
  # _@param_ `name` — The name of the association to find.
  #
  # _@return_ — The matching association metadata.
  #
  # Find association metadata by name.
  # ```ruby
  # person.reflect_on_association(:addresses)
  # ```
  def reflect_on_association: (String | Symbol name) -> Association

  # Returns all association metadata for the supplied macros.
  #
  # _@param_ `macros` — The association macros.
  #
  # _@return_ — The matching association metadata.
  #
  # Find multiple association metadata by macro.
  # ```ruby
  # person.reflect_on_all_associations(:embeds_many)
  # ```
  def reflect_on_all_association: (*::Array[Symbol] macros) -> ::Array[Association]

  # This is convenience for libraries still on the old API.
  #
  # _@return_ — The associations.
  #
  # Get the associations.
  # ```ruby
  # person.associations
  # ```
  def associations: () -> ::Hash[untyped, untyped]

  # Parse out the attributes and the options from the args passed to a
  # build_ or create_ methods.
  #
  # _@param_ `args` — The arguments.
  #
  # _@return_ — The attributes and options.
  #
  # Parse the args.
  # ```ruby
  # doc.parse_args(:name => "Joe")
  # ```
  def parse_args: (*::Array[untyped] args) -> ::Array[::Hash[untyped, untyped]]

  # Perform all cascading deletes, destroys, or nullifies. Will delegate to
  # the appropriate strategy to perform the operation.
  #
  # Execute cascades.
  # ```ruby
  # document.apply_delete_dependencies!
  # ```
  def apply_delete_dependencies!: () -> untyped

  def _dependent_delete_all!: (untyped association) -> untyped

  def _dependent_destroy!: (untyped association) -> untyped

  def _dependent_nullify!: (untyped association) -> untyped

  def _dependent_restrict_with_exception!: (untyped association) -> untyped

  def _dependent_restrict_with_error!: (untyped association) -> untyped

  def __build__: (String | Symbol name, ::Hash[untyped, untyped] | BSON::ObjectId object, Association association, ?::Hash[untyped, untyped]? selected_fields) -> Proxy

  # Create an association from an object and association metadata.
  #
  # _@param_ `object` — The association target.
  #
  # _@param_ `association` — The association metadata.
  #
  # _@param_ `selected_fields` — Fields which were retrieved via #only. If selected_fields is specified, fields not listed in it will not be accessible in the created association document.
  #
  # _@return_ — The association.
  #
  # Create the association.
  # ```ruby
  # person.create_relation(document, association)
  # ```
  def create_relation: (Document | ::Array[Document] object, Association association, ?::Hash[untyped, untyped]? selected_fields) -> Proxy

  # Resets the criteria inside the association proxy. Used by many-to-many
  # associations to keep the underlying ids array in sync.
  #
  # _@param_ `name` — The name of the association.
  #
  # Reset the association criteria.
  # ```ruby
  # person.reset_relation_criteria(:preferences)
  # ```
  def reset_relation_criteria: (Symbol name) -> untyped

  # Set the supplied association to an instance variable on the class with the
  # provided name. Used as a helper just for code cleanliness.
  #
  # _@param_ `name` — The name of the association.
  #
  # _@param_ `relation` — The association to set.
  #
  # _@return_ — The association.
  #
  # Set the proxy on the document.
  # ```ruby
  # person.set(:addresses, addresses)
  # ```
  def set_relation: (String | Symbol name, Proxy relation) -> Proxy

  def get_relation: (Symbol name, Association association, Object object, ?bool reload) -> Proxy

  # Returns a subset of __selected_fields attribute applicable to the
  # (embedded) association with the given key, or nil if no projection
  # is to be performed.
  #
  # For example, if __selected_fields is {'a' => 1, 'b.c' => 2, 'b.c.f' => 3},
  # and assoc_key is 'b', return value would be {'c' => 2, 'c.f' => 3}.
  #
  # _@param_ `assoc_key`
  def _mongoid_filter_selected_fields: (String assoc_key) -> ::Hash[untyped, untyped]?

  def needs_no_database_query?: (untyped object, untyped association) -> bool

  # Is the current code executing without autobuild functionality?
  #
  # _@return_ — If autobuild is disabled.
  #
  # Is autobuild disabled?
  # ```ruby
  # document.without_autobuild?
  # ```
  def without_autobuild?: () -> bool

  # Yield to the block with autobuild functionality turned off.
  #
  # _@return_ — The result of the yield.
  #
  # Execute without autobuild.
  # ```ruby
  # document.without_autobuild do
  #   document.name
  # end
  # ```
  def without_autobuild: () -> Object

  # Is the document able to be synced on the inverse side? This is only if
  # the key has changed and the association bindings have not been run.
  #
  # _@param_ `association` — The association metadata.
  #
  # _@return_ — If we can sync.
  #
  # Are the foreign keys syncable?
  # ```ruby
  # document._syncable?(association)
  # ```
  def _syncable?: (Association association) -> bool

  # Get the synced foreign keys.
  #
  # _@return_ — The synced foreign keys.
  #
  # Get the synced foreign keys.
  # ```ruby
  # document._synced
  # ```
  def _synced: () -> ::Hash[untyped, untyped]

  # Has the document been synced for the foreign key?
  #
  # _@param_ `foreign_key` — The foreign key.
  #
  # _@return_ — If we can sync.
  #
  # Has the document been synced?
  # ```ruby
  # document._synced?
  # ```
  def _synced?: (String foreign_key) -> bool

  # Update the inverse keys on destroy.
  #
  # _@param_ `association` — The association.
  #
  # _@return_ — The updated values.
  #
  # Update the inverse keys.
  # ```ruby
  # document.remove_inverse_keys(association)
  # ```
  def remove_inverse_keys: (Association association) -> Object

  # Update the inverse keys for the association.
  #
  # _@param_ `association` — The document association.
  #
  # _@return_ — The updated values.
  #
  # Update the inverse keys
  # ```ruby
  # document.update_inverse_keys(association)
  # ```
  def update_inverse_keys: (Association association) -> Object

  # Reset the given counter using the .count() query from the
  # db. This method is usuful in case that a counter got
  # corrupted, or a new counter was added to the collection.
  #
  # _@param_ `counters` — One or more counter caches to reset
  #
  # Reset the given counter cache
  # ```ruby
  # post.reset_counters(:comments)
  # ```
  def reset_counters: (*Symbol | ::Array[untyped] counters) -> untyped

  # Used to prevent infinite loops in associated autosaves.
  #
  # _@return_ — Has the document already been autosaved?
  #
  # Is the document autosaved?
  # ```ruby
  # document.autosaved?
  # ```
  def autosaved?: () -> bool

  # Begin the associated autosave.
  #
  # Begin autosave.
  # ```ruby
  # document.__autosaving__
  # ```
  def __autosaving__: () -> untyped

  # Check if there is changes for auto-saving
  #
  #   document.changed_for_autosave?
  #
  # Return true if there is changes on self or in
  # ```ruby
  # autosaved associations.
  # ```
  def changed_for_autosave?: (untyped doc) -> bool

  # Execute operations atomically (in a single database call) for everything
  # that would happen inside the block. This method supports nesting further
  # calls to atomically, which will behave according to the options described
  # below.
  #
  # An option join_context can be given which, when true, will merge the
  # operations declared by the given block with the atomically block wrapping
  # the current invocation for the same document, if one exists. If this
  # block or any other block sharing the same context raises before
  # persisting, then all the operations of that context will not be
  # persisted, and will also be reset in memory.
  #
  # When join_context is false, the given block of operations will be
  # persisted independently of other contexts. Failures in other contexts will
  # not affect this one, so long as this block was able to run and persist
  # changes.
  #
  # The default value of join_context is set by the global configuration
  # option join_contexts, whose own default is false.
  #
  # _@param_ `join_context` — Join the context (i.e. merge declared atomic operations) of the atomically block wrapping this one for the same document, if one exists.
  #
  # _@return_ — If the operation succeeded.
  #
  # Execute the operations atomically.
  # ```ruby
  # document.atomically do
  #   document.set(name: "Tool").inc(likes: 10)
  # end
  # ```
  #
  # Execute some inner operations atomically, but independently from the outer operations.
  # ```ruby
  #
  # document.atomically do
  #   document.inc likes: 10
  #   document.atomically join_context: false do
  #     # The following is persisted to the database independently.
  #     document.unset :origin
  #   end
  #   document.atomically join_context: true do
  #     # The following is persisted along with the other outer operations.
  #     document.inc member_count: 3
  #   end
  #   document.set name: "Tool"
  # end
  # ```
  def atomically: (?join_context: bool? join_context) -> bool

  # Raise an error if validation failed.
  #
  # Raise the validation error.
  # ```ruby
  # Person.fail_due_to_validation!(person)
  # ```
  def fail_due_to_validation!: () -> untyped

  # Raise an error if a callback failed.
  #
  # _@param_ `method` — The method being called.
  #
  # Raise the callback error.
  # ```ruby
  # Person.fail_due_to_callback!(person, :create!)
  # ```
  def fail_due_to_callback!: (Symbol method) -> untyped

  # Are we executing an atomically block on the current document?
  #
  # _@return_ — If we are current executing atomically.
  #
  # Are we executing atomically?
  # ```ruby
  # document.executing_atomically?
  # ```
  def executing_atomically?: () -> bool

  # Post process the persistence operation.
  #
  # _@param_ `result` — The result of the operation.
  #
  # _@param_ `options` — The options.
  #
  # _@return_ — true.
  #
  # Post process the persistence operation.
  # ```ruby
  # document.post_process_persist(true)
  # ```
  def post_process_persist: (Object result, ?::Hash[untyped, untyped] options) -> bool

  # Prepare an atomic persistence operation. Yields an empty hash to be sent
  # to the update.
  #
  # _@return_ — The result of the operation.
  #
  # Prepare the atomic operation.
  # ```ruby
  # document.prepare_atomic_operation do |coll, selector, opts|
  #   ...
  # end
  # ```
  def prepare_atomic_operation: () -> Object

  # Process the atomic operations - this handles the common behavior of
  # iterating through each op, getting the aliased field name, and removing
  # appropriate dirty changes.
  #
  # _@param_ `operations` — The atomic operations.
  #
  # _@return_ — The operations.
  #
  # Process the atomic operations.
  # ```ruby
  # document.process_atomic_operations(pulls) do |field, value|
  #   ...
  # end
  # ```
  def process_atomic_operations: (::Hash[untyped, untyped] operations) -> ::Hash[untyped, untyped]

  # Remove the dirty changes for all fields changed in the current atomic
  # context.
  #
  # Remove the current atomic context's dirty changes.
  # ```ruby
  # document._mongoid_remove_atomic_context_changes
  # ```
  def _mongoid_remove_atomic_context_changes: () -> untyped

  # Reset the attributes for all fields changed in the current atomic
  # context.
  #
  # Reset the current atomic context's changed attributes.
  # ```ruby
  # document._mongoid_reset_atomic_context_changes!
  # ```
  def _mongoid_reset_atomic_context_changes!: () -> untyped

  # Push a new atomic context onto the stack.
  #
  # Push a new atomic context onto the stack.
  # ```ruby
  # document._mongoid_push_atomic_context
  # ```
  def _mongoid_push_atomic_context: () -> untyped

  # Pop an atomic context off the stack.
  #
  # Pop an atomic context off the stack.
  # ```ruby
  # document._mongoid_pop_atomic_context
  # ```
  def _mongoid_pop_atomic_context: () -> untyped

  # Return the current atomic context's changed fields.
  #
  # _@return_ — The changed fields.
  #
  # Return the current atomic context's changed fields.
  # ```ruby
  # document._mongoid_atomic_context_changed_fields
  # ```
  def _mongoid_atomic_context_changed_fields: () -> ::Array[untyped]

  # If we are in an atomically block, add the operations to the delayed group,
  # otherwise persist immediately.
  #
  # _@param_ `operation` — The operation.
  #
  # Persist immediately or delay the operations.
  # ```ruby
  # document.persist_or_delay_atomic_operation(ops)
  # ```
  def persist_or_delay_atomic_operation: (::Hash[untyped, untyped] operation) -> untyped

  # Persist the atomic operations.
  #
  # _@param_ `operations` — The atomic operations.
  #
  # Persist the atomic operations.
  # ```ruby
  # persist_atomic_operations(ops)
  # ```
  def persist_atomic_operations: (::Hash[untyped, untyped] operations) -> untyped

  # Perform an $unset operation on the provided fields and in the
  # values in the document in memory.
  #
  # _@param_ `fields` — The names of the fields to unset.
  #
  # _@return_ — The document.
  #
  # Unset the values.
  # ```ruby
  # document.unset(:first_name, :last_name, :middle)
  # ```
  def unset: (*::Array[String | Symbol] fields) -> Document

  # Perform an upsert of the document. If the document does not exist in the
  # database, then Mongo will insert a new one, otherwise the fields will get
  # overwritten with new values on the existing document.
  #
  # _@param_ `options` — The validation options.
  #
  # _@return_ — True.
  #
  # Upsert the document.
  # ```ruby
  # document.upsert
  # ```
  def upsert: (?::Hash[untyped, untyped] options) -> bool

  # Prepare the upsert for execution.
  #
  # _@param_ `options` — The options hash.
  #
  # _@return_ — If the operation succeeded.
  #
  # Prepare the upsert
  # ```ruby
  # document.prepare_upsert do
  #   collection.find(selector).update(as_document)
  # end
  # ```
  def prepare_upsert: (?::Hash[untyped, untyped] options) -> bool

  # Update a single attribute and persist the entire document.
  # This skips validation but fires the callbacks.
  #
  # _@param_ `name` — The name of the attribute.
  #
  # _@param_ `value` — The new value of the attribute.a
  #
  # _@return_ — True if save was successfull, false if not.
  #
  # Update the attribute.
  # ```ruby
  # person.update_attribute(:title, "Sir")
  # ```
  def update_attribute: (Symbol | String name, Object value) -> bool

  # Update the document attributes in the database.
  #
  # _@param_ `attributes` — The attributes to update.
  #
  # _@return_ — True if validation passed, false if not.
  #
  # Update the document's attributes
  # ```ruby
  # document.update(:title => "Sir")
  # ```
  def update: (?::Hash[untyped, untyped] attributes) -> bool

  # Update the document attributes in the database and raise an error if
  # validation failed.
  #
  # _@param_ `attributes` — The attributes to update.
  #
  # _@return_ — True if validation passed.
  #
  # Update the document's attributes.
  # ```ruby
  # document.update!(:title => "Sir")
  # ```
  def update!: (?::Hash[untyped, untyped] attributes) -> bool

  # Initialize the atomic updates.
  #
  # _@return_ — The updates and conflicts.
  #
  # Initialize the atomic updates.
  # ```ruby
  # document.init_atomic_updates
  # ```
  def init_atomic_updates: () -> ::Array[::Hash[untyped, untyped]]

  # Prepare the update for execution. Validates and runs callbacks, etc.
  #
  # _@param_ `options` — The options.
  #
  # _@return_ — The result of the update.
  #
  # Prepare for update.
  # ```ruby
  # document.prepare_update do
  #   collection.update(atomic_selector)
  # end
  # ```
  def prepare_update: (?::Hash[untyped, untyped] options) -> bool

  # Update the document in the database.
  #
  # _@param_ `options` — Options to pass to update.
  #
  # _@return_ — True if succeeded, false if not.
  #
  # Update an existing document.
  # ```ruby
  # document.update
  # ```
  def update_document: (?::Hash[untyped, untyped] options) -> bool

  # Perform a $set operation on the provided field/value pairs and set the
  # values in the document in memory.
  #
  # The key can be a dotted sequence of keys, in which case the
  # top level field is treated as a nested hash and any missing keys
  # are created automatically:
  #
  # Performing a nested set like this merges values of intermediate keys:
  #
  # If the top level field was not a hash, its original value is discarded
  # and the field is replaced with a hash.
  #
  # Note that unlike MongoDB's $set, Mongoid's set writes out the entire
  # field even when setting a subset of the field via the nested hash
  # semantics. This means performing a $set with nested hash semantics
  # can overwrite other hash keys within the top level field in the database.
  #
  # _@param_ `setters` — The field/value pairs to set.
  #
  # _@return_ — The document.
  #
  # Set the values.
  # ```ruby
  # document.set(title: "sir", dob: Date.new(1970, 1, 1))
  # ```
  #
  # Set the values using nested hash semantics.
  # ```ruby
  # document.set('author.title' => 'Sir')
  # # => document.author == {'title' => 'Sir'}
  # ```
  #
  # Nested hash value merging.
  # ```ruby
  # document.set('author.title' => 'Sir')
  # document.set('author.name' => 'Linus Torvalds')
  # # => document.author == {'title' => 'Sir', 'name' => 'Linus Torvalds'}
  # ```
  #
  # Nested hash overwriting a non-hash value.
  # ```ruby
  # document.set('author' => 'John Doe')
  # document.set('author.title' => 'Sir')
  # # => document.author == {'title' => 'Sir'}
  # ```
  def set: (::Hash[untyped, untyped] setters) -> Document

  # Save the document - will perform an insert if the document is new, and
  # update if not.
  #
  # _@param_ `options` — Options to pass to the save.
  #
  # _@return_ — True is success, false if not.
  #
  # Save the document.
  # ```ruby
  # document.save
  # ```
  def save: (?::Hash[untyped, untyped] options) -> bool

  # Save the document - will perform an insert if the document is new, and
  # update if not. If a validation error occurs an error will get raised.
  #
  # _@param_ `options` — Options to pass to the save.
  #
  # _@return_ — True if validation passed.
  #
  # Save the document.
  # ```ruby
  # document.save!
  # ```
  def save!: (?::Hash[untyped, untyped] options) -> bool

  # Rename fields from one value to another via $rename.
  #
  # _@param_ `renames` — The rename pairs of old name/new name.
  #
  # _@return_ — The document.
  #
  # Rename the fields.
  # ```ruby
  # document.rename(title: "salutation", name: "nombre")
  # ```
  #
  # _@note_ — This does not work for fields in embeds many associations.
  def rename: (::Hash[untyped, untyped] renames) -> Document

  # Add the single values to the arrays only if the value does not already
  # exist in the array.
  #
  # _@param_ `adds` — The field/value pairs to add.
  #
  # _@return_ — The document.
  #
  # Add the values to the sets.
  # ```ruby
  # document.add_to_set(names: "James", aliases: "Bond")
  # ```
  def add_to_set: (::Hash[untyped, untyped] adds) -> Document

  # Push a single value or multiple values onto arrays.
  #
  # _@param_ `pushes` — The $push operations.
  #
  # _@return_ — The document.
  #
  # Push a single value onto arrays.
  # ```ruby
  # document.push(names: "James", aliases: "007")
  # ```
  #
  # Push multiple values onto arrays.
  # ```ruby
  # document.push(names: [ "James", "Bond" ])
  # ```
  def push: (::Hash[untyped, untyped] pushes) -> Document

  # Pull single values from the provided arrays.
  #
  # _@param_ `pulls` — The field/value pull pairs.
  #
  # _@return_ — The document.
  #
  # Pull a value from the array.
  # ```ruby
  # document.pull(names: "Jeff", levels: 5)
  # ```
  #
  # _@note_ — If duplicate values are found they will all be pulled.
  def pull: (::Hash[untyped, untyped] pulls) -> Document

  # Pull multiple values from the provided array fields.
  #
  # _@param_ `pulls` — The pull all operations.
  #
  # _@return_ — The document.
  #
  # Pull values from the arrays.
  # ```ruby
  # document.pull_all(names: [ "Jeff", "Bob" ], levels: [ 5, 6 ])
  # ```
  def pull_all: (::Hash[untyped, untyped] pulls) -> Document

  # Takes the provided selector and atomic operations and replaces the
  # indexes of the embedded documents with the positional operator when
  # needed.
  #
  # _@param_ `selector` — The selector.
  #
  # _@param_ `operations` — The update operations.
  #
  # _@param_ `processed` — The processed update operations.
  #
  # _@return_ — The new operations.
  #
  # Process the operations.
  # ```ruby
  # positionally(
  #   { "_id" => 1, "addresses._id" => 2 },
  #   { "$set" => { "addresses.0.street" => "hobrecht" }}
  # )
  # ```
  #
  # _@note_ — The only time we can accurately know when to use the positional
  # operator is at the exact time we are going to persist something. So
  # we can tell by the selector that we are sending if it is actually
  # possible to use the positional operator at all. For example, if the
  # selector is: { "_id" => 1 }, then we could not use the positional
  # operator for updating embedded documents since there would never be a
  # match - we base whether we can based on the number of levels deep the
  # selector goes, and if the id values are not nil.
  def positionally: (::Hash[untyped, untyped] selector, ::Hash[untyped, untyped] operations, ?::Hash[untyped, untyped] processed) -> ::Hash[untyped, untyped]

  def process_operations: (untyped keys, untyped operations, untyped processed) -> untyped

  def process_updates: (untyped keys, untyped update, ?untyped updates) -> untyped

  def replace_index: (untyped keys, untyped position) -> untyped

  # Pop or shift items from arrays using the $pop operator.
  #
  # _@param_ `pops` — The field/value pop operations.
  #
  # _@return_ — The document.
  #
  # Pop items from an array.
  # ```ruby
  # document.pop(aliases: 1)
  # ```
  #
  # Shift items in the array.
  # ```ruby
  # document.pop(aliases: -1)
  # ```
  #
  # Multiple pops in one call.
  # ```ruby
  # document.pop(names: 1, aliases: 1)
  # ```
  def pop: (::Hash[untyped, untyped] pops) -> Document

  # Performs an atomic $bit operation on the field with the provided hash
  # of bitwise ops to execute in order.
  #
  # _@param_ `operations` — The bitwise operations.
  #
  # _@return_ — The document.
  #
  # Execute the bitwise operations.
  # ```ruby
  # person.bit(age: { :and => 12 }, val: { and: 10, or: 12 })
  # ```
  def bit: (::Hash[untyped, untyped] operations) -> Document

  # Increment the provided fields by the corresponding values. Values can
  # be positive or negative, and if no value exists for the field it will
  # be set with the provided value.
  #
  # _@param_ `increments` — The field/inc increment pairs.
  #
  # _@return_ — The document.
  #
  # Increment the fields.
  # ```ruby
  # document.inc(score: 10, place: 1, lives: -10)
  # ```
  def inc: (::Hash[untyped, untyped] increments) -> Document

  # Remove the document from the database with callbacks.
  #
  # _@param_ `options` — Options to pass to destroy.
  #
  # _@return_ — True if successful, false if not.
  #
  # Destroy a document.
  # ```ruby
  # document.destroy
  # ```
  def destroy: (?::Hash[untyped, untyped]? options) -> bool

  def destroy!: (?untyped options) -> untyped

  # Remove the document from the database.
  #
  # _@param_ `options` — Options to pass to remove.
  #
  # _@return_ — True.
  #
  # Remove the document.
  # ```ruby
  # document.remove
  # ```
  def delete: (?::Hash[untyped, untyped] options) -> TrueClass

  # Get the atomic deletes for the operation.
  #
  # _@return_ — The atomic deletes.
  #
  # Get the atomic deletes.
  # ```ruby
  # document.atomic_deletes
  # ```
  def atomic_deletes: () -> ::Hash[untyped, untyped]

  # Delete the embedded document.
  #
  # _@param_ `options` — The deletion options.
  #
  # _@return_ — If the operation succeeded.
  #
  # Delete the embedded document.
  # ```ruby
  # document.delete_as_embedded
  # ```
  def delete_as_embedded: (?::Hash[untyped, untyped] options) -> bool

  # Delete the root document.
  #
  # _@return_ — If the document was removed.
  #
  # Delete the root document.
  # ```ruby
  # document.delete_as_root
  # ```
  def delete_as_root: () -> bool

  # Are we needing to notify the parent document of the deletion.
  #
  # _@param_ `options` — The delete options.
  #
  # _@return_ — If the parent should be notified.
  #
  # Are we notifying the parent.
  # ```ruby
  # document.notifying_parent?(suppress: true)
  # ```
  def notifying_parent?: (?::Hash[untyped, untyped] options) -> bool

  # Prepare the delete operation.
  #
  # _@return_ — The result of the block.
  #
  # Prepare the delete operation.
  # ```ruby
  # document.prepare_delete do
  #   collection.find(atomic_selector).remove
  # end
  # ```
  def prepare_delete: () -> Object

  # Insert a new document into the database. Will return the document
  # itself whether or not the save was successful.
  #
  # _@param_ `options` — Options to pass to insert.
  #
  # _@return_ — The persisted document.
  #
  # Insert a document.
  # ```ruby
  # document.insert
  # ```
  def insert: (?::Hash[untyped, untyped] options) -> Document

  # Get the atomic insert for embedded documents, either a push or set.
  #
  # _@return_ — The insert ops.
  #
  # Get the inserts.
  # ```ruby
  # document.inserts
  # ```
  def atomic_inserts: () -> ::Hash[untyped, untyped]

  # Insert the embedded document.
  #
  # _@return_ — The document.
  #
  # Insert the document as embedded.
  # ```ruby
  # document.insert_as_embedded
  # ```
  def insert_as_embedded: () -> Document

  # Insert the root document.
  #
  # _@return_ — The document.
  #
  # Insert the document as root.
  # ```ruby
  # document.insert_as_root
  # ```
  def insert_as_root: () -> Document

  # Post process an insert, which sets the new record attribute to false
  # and flags all the children as persisted.
  #
  # _@return_ — true.
  #
  # Post process the insert.
  # ```ruby
  # document.post_process_insert
  # ```
  def post_process_insert: () -> bool

  # Prepare the insert for execution. Validates and runs callbacks, etc.
  #
  # _@param_ `options` — The options.
  #
  # _@return_ — The document.
  #
  # Prepare for insertion.
  # ```ruby
  # document.prepare_insert do
  #   collection.insert(as_document)
  # end
  # ```
  def prepare_insert: (?::Hash[untyped, untyped] options) -> Document

  # Determines if this document has the attributes to match the supplied
  # MongoDB selector. Used for matching on embedded associations.
  #
  # _@param_ `selector` — The MongoDB selector.
  #
  # _@return_ — True if matches, false if not.
  #
  # Does the document match?
  # ```ruby
  # document._matches?(:title => { "$in" => [ "test" ] })
  # ```
  def _matches?: (::Hash[untyped, untyped] selector) -> bool

  # Apply all default values to the document which are not procs.
  #
  # _@return_ — The names of the non-proc defaults.
  #
  # Apply all the non-proc defaults.
  # ```ruby
  # model.apply_pre_processed_defaults
  # ```
  def apply_pre_processed_defaults: () -> ::Array[String]

  # Apply all default values to the document which are procs.
  #
  # _@return_ — The names of the proc defaults.
  #
  # Apply all the proc defaults.
  # ```ruby
  # model.apply_post_processed_defaults
  # ```
  def apply_post_processed_defaults: () -> ::Array[String]

  # Applies a single default value for the given name.
  #
  # _@param_ `name` — The name of the field.
  #
  # Apply a single default.
  # ```ruby
  # model.apply_default("name")
  # ```
  def apply_default: (String name) -> untyped

  # Apply all the defaults at once.
  #
  # Apply all the defaults.
  # ```ruby
  # model.apply_defaults
  # ```
  def apply_defaults: () -> untyped

  # Returns an array of names for the attributes available on this object.
  #
  # Provides the field names in an ORM-agnostic way. Rails v3.1+ uses this
  # method to automatically wrap params in JSON requests.
  #
  # _@return_ — The field names
  #
  # Get the field names
  # ```ruby
  # docment.attribute_names
  # ```
  def attribute_names: () -> ::Array[String]

  # Get the name of the provided field as it is stored in the database.
  # Used in determining if the field is aliased or not.
  #
  # _@param_ `name` — The name to get.
  #
  # _@return_ — The name of the field as it's stored in the db.
  #
  # Get the database field name.
  # ```ruby
  # model.database_field_name(:authorization)
  # ```
  def database_field_name: (String | Symbol name) -> String

  # Is the provided field a lazy evaluation?
  #
  # _@param_ `field` — The field.
  #
  # _@param_ `value` — The current value.
  #
  # _@return_ — If we set the field lazily.
  #
  # If the field is lazy settable.
  # ```ruby
  # doc.lazy_settable?(field, nil)
  # ```
  def lazy_settable?: (Standard | ForeignKey field, Object value) -> bool

  # Is the document using object ids?
  #
  # _@return_ — Using object ids.
  #
  # Is the document using object ids?
  # ```ruby
  # model.using_object_ids?
  # ```
  #
  # _@note_ — Refactored from using delegate for class load performance.
  def using_object_ids?: () -> bool

  # Evolve the document into an object id.
  #
  # _@return_ — The document's id.
  #
  # Evolve the document.
  # ```ruby
  # document.__evolve_object_id__
  # ```
  def __evolve_object_id__: () -> Object

  # Determine if an attribute is present.
  #
  # _@param_ `name` — The name of the attribute.
  #
  # _@return_ — True if present, false if not.
  #
  # Is the attribute present?
  # ```ruby
  # person.attribute_present?("title")
  # ```
  def attribute_present?: (String | Symbol name) -> bool

  # Get the attributes that have not been cast.
  #
  # _@return_ — The uncast attributes.
  #
  # Get the attributes before type cast.
  # ```ruby
  # document.attributes_before_type_cast
  # ```
  def attributes_before_type_cast: () -> ::Hash[untyped, untyped]

  # Does the document have the provided attribute?
  #
  # _@param_ `name` — The name of the attribute.
  #
  # _@return_ — If the key is present in the attributes.
  #
  # Does the document have the attribute?
  # ```ruby
  # model.has_attribute?(:name)
  # ```
  def has_attribute?: (String | Symbol name) -> bool

  # Does the document have the provided attribute before it was assigned
  # and type cast?
  #
  # _@param_ `name` — The name of the attribute.
  #
  # _@return_ — If the key is present in the
  # attributes_before_type_cast.
  #
  # Does the document have the attribute before it was assigned?
  # ```ruby
  # model.has_attribute_before_type_cast?(:name)
  # ```
  def has_attribute_before_type_cast?: (String | Symbol name) -> bool

  # Read a value from the document attributes. If the value does not exist
  # it will return nil.
  #
  # _@param_ `name` — The name of the attribute to get.
  #
  # _@return_ — The value of the attribute.
  #
  # Read an attribute.
  # ```ruby
  # person.read_attribute(:title)
  # ```
  #
  # Read an attribute (alternate syntax.)
  # ```ruby
  # person[:title]
  # ```
  def read_attribute: (String | Symbol name) -> Object

  # Read a value from the attributes before type cast. If the value has not
  # yet been assigned then this will return the attribute's existing value
  # using read_raw_attribute.
  #
  # _@param_ `name` — The name of the attribute to get.
  #
  # _@return_ — The value of the attribute before type cast, if
  # available. Otherwise, the value of the attribute.
  #
  # Read an attribute before type cast.
  # ```ruby
  # person.read_attribute_before_type_cast(:price)
  # ```
  def read_attribute_before_type_cast: (String | Symbol name) -> Object

  # Remove a value from the +Document+ attributes. If the value does not exist
  # it will fail gracefully.
  #
  # _@param_ `name` — The name of the attribute to remove.
  #
  # Remove the attribute.
  # ```ruby
  # person.remove_attribute(:title)
  # ```
  def remove_attribute: (String | Symbol name) -> untyped

  # Write a single attribute to the document attribute hash. This will
  # also fire the before and after update callbacks, and perform any
  # necessary typecasting.
  #
  # _@param_ `name` — The name of the attribute to update.
  #
  # _@param_ `value` — The value to set for the attribute.
  #
  # Write the attribute.
  # ```ruby
  # person.write_attribute(:title, "Mr.")
  # ```
  #
  # Write the attribute (alternate syntax.)
  # ```ruby
  # person[:title] = "Mr."
  # ```
  def write_attribute: (String | Symbol name, Object value) -> untyped

  # Allows you to set all the attributes for a particular mass-assignment security role
  # by passing in a hash of attributes with keys matching the attribute names
  # (which again matches the column names)  and the role name using the :as option.
  # To bypass mass-assignment security you can use the :without_protection => true option.
  #
  # _@param_ `attrs` — The new attributes to set.
  #
  # Assign the attributes.
  # ```ruby
  # person.assign_attributes(:title => "Mr.")
  # ```
  #
  # Assign the attributes (with a role).
  # ```ruby
  # person.assign_attributes({ :title => "Mr." }, :as => :admin)
  # ```
  def assign_attributes: (?::Hash[untyped, untyped]? attrs) -> untyped

  # Writes the supplied attributes hash to the document. This will only
  # overwrite existing attributes if they are present in the new +Hash+, all
  # others will be preserved.
  #
  # _@param_ `attrs` — The new attributes to set.
  #
  # Write the attributes.
  # ```ruby
  # person.write_attributes(:title => "Mr.")
  # ```
  #
  # Write the attributes (alternate syntax.)
  # ```ruby
  # person.attributes = { :title => "Mr." }
  # ```
  def write_attributes: (?::Hash[untyped, untyped]? attrs) -> untyped

  # Determine if the attribute is missing from the document, due to loading
  # it from the database with missing fields.
  #
  # _@param_ `name` — The name of the attribute.
  #
  # _@return_ — If the attribute is missing.
  #
  # Is the attribute missing?
  # ```ruby
  # document.attribute_missing?("test")
  # ```
  def attribute_missing?: (String name) -> bool

  # Return type-casted attributes.
  #
  # _@return_ — The hash with keys and values of the type-casted attributes.
  #
  # Type-casted attributes.
  # ```ruby
  # document.typed_attributes
  # ```
  def typed_attributes: () -> Object

  def selection_excluded?: (untyped name, untyped selection, untyped field) -> bool

  def selection_included?: (untyped name, untyped selection, untyped field) -> bool

  # Does the string contain dot syntax for accessing hashes?
  #
  # _@return_ — If the string contains a "."
  #
  # Is the string in dot syntax.
  # ```ruby
  # model.hash_dot_syntax?
  # ```
  def hash_dot_syntax?: (untyped string) -> bool

  # Return the typecasted value for a field.
  #
  # _@param_ `key` — The field name.
  #
  # _@param_ `value` — The uncast value.
  #
  # _@return_ — The cast value.
  #
  # Get the value typecasted.
  # ```ruby
  # person.typed_value_for(:title, :sir)
  # ```
  def typed_value_for: (String | Symbol key, Object value) -> Object

  def read_raw_attribute: (untyped name) -> untyped

  # Validates an attribute value as being assignable to the specified field.
  #
  # For now, only Hash and Array fields are validated, and the value is
  # being checked to be of an appropriate type (i.e. either Hash or Array,
  # respectively, or nil).
  #
  # This method takes the name of the field as stored in the document
  # in the database, not (necessarily) the Ruby method name used to read/write
  # the said field.
  #
  # _@param_ `field_name` — The name of the field.
  #
  # _@param_ `value` — The value to be validated.
  def validate_attribute_value: (String | Symbol field_name, Object value) -> untyped

  def lookup_attribute_presence: (untyped name, untyped value) -> untyped

  # Are we able to write the attribute with the provided name?
  #
  # _@param_ `name` — The name of the field.
  #
  # _@return_ — If the document is new, or if the field is not
  # readonly.
  #
  # Can we write the attribute?
  # ```ruby
  # model.attribute_writable?(:title)
  # ```
  def attribute_writable?: (String | Symbol name) -> bool

  def as_writable_attribute!: (untyped name, ?untyped value) -> untyped

  def _loaded?: (untyped name) -> bool

  def projected_field?: (untyped name) -> bool

  # Process the provided attributes casting them to their proper values if a
  # field exists for them on the document. This will be limited to only the
  # attributes provided in the suppied +Hash+ so that no extra nil values get
  # put into the document's attributes.
  #
  # _@param_ `attrs` — The attributes to set.
  #
  # Process the attributes.
  # ```ruby
  # person.process_attributes(:title => "sir", :age => 40)
  # ```
  def process_attributes: (?::Hash[untyped, untyped]? attrs) -> untyped

  # If the key provided is the name of an association or a nested attribute, we
  # need to wait until all other attributes are set before processing
  # these.
  #
  # _@param_ `key` — The name of the attribute.
  #
  # _@param_ `value` — The value of the attribute.
  #
  # _@return_ — True if pending, false if not.
  #
  # Is the attribute pending?
  # ```ruby
  # document.pending_attribute?(:name, "Durran")
  # ```
  def pending_attribute?: (Symbol key, Object value) -> bool

  # Get all the pending associations that need to be set.
  #
  # _@return_ — The pending associations in key/value pairs.
  #
  # Get the pending associations.
  # ```ruby
  # document.pending_relations
  # ```
  def pending_relations: () -> ::Hash[untyped, untyped]

  # Get all the pending nested attributes that need to be set.
  #
  # _@return_ — The pending nested attributes in key/value pairs.
  #
  # Get the pending nested attributes.
  # ```ruby
  # document.pending_nested
  # ```
  def pending_nested: () -> ::Hash[untyped, untyped]

  # If the attribute is dynamic, add a field for it with a type of object
  # and then either way set the value.
  #
  # _@param_ `name` — The name of the field.
  #
  # _@param_ `value` — The value of the field.
  #
  # Process the attribute.
  # ```ruby
  # document.process_attribute(name, value)
  # ```
  def process_attribute: (Symbol name, Object value) -> untyped

  # Process all the pending nested attributes that needed to wait until
  # ids were set to fire off.
  #
  # Process the nested attributes.
  # ```ruby
  # document.process_nested
  # ```
  def process_nested: () -> untyped

  # Process all the pending items, then clear them out.
  #
  # Process the pending items.
  # ```ruby
  # document.process_pending
  # ```
  def process_pending: () -> untyped

  # Process all the pending associations that needed to wait until ids were set
  # to fire off.
  #
  # Process the associations.
  # ```ruby
  # document.process_relations
  # ```
  def process_relations: () -> untyped

  # Execute a block within the context of a session.
  #
  # _@param_ `options` — The session options. Please see the driver documentation for the available session options.
  #
  # _@return_ — The result of calling the block.
  #
  # Execute some operations in the context of a session.
  # ```ruby
  # band.with_session(causal_consistency: true) do
  #   band.records << Record.create
  #   band.name = 'FKA Twigs'
  #   band.save
  #   band.reload
  # end
  # ```
  #
  # _@note_ — You cannot do any operations in the block using models or objects
  # that use a different client; the block will execute all operations
  # in the context of the implicit session and operations on any models using
  # another client will fail. For example, if you set a client using store_in on a
  # particular model and execute an operation on it in the session context block,
  # that operation can't use the block's session and an error will be raised.
  # An error will also be raised if sessions are nested.
  def with_session: (?::Hash[untyped, untyped] options) -> Object

  def _session: () -> untyped

  # Change the persistence context for this object during the block.
  #
  # _@param_ `options_or_context` — The storage options or a persistence context.
  #
  # Save the current document to a different collection.
  # ```ruby
  # model.with(collection: "bands") do |m|
  #   m.save
  # end
  # ```
  def with: (::Hash[untyped, untyped] | Mongoid::PersistenceContext options_or_context) { () -> untyped } -> untyped

  def collection: (?untyped parent) -> untyped

  def collection_name: () -> untyped

  def mongo_client: () -> untyped

  def persistence_context: () -> untyped

  def set_persistence_context: (untyped options_or_context) -> untyped

  def clear_persistence_context: (?untyped original_cluster, ?untyped context) -> untyped

  # Get the changed attributes for the document.
  #
  # _@return_ — The changed attributes.
  #
  # Get the changed attributes.
  # ```ruby
  # model.changed
  # ```
  def changed: () -> ::Array[String]

  # Has the document changed?
  #
  # _@return_ — If the document is changed.
  #
  # Has the document changed?
  # ```ruby
  # model.changed?
  # ```
  def changed?: () -> bool

  # Have any children (embedded documents) of this document changed?
  #
  # _@return_ — If any children have changed.
  #
  # Have any children changed?
  # ```ruby
  # model.children_changed?
  # ```
  def children_changed?: () -> bool

  # Get the attribute changes.
  #
  # _@return_ — The attribute changes.
  #
  # Get the attribute changes.
  # ```ruby
  # model.changed_attributes
  # ```
  def changed_attributes: () -> ::Hash[String, Object]

  # Get all the changes for the document.
  #
  # _@return_ — The changes.
  #
  # Get all the changes.
  # ```ruby
  # model.changes
  # ```
  def changes: () -> ::Hash[String, ::Array[Object | Object]]

  # Call this method after save, so the changes can be properly switched.
  #
  # This will unset the memoized children array, set new record to
  # false, set the document as validated, and move the dirty changes.
  #
  # Move the changes to previous.
  # ```ruby
  # person.move_changes
  # ```
  def move_changes: () -> untyped

  # Things that need to execute after a document has been persisted.
  #
  # Handle post persistence.
  # ```ruby
  # document.post_persist
  # ```
  def post_persist: () -> untyped

  # Get the previous changes on the document.
  #
  # _@return_ — The previous changes.
  #
  # Get the previous changes.
  # ```ruby
  # model.previous_changes
  # ```
  def previous_changes: () -> ::Hash[String, ::Array[Object | Object]]

  # Remove a change from the dirty attributes hash. Used by the single field
  # atomic updators.
  #
  # _@param_ `name` — The name of the field.
  #
  # Remove a flagged change.
  # ```ruby
  # model.remove_change(:field)
  # ```
  def remove_change: (Symbol | String name) -> untyped

  # Gets all the new values for each of the changed fields, to be passed to
  # a MongoDB $set modifier.
  #
  # _@return_ — A +Hash+ of atomic setters.
  #
  # Get the setters for the atomic updates.
  # ```ruby
  # person = Person.new(:title => "Sir")
  # person.title = "Madam"
  # person.setters # returns { "title" => "Madam" }
  # ```
  def setters: () -> ::Hash[untyped, untyped]

  # Get the old and new value for the provided attribute.
  #
  # _@param_ `attr` — The name of the attribute.
  #
  # _@return_ — The old and new values.
  #
  # Get the attribute change.
  # ```ruby
  # model.attribute_change("name")
  # ```
  def attribute_change: (String attr) -> ::Array[Object]

  # Determine if a specific attribute has changed.
  #
  # _@param_ `attr` — The name of the attribute.
  #
  # _@return_ — Whether the attribute has changed.
  #
  # Has the attribute changed?
  # ```ruby
  # model.attribute_changed?("name")
  # ```
  def attribute_changed?: (String attr) -> bool

  # Get whether or not the field has a different value from the default.
  #
  # _@param_ `attr` — The name of the attribute.
  #
  # _@return_ — If the attribute differs.
  #
  # Is the field different from the default?
  # ```ruby
  # model.attribute_changed_from_default?
  # ```
  def attribute_changed_from_default?: (String attr) -> bool

  # Get the previous value for the attribute.
  #
  # _@param_ `attr` — The attribute name.
  #
  # Get the previous value.
  # ```ruby
  # model.attribute_was("name")
  # ```
  def attribute_was: (String attr) -> untyped

  # Flag an attribute as going to change.
  #
  # _@param_ `attr` — The name of the attribute.
  #
  # _@return_ — The old value.
  #
  # Flag the attribute.
  # ```ruby
  # model.attribute_will_change!("name")
  # ```
  def attribute_will_change!: (String attr) -> Object

  # Set the attribute back to its old value.
  #
  # _@param_ `attr` — The name of the attribute.
  #
  # _@return_ — The old value.
  #
  # Reset the attribute.
  # ```ruby
  # model.reset_attribute!("name")
  # ```
  def reset_attribute!: (String attr) -> Object

  def reset_attribute_to_default!: (untyped attr) -> untyped

  # Add the document as an atomic pull.
  #
  # _@param_ `document` — The embedded document to pull.
  #
  # Add the atomic pull.
  # ```ruby
  # person.add_atomic_pull(address)
  # ```
  def add_atomic_pull: (Document document) -> untyped

  # Add an atomic unset for the document.
  #
  # _@param_ `document` — The child document.
  #
  # _@return_ — The children.
  #
  # Add an atomic unset.
  # ```ruby
  # document.add_atomic_unset(doc)
  # ```
  def add_atomic_unset: (Document document) -> ::Array[Document]

  # Returns path of the attribute for modification
  #
  # _@return_ — The path to the document attribute in the database
  #
  # Get path of the attribute
  # ```ruby
  # address.atomic_attribute_name(:city)
  # ```
  def atomic_attribute_name: (untyped name) -> String

  # For array fields these are the pushes that need to happen.
  #
  # _@return_ — The array pushes.
  #
  # Get the array pushes.
  # ```ruby
  # person.atomic_array_pushes
  # ```
  def atomic_array_pushes: () -> ::Hash[untyped, untyped]

  # For array fields these are the pulls that need to happen.
  #
  # _@return_ — The array pulls.
  #
  # Get the array pulls.
  # ```ruby
  # person.atomic_array_pulls
  # ```
  def atomic_array_pulls: () -> ::Hash[untyped, untyped]

  # For array fields these are the unique adds that need to happen.
  #
  # _@return_ — The array add_to_sets.
  #
  # Get the array unique adds.
  # ```ruby
  # person.atomic_array_add_to_sets
  # ```
  def atomic_array_add_to_sets: () -> ::Hash[untyped, untyped]

  # Get all the atomic updates that need to happen for the current
  # +Document+. This includes all changes that need to happen in the
  # entire hierarchy that exists below where the save call was made.
  #
  # _@return_ — The updates and their modifiers.
  #
  # Get the updates that need to occur.
  # ```ruby
  # person.atomic_updates(children)
  # ```
  #
  # _@note_ — MongoDB does not allow "conflicting modifications" to be
  # performed in a single operation. Conflicting modifications are
  # detected by the 'haveConflictingMod' function in MongoDB.
  # Examination of the code suggests that two modifications (a $set
  # and a $push with $each, for example) conflict if:
  #   (1) the key paths being modified are equal.
  #   (2) one key path is a prefix of the other.
  # So a $set of 'addresses.0.street' will conflict with a $push and $each
  # to 'addresses', and we will need to split our update into two
  # pieces. We do not, however, attempt to match MongoDB's logic
  # exactly. Instead, we assume that two updates conflict if the
  # first component of the two key paths matches.
  def atomic_updates: (?untyped _use_indexes) -> ::Hash[untyped, untyped]

  # Get the removal modifier for the document. Will be nil on root
  # documents, $unset on embeds_one, $set on embeds_many.
  #
  # _@return_ — The pull or unset operation.
  #
  # Get the removal operator.
  # ```ruby
  # name.atomic_delete_modifier
  # ```
  def atomic_delete_modifier: () -> String

  # Get the insertion modifier for the document. Will be nil on root
  # documents, $set on embeds_one, $push on embeds_many.
  #
  # _@return_ — The pull or set operator.
  #
  # Get the insert operation.
  # ```ruby
  # name.atomic_insert_modifier
  # ```
  def atomic_insert_modifier: () -> String

  # Return the path to this +Document+ in JSON notation, used for atomic
  # updates via $set in MongoDB.
  #
  # _@return_ — The path to the document in the database.
  #
  # Get the path to this document.
  # ```ruby
  # address.atomic_path
  # ```
  def atomic_path: () -> String

  # Returns the positional operator of this document for modification.
  #
  # _@return_ — The positional operator with indexes.
  #
  # Get the positional operator.
  # ```ruby
  # address.atomic_position
  # ```
  def atomic_position: () -> String

  # Get the atomic paths utility for this document.
  #
  # _@return_ — The associated path.
  #
  # Get the atomic paths.
  # ```ruby
  # document.atomic_paths
  # ```
  def atomic_paths: () -> Object

  # Get all the attributes that need to be pulled.
  #
  # _@return_ — The $pullAll operations.
  #
  # Get the pulls.
  # ```ruby
  # person.atomic_pulls
  # ```
  def atomic_pulls: () -> ::Array[::Hash[untyped, untyped]]

  # Get all the push attributes that need to occur.
  #
  # _@return_ — The $push and $each operations.
  #
  # Get the pushes.
  # ```ruby
  # person.atomic_pushes
  # ```
  def atomic_pushes: () -> ::Hash[untyped, untyped]

  # Get all the attributes that need to be set.
  #
  # _@return_ — The $set operations.
  #
  # Get the sets.
  # ```ruby
  # person.atomic_sets
  # ```
  def atomic_sets: () -> ::Hash[untyped, untyped]

  # Get all the attributes that need to be unset.
  #
  # _@return_ — The $unset operations.
  #
  # Get the unsets.
  # ```ruby
  # person.atomic_unsets
  # ```
  def atomic_unsets: () -> ::Array[::Hash[untyped, untyped]]

  # Get all the atomic sets that have had their saves delayed.
  #
  # _@return_ — The delayed $sets.
  #
  # Get the delayed atomic sets.
  # ```ruby
  # person.delayed_atomic_sets
  # ```
  def delayed_atomic_sets: () -> ::Hash[untyped, untyped]

  # Get a hash of atomic pulls that are pending.
  #
  # _@return_ — name/document pairs.
  #
  # Get the atomic pulls.
  # ```ruby
  # document.delayed_atomic_pulls
  # ```
  def delayed_atomic_pulls: () -> ::Hash[untyped, untyped]

  # Get the delayed atomic unsets.
  #
  # _@return_ — The atomic unsets
  #
  # Get the delayed atomic unsets.
  # ```ruby
  # document.delayed_atomic_unsets
  # ```
  def delayed_atomic_unsets: () -> ::Hash[untyped, untyped]

  # Flag the document as destroyed and return the atomic path.
  #
  # _@return_ — The atomic path.
  #
  # Flag destroyed and return path.
  # ```ruby
  # document.flag_as_destroyed
  # ```
  def flag_as_destroyed: () -> String

  # Get the flagged destroys.
  #
  # _@return_ — The flagged destroys.
  #
  # Get the flagged destroy.
  # ```ruby
  # document.flagged_destroys
  # ```
  def flagged_destroys: () -> ::Array[Proc]

  # Process all the pending flagged destroys from nested attributes.
  #
  # _@return_ — The cleared array.
  #
  # Process all the pending flagged destroys.
  # ```ruby
  # document.process_flagged_destroys
  # ```
  def process_flagged_destroys: () -> ::Array[untyped]

  # Generates the atomic updates in the correct order.
  #
  # _@param_ `mods` — The atomic modifications.
  #
  # _@param_ `doc` — The document to update for.
  #
  # Generate the updates.
  # ```ruby
  # model.generate_atomic_updates(mods, doc)
  # ```
  def generate_atomic_updates: (Modifiers mods, Document doc) -> untyped

  # Get the atomic updates for a touch operation. Should only include the
  # updated_at field and the optional extra field.
  #
  # _@param_ `field` — The optional field.
  #
  # _@return_ — The atomic updates.
  #
  # Get the touch atomic updates.
  # ```ruby
  # document.touch_atomic_updates
  # ```
  def touch_atomic_updates: (?Symbol? field) -> ::Hash[untyped, untyped]
end

Mongoid::Composable::MODULES: untyped

Mongoid::Composable::RESERVED_METHOD_NAMES: untyped

Mongoid::Composable::CALLBACKS: untyped

Mongoid::Composable::MACRO_MAPPING: untyped

Mongoid::Composable::STRATEGIES: untyped

Mongoid::Composable::LIST_OPERATIONS: untyped

Mongoid::Composable::StringifiedSymbol: untyped

Mongoid::Composable::Boolean: untyped

Mongoid::Composable::TYPE_MAPPINGS: untyped

Mongoid::Composable::IDS: untyped

Mongoid::Composable::CREATE_LOCK: untyped

Mongoid::Composable::UPDATES: untyped

module Mongoid::Contextual
  extend Forwardable

  # Get the context in which criteria queries should execute. This is either
  # in memory (for embedded documents) or mongo (for root level documents.)
  #
  # _@return_ — The context.
  #
  # Get the context.
  # ```ruby
  # criteria.context
  # ```
  def context: () -> (Memory | Mongo)

  # Create the context for the queries to execute. Will be memory for
  # embedded documents and mongo for root documents.
  #
  # _@return_ — The context.
  #
  # Create the context.
  # ```ruby
  # contextual.create_context
  # ```
  def create_context: () -> (Mongo | Memory)
end

class Mongoid::Contextual::None
  include Enumerable

  include Mongoid::Contextual::Queryable

  # Check if the context is equal to the other object.
  #
  # _@param_ `other` — The other array.
  #
  # _@return_ — If the objects are equal.
  #
  # Check equality.
  # ```ruby
  # context == []
  # ```
  def ==: (::Array[untyped] other) -> bool

  # Allow distinct for null context.
  #
  # _@param_ `field` — the name of the field.
  #
  # _@return_ — Empty Array
  #
  # Get the distinct values.
  # ```ruby
  # context.distinct(:name)
  # ```
  def distinct: (String | Symbol field) -> ::Array[untyped]

  # Iterate over the null context. There are no documents to iterate over
  # in this case.
  #
  # _@return_ — The enumerator.
  #
  # Iterate over the context.
  # ```ruby
  # context.each do |doc|
  #   puts doc.name
  # end
  # ```
  def each: () -> ::Enumerator[untyped]

  # Do any documents exist for the context.
  #
  # _@return_ — If the count is more than zero.
  #
  # Do any documents exist for the context.
  # ```ruby
  # context.exists?
  # ```
  def exists?: () -> bool

  # Allow pluck for null context.
  #
  # _@param_ `args` — Field or fields to pluck.
  #
  # _@return_ — Emtpy Array
  #
  # Allow pluck for null context.
  # ```ruby
  # context.pluck(:name)
  # ```
  def pluck: (*String | Symbol | ::Array[untyped] args) -> ::Array[untyped]

  # Create the new null context.
  #
  # _@param_ `criteria` — The criteria.
  #
  # Create the new context.
  # ```ruby
  # Null.new(criteria)
  # ```
  def initialize: (Criteria criteria) -> void

  # Always returns nil.
  #
  # _@return_ — Always nil.
  #
  # Get the last document.
  # ```ruby
  # context.last
  # ```
  def last: () -> nil

  # Always returns zero.
  #
  # _@return_ — Always zero.
  #
  # Get the length of matching documents.
  # ```ruby
  # context.length
  # ```
  def length: () -> Integer

  # Is the enumerable of matching documents empty?
  #
  # _@return_ — If the context is empty.
  #
  # Is the context empty?
  # ```ruby
  # context.blank?
  # ```
  def blank?: () -> bool
end

class Mongoid::Contextual::Mongo
  include Enumerable

  include Mongoid::Contextual::Aggregable::Mongo

  include Mongoid::Atomic

  include Mongoid::Association::EagerLoadable

  include Mongoid::Contextual::Queryable

  extend Forwardable

  # Returns the value of attribute criteria.
  #
  # Returns the value of attribute klass.
  #
  # Is the context cached?
  #
  # _@return_ — If the context is cached.
  #
  # Is the context cached?
  # ```ruby
  # context.cached?
  # ```
  def cached?: () -> untyped
             | () -> untyped
             | () -> bool

  # Get the number of documents matching the query.
  #
  # _@param_ `options` — The options, such as skip and limit to be factored into the count.
  #
  # _@return_ — The number of matches.
  #
  # Get the number of matching documents.
  # ```ruby
  # context.count
  # ```
  #
  # Get the count of documents with the provided options.
  # ```ruby
  # context.count(limit: 1)
  # ```
  #
  # Get the count for where the provided block is true.
  # ```ruby
  # context.count do |doc|
  #   doc.likes > 1
  # end
  # ```
  def count: (?::Hash[untyped, untyped] options) { () -> untyped } -> Integer

  # Get the estimated number of documents matching the query.
  #
  # Unlike count, estimated_count does not take a block because it is not
  # traditionally defined (with a block) on Enumarable like count is.
  #
  # _@param_ `options` — The options, such as maxTimeMS to be factored into the count.
  #
  # _@return_ — The number of matches.
  #
  # Get the estimated number of matching documents.
  # ```ruby
  # context.estimated_count
  # ```
  def estimated_count: (?::Hash[untyped, untyped] options) -> Integer

  # Delete all documents in the database that match the selector.
  #
  # _@return_ — Nil.
  #
  # Delete all the documents.
  # ```ruby
  # context.delete
  # ```
  def delete: () -> nil

  # Destroy all documents in the database that match the selector.
  #
  # _@return_ — Nil.
  #
  # Destroy all the documents.
  # ```ruby
  # context.destroy
  # ```
  def destroy: () -> nil

  # Get the distinct values in the db for the provided field.
  #
  # _@param_ `field` — The name of the field.
  #
  # _@return_ — The distinct values for the field.
  #
  # Get the distinct values.
  # ```ruby
  # context.distinct(:name)
  # ```
  def distinct: (String | Symbol field) -> ::Array[Object]

  # Iterate over the context. If provided a block, yield to a Mongoid
  # document for each, otherwise return an enum.
  #
  # _@return_ — The enumerator.
  #
  # Iterate over the context.
  # ```ruby
  # context.each do |doc|
  #   puts doc.name
  # end
  # ```
  def each: () { () -> untyped } -> ::Enumerator[untyped]

  # Do any documents exist for the context.
  #
  # _@return_ — If the count is more than zero.
  #
  # Do any documents exist for the context.
  # ```ruby
  # context.exists?
  # ```
  #
  # _@note_ — We don't use count here since Mongo does not use counted
  # b-tree indexes, unless a count is already cached then that is
  # used to determine the value.
  def exists?: () -> bool

  # Run an explain on the criteria.
  #
  # _@return_ — The explain result.
  #
  # Explain the criteria.
  # ```ruby
  # Band.where(name: "Depeche Mode").explain
  # ```
  def explain: () -> ::Hash[untyped, untyped]

  # Execute the find and modify command, used for MongoDB's
  # $findAndModify.
  #
  # _@param_ `update` — The updates.
  #
  # _@param_ `options` — The command options.
  #
  # _@return_ — The result of the command.
  #
  # Execute the command.
  # ```ruby
  # context.find_one_and_update({ "$inc" => { likes: 1 }})
  # ```
  def find_one_and_update: (::Hash[untyped, untyped] update, ?::Hash[untyped, untyped] options) -> Document

  # Execute the find and modify command, used for MongoDB's
  # $findAndModify.
  #
  # _@param_ `replacement` — The replacement.
  #
  # _@param_ `options` — The command options.
  #
  # _@return_ — The result of the command.
  #
  # Execute the command.
  # ```ruby
  # context.find_one_and_update({ likes: 1 })
  # ```
  def find_one_and_replace: (::Hash[untyped, untyped] replacement, ?::Hash[untyped, untyped] options) -> Document

  # Execute the find and modify command, used for MongoDB's
  # $findAndModify. This deletes the found document.
  #
  # _@return_ — The result of the command.
  #
  # Execute the command.
  # ```ruby
  # context.find_one_and_delete
  # ```
  def find_one_and_delete: () -> Document

  # Get the first document in the database for the criteria's selector.
  #
  # _@param_ `opts` — The options for the query returning the first document.
  #
  # _@return_ — The first document.
  #
  # Get the first document.
  # ```ruby
  # context.first
  # ```
  #
  # _@note_ — Automatically adding a sort on _id when no other sort is
  # defined on the criteria has the potential to cause bad performance issues.
  # If you experience unexpected poor performance when using #first or #last
  # and have no sort defined on the criteria, use the option { id_sort: :none }.
  # Be aware that #first/#last won't guarantee order in this case.
  def first: (?::Hash[untyped, untyped] opts) -> Document

  # Return the first result without applying sort
  def find_first: () -> untyped

  # Execute a $geoNear command against the database.
  #
  # _@param_ `coordinates` — The coordinates.
  #
  # _@return_ — The GeoNear command.
  #
  # Find documents close to 10, 10.
  # ```ruby
  # context.geo_near([ 10, 10 ])
  # ```
  #
  # Find with spherical distance.
  # ```ruby
  # context.geo_near([ 10, 10 ]).spherical
  # ```
  #
  # Find with a max distance.
  # ```ruby
  # context.geo_near([ 10, 10 ]).max_distance(0.5)
  # ```
  #
  # Provide a distance multiplier.
  # ```ruby
  # context.geo_near([ 10, 10 ]).distance_multiplier(1133)
  # ```
  #
  # _@deprecated_ — 
  def geo_near: (::Array[Float] coordinates) -> GeoNear

  # Invoke the block for each element of Contextual. Create a new array
  # containing the values returned by the block.
  #
  # If the symbol field name is passed instead of the block, additional
  # optimizations would be used.
  #
  # _@param_ `field` — The field name.
  #
  # _@return_ — The result of mapping.
  #
  # Map by some field.
  # ```ruby
  # context.map(:field1)
  # ```
  #
  # Map with block.
  # ```ruby
  # context.map(&:field1)
  # ```
  def map: (?Symbol? field) { () -> untyped } -> ::Array[untyped]

  # Create the new Mongo context. This delegates operations to the
  # underlying driver.
  #
  # _@param_ `criteria` — The criteria.
  #
  # Create the new context.
  # ```ruby
  # Mongo.new(criteria)
  # ```
  def initialize: (Criteria criteria) -> void

  # Get the last document in the database for the criteria's selector.
  #
  # _@param_ `opts` — The options for the query returning the first document.
  #
  # Get the last document.
  # ```ruby
  # context.last
  # ```
  #
  # _@note_ — Automatically adding a sort on _id when no other sort is
  # defined on the criteria has the potential to cause bad performance issues.
  # If you experience unexpected poor performance when using #first or #last
  # and have no sort defined on the criteria, use the option { id_sort: :none }.
  # Be aware that #first/#last won't guarantee order in this case.
  def last: (?::Hash[untyped, untyped] opts) -> untyped

  # Get's the number of documents matching the query selector.
  #
  # _@return_ — The number of documents.
  #
  # Get the length.
  # ```ruby
  # context.length
  # ```
  def length: () -> Integer

  # Limits the number of documents that are returned from the database.
  #
  # _@param_ `value` — The number of documents to return.
  #
  # _@return_ — The context.
  #
  # Limit the documents.
  # ```ruby
  # context.limit(20)
  # ```
  def limit: (Integer value) -> Mongo

  # Initiate a map/reduce operation from the context.
  #
  # _@param_ `map` — The map js function.
  #
  # _@param_ `reduce` — The reduce js function.
  #
  # _@return_ — The map/reduce lazy wrapper.
  #
  # Initiate a map/reduce.
  # ```ruby
  # context.map_reduce(map, reduce)
  # ```
  def map_reduce: (String map, String reduce) -> MapReduce

  # Pluck the single field values from the database. Will return duplicates
  # if they exist and only works for top level fields.
  #
  # _@param_ `fields` — Fields to pluck.
  #
  # _@return_ — The plucked values.
  #
  # Pluck a field.
  # ```ruby
  # context.pluck(:_id)
  # ```
  #
  # _@note_ — This method will return the raw db values - it performs no custom
  # serialization.
  def pluck: (*String | Symbol | ::Array[untyped] fields) -> ::Array[Object | ::Array[untyped]]

  # Skips the provided number of documents.
  #
  # _@param_ `value` — The number of documents to skip.
  #
  # _@return_ — The context.
  #
  # Skip the documents.
  # ```ruby
  # context.skip(20)
  # ```
  def skip: (Integer value) -> Mongo

  # Sorts the documents by the provided spec.
  #
  # _@param_ `values` — The sorting values as field/direction(1/-1) pairs.
  #
  # _@return_ — The context.
  #
  # Sort the documents.
  # ```ruby
  # context.sort(name: -1, title: 1)
  # ```
  def sort: (?::Hash[untyped, untyped]? values) { () -> untyped } -> Mongo

  # Update the first matching document atomically.
  #
  # _@param_ `attributes` — The new attributes for the document.
  #
  # _@param_ `opts` — The update operation options.
  #
  # _@return_ — False if no attributes were provided.
  #
  # Update the first matching document.
  # ```ruby
  # context.update({ "$set" => { name: "Smiths" }})
  # ```
  def update: (?::Hash[untyped, untyped]? attributes, ?::Hash[untyped, untyped] opts) -> bool?

  # Update all the matching documents atomically.
  #
  # _@param_ `attributes` — The new attributes for each document.
  #
  # _@param_ `opts` — The update operation options.
  #
  # _@return_ — False if no attributes were provided.
  #
  # Update all the matching documents.
  # ```ruby
  # context.update_all({ "$set" => { name: "Smiths" }})
  # ```
  def update_all: (?::Hash[untyped, untyped]? attributes, ?::Hash[untyped, untyped] opts) -> bool?

  # yield the block given or return the cached value
  #
  # _@param_ `key` — The instance variable name
  #
  # _@return_ — the result of the block
  def try_cache: (String | Symbol key) { () -> untyped } -> untyped

  # Update the documents for the provided method.
  #
  # _@param_ `attributes` — The updates.
  #
  # _@param_ `method` — The method to use.
  #
  # _@return_ — If the update succeeded.
  #
  # Update the documents.
  # ```ruby
  # context.update_documents(attrs)
  # ```
  def update_documents: (::Hash[untyped, untyped] attributes, ?Symbol method, ?untyped opts) -> bool

  # Apply the field limitations.
  #
  # Apply the field limitations.
  # ```ruby
  # context.apply_fields
  # ```
  def apply_fields: () -> untyped

  # Apply the options.
  #
  # Apply all options.
  # ```ruby
  # context.apply_options
  # ```
  def apply_options: () -> untyped

  # Apply an option.
  #
  # Apply the skip option.
  # ```ruby
  # context.apply_option(:skip)
  # ```
  def apply_option: (untyped name) -> untyped

  # Map the inverse sort symbols to the correct MongoDB values.
  #
  # Apply the inverse sorting params to the given block
  # ```ruby
  # context.with_inverse_sorting
  # ```
  def with_inverse_sorting: (?untyped opts) -> untyped

  # Is the cache able to be added to?
  #
  # _@return_ — If caching, and the cache isn't loaded.
  #
  # Is the context cacheable?
  # ```ruby
  # context.cacheable?
  # ```
  def cacheable?: () -> bool

  # Is the cache fully loaded? Will be true if caching after one full
  # iteration.
  #
  # _@return_ — If the cache is loaded.
  #
  # Is the cache loaded?
  # ```ruby
  # context.cache_loaded?
  # ```
  def cache_loaded?: () -> bool

  # Get the documents for cached queries.
  #
  # _@return_ — The documents.
  #
  # Get the cached documents.
  # ```ruby
  # context.documents
  # ```
  def documents: () -> ::Array[Document]

  # sord warn - Mongo::Collection::View wasn't able to be resolved to a constant in this project
  # Get the documents the context should iterate. This follows 3 rules:
  #
  # 1. If the query is cached, and we already have documents loaded, use
  #   them.
  # 2. If we are eager loading, then eager load the documents and use
  #   those.
  # 3. Use the query.
  #
  # _@return_ — The docs to iterate.
  #
  # Get the documents for iteration.
  # ```ruby
  # context.documents_for_iteration
  # ```
  def documents_for_iteration: () -> (::Array[Document] | ::Collection::View)

  # Yield to the document.
  #
  # _@param_ `document` — The document to yield to.
  #
  # Yield the document.
  # ```ruby
  # context.yield_document(doc) do |doc|
  #   ...
  # end
  # ```
  def yield_document: (Document document) { () -> untyped } -> untyped

  def _session: () -> untyped

  def acknowledged_write?: () -> bool

  # Is the enumerable of matching documents empty?
  #
  # _@return_ — If the context is empty.
  #
  # Is the context empty?
  # ```ruby
  # context.blank?
  # ```
  def blank?: () -> bool

  def eager_loadable?: () -> bool

  def eager_load: (untyped docs) -> untyped

  def preload: (untyped relations, untyped docs) -> untyped

  # Add the document as an atomic pull.
  #
  # _@param_ `document` — The embedded document to pull.
  #
  # Add the atomic pull.
  # ```ruby
  # person.add_atomic_pull(address)
  # ```
  def add_atomic_pull: (Document document) -> untyped

  # Add an atomic unset for the document.
  #
  # _@param_ `document` — The child document.
  #
  # _@return_ — The children.
  #
  # Add an atomic unset.
  # ```ruby
  # document.add_atomic_unset(doc)
  # ```
  def add_atomic_unset: (Document document) -> ::Array[Document]

  # Returns path of the attribute for modification
  #
  # _@return_ — The path to the document attribute in the database
  #
  # Get path of the attribute
  # ```ruby
  # address.atomic_attribute_name(:city)
  # ```
  def atomic_attribute_name: (untyped name) -> String

  # For array fields these are the pushes that need to happen.
  #
  # _@return_ — The array pushes.
  #
  # Get the array pushes.
  # ```ruby
  # person.atomic_array_pushes
  # ```
  def atomic_array_pushes: () -> ::Hash[untyped, untyped]

  # For array fields these are the pulls that need to happen.
  #
  # _@return_ — The array pulls.
  #
  # Get the array pulls.
  # ```ruby
  # person.atomic_array_pulls
  # ```
  def atomic_array_pulls: () -> ::Hash[untyped, untyped]

  # For array fields these are the unique adds that need to happen.
  #
  # _@return_ — The array add_to_sets.
  #
  # Get the array unique adds.
  # ```ruby
  # person.atomic_array_add_to_sets
  # ```
  def atomic_array_add_to_sets: () -> ::Hash[untyped, untyped]

  # Get all the atomic updates that need to happen for the current
  # +Document+. This includes all changes that need to happen in the
  # entire hierarchy that exists below where the save call was made.
  #
  # _@return_ — The updates and their modifiers.
  #
  # Get the updates that need to occur.
  # ```ruby
  # person.atomic_updates(children)
  # ```
  #
  # _@note_ — MongoDB does not allow "conflicting modifications" to be
  # performed in a single operation. Conflicting modifications are
  # detected by the 'haveConflictingMod' function in MongoDB.
  # Examination of the code suggests that two modifications (a $set
  # and a $push with $each, for example) conflict if:
  #   (1) the key paths being modified are equal.
  #   (2) one key path is a prefix of the other.
  # So a $set of 'addresses.0.street' will conflict with a $push and $each
  # to 'addresses', and we will need to split our update into two
  # pieces. We do not, however, attempt to match MongoDB's logic
  # exactly. Instead, we assume that two updates conflict if the
  # first component of the two key paths matches.
  def atomic_updates: (?untyped _use_indexes) -> ::Hash[untyped, untyped]

  # Get the removal modifier for the document. Will be nil on root
  # documents, $unset on embeds_one, $set on embeds_many.
  #
  # _@return_ — The pull or unset operation.
  #
  # Get the removal operator.
  # ```ruby
  # name.atomic_delete_modifier
  # ```
  def atomic_delete_modifier: () -> String

  # Get the insertion modifier for the document. Will be nil on root
  # documents, $set on embeds_one, $push on embeds_many.
  #
  # _@return_ — The pull or set operator.
  #
  # Get the insert operation.
  # ```ruby
  # name.atomic_insert_modifier
  # ```
  def atomic_insert_modifier: () -> String

  # Return the path to this +Document+ in JSON notation, used for atomic
  # updates via $set in MongoDB.
  #
  # _@return_ — The path to the document in the database.
  #
  # Get the path to this document.
  # ```ruby
  # address.atomic_path
  # ```
  def atomic_path: () -> String

  # Returns the positional operator of this document for modification.
  #
  # _@return_ — The positional operator with indexes.
  #
  # Get the positional operator.
  # ```ruby
  # address.atomic_position
  # ```
  def atomic_position: () -> String

  # Get the atomic paths utility for this document.
  #
  # _@return_ — The associated path.
  #
  # Get the atomic paths.
  # ```ruby
  # document.atomic_paths
  # ```
  def atomic_paths: () -> Object

  # Get all the attributes that need to be pulled.
  #
  # _@return_ — The $pullAll operations.
  #
  # Get the pulls.
  # ```ruby
  # person.atomic_pulls
  # ```
  def atomic_pulls: () -> ::Array[::Hash[untyped, untyped]]

  # Get all the push attributes that need to occur.
  #
  # _@return_ — The $push and $each operations.
  #
  # Get the pushes.
  # ```ruby
  # person.atomic_pushes
  # ```
  def atomic_pushes: () -> ::Hash[untyped, untyped]

  # Get all the attributes that need to be set.
  #
  # _@return_ — The $set operations.
  #
  # Get the sets.
  # ```ruby
  # person.atomic_sets
  # ```
  def atomic_sets: () -> ::Hash[untyped, untyped]

  # Get all the attributes that need to be unset.
  #
  # _@return_ — The $unset operations.
  #
  # Get the unsets.
  # ```ruby
  # person.atomic_unsets
  # ```
  def atomic_unsets: () -> ::Array[::Hash[untyped, untyped]]

  # Get all the atomic sets that have had their saves delayed.
  #
  # _@return_ — The delayed $sets.
  #
  # Get the delayed atomic sets.
  # ```ruby
  # person.delayed_atomic_sets
  # ```
  def delayed_atomic_sets: () -> ::Hash[untyped, untyped]

  # Get a hash of atomic pulls that are pending.
  #
  # _@return_ — name/document pairs.
  #
  # Get the atomic pulls.
  # ```ruby
  # document.delayed_atomic_pulls
  # ```
  def delayed_atomic_pulls: () -> ::Hash[untyped, untyped]

  # Get the delayed atomic unsets.
  #
  # _@return_ — The atomic unsets
  #
  # Get the delayed atomic unsets.
  # ```ruby
  # document.delayed_atomic_unsets
  # ```
  def delayed_atomic_unsets: () -> ::Hash[untyped, untyped]

  # Flag the document as destroyed and return the atomic path.
  #
  # _@return_ — The atomic path.
  #
  # Flag destroyed and return path.
  # ```ruby
  # document.flag_as_destroyed
  # ```
  def flag_as_destroyed: () -> String

  # Get the flagged destroys.
  #
  # _@return_ — The flagged destroys.
  #
  # Get the flagged destroy.
  # ```ruby
  # document.flagged_destroys
  # ```
  def flagged_destroys: () -> ::Array[Proc]

  # Process all the pending flagged destroys from nested attributes.
  #
  # _@return_ — The cleared array.
  #
  # Process all the pending flagged destroys.
  # ```ruby
  # document.process_flagged_destroys
  # ```
  def process_flagged_destroys: () -> ::Array[untyped]

  # Generates the atomic updates in the correct order.
  #
  # _@param_ `mods` — The atomic modifications.
  #
  # _@param_ `doc` — The document to update for.
  #
  # Generate the updates.
  # ```ruby
  # model.generate_atomic_updates(mods, doc)
  # ```
  def generate_atomic_updates: (Modifiers mods, Document doc) -> untyped

  # Get the atomic updates for a touch operation. Should only include the
  # updated_at field and the optional extra field.
  #
  # _@param_ `field` — The optional field.
  #
  # _@return_ — The atomic updates.
  #
  # Get the touch atomic updates.
  # ```ruby
  # document.touch_atomic_updates
  # ```
  def touch_atomic_updates: (?Symbol? field) -> ::Hash[untyped, untyped]

  # Get all the aggregate values for the provided field.
  #
  # _@param_ `field` — The field name.
  #
  # _@return_ — count is a number of documents with the provided
  # field. If there're none, then count is 0 and max, min, sum, avg
  # are nil.
  #
  # Get all the aggregate values.
  # ```ruby
  # aggregable.aggregates(:likes)
  # # => {
  # #   "count" => 2.0,
  # #   "max" => 1000.0,
  # #   "min" => 500.0,
  # #   "sum" => 1500.0,
  # #   "avg" => 750.0
  # # }
  # ```
  def aggregates: (String | Symbol field) -> ::Hash[untyped, untyped]

  # Get the average value of the provided field.
  #
  # _@param_ `field` — The field to average.
  #
  # _@return_ — The average.
  #
  # Get the average of a single field.
  # ```ruby
  # aggregable.avg(:likes)
  # ```
  def avg: (Symbol field) -> Float

  # Get the max value of the provided field. If provided a block, will
  # return the Document with the greatest value for the field, in
  # accordance with Ruby's enumerable API.
  #
  # _@param_ `field` — The field to max.
  #
  # _@return_ — The max value or document with the max
  # value.
  #
  # Get the max of a single field.
  # ```ruby
  # aggregable.max(:likes)
  # ```
  #
  # Get the document with the max value.
  # ```ruby
  # aggregable.max do |a, b|
  #   a.likes <=> b.likes
  # end
  # ```
  def max: (?Symbol? field) -> (Float | Document)

  # Get the min value of the provided field. If provided a block, will
  # return the Document with the smallest value for the field, in
  # accordance with Ruby's enumerable API.
  #
  # _@param_ `field` — The field to min.
  #
  # _@return_ — The min value or document with the min
  # value.
  #
  # Get the min of a single field.
  # ```ruby
  # aggregable.min(:likes)
  # ```
  #
  # Get the document with the min value.
  # ```ruby
  # aggregable.min do |a, b|
  #   a.likes <=> b.likes
  # end
  # ```
  def min: (?Symbol? field) -> (Float | Document)

  # Get the sum value of the provided field. If provided a block, will
  # return the sum in accordance with Ruby's enumerable API.
  #
  # _@param_ `field` — The field to sum.
  #
  # _@return_ — The sum value.
  #
  # Get the sum of a single field.
  # ```ruby
  # aggregable.sum(:likes)
  # ```
  #
  # Get the sum for the provided block.
  # ```ruby
  # aggregable.sum(&:likes)
  # ```
  def sum: (?Symbol? field) -> Float

  # Get the aggregation pipeline for provided field.
  #
  # _@param_ `field` — The name of the field.
  #
  # _@return_ — The array of pipeline operators.
  #
  # Get the pipeline.
  # ```ruby
  # aggregable.pipeline(:likes)
  # ```
  def pipeline: (String | Symbol field) -> ::Array[untyped]
end

Mongoid::Contextual::Mongoid::Contextual::Mongo::OPTIONS: untyped

Mongoid::Contextual::Mongoid::Contextual::Mongo::UPDATES: untyped

module Mongoid::Contextual::Atomic
  # Returns the value of attribute view.
  #
  # Execute an atomic $addToSet on the matching documents.
  #
  # _@param_ `adds` — The operations.
  #
  # _@return_ — Nil.
  #
  # Add the value to the set.
  # ```ruby
  # context.add_to_set(members: "Dave", genres: "Electro")
  # ```
  def add_to_set: () -> untyped
                | () -> untyped
                | (::Hash[untyped, untyped] adds) -> nil

  # Perform an atomic $addToSet/$each on the matching documents.
  #
  # _@param_ `adds` — The operations.
  #
  # _@return_ — Nil.
  #
  # Add the value to the set.
  # ```ruby
  # context.add_each_to_set(members: ["Dave", "Bill"], genres: ["Electro", "Disco"])
  # ```
  def add_each_to_set: (::Hash[untyped, untyped] adds) -> nil

  # Perform an atomic $bit operation on the matching documents.
  #
  # _@param_ `bits` — The operations.
  #
  # _@return_ — Nil.
  #
  # Perform the bitwise op.
  # ```ruby
  # context.bit(likes: { and: 14, or: 4 })
  # ```
  def bit: (::Hash[untyped, untyped] bits) -> nil

  # Perform an atomic $inc operation on the matching documents.
  #
  # _@param_ `incs` — The operations.
  #
  # _@return_ — Nil.
  #
  # Perform the atomic increment.
  # ```ruby
  # context.inc(likes: 10)
  # ```
  def inc: (::Hash[untyped, untyped] incs) -> nil

  # Perform an atomic $pop operation on the matching documents.
  #
  # _@param_ `pops` — The operations.
  #
  # _@return_ — Nil.
  #
  # Pop the first value on the matches.
  # ```ruby
  # context.pop(members: -1)
  # ```
  #
  # Pop the last value on the matches.
  # ```ruby
  # context.pop(members: 1)
  # ```
  def pop: (::Hash[untyped, untyped] pops) -> nil

  # Perform an atomic $pull operation on the matching documents.
  #
  # _@param_ `pulls` — The operations.
  #
  # _@return_ — Nil.
  #
  # Pull the value from the matches.
  # ```ruby
  # context.pull(members: "Dave")
  # ```
  #
  # _@note_ — Expression pulling is not yet supported.
  def pull: (::Hash[untyped, untyped] pulls) -> nil

  # Perform an atomic $pullAll operation on the matching documents.
  #
  # _@param_ `pulls` — The operations.
  #
  # _@return_ — Nil.
  #
  # Pull all the matching values from the matches.
  # ```ruby
  # context.pull_all(:members, [ "Alan", "Vince" ])
  # ```
  def pull_all: (::Hash[untyped, untyped] pulls) -> nil

  # Perform an atomic $push operation on the matching documents.
  #
  # _@param_ `pushes` — The operations.
  #
  # _@return_ — Nil.
  #
  # Push the value to the matching docs.
  # ```ruby
  # context.push(members: "Alan")
  # ```
  def push: (::Hash[untyped, untyped] pushes) -> nil

  # Perform an atomic $push/$each operation on the matching documents.
  #
  # _@param_ `pushes` — The operations.
  #
  # _@return_ — Nil.
  #
  # Push the values to the matching docs.
  # ```ruby
  # context.push_all(members: [ "Alan", "Fletch" ])
  # ```
  def push_all: (::Hash[untyped, untyped] pushes) -> nil

  # Perform an atomic $rename of fields on the matching documents.
  #
  # _@param_ `renames` — The operations.
  #
  # _@return_ — Nil.
  #
  # Rename the fields on the matching documents.
  # ```ruby
  # context.rename(members: :artists)
  # ```
  def rename: (::Hash[untyped, untyped] renames) -> nil

  # Perform an atomic $set of fields on the matching documents.
  #
  # _@param_ `sets` — The operations.
  #
  # _@return_ — Nil.
  #
  # Set the field value on the matches.
  # ```ruby
  # context.set(name: "Depeche Mode")
  # ```
  def set: (::Hash[untyped, untyped] sets) -> nil

  # Perform an atomic $unset of a field on the matching documents.
  #
  # _@param_ `args` — The name of the fields.
  #
  # _@return_ — Nil.
  #
  # Unset the field on the matches.
  # ```ruby
  # context.unset(:name)
  # ```
  def unset: (*String | Symbol | ::Array[untyped] args) -> nil

  def collect_operations: (untyped ops) -> untyped

  def collect_each_operations: (untyped ops) -> untyped
end

class Mongoid::Contextual::Memory
  include Enumerable

  include Mongoid::Contextual::Aggregable::Memory

  include Mongoid::Association::EagerLoadable

  include Mongoid::Contextual::Queryable

  include Mongoid::Positional

  # Check if the context is equal to the other object.
  #
  # _@param_ `other` — The other array.
  #
  # _@return_ — If the objects are equal.
  #
  # Check equality.
  # ```ruby
  # context == []
  # ```
  def ==: (::Array[untyped] other) -> bool

  # Delete all documents in the database that match the selector.
  #
  # _@return_ — Nil.
  #
  # Delete all the documents.
  # ```ruby
  # context.delete
  # ```
  def delete: () -> nil

  # Destroy all documents in the database that match the selector.
  #
  # _@return_ — Nil.
  #
  # Destroy all the documents.
  # ```ruby
  # context.destroy
  # ```
  def destroy: () -> nil

  # Get the distinct values in the db for the provided field.
  #
  # _@param_ `field` — The name of the field.
  #
  # _@return_ — The distinct values for the field.
  #
  # Get the distinct values.
  # ```ruby
  # context.distinct(:name)
  # ```
  def distinct: (String | Symbol field) -> ::Array[Object]

  # Iterate over the context. If provided a block, yield to a Mongoid
  # document for each, otherwise return an enum.
  #
  # _@return_ — The enumerator.
  #
  # Iterate over the context.
  # ```ruby
  # context.each do |doc|
  #   puts doc.name
  # end
  # ```
  def each: () -> ::Enumerator[untyped]

  # Do any documents exist for the context.
  #
  # _@return_ — If the count is more than zero.
  #
  # Do any documents exist for the context.
  # ```ruby
  # context.exists?
  # ```
  def exists?: () -> bool

  # Get the first document in the database for the criteria's selector.
  #
  # _@return_ — The first document.
  #
  # Get the first document.
  # ```ruby
  # context.first
  # ```
  def first: (*untyped args) -> Document

  # Create the new in memory context.
  #
  # _@param_ `criteria` — The criteria.
  #
  # Create the new context.
  # ```ruby
  # Memory.new(criteria)
  # ```
  def initialize: (Criteria criteria) -> void

  # Increment a value on all documents.
  #
  # _@param_ `incs` — The operations.
  #
  # _@return_ — The enumerator.
  #
  # Perform the increment.
  # ```ruby
  # context.inc(likes: 10)
  # ```
  def inc: (::Hash[untyped, untyped] incs) -> ::Enumerator[untyped]

  # Get the last document in the database for the criteria's selector.
  #
  # _@return_ — The last document.
  #
  # Get the last document.
  # ```ruby
  # context.last
  # ```
  def last: () -> Document

  # Get the length of matching documents in the context.
  #
  # _@return_ — The matching length.
  #
  # Get the length of matching documents.
  # ```ruby
  # context.length
  # ```
  def length: () -> Integer

  # Limits the number of documents that are returned.
  #
  # _@param_ `value` — The number of documents to return.
  #
  # _@return_ — The context.
  #
  # Limit the documents.
  # ```ruby
  # context.limit(20)
  # ```
  def limit: (Integer value) -> Mongo

  def pluck: (*untyped fields) -> untyped

  # Skips the provided number of documents.
  #
  # _@param_ `value` — The number of documents to skip.
  #
  # _@return_ — The context.
  #
  # Skip the documents.
  # ```ruby
  # context.skip(20)
  # ```
  def skip: (Integer value) -> Mongo

  # Sorts the documents by the provided spec.
  #
  # _@param_ `values` — The sorting values as field/direction(1/-1) pairs.
  #
  # _@return_ — The context.
  #
  # Sort the documents.
  # ```ruby
  # context.sort(name: -1, title: 1)
  # ```
  def sort: (::Hash[untyped, untyped] values) -> Mongo

  # Update the first matching document atomically.
  #
  # _@param_ `attributes` — The new attributes for the document.
  #
  # _@return_ — False if no attributes were provided.
  #
  # Update the matching document.
  # ```ruby
  # context.update(name: "Smiths")
  # ```
  def update: (?::Hash[untyped, untyped]? attributes) -> bool?

  # Update all the matching documents atomically.
  #
  # _@param_ `attributes` — The new attributes for each document.
  #
  # _@return_ — False if no attributes were provided.
  #
  # Update all the matching documents.
  # ```ruby
  # context.update_all(name: "Smiths")
  # ```
  def update_all: (?::Hash[untyped, untyped]? attributes) -> bool?

  # Get the documents the context should iterate. This follows 3 rules:
  #
  # _@return_ — The docs to iterate.
  #
  # Get the documents for iteration.
  # ```ruby
  # context.documents_for_iteration
  # ```
  def documents_for_iteration: () -> ::Array[Document]

  # Update the provided documents with the attributes.
  #
  # _@param_ `attributes` — The attributes.
  #
  # _@param_ `docs` — The docs to update.
  #
  # Update the documents.
  # ```ruby
  # context.update_documents({}, doc)
  # ```
  def update_documents: (::Hash[untyped, untyped] attributes, ::Array[Document] docs) -> untyped

  # Get the limiting value.
  #
  # _@return_ — The limit.
  #
  # Get the limiting value.
  # ```ruby
  # ```
  def limiting: () -> Integer

  # Set the limiting value.
  #
  # _@param_ `value` — The limit.
  #
  # _@return_ — The limit.
  #
  # Set the limiting value.
  # ```ruby
  # ```
  def limiting=: (Integer value) -> Integer

  # Get the skiping value.
  #
  # _@return_ — The skip.
  #
  # Get the skiping value.
  # ```ruby
  # ```
  def skipping: () -> Integer

  # Set the skiping value.
  #
  # _@param_ `value` — The skip.
  #
  # _@return_ — The skip.
  #
  # Set the skiping value.
  # ```ruby
  # ```
  def skipping=: (Integer value) -> Integer

  # Apply criteria options.
  #
  # _@return_ — self.
  #
  # Apply criteria options.
  # ```ruby
  # context.apply_options
  # ```
  def apply_options: () -> Memory

  # Map the sort symbols to the correct MongoDB values.
  #
  # Apply the sorting params.
  # ```ruby
  # context.apply_sorting
  # ```
  def apply_sorting: () -> untyped

  # Compare two values, checking for nil.
  #
  # _@param_ `a` — The first object.
  #
  # _@param_ `b` — The first object.
  #
  # _@return_ — The comparison value.
  #
  # Compare the two objects.
  # ```ruby
  # context.compare(a, b)
  # ```
  def compare: (Object a, Object b) -> Integer

  # Sort the documents in place.
  #
  # _@param_ `values` — The field/direction sorting pairs.
  #
  # Sort the documents.
  # ```ruby
  # context.in_place_sort(name: 1)
  # ```
  def in_place_sort: (::Hash[untyped, untyped] values) -> untyped

  # Prepare the document for batch removal.
  #
  # _@param_ `doc` — The document.
  #
  # Prepare for removal.
  # ```ruby
  # context.prepare_remove(doc)
  # ```
  def prepare_remove: (Document doc) -> untyped

  def _session: () -> untyped

  # Takes the provided selector and atomic operations and replaces the
  # indexes of the embedded documents with the positional operator when
  # needed.
  #
  # _@param_ `selector` — The selector.
  #
  # _@param_ `operations` — The update operations.
  #
  # _@param_ `processed` — The processed update operations.
  #
  # _@return_ — The new operations.
  #
  # Process the operations.
  # ```ruby
  # positionally(
  #   { "_id" => 1, "addresses._id" => 2 },
  #   { "$set" => { "addresses.0.street" => "hobrecht" }}
  # )
  # ```
  #
  # _@note_ — The only time we can accurately know when to use the positional
  # operator is at the exact time we are going to persist something. So
  # we can tell by the selector that we are sending if it is actually
  # possible to use the positional operator at all. For example, if the
  # selector is: { "_id" => 1 }, then we could not use the positional
  # operator for updating embedded documents since there would never be a
  # match - we base whether we can based on the number of levels deep the
  # selector goes, and if the id values are not nil.
  def positionally: (::Hash[untyped, untyped] selector, ::Hash[untyped, untyped] operations, ?::Hash[untyped, untyped] processed) -> ::Hash[untyped, untyped]

  def process_operations: (untyped keys, untyped operations, untyped processed) -> untyped

  def process_updates: (untyped keys, untyped update, ?untyped updates) -> untyped

  def replace_index: (untyped keys, untyped position) -> untyped

  # Is the enumerable of matching documents empty?
  #
  # _@return_ — If the context is empty.
  #
  # Is the context empty?
  # ```ruby
  # context.blank?
  # ```
  def blank?: () -> bool

  def eager_loadable?: () -> bool

  def eager_load: (untyped docs) -> untyped

  def preload: (untyped relations, untyped docs) -> untyped

  # Get the average value of the provided field.
  #
  # _@param_ `field` — The field to average.
  #
  # _@return_ — The average.
  #
  # Get the average of a single field.
  # ```ruby
  # aggregable.avg(:likes)
  # ```
  def avg: (Symbol field) -> Float

  # Get the max value of the provided field. If provided a block, will
  # return the Document with the greatest value for the field, in
  # accordance with Ruby's enumerable API.
  #
  # _@param_ `field` — The field to max.
  #
  # _@return_ — The max value or document with the max
  # value.
  #
  # Get the max of a single field.
  # ```ruby
  # aggregable.max(:likes)
  # ```
  #
  # Get the document with the max value.
  # ```ruby
  # aggregable.max do |a, b|
  #   a.likes <=> b.likes
  # end
  # ```
  def max: (?Symbol? field) -> (Float | Document)

  # Get the min value of the provided field. If provided a block, will
  # return the Document with the smallest value for the field, in
  # accordance with Ruby's enumerable API.
  #
  # _@param_ `field` — The field to min.
  #
  # _@return_ — The min value or document with the min
  # value.
  #
  # Get the min of a single field.
  # ```ruby
  # aggregable.min(:likes)
  # ```
  #
  # Get the document with the min value.
  # ```ruby
  # aggregable.min do |a, b|
  #   a.likes <=> b.likes
  # end
  # ```
  def min: (?Symbol? field) -> (Float | Document)

  # Get the sum value of the provided field. If provided a block, will
  # return the sum in accordance with Ruby's enumerable API.
  #
  # _@param_ `field` — The field to sum.
  #
  # _@return_ — The sum value.
  #
  # Get the sum of a single field.
  # ```ruby
  # aggregable.sum(:likes)
  # ```
  #
  # Get the sum for the provided block.
  # ```ruby
  # aggregable.sum(&:likes)
  # ```
  def sum: (?Symbol? field) -> Float

  # Aggregate by the provided field and method.
  #
  # _@param_ `field` — The field to aggregate on.
  #
  # _@param_ `method` — The method (min_by or max_by).
  #
  # _@return_ — The aggregate.
  #
  # Aggregate by the field and method.
  # ```ruby
  # aggregable.aggregate_by(:name, :min_by)
  # ```
  def aggregate_by: (Symbol field, Symbol method) -> Integer
end

module Mongoid::Contextual::Command
  # Returns the value of attribute documents.
  #
  # Returns the value of attribute path.
  #
  # Returns the value of attribute root.
  #
  # Returns the value of attribute selector.
  #
  # The database command that is being built to send to the db.
  #
  # _@return_ — The db command.
  #
  # Get the command.
  # ```ruby
  # command.command
  # ```
  def command: () -> untyped
             | () -> untyped
             | () -> untyped
             | () -> untyped
             | () -> untyped
             | () -> untyped
             | () -> untyped
             | () -> untyped
             | () -> ::Hash[untyped, untyped]

  # sord warn - Mongo::Client wasn't able to be resolved to a constant in this project
  # Get the database client.
  #
  # _@return_ — The Mongo client.
  #
  # Get the client.
  # ```ruby
  # command.client
  # ```
  def client: () -> ::Client
end

class Mongoid::Contextual::GeoNear
  include Enumerable

  include Mongoid::Contextual::Command

  extend Forwardable

  # Returns the value of attribute collection.
  #
  # Returns the value of attribute criteria.
  #
  # Get the average distance for all documents from the point in the
  # command.
  #
  # _@return_ — The average distance.
  #
  # Get the average distance.
  # ```ruby
  # geo_near.average_distance
  # ```
  def average_distance: () -> untyped
                      | () -> untyped
                      | () -> untyped
                      | () -> untyped
                      | () -> Float?

  # Iterates over each of the documents in the $geoNear, excluding the
  # extra information that was passed back from the database.
  #
  # _@return_ — The enumerator.
  #
  # Iterate over the results.
  # ```ruby
  # geo_near.each do |doc|
  #   p doc
  # end
  # ```
  def each: () -> ::Enumerator[untyped]

  # Provide a distance multiplier to be used for each returned distance.
  #
  # _@param_ `value` — The distance multiplier.
  #
  # _@return_ — The GeoNear wrapper.
  #
  # Provide the distance multiplier.
  # ```ruby
  # geo_near.distance_multiplier(13113.1)
  # ```
  def distance_multiplier: (Integer | Float value) -> GeoNear

  # sord warn - Mongo::Collection wasn't able to be resolved to a constant in this project
  # Initialize the new map/reduce directive.
  #
  # _@param_ `collection` — The collection to run the operation on.
  #
  # _@param_ `criteria` — The Mongoid criteria.
  #
  # _@param_ `near`
  #
  # Initialize the new map/reduce.
  # ```ruby
  # MapReduce.new(criteria, map, reduce)
  # ```
  def initialize: (::Collection collection, Criteria criteria, String near) -> void

  # Get a pretty string representation of the command.
  #
  # _@return_ — The inspection string.
  #
  # Inspect the geoNear.
  # ```ruby
  # geo_near.inspect
  # ```
  def inspect: () -> String

  # Specify the maximum distance to find documents for, or get the value of
  # the document with the furthest distance.
  #
  # _@param_ `value` — The maximum distance.
  #
  # _@return_ — The GeoNear command or the value.
  #
  # Set the max distance.
  # ```ruby
  # geo_near.max_distance(0.5)
  # ```
  #
  # Get the max distance.
  # ```ruby
  # geo_near.max_distance
  # ```
  def max_distance: (?(Integer | Float)? value) -> (GeoNear | Float)

  # Specify the minimum distance to find documents for.
  #
  # _@param_ `value` — The minimum distance.
  #
  # _@return_ — The GeoNear command.
  #
  # Set the min distance.
  # ```ruby
  # geo_near.min_distance(0.5)
  # ```
  def min_distance: (Integer | Float value) -> GeoNear

  # Tell the command to calculate based on spherical distances.
  #
  # _@return_ — The command.
  #
  # Add the spherical flag.
  # ```ruby
  # geo_near.spherical
  # ```
  def spherical: () -> GeoNear

  # Tell the command whether or not the retured results should be unique.
  #
  # _@param_ `value` — Whether to return unique documents.
  #
  # _@return_ — The command.
  #
  # Set the unique flag.
  # ```ruby
  # geo_near.unique(false)
  # ```
  def unique: (?bool value) -> GeoNear

  # Execute the $geoNear, returning the raw output.
  #
  # _@return_ — The raw output
  #
  # Run the $geoNear
  # ```ruby
  # geo_near.execute
  # ```
  def execute: () -> ::Hash[untyped, untyped]

  # Get the stats for the command run.
  #
  # _@return_ — The stats from the command run.
  #
  # Get the stats.
  # ```ruby
  # geo_near.stats
  # ```
  def stats: () -> ::Hash[untyped, untyped]

  # Get the execution time of the command.
  #
  # _@return_ — The execution time.
  #
  # Get the execution time.
  # ```ruby
  # geo_near.time
  # ```
  def time: () -> Float

  # Is this context's criteria considered empty?
  #
  # _@return_ — Always true.
  #
  # Is this context's criteria considered empty?
  # ```ruby
  # geo_near.empty_and_chainable?
  # ```
  def empty_and_chainable?: () -> bool

  # Apply criteria specific options - query, limit.
  #
  # _@return_ — Nothing.
  #
  # Apply the criteria options
  # ```ruby
  # geo_near.apply_criteria_options
  # ```
  def apply_criteria_options: () -> nil

  # sord warn - Cursor wasn't able to be resolved to a constant in this project
  # Get the result documents from the $geoNear.
  #
  # _@return_ — The documents.
  #
  # Get the documents.
  # ```ruby
  # geo_near.documents
  # ```
  def documents: () -> (::Array[untyped] | ::Cursor)

  # Execute the $geoNear command and get the results.
  #
  # _@return_ — The results of the command.
  #
  # Get the results.
  # ```ruby
  # geo_near.results
  # ```
  def results: () -> ::Hash[untyped, untyped]

  # The database command that is being built to send to the db.
  #
  # _@return_ — The db command.
  #
  # Get the command.
  # ```ruby
  # command.command
  # ```
  def command: () -> ::Hash[untyped, untyped]

  # sord warn - Mongo::Client wasn't able to be resolved to a constant in this project
  # Get the database client.
  #
  # _@return_ — The Mongo client.
  #
  # Get the client.
  # ```ruby
  # command.client
  # ```
  def client: () -> ::Client
end

module Mongoid::Contextual::Queryable
  # Is the enumerable of matching documents empty?
  #
  # _@return_ — If the context is empty.
  #
  # Is the context empty?
  # ```ruby
  # context.blank?
  # ```
  def blank?: () -> bool
end

class Mongoid::Contextual::MapReduce
  include Enumerable

  include Mongoid::Contextual::Command

  extend Forwardable

  # Returns the value of attribute collection.
  #
  # Returns the value of attribute criteria.
  #
  # Returns the value of attribute klass.
  #
  # Get all the counts returned by the map/reduce.
  #
  # _@return_ — The counts.
  #
  # Get the counts.
  # ```ruby
  # map_reduce.counts
  # ```
  def counts: () -> untyped
            | () -> untyped
            | () -> untyped
            | () -> untyped
            | () -> untyped
            | () -> untyped
            | () -> ::Hash[untyped, untyped]

  # Iterates over each of the documents in the map/reduce, excluding the
  # extra information that was passed back from the database.
  #
  # _@return_ — The enumerator.
  #
  # Iterate over the results.
  # ```ruby
  # map_reduce.each do |doc|
  #   p doc
  # end
  # ```
  def each: () -> ::Enumerator[untyped]

  # Get the number of documents emitted by the map/reduce.
  #
  # _@return_ — The number of emitted documents.
  #
  # Get the emitted document count.
  # ```ruby
  # map_reduce.emitted
  # ```
  def emitted: () -> Integer

  # Provide a finalize js function for the map/reduce.
  #
  # _@param_ `function` — The finalize function.
  #
  # _@return_ — The map reduce.
  #
  # Provide a finalize function.
  # ```ruby
  # map_reduce.finalize(func)
  # ```
  def finalize: (String function) -> MapReduce

  def initialize: (untyped collection, Criteria criteria, String map, String reduce) -> void

  # Get the number of documents that were input into the map/reduce.
  #
  # _@return_ — The number of input documents.
  #
  # Get the count of input documents.
  # ```ruby
  # map_reduce.input
  # ```
  def input: () -> Integer

  # Sets the map/reduce to use jsMode.
  #
  # _@return_ — The map/reduce.
  #
  # Set the map/reduce to jsMode.
  # ```ruby
  # map_reduce.js_mode
  # ```
  def js_mode: () -> MapReduce

  # Specifies where the map/reduce output is to be stored.
  # Please see MongoDB documentation for supported map reduce options.
  #
  # _@param_ `location` — The place to store the results.
  #
  # _@return_ — The map/reduce object.
  #
  # Store output in memory.
  # ```ruby
  # map_reduce.out(inline: 1)
  # ```
  #
  # Store output in a collection, replacing existing documents.
  # ```ruby
  # map_reduce.out(replace: "collection_name")
  # ```
  #
  # Store output in a collection, merging existing documents.
  # ```ruby
  # map_reduce.out(merge: "collection_name")
  # ```
  #
  # Store output in a collection, reducing existing documents.
  # ```ruby
  # map_reduce.out(reduce: "collection_name")
  # ```
  #
  # Return results from map reduce.
  # ```ruby
  # map_reduce.out(inline: 1)
  # ```
  def out: (::Hash[untyped, untyped] location) -> MapReduce

  # Get the number of documents output by the map/reduce.
  #
  # _@return_ — The number of output documents.
  #
  # Get the output document count.
  # ```ruby
  # map_reduce.output
  # ```
  def output: () -> Integer

  # Get the raw output from the map/reduce operation.
  #
  # _@return_ — The raw output.
  #
  # Get the raw output.
  # ```ruby
  # map_reduce.raw
  # ```
  def raw: () -> ::Hash[untyped, untyped]

  # Get the number of documents reduced by the map/reduce.
  #
  # _@return_ — The number of reduced documents.
  #
  # Get the reduced document count.
  # ```ruby
  # map_reduce.reduced
  # ```
  def reduced: () -> Integer

  # Adds a javascript object to the global scope of the map/reduce.
  #
  # _@param_ `object` — A hash of key/values for the global scope.
  #
  # Add an object to the global scope.
  # ```ruby
  # map_reduce.scope(name: value)
  # ```
  def scope: (::Hash[untyped, untyped] object) -> MapReduce

  # Get the execution time of the map/reduce.
  #
  # _@return_ — The time in milliseconds.
  #
  # Get the execution time.
  # ```ruby
  # map_reduce.time
  # ```
  def time: () -> Float

  # Get a pretty string representation of the map/reduce, including the
  # criteria, map, reduce, finalize, and out option.
  #
  # _@return_ — The inspection string.
  #
  # Inspect the map_reduce.
  # ```ruby
  # map_reduce.inspect
  # ```
  def inspect: () -> String

  def command: () -> untyped

  def validate_out!: () -> untyped

  def _session: () -> untyped

  # sord warn - Mongo::Client wasn't able to be resolved to a constant in this project
  # Get the database client.
  #
  # _@return_ — The Mongo client.
  #
  # Get the client.
  # ```ruby
  # command.client
  # ```
  def client: () -> ::Client
end

module Mongoid::Contextual::Aggregable
end

# Contains behavior for aggregating values in Mongo.
module Mongoid::Contextual::Mongoid::Contextual::Aggregable::Mongo
  # Get all the aggregate values for the provided field.
  #
  # _@param_ `field` — The field name.
  #
  # _@return_ — count is a number of documents with the provided
  # field. If there're none, then count is 0 and max, min, sum, avg
  # are nil.
  #
  # Get all the aggregate values.
  # ```ruby
  # aggregable.aggregates(:likes)
  # # => {
  # #   "count" => 2.0,
  # #   "max" => 1000.0,
  # #   "min" => 500.0,
  # #   "sum" => 1500.0,
  # #   "avg" => 750.0
  # # }
  # ```
  def aggregates: (String | Symbol field) -> ::Hash[untyped, untyped]

  # Get the average value of the provided field.
  #
  # _@param_ `field` — The field to average.
  #
  # _@return_ — The average.
  #
  # Get the average of a single field.
  # ```ruby
  # aggregable.avg(:likes)
  # ```
  def avg: (Symbol field) -> Float

  # Get the max value of the provided field. If provided a block, will
  # return the Document with the greatest value for the field, in
  # accordance with Ruby's enumerable API.
  #
  # _@param_ `field` — The field to max.
  #
  # _@return_ — The max value or document with the max
  # value.
  #
  # Get the max of a single field.
  # ```ruby
  # aggregable.max(:likes)
  # ```
  #
  # Get the document with the max value.
  # ```ruby
  # aggregable.max do |a, b|
  #   a.likes <=> b.likes
  # end
  # ```
  def max: (?Symbol? field) -> (Float | Document)

  # Get the min value of the provided field. If provided a block, will
  # return the Document with the smallest value for the field, in
  # accordance with Ruby's enumerable API.
  #
  # _@param_ `field` — The field to min.
  #
  # _@return_ — The min value or document with the min
  # value.
  #
  # Get the min of a single field.
  # ```ruby
  # aggregable.min(:likes)
  # ```
  #
  # Get the document with the min value.
  # ```ruby
  # aggregable.min do |a, b|
  #   a.likes <=> b.likes
  # end
  # ```
  def min: (?Symbol? field) -> (Float | Document)

  # Get the sum value of the provided field. If provided a block, will
  # return the sum in accordance with Ruby's enumerable API.
  #
  # _@param_ `field` — The field to sum.
  #
  # _@return_ — The sum value.
  #
  # Get the sum of a single field.
  # ```ruby
  # aggregable.sum(:likes)
  # ```
  #
  # Get the sum for the provided block.
  # ```ruby
  # aggregable.sum(&:likes)
  # ```
  def sum: (?Symbol? field) -> Float

  # Get the aggregation pipeline for provided field.
  #
  # _@param_ `field` — The name of the field.
  #
  # _@return_ — The array of pipeline operators.
  #
  # Get the pipeline.
  # ```ruby
  # aggregable.pipeline(:likes)
  # ```
  def pipeline: (String | Symbol field) -> ::Array[untyped]
end

# Contains behavior for aggregating values in memory.
module Mongoid::Contextual::Mongoid::Contextual::Aggregable::Memory
  # Get the average value of the provided field.
  #
  # _@param_ `field` — The field to average.
  #
  # _@return_ — The average.
  #
  # Get the average of a single field.
  # ```ruby
  # aggregable.avg(:likes)
  # ```
  def avg: (Symbol field) -> Float

  # Get the max value of the provided field. If provided a block, will
  # return the Document with the greatest value for the field, in
  # accordance with Ruby's enumerable API.
  #
  # _@param_ `field` — The field to max.
  #
  # _@return_ — The max value or document with the max
  # value.
  #
  # Get the max of a single field.
  # ```ruby
  # aggregable.max(:likes)
  # ```
  #
  # Get the document with the max value.
  # ```ruby
  # aggregable.max do |a, b|
  #   a.likes <=> b.likes
  # end
  # ```
  def max: (?Symbol? field) -> (Float | Document)

  # Get the min value of the provided field. If provided a block, will
  # return the Document with the smallest value for the field, in
  # accordance with Ruby's enumerable API.
  #
  # _@param_ `field` — The field to min.
  #
  # _@return_ — The min value or document with the min
  # value.
  #
  # Get the min of a single field.
  # ```ruby
  # aggregable.min(:likes)
  # ```
  #
  # Get the document with the min value.
  # ```ruby
  # aggregable.min do |a, b|
  #   a.likes <=> b.likes
  # end
  # ```
  def min: (?Symbol? field) -> (Float | Document)

  # Get the sum value of the provided field. If provided a block, will
  # return the sum in accordance with Ruby's enumerable API.
  #
  # _@param_ `field` — The field to sum.
  #
  # _@return_ — The sum value.
  #
  # Get the sum of a single field.
  # ```ruby
  # aggregable.sum(:likes)
  # ```
  #
  # Get the sum for the provided block.
  # ```ruby
  # aggregable.sum(&:likes)
  # ```
  def sum: (?Symbol? field) -> Float

  # Aggregate by the provided field and method.
  #
  # _@param_ `field` — The field to aggregate on.
  #
  # _@param_ `method` — The method (min_by or max_by).
  #
  # _@return_ — The aggregate.
  #
  # Aggregate by the field and method.
  # ```ruby
  # aggregable.aggregate_by(:name, :min_by)
  # ```
  def aggregate_by: (Symbol field, Symbol method) -> Integer
end

# This module is responsible for taking update selectors and switching out
# the indexes for the $ positional operator where appropriate.
#
# @since 4.0.0
module Mongoid::Positional
  # Takes the provided selector and atomic operations and replaces the
  # indexes of the embedded documents with the positional operator when
  # needed.
  #
  # _@param_ `selector` — The selector.
  #
  # _@param_ `operations` — The update operations.
  #
  # _@param_ `processed` — The processed update operations.
  #
  # _@return_ — The new operations.
  #
  # Process the operations.
  # ```ruby
  # positionally(
  #   { "_id" => 1, "addresses._id" => 2 },
  #   { "$set" => { "addresses.0.street" => "hobrecht" }}
  # )
  # ```
  #
  # _@note_ — The only time we can accurately know when to use the positional
  # operator is at the exact time we are going to persist something. So
  # we can tell by the selector that we are sending if it is actually
  # possible to use the positional operator at all. For example, if the
  # selector is: { "_id" => 1 }, then we could not use the positional
  # operator for updating embedded documents since there would never be a
  # match - we base whether we can based on the number of levels deep the
  # selector goes, and if the id values are not nil.
  def positionally: (::Hash[untyped, untyped] selector, ::Hash[untyped, untyped] operations, ?::Hash[untyped, untyped] processed) -> ::Hash[untyped, untyped]

  def process_operations: (untyped keys, untyped operations, untyped processed) -> untyped

  def process_updates: (untyped keys, untyped update, ?untyped updates) -> untyped

  def replace_index: (untyped keys, untyped position) -> untyped
end

# This module handles reloading behavior of documents.
#
# @since 4.0.0
module Mongoid::Reloadable
  # Reloads the +Document+ attributes from the database. If the document has
  # not been saved then an error will get raised if the configuration option
  # was set. This can reload root documents or embedded documents.
  #
  # _@return_ — The document, reloaded.
  #
  # Reload the document.
  # ```ruby
  # person.reload
  # ```
  def reload: () -> Document

  # Reload the document, determining if it's embedded or not and what
  # behavior to use.
  #
  # _@return_ — The reloaded attributes.
  #
  # Reload the document.
  # ```ruby
  # document._reload
  # ```
  def _reload: () -> ::Hash[untyped, untyped]

  # Reload the root document.
  #
  # _@return_ — The reloaded attributes.
  #
  # Reload the document.
  # ```ruby
  # document.reload_root_document
  # ```
  def reload_root_document: () -> ::Hash[untyped, untyped]

  # Reload the embedded document.
  #
  # _@return_ — The reloaded attributes.
  #
  # Reload the document.
  # ```ruby
  # document.reload_embedded_document
  # ```
  def reload_embedded_document: () -> ::Hash[untyped, untyped]

  # Extract only the desired embedded document from the attributes.
  #
  # _@param_ `attributes` — The document in the db.
  #
  # _@return_ — The document's extracted attributes.
  #
  # Extract the embedded document.
  # ```ruby
  # document.extract_embedded_attributes(attributes)
  # ```
  def extract_embedded_attributes: (::Hash[untyped, untyped] attributes) -> ::Hash[untyped, untyped]
end

# Provides behavior for generating the selector for a specific document.
#
# @since 4.0.0
module Mongoid::Selectable
  extend ActiveSupport::Concern

  # Get the atomic selector for the document. This is a hash in the simplest
  # case { "_id" => id }, but can become more complex for embedded documents
  # and documents that use a shard key.
  #
  # _@return_ — The document's selector.
  #
  # Get the document's atomic selector.
  # ```ruby
  # document.atomic_selector
  # ```
  def atomic_selector: () -> ::Hash[untyped, untyped]

  # Get the atomic selector for an embedded document.
  #
  # _@return_ — The embedded document selector.
  #
  # Get the embedded atomic selector.
  # ```ruby
  # document.embedded_atomic_selector
  # ```
  def embedded_atomic_selector: () -> ::Hash[untyped, untyped]

  # Get the atomic selector for a root document.
  #
  # _@return_ — The root document selector.
  #
  # Get the root atomic selector.
  # ```ruby
  # document.root_atomic_selector
  # ```
  def root_atomic_selector: () -> ::Hash[untyped, untyped]
end

# This module handles the behavior for setting up document created at and
# updated at timestamps.
module Mongoid::Timestamps
  include Mongoid::Timestamps::Created

  include Mongoid::Timestamps::Updated

  extend ActiveSupport::Concern

  # Update the updated_at field on the Document to the current time.
  # This is only called on create and on save.
  #
  # Set the updated at time.
  # ```ruby
  # person.set_updated_at
  # ```
  def set_updated_at: () -> untyped

  # Is the updated timestamp able to be set?
  #
  # _@return_ — If the timestamp can be set.
  #
  # Can the timestamp be set?
  # ```ruby
  # document.able_to_set_updated_at?
  # ```
  def able_to_set_updated_at?: () -> bool

  # Update the created_at field on the Document to the current time. This is
  # only called on create.
  #
  # Set the created at time.
  # ```ruby
  # person.set_created_at
  # ```
  def set_created_at: () -> untyped
end

module Mongoid::Timestamps::Short
  include Mongoid::Timestamps::Created::Short

  include Mongoid::Timestamps::Updated::Short

  extend ActiveSupport::Concern
end

# This module handles the behavior for setting up document created at
# timestamp.
module Mongoid::Timestamps::Created
  extend ActiveSupport::Concern

  # Update the created_at field on the Document to the current time. This is
  # only called on create.
  #
  # Set the created at time.
  # ```ruby
  # person.set_created_at
  # ```
  def set_created_at: () -> untyped
end

# Adds a created_at timestamp to the document, but it is stored as c_at
# with a created_at alias.
module Mongoid::Timestamps::Mongoid::Timestamps::Created::Short
  extend ActiveSupport::Concern
end

# This module handles the behavior for setting up document updated at
# timestamp.
module Mongoid::Timestamps::Updated
  extend ActiveSupport::Concern

  # Update the updated_at field on the Document to the current time.
  # This is only called on create and on save.
  #
  # Set the updated at time.
  # ```ruby
  # person.set_updated_at
  # ```
  def set_updated_at: () -> untyped

  # Is the updated timestamp able to be set?
  #
  # _@return_ — If the timestamp can be set.
  #
  # Can the timestamp be set?
  # ```ruby
  # document.able_to_set_updated_at?
  # ```
  def able_to_set_updated_at?: () -> bool
end

# Adds an updated_at timestamp to the document, but it is stored as u_at
# with an updated_at alias.
module Mongoid::Timestamps::Mongoid::Timestamps::Updated::Short
  extend ActiveSupport::Concern
end

# This module adds behavior for turning off timestamping in single or
# multiple calls.
module Mongoid::Timestamps::Timeless
  extend ActiveSupport::Concern

  extend Forwardable

  # Clears out the timeless option.
  #
  # _@return_ — True.
  #
  # Clear the timeless option.
  # ```ruby
  # document.clear_timeless_option
  # ```
  def clear_timeless_option: () -> bool

  # Begin an execution that should skip timestamping.
  #
  # _@return_ — The document this was called on.
  #
  # Save a document but don't timestamp.
  # ```ruby
  # person.timeless.save
  # ```
  def timeless: () -> Document

  def timeless?: () -> bool

  def self.timeless_table: () -> untyped
end

module Mongoid::Timestamps::Mongoid::Timestamps::Timeless::ClassMethods
  # Begin an execution that should skip timestamping.
  #
  # _@return_ — The class this was called on.
  #
  # Create a document but don't timestamp.
  # ```ruby
  # Person.timeless.create(:title => "Sir")
  # ```
  def timeless: () -> Class

  def clear_timeless_option: () -> untyped

  def clear_timeless_option_on_update: () -> untyped

  def set_timeless_counter: (untyped counter) -> untyped

  def timeless?: () -> bool
end

module Mongoid::Association
  include Mongoid::Association::Embedded::Cyclic

  include Mongoid::Association::Referenced::AutoSave

  include Mongoid::Association::Referenced::CounterCache

  include Mongoid::Association::Referenced::Syncable

  include Mongoid::Association::Accessors

  include Mongoid::Association::Depending

  include Mongoid::Association::Builders

  include Mongoid::Association::Macros

  include Mongoid::Association::Reflections

  extend ActiveSupport::Concern

  # Determine if the document itself is embedded in another document via the
  # proper channels. (If it has a parent document.)
  #
  # _@return_ — True if the document has a parent document.
  #
  # Is the document embedded?
  # ```ruby
  # address.embedded?
  # ```
  def embedded?: () -> bool

  # Determine if the document is part of an embeds_many association.
  #
  # _@return_ — True if in an embeds many.
  #
  # Is the document in an embeds many?
  # ```ruby
  # address.embedded_many?
  # ```
  def embedded_many?: () -> bool

  # Determine if the document is part of an embeds_one association.
  #
  # _@return_ — True if in an embeds one.
  #
  # Is the document in an embeds one?
  # ```ruby
  # address.embedded_one?
  # ```
  def embedded_one?: () -> bool

  # Get the association name for this document. If no association was defined
  #   an error will be raised.
  #
  # _@return_ — The association name.
  #
  # Get the association name.
  # ```ruby
  # document.association_name
  # ```
  def association_name: () -> Symbol

  # Determine if the document is part of an references_many association.
  #
  # _@return_ — True if in a references many.
  #
  # Is the document in a references many?
  # ```ruby
  # post.referenced_many?
  # ```
  def referenced_many?: () -> bool

  # Determine if the document is part of an references_one association.
  #
  # _@return_ — True if in a references one.
  #
  # Is the document in a references one?
  # ```ruby
  # address.referenced_one?
  # ```
  def referenced_one?: () -> bool

  # Convenience method for iterating through the loaded associations and
  # reloading them.
  #
  # _@return_ — The association metadata.
  #
  # Reload the associations.
  # ```ruby
  # document.reload_relations
  # ```
  def reload_relations: () -> ::Hash[untyped, untyped]

  # Returns the association metadata for the supplied name.
  #
  # _@param_ `name` — The name of the association to find.
  #
  # _@return_ — The matching association metadata.
  #
  # Find association metadata by name.
  # ```ruby
  # person.reflect_on_association(:addresses)
  # ```
  def reflect_on_association: (String | Symbol name) -> Association

  # Returns all association metadata for the supplied macros.
  #
  # _@param_ `macros` — The association macros.
  #
  # _@return_ — The matching association metadata.
  #
  # Find multiple association metadata by macro.
  # ```ruby
  # person.reflect_on_all_associations(:embeds_many)
  # ```
  def reflect_on_all_association: (*::Array[Symbol] macros) -> ::Array[Association]

  # This is convenience for libraries still on the old API.
  #
  # _@return_ — The associations.
  #
  # Get the associations.
  # ```ruby
  # person.associations
  # ```
  def associations: () -> ::Hash[untyped, untyped]

  # Parse out the attributes and the options from the args passed to a
  # build_ or create_ methods.
  #
  # _@param_ `args` — The arguments.
  #
  # _@return_ — The attributes and options.
  #
  # Parse the args.
  # ```ruby
  # doc.parse_args(:name => "Joe")
  # ```
  def parse_args: (*::Array[untyped] args) -> ::Array[::Hash[untyped, untyped]]

  # Perform all cascading deletes, destroys, or nullifies. Will delegate to
  # the appropriate strategy to perform the operation.
  #
  # Execute cascades.
  # ```ruby
  # document.apply_delete_dependencies!
  # ```
  def apply_delete_dependencies!: () -> untyped

  def _dependent_delete_all!: (untyped association) -> untyped

  def _dependent_destroy!: (untyped association) -> untyped

  def _dependent_nullify!: (untyped association) -> untyped

  def _dependent_restrict_with_exception!: (untyped association) -> untyped

  def _dependent_restrict_with_error!: (untyped association) -> untyped

  def __build__: (String | Symbol name, ::Hash[untyped, untyped] | BSON::ObjectId object, Association association, ?::Hash[untyped, untyped]? selected_fields) -> Proxy

  # Create an association from an object and association metadata.
  #
  # _@param_ `object` — The association target.
  #
  # _@param_ `association` — The association metadata.
  #
  # _@param_ `selected_fields` — Fields which were retrieved via #only. If selected_fields is specified, fields not listed in it will not be accessible in the created association document.
  #
  # _@return_ — The association.
  #
  # Create the association.
  # ```ruby
  # person.create_relation(document, association)
  # ```
  def create_relation: (Document | ::Array[Document] object, Association association, ?::Hash[untyped, untyped]? selected_fields) -> Proxy

  # Resets the criteria inside the association proxy. Used by many-to-many
  # associations to keep the underlying ids array in sync.
  #
  # _@param_ `name` — The name of the association.
  #
  # Reset the association criteria.
  # ```ruby
  # person.reset_relation_criteria(:preferences)
  # ```
  def reset_relation_criteria: (Symbol name) -> untyped

  # Set the supplied association to an instance variable on the class with the
  # provided name. Used as a helper just for code cleanliness.
  #
  # _@param_ `name` — The name of the association.
  #
  # _@param_ `relation` — The association to set.
  #
  # _@return_ — The association.
  #
  # Set the proxy on the document.
  # ```ruby
  # person.set(:addresses, addresses)
  # ```
  def set_relation: (String | Symbol name, Proxy relation) -> Proxy

  def get_relation: (Symbol name, Association association, Object object, ?bool reload) -> Proxy

  # Returns a subset of __selected_fields attribute applicable to the
  # (embedded) association with the given key, or nil if no projection
  # is to be performed.
  #
  # For example, if __selected_fields is {'a' => 1, 'b.c' => 2, 'b.c.f' => 3},
  # and assoc_key is 'b', return value would be {'c' => 2, 'c.f' => 3}.
  #
  # _@param_ `assoc_key`
  def _mongoid_filter_selected_fields: (String assoc_key) -> ::Hash[untyped, untyped]?

  def needs_no_database_query?: (untyped object, untyped association) -> bool

  # Is the current code executing without autobuild functionality?
  #
  # _@return_ — If autobuild is disabled.
  #
  # Is autobuild disabled?
  # ```ruby
  # document.without_autobuild?
  # ```
  def without_autobuild?: () -> bool

  # Yield to the block with autobuild functionality turned off.
  #
  # _@return_ — The result of the yield.
  #
  # Execute without autobuild.
  # ```ruby
  # document.without_autobuild do
  #   document.name
  # end
  # ```
  def without_autobuild: () -> Object

  # Is the document able to be synced on the inverse side? This is only if
  # the key has changed and the association bindings have not been run.
  #
  # _@param_ `association` — The association metadata.
  #
  # _@return_ — If we can sync.
  #
  # Are the foreign keys syncable?
  # ```ruby
  # document._syncable?(association)
  # ```
  def _syncable?: (Association association) -> bool

  # Get the synced foreign keys.
  #
  # _@return_ — The synced foreign keys.
  #
  # Get the synced foreign keys.
  # ```ruby
  # document._synced
  # ```
  def _synced: () -> ::Hash[untyped, untyped]

  # Has the document been synced for the foreign key?
  #
  # _@param_ `foreign_key` — The foreign key.
  #
  # _@return_ — If we can sync.
  #
  # Has the document been synced?
  # ```ruby
  # document._synced?
  # ```
  def _synced?: (String foreign_key) -> bool

  # Update the inverse keys on destroy.
  #
  # _@param_ `association` — The association.
  #
  # _@return_ — The updated values.
  #
  # Update the inverse keys.
  # ```ruby
  # document.remove_inverse_keys(association)
  # ```
  def remove_inverse_keys: (Association association) -> Object

  # Update the inverse keys for the association.
  #
  # _@param_ `association` — The document association.
  #
  # _@return_ — The updated values.
  #
  # Update the inverse keys
  # ```ruby
  # document.update_inverse_keys(association)
  # ```
  def update_inverse_keys: (Association association) -> Object

  # Reset the given counter using the .count() query from the
  # db. This method is usuful in case that a counter got
  # corrupted, or a new counter was added to the collection.
  #
  # _@param_ `counters` — One or more counter caches to reset
  #
  # Reset the given counter cache
  # ```ruby
  # post.reset_counters(:comments)
  # ```
  def reset_counters: (*Symbol | ::Array[untyped] counters) -> untyped

  # Used to prevent infinite loops in associated autosaves.
  #
  # _@return_ — Has the document already been autosaved?
  #
  # Is the document autosaved?
  # ```ruby
  # document.autosaved?
  # ```
  def autosaved?: () -> bool

  # Begin the associated autosave.
  #
  # Begin autosave.
  # ```ruby
  # document.__autosaving__
  # ```
  def __autosaving__: () -> untyped

  # Check if there is changes for auto-saving
  #
  #   document.changed_for_autosave?
  #
  # Return true if there is changes on self or in
  # ```ruby
  # autosaved associations.
  # ```
  def changed_for_autosave?: (untyped doc) -> bool
end

Mongoid::Association::MACRO_MAPPING: untyped

Mongoid::Association::STRATEGIES: untyped

# This is the superclass for one to one relations and defines the common
# behavior or those proxies.
class Mongoid::Association::One < Mongoid::Association::Proxy
  # Returns the value of attribute _association.
  #
  # Clear this relation - same as calling #delete on the document.
  #
  # _@return_ — If the delete suceeded.
  #
  # Clear the relation.
  # ```ruby
  # relation.clear
  # ```
  def clear: () -> untyped
           | () -> bool

  # Get all the documents in the relation that are loaded into memory.
  #
  # _@return_ — The documents in memory.
  #
  # Get the in memory documents.
  # ```ruby
  # relation.in_memory
  # ```
  def in_memory: () -> ::Array[Document]

  # Since method_missing is overridden we should override this as well.
  #
  # _@param_ `name` — The method name.
  #
  # _@return_ — If the proxy responds to the method.
  #
  # Does the proxy respond to the method?
  # ```ruby
  # relation.respond_to?(:name)
  # ```
  def respond_to?: (Symbol name, ?untyped include_private) -> bool

  # Evolve the proxy document into an object id.
  #
  # _@return_ — The proxy document's id.
  #
  # Evolve the proxy document.
  # ```ruby
  # proxy.__evolve_object_id__
  # ```
  def __evolve_object_id__: () -> Object
end

# This is the superclass for all many to one and many to many association
# proxies.
class Mongoid::Association::Many < Mongoid::Association::Proxy
  include Enumerable

  extend Forwardable

  # Is the association empty?
  #
  # _@return_ — If the association is empty or not.
  #
  # Is the association empty??
  # ```ruby
  # person.addresses.blank?
  # ```
  def blank?: () -> bool

  # Creates a new document on the references many association. This will
  # save the document if the parent has been persisted.
  #
  # _@param_ `attributes` — The attributes to create with.
  #
  # _@param_ `type` — The optional type of document to create.
  #
  # _@return_ — The newly created document.
  #
  # Create and save the new document.
  # ```ruby
  # person.posts.create(:text => "Testing")
  # ```
  def create: (?::Hash[untyped, untyped]? attributes, ?Class? `type`) { () -> untyped } -> Document

  # Creates a new document on the references many association. This will
  # save the document if the parent has been persisted and will raise an
  # error if validation fails.
  #
  # _@param_ `attributes` — The attributes to create with.
  #
  # _@param_ `type` — The optional type of document to create.
  #
  # _@return_ — The newly created document.
  #
  # Create and save the new document.
  # ```ruby
  # person.posts.create!(:text => "Testing")
  # ```
  def create!: (?::Hash[untyped, untyped]? attributes, ?Class? `type`) { () -> untyped } -> Document

  # Find the first document given the conditions, or creates a new document
  # with the conditions that were supplied.
  #
  #  @param [ Hash ] attrs The attributes to search or create with.
  #  @param [ Class ] type The optional type of document to create.
  #
  # _@return_ — An existing document or newly created one.
  #
  # Find or create.
  # ```ruby
  # person.posts.find_or_create_by(:title => "Testing")
  # ```
  def find_or_create_by: (?untyped attrs, ?untyped `type`) { () -> untyped } -> Document

  # Find the first document given the conditions, or creates a new document
  # with the conditions that were supplied. This will raise an error if validation fails.
  #
  # _@param_ `attrs` — The attributes to search or create with.
  #
  # _@param_ `type` — The optional type of document to create.
  #
  # _@return_ — An existing document or newly created one.
  #
  # Find or create.
  # ```ruby
  # person.posts.find_or_create_by!(:title => "Testing")
  # ```
  def find_or_create_by!: (?::Hash[untyped, untyped] attrs, ?Class? `type`) { () -> untyped } -> Document

  # Find the first +Document+ given the conditions, or instantiates a new document
  # with the conditions that were supplied
  #
  # _@param_ `attrs` — The attributes to search or initialize with.
  #
  # _@param_ `type` — The optional subclass to build.
  #
  # _@return_ — An existing document or newly instantiated one.
  #
  # Find or initialize.
  # ```ruby
  # person.posts.find_or_initialize_by(:title => "Test")
  # ```
  def find_or_initialize_by: (?::Hash[untyped, untyped] attrs, ?Class? `type`) { () -> untyped } -> Document

  # This proxy can never be nil.
  #
  # _@return_ — Always false.
  #
  # Is the proxy nil?
  # ```ruby
  # relation.nil?
  # ```
  def nil?: () -> bool

  # Since method_missing is overridden we should override this as well.
  #
  # _@param_ `name` — The method name.
  #
  # _@param_ `include_private` — Whether to include private methods.
  #
  # _@return_ — If the proxy responds to the method.
  #
  # Does the proxy respond to the method?
  # ```ruby
  # relation.respond_to?(:name)
  # ```
  def respond_to?: (Symbol name, ?bool include_private) -> bool

  # This is public access to the association's criteria.
  #
  # _@return_ — The scoped criteria.
  #
  # Get the scoped association.
  # ```ruby
  # relation.scoped
  # ```
  def scoped: () -> Criteria

  # Gets the document as a serializable hash, used by ActiveModel's JSON and
  # XML serializers. This override is just to be able to pass the :include
  # and :except options to get associations in the hash.
  #
  # _@param_ `options` — The options to pass.
  #
  # _@return_ — The documents, ready to be serialized.
  #
  # Get the serializable hash.
  # ```ruby
  # relation.serializable_hash
  # ```
  def serializable_hash: (?::Hash[untyped, untyped] options) -> ::Hash[untyped, untyped]

  # Get a criteria for the embedded documents without the default scoping
  # applied.
  #
  # _@return_ — The unscoped criteria.
  #
  # Get the unscoped criteria.
  # ```ruby
  # person.addresses.unscoped
  # ```
  def unscoped: () -> Criteria

  def _session: () -> untyped

  def find_or: (untyped method, ?untyped attrs, ?untyped `type`) { () -> untyped } -> Document
end

# This class is the superclass for all association proxy objects, and contains
# common behavior for all of them.
class Mongoid::Association::Proxy
  include Mongoid::Threaded::Lifecycle

  include Mongoid::Association::Marshalable

  extend Forwardable

  # Convenience for setting the target and the association metadata properties since
  # all proxies will need to do this.
  #
  # _@param_ `base` — The base document on the proxy.
  #
  # _@param_ `target` — The target of the proxy.
  #
  # _@param_ `association` — The association metadata.
  #
  # Initialize the proxy.
  # ```ruby
  # proxy.init(person, name, association)
  # ```
  def init: (Document base, Document | ::Array[Document] target, Association association) -> untyped

  # Allow extension to be an array and extend each module
  def extend_proxies: (*untyped `extension`) -> untyped

  # Get the class from the association, or return nil if no association present.
  #
  # _@return_ — The association class.
  #
  # Get the class.
  # ```ruby
  # proxy.klass
  # ```
  def klass: () -> Class

  # Resets the criteria inside the association proxy. Used by many to many
  # associations to keep the underlying ids array in sync.
  #
  # Reset the association criteria.
  # ```ruby
  # person.preferences.reset_relation_criteria
  # ```
  def reset_unloaded: () -> untyped

  # The default substitutable object for an association proxy is the clone of
  # the target.
  #
  # _@return_ — A clone of the target.
  #
  # Get the substitutable.
  # ```ruby
  # proxy.substitutable
  # ```
  def substitutable: () -> Object

  # sord warn - Collection wasn't able to be resolved to a constant in this project
  # Get the collection from the root of the hierarchy.
  #
  # _@return_ — The root's collection.
  #
  # Get the collection.
  # ```ruby
  # relation.collection
  # ```
  def collection: () -> Mongo::Collection

  # Takes the supplied document and sets the association on it.
  #
  # _@param_ `document` — The document to set on.
  #
  # Set the association metadata.
  # ```ruby
  # proxt.characterize_one(name)
  # ```
  def characterize_one: (Document document) -> untyped

  # Default behavior of method missing should be to delegate all calls
  # to the target of the proxy. This can be overridden in special cases.
  #
  # _@param_ `name` — The name of the method.
  #
  # _@param_ `args` — The arguments passed to the method.
  def method_missing: (String | Symbol name, *::Array[untyped] args) { () -> untyped } -> untyped

  def respond_to_missing?: (untyped name, *untyped args) -> bool

  # When the base document illegally references an embedded document this
  # error will get raised.
  #
  # Raise the error.
  # ```ruby
  # relation.raise_mixed
  # ```
  def raise_mixed: () -> untyped

  # When the base is not yet saved and the user calls create or create!
  # on the association, this error will get raised.
  #
  # _@param_ `doc` — The child document getting created.
  #
  # Raise the error.
  # ```ruby
  # relation.raise_unsaved(post)
  # ```
  def raise_unsaved: (Document doc) -> untyped

  # Executes a callback method
  #
  # _@param_ `callback` — to be executed
  #
  # execute the before add callback
  # ```ruby
  # execute_callback(:before_add)
  # ```
  def execute_callback: (Symbol callback, untyped doc) -> untyped

  # Apply ordering to the criteria if it was defined on the association.
  #
  # _@param_ `criteria` — The criteria to modify.
  #
  # _@param_ `association` — The association metadata.
  #
  # _@return_ — The ordered criteria.
  #
  # Apply the ordering.
  # ```ruby
  # Proxy.apply_ordering(criteria, association)
  # ```
  def self.apply_ordering: (Criteria criteria, Association association) -> Criteria

  # Provides the data needed to Marshal.dump an association proxy.
  #
  # _@return_ — The dumped data.
  #
  # Dump the proxy.
  # ```ruby
  # Marshal.dump(proxy)
  # ```
  def marshal_dump: () -> ::Array[Object]

  # Takes the provided data and sets it back on the proxy.
  #
  # _@param_ `data` — The data to set on the proxy.
  #
  # _@return_ — The loaded data.
  #
  # Load the proxy.
  # ```ruby
  # Marshal.load(proxy)
  # ```
  def marshal_load: (::Array[Object] data) -> ::Array[Object]

  # Begin the assignment of attributes. While in this block embedded
  # documents will not autosave themselves in order to allow the document to
  # be in a valid state.
  #
  # _@return_ — The yielded value.
  #
  # Execute the assignment.
  # ```ruby
  # _assigning do
  #   person.attributes = { :addresses => [ address ] }
  # end
  # ```
  def _assigning: () -> Object

  # Is the current thread in assigning mode?
  #
  # _@return_ — If the thread is assigning.
  #
  # Is the current thread in assigning mode?
  # ```ruby
  # proxy._assigning?
  # ```
  def _assigning?: () -> bool

  # Execute a block in binding mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in binding mode.
  # ```ruby
  # binding do
  #   relation.push(doc)
  # end
  # ```
  def _binding: () -> Object

  # Is the current thread in binding mode?
  #
  # _@return_ — If the thread is binding.
  #
  # Is the current thread in binding mode?
  # ```ruby
  # proxy.binding?
  # ```
  def _binding?: () -> bool

  # Execute a block in building mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in building mode.
  # ```ruby
  # _building do
  #   relation.push(doc)
  # end
  # ```
  def _building: () -> Object

  # Is the current thread in building mode?
  #
  # _@return_ — If the thread is building.
  #
  # Is the current thread in building mode?
  # ```ruby
  # proxy._building?
  # ```
  def _building?: () -> bool

  # Is the current thread in creating mode?
  #
  # _@return_ — If the thread is creating.
  #
  # Is the current thread in creating mode?
  # ```ruby
  # proxy.creating?
  # ```
  def _creating?: () -> bool

  # Execute a block in loading mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in loading mode.
  # ```ruby
  # _loading do
  #   relation.push(doc)
  # end
  # ```
  def _loading: () -> Object

  # Is the current thread in loading mode?
  #
  # _@return_ — If the thread is loading.
  #
  # Is the current thread in loading mode?
  # ```ruby
  # proxy._loading?
  # ```
  def _loading?: () -> bool
end

# This module contains the core macros for defining associations between
# documents. They can be either embedded or referenced.
module Mongoid::Association::Macros
  extend ActiveSupport::Concern

  # Model instance for the base of the association.
  #
  # For example, if a Post embeds_many Comments, _base is a particular
  # instance of the Post model.
  #
  # Returns the value of attribute _association.
  #
  # Model instance for one to one associations, or array of model instances
  # for one to many associations, for the target of the association.
  #
  # For example, if a Post embeds_many Comments, _target is an array of
  # Comment models embedded in a particular Post.
  #
  # This is convenience for libraries still on the old API.
  #
  # _@return_ — The associations.
  #
  # Get the associations.
  # ```ruby
  # person.associations
  # ```
  def associations: () -> untyped
                  | () -> untyped
                  | () -> untyped
                  | () -> ::Hash[untyped, untyped]
end

module Mongoid::Association::Mongoid::Association::Macros::ClassMethods
  # Adds the association back to the parent document. This macro is
  # necessary to set the references from the child back to the parent
  # document. If a child does not define this association calling
  # persistence methods on the child object will cause a save to fail.
  #
  # _@param_ `name` — The name of the association.
  #
  # _@param_ `options` — The association options.
  #
  # _@param_ `block` — Optional block for defining extensions.
  #
  # Define the association.
  # ```ruby
  #
  # class Person
  #   include Mongoid::Document
  #   embeds_many :addresses
  # end
  #
  # class Address
  #   include Mongoid::Document
  #   embedded_in :person
  # end
  # ```
  def embedded_in: (Symbol name, ?::Hash[untyped, untyped] options) { () -> untyped } -> untyped

  # Adds the association from a parent document to its children. The name
  # of the association needs to be a pluralized form of the child class
  # name.
  #
  # _@param_ `name` — The name of the association.
  #
  # _@param_ `options` — The association options.
  #
  # _@param_ `block` — Optional block for defining extensions.
  #
  # Define the association.
  # ```ruby
  #
  # class Person
  #   include Mongoid::Document
  #   embeds_many :addresses
  # end
  #
  # class Address
  #   include Mongoid::Document
  #   embedded_in :person
  # end
  # ```
  def embeds_many: (Symbol name, ?::Hash[untyped, untyped] options) { () -> untyped } -> untyped

  # Adds the association from a parent document to its child. The name
  # of the association needs to be a singular form of the child class
  # name.
  #
  # _@param_ `name` — The name of the association.
  #
  # _@param_ `options` — The association options.
  #
  # _@param_ `block` — Optional block for defining extensions.
  #
  # Define the association.
  # ```ruby
  #
  # class Person
  #   include Mongoid::Document
  #   embeds_one :name
  # end
  #
  # class Name
  #   include Mongoid::Document
  #   embedded_in :person
  # end
  # ```
  def embeds_one: (Symbol name, ?::Hash[untyped, untyped] options) { () -> untyped } -> untyped

  # Adds a referenced association from the child Document to a Document
  # in another database or collection.
  #
  # _@param_ `name` — The name of the association.
  #
  # _@param_ `options` — The association options.
  #
  # _@param_ `block` — Optional block for defining extensions.
  #
  # Define the association.
  # ```ruby
  #
  # class Game
  #   include Mongoid::Document
  #   belongs_to :person
  # end
  #
  # class Person
  #   include Mongoid::Document
  #   has_one :game
  # end
  # ```
  def belongs_to: (Symbol name, ?::Hash[untyped, untyped] options) { () -> untyped } -> untyped

  # Adds a referenced association from a parent Document to many
  # Documents in another database or collection.
  #
  # _@param_ `name` — The name of the association.
  #
  # _@param_ `options` — The association options.
  #
  # _@param_ `block` — Optional block for defining extensions.
  #
  # Define the association.
  # ```ruby
  #
  # class Person
  #   include Mongoid::Document
  #   has_many :posts
  # end
  #
  # class Game
  #   include Mongoid::Document
  #   belongs_to :person
  # end
  # ```
  def has_many: (Symbol name, ?::Hash[untyped, untyped] options) { () -> untyped } -> untyped

  # Adds a referenced many-to-many association between many of this
  # Document and many of another Document.
  #
  # _@param_ `name` — The name of the association.
  #
  # _@param_ `options` — The association options.
  #
  # _@param_ `block` — Optional block for defining extensions.
  #
  # Define the association.
  # ```ruby
  #
  # class Person
  #   include Mongoid::Document
  #   has_and_belongs_to_many :preferences
  # end
  #
  # class Preference
  #   include Mongoid::Document
  #   has_and_belongs_to_many :people
  # end
  # ```
  def has_and_belongs_to_many: (Symbol name, ?::Hash[untyped, untyped] options) { () -> untyped } -> untyped

  # Adds a referenced association from the child Document to a Document
  # in another database or collection.
  #
  # _@param_ `name` — The name of the association.
  #
  # _@param_ `options` — The association options.
  #
  # _@param_ `block` — Optional block for defining extensions.
  #
  # Define the association.
  # ```ruby
  #
  # class Game
  #   include Mongoid::Document
  #   belongs_to :person
  # end
  #
  # class Person
  #   include Mongoid::Document
  #   has_one :game
  # end
  # ```
  def has_one: (Symbol name, ?::Hash[untyped, untyped] options) { () -> untyped } -> untyped

  def define_association!: (untyped macro_name, untyped name, ?untyped options) { () -> untyped } -> untyped
end

module Mongoid::Association::Nested
end

Mongoid::Association::Mongoid::Association::Nested::DESTROY_FLAGS: untyped

class Mongoid::Association::Mongoid::Association::Nested::One
  include Mongoid::Association::Nested::Buildable

  # Builds the association depending on the attributes and the options
  # passed to the macro.
  #
  # _@param_ `parent` — The parent document.
  #
  # _@return_ — The built document.
  #
  # Build a 1-1 nested document.
  # ```ruby
  # one.build(person, as: :admin)
  # ```
  #
  # _@note_ — This attempts to perform 3 operations, either one of an update of
  # the existing association, a replacement of the association with a new
  # document, or a removal of the association.
  def build: (Document parent) -> Document

  # Create the new builder for nested attributes on one-to-one
  # associations.
  #
  # _@param_ `association` — The association metadata.
  #
  # _@param_ `attributes` — The attributes hash to attempt to set.
  #
  # _@param_ `options` — The options defined.
  #
  # Instantiate the builder.
  # ```ruby
  # One.new(association, attributes)
  # ```
  def initialize: (Association association, ::Hash[untyped, untyped] attributes, ::Hash[untyped, untyped] options) -> void

  # Is the id in the attribtues acceptable for allowing an update to
  # the existing association?
  #
  # _@return_ — If the id part of the logic will allow an update.
  #
  # Is the id acceptable?
  # ```ruby
  # one.acceptable_id?
  # ```
  def acceptable_id?: () -> bool

  # Can the existing association be deleted?
  #
  # _@return_ — If the association should be deleted.
  #
  # Can the existing object be deleted?
  # ```ruby
  # one.delete?
  # ```
  def delete?: () -> bool

  # Can the existing association potentially be destroyed?
  #
  # _@return_ — If the association can potentially be
  # destroyed.
  #
  # Is the object destroyable?
  # ```ruby
  # one.destroyable?({ :_destroy => "1" })
  # ```
  def destroyable?: () -> bool

  # Is the document to be replaced?
  #
  # _@return_ — If the document should be replaced.
  #
  # Is the document to be replaced?
  # ```ruby
  # one.replace?
  # ```
  def replace?: () -> bool

  # Should the document be updated?
  #
  # _@return_ — If the object should have its attributes updated.
  #
  # Should the document be updated?
  # ```ruby
  # one.update?
  # ```
  def update?: () -> bool

  # Determines if destroys are allowed for this document.
  #
  # _@return_ — True if the allow destroy option was set.
  #
  # Do we allow a destroy?
  # ```ruby
  # builder.allow_destroy?
  # ```
  def allow_destroy?: () -> bool

  # Returns the reject if option defined with the macro.
  #
  # _@param_ `document` — The parent document of the association
  #
  # _@param_ `attrs` — The attributes to check for rejection.
  #
  # _@return_ — True and call proc or method if rejectable, false if not.
  #
  # Is there a reject proc?
  # ```ruby
  # builder.reject?
  # ```
  def reject?: (Document document, ::Hash[untyped, untyped] attrs) -> bool

  # Determines if only updates can occur. Only valid for one-to-one
  # associations.
  #
  # _@return_ — True if the update_only option was set.
  #
  # Is this update only?
  # ```ruby
  # builder.update_only?
  # ```
  def update_only?: () -> bool

  # Convert an id to its appropriate type.
  #
  # _@param_ `klass` — The class we're trying to convert for.
  #
  # _@param_ `id` — The id, usually coming from the form.
  #
  # _@return_ — The converted id.
  #
  # Convert the id.
  # ```ruby
  # builder.convert_id(Person, "4d371b444835d98b8b000010")
  # ```
  def convert_id: (Class klass, String id) -> (BSON::ObjectId | String | Object)
end

class Mongoid::Association::Mongoid::Association::Nested::Many
  include Mongoid::Association::Nested::Buildable

  # Returns the value of attribute destroy.
  #
  # Builds the association depending on the attributes and the options
  # passed to the macro.
  #
  # This attempts to perform 3 operations, either one of an update of
  # the existing association, a replacement of the association with a new
  # document, or a removal of the association.
  #
  # _@param_ `parent` — The parent document of the association.
  #
  # _@param_ `options` — The options.
  #
  # _@return_ — The attributes.
  #
  # Build the nested attrs.
  # ```ruby
  # many.build(person)
  # ```
  def build: () -> untyped
           | (Document parent, ?::Hash[untyped, untyped] options) -> ::Array[untyped]

  # Create the new builder for nested attributes on one-to-many
  # associations.
  #
  # _@param_ `association` — The association metadata.
  #
  # _@param_ `attributes` — The attributes hash to attempt to set.
  #
  # _@param_ `options` — The options defined.
  #
  # Initialize the builder.
  # ```ruby
  # Many.new(association, attributes, options)
  # ```
  def initialize: (Association association, ::Hash[untyped, untyped] attributes, ?::Hash[untyped, untyped] options) -> void

  # Can the existing association potentially be deleted?
  #
  # _@param_ `attributes` — The attributes to pull the flag from.
  #
  # _@return_ — If the association can potentially be deleted.
  #
  # Is the document destroyable?
  # ```ruby
  # destroyable?({ :_destroy => "1" })
  # ```
  def destroyable?: (::Hash[untyped, untyped] attributes) -> bool

  # Are the supplied attributes of greater number than the supplied
  # limit?
  #
  # _@param_ `attributes` — The attributes being set.
  #
  # _@return_ — If the attributes exceed the limit.
  #
  # Are we over the set limit?
  # ```ruby
  # builder.over_limit?({ "street" => "Bond" })
  # ```
  def over_limit?: (::Hash[untyped, untyped] attributes) -> bool

  # Process each set of attributes one at a time for each potential
  # new, existing, or ignored document.
  #
  # _@param_ `parent` — The parent document.
  #
  # _@param_ `attrs` — The single document attributes to process.
  #
  # Process the attributes
  # ```ruby
  # builder.process_attributes({ "id" => 1, "street" => "Bond" })
  # ```
  def process_attributes: (Document parent, ::Hash[untyped, untyped] attrs) -> untyped

  # Destroy the child document, needs to do some checking for embedded
  # associations and delay the destroy in case parent validation fails.
  #
  # _@param_ `parent` — The parent document.
  #
  # _@param_ `relation` — The association proxy.
  #
  # _@param_ `doc` — The doc to destroy.
  #
  # Destroy the child.
  # ```ruby
  # builder.destroy(parent, relation, doc)
  # ```
  def destroy: (Document parent, Proxy relation, Document doc) -> untyped

  # Destroy the document.
  #
  # _@param_ `relation` — The association proxy.
  #
  # _@param_ `doc` — The document to delete.
  #
  # Destroy the document.
  # ```ruby
  # builder.destroy_document(relation, doc)
  # ```
  def destroy_document: (Proxy relation, Document doc) -> untyped

  # Update the document.
  #
  # _@param_ `doc` — The document to update.
  #
  # _@param_ `attrs` — The attributes.
  #
  # Update the document.
  # ```ruby
  # builder.update_document(doc, {}, options)
  # ```
  def update_document: (Document doc, ::Hash[untyped, untyped] attrs) -> untyped

  # Update nested association.
  #
  # _@param_ `parent` — The parent document.
  #
  # _@param_ `id` — of the related document.
  #
  # _@param_ `attrs` — The single document attributes to process.
  #
  # Update nested association.
  # ```ruby
  # builder.update_nested_relation(parent, id, attrs)
  # ```
  def update_nested_relation: (Document parent, String | BSON::ObjectId id, ::Hash[untyped, untyped] attrs) -> untyped

  # Determines if destroys are allowed for this document.
  #
  # _@return_ — True if the allow destroy option was set.
  #
  # Do we allow a destroy?
  # ```ruby
  # builder.allow_destroy?
  # ```
  def allow_destroy?: () -> bool

  # Returns the reject if option defined with the macro.
  #
  # _@param_ `document` — The parent document of the association
  #
  # _@param_ `attrs` — The attributes to check for rejection.
  #
  # _@return_ — True and call proc or method if rejectable, false if not.
  #
  # Is there a reject proc?
  # ```ruby
  # builder.reject?
  # ```
  def reject?: (Document document, ::Hash[untyped, untyped] attrs) -> bool

  # Determines if only updates can occur. Only valid for one-to-one
  # associations.
  #
  # _@return_ — True if the update_only option was set.
  #
  # Is this update only?
  # ```ruby
  # builder.update_only?
  # ```
  def update_only?: () -> bool

  # Convert an id to its appropriate type.
  #
  # _@param_ `klass` — The class we're trying to convert for.
  #
  # _@param_ `id` — The id, usually coming from the form.
  #
  # _@return_ — The converted id.
  #
  # Convert the id.
  # ```ruby
  # builder.convert_id(Person, "4d371b444835d98b8b000010")
  # ```
  def convert_id: (Class klass, String id) -> (BSON::ObjectId | String | Object)
end

module Mongoid::Association::Mongoid::Association::Nested::Buildable
  # Determines if destroys are allowed for this document.
  #
  # _@return_ — True if the allow destroy option was set.
  #
  # Do we allow a destroy?
  # ```ruby
  # builder.allow_destroy?
  # ```
  def allow_destroy?: () -> bool

  # Returns the reject if option defined with the macro.
  #
  # _@param_ `document` — The parent document of the association
  #
  # _@param_ `attrs` — The attributes to check for rejection.
  #
  # _@return_ — True and call proc or method if rejectable, false if not.
  #
  # Is there a reject proc?
  # ```ruby
  # builder.reject?
  # ```
  def reject?: (Document document, ::Hash[untyped, untyped] attrs) -> bool

  # Determines if only updates can occur. Only valid for one-to-one
  # associations.
  #
  # _@return_ — True if the update_only option was set.
  #
  # Is this update only?
  # ```ruby
  # builder.update_only?
  # ```
  def update_only?: () -> bool

  # Convert an id to its appropriate type.
  #
  # _@param_ `klass` — The class we're trying to convert for.
  #
  # _@param_ `id` — The id, usually coming from the form.
  #
  # _@return_ — The converted id.
  #
  # Convert the id.
  # ```ruby
  # builder.convert_id(Person, "4d371b444835d98b8b000010")
  # ```
  def convert_id: (Class klass, String id) -> (BSON::ObjectId | String | Object)
end

module Mongoid::Association::Options
  # Returns the value of attribute attributes.
  #
  # Returns the value of attribute existing.
  #
  # Returns the value of attribute association.
  #
  # Returns the value of attribute options.
  #
  # Returns the name of the parent to a polymorphic child.
  #
  # _@return_ — The name.
  def as: () -> untyped
        | () -> untyped
        | () -> untyped
        | () -> untyped
        | () -> (String | Symbol)

  # Specify what happens to the associated object when the owner is destroyed.
  #
  # _@return_ — The dependent option.
  def dependent: () -> String

  # The custom sorting options on the association.
  #
  # _@return_ — The custom sorting options.
  def order: () -> Criteria::Queryable::Key

  # Whether to index the primary or foreign key field.
  def indexed?: () -> bool

  # Whether the association is autobuilding.
  def autobuilding?: () -> bool

  # Is the association cyclic.
  #
  # _@return_ — Whether the association is cyclic.
  def cyclic?: () -> bool

  # The name the owning object uses to refer to this association.
  #
  # _@return_ — The inverse_of option.
  def inverse_of: () -> String

  # Mongoid assumes that the field used to hold the primary key of the association is id.
  # You can override this and explicitly specify the primary key with the :primary_key option.
  #
  # _@return_ — The primary key.
  def primary_key: () -> (Symbol | String)

  # Options to save any loaded members and destroy members that are marked for destruction
  # when the parent object is saved.
  #
  # _@return_ — The autosave option.
  def autosave: () -> bool

  # Whether the association is counter-cached.
  def counter_cached?: () -> bool

  # Whether this association is polymorphic.
  #
  # _@return_ — Whether the association is polymorphic.
  def polymorphic?: () -> bool

  # Whether the association has callbacks cascaded down from the parent.
  #
  # _@return_ — Whether callbacks are cascaded.
  def cascading_callbacks?: () -> bool

  # The store_as option.
  #
  # _@return_ — Default is nil.
  def store_as: () -> nil

  # Whether the association has forced nil inverse (So no foreign keys are saved).
  #
  # _@return_ — Default is false.
  def forced_nil_inverse?: () -> bool

  # The field for saving the associated object's type.
  #
  # _@return_ — Default is nil.
  def type: () -> nil

  # The field for saving the associated object's type.
  #
  # _@return_ — Default is nil.
  def touch_field: () -> nil

  def touchable?: () -> bool
end

# Superclass for all objects that bind associations together.
module Mongoid::Association::Bindable
  include Mongoid::Threaded::Lifecycle

  # Create the new binding.
  #
  # _@param_ `base` — The base of the binding.
  #
  # _@param_ `target` — The target of the binding.
  #
  # _@param_ `association` — The association metadata.
  #
  # Initialize a binding.
  # ```ruby
  # Binding.new(base, target, association)
  # ```
  def initialize: (Document base, Document | ::Array[Document] target, Association association) -> void

  # Execute the provided block inside a binding.
  #
  # _@return_ — The result of the yield.
  #
  # Execute the binding block.
  # ```ruby
  # binding.binding do
  #   base.foreign_key = 1
  # end
  # ```
  def binding: () -> Object

  # Check if the inverse is properly defined.
  #
  # _@param_ `doc` — The document getting bound.
  #
  # Check the inverse definition.
  # ```ruby
  # binding.check_inverse!(doc)
  # ```
  def check_inverse!: (Document doc) -> untyped

  # Set the id of the related document in the foreign key field on the
  # keyed document.
  #
  # _@param_ `keyed` — The document that stores the foreign key.
  #
  # _@param_ `id` — The id of the bound document.
  #
  # Bind the foreign key.
  # ```ruby
  # binding.bind_foreign_key(post, person._id)
  # ```
  def bind_foreign_key: (Document keyed, Object id) -> untyped

  # Set the type of the related document on the foreign type field, used
  # when associations are polymorphic.
  #
  # _@param_ `typed` — The document that stores the type field.
  #
  # _@param_ `name` — The name of the model.
  #
  # Bind the polymorphic type.
  # ```ruby
  # binding.bind_polymorphic_type(post, "Person")
  # ```
  def bind_polymorphic_type: (Document typed, String name) -> untyped

  # Set the type of the related document on the foreign type field, used
  # when associations are polymorphic.
  #
  # _@param_ `typed` — The document that stores the type field.
  #
  # _@param_ `name` — The name of the model.
  #
  # Bind the polymorphic type.
  # ```ruby
  # binding.bind_polymorphic_inverse_type(post, "Person")
  # ```
  def bind_polymorphic_inverse_type: (Document typed, String name) -> untyped

  # Bind the inverse document to the child document so that the in memory
  # instances are the same.
  #
  # _@param_ `doc` — The base document.
  #
  # _@param_ `inverse` — The inverse document.
  #
  # Bind the inverse.
  # ```ruby
  # binding.bind_inverse(post, person)
  # ```
  def bind_inverse: (Document doc, Document inverse) -> untyped

  # Bind the provided document with the base from the parent association.
  #
  # _@param_ `doc` — The document to bind.
  #
  # Bind the document with the base.
  # ```ruby
  # binding.bind_from_relational_parent(doc)
  # ```
  def bind_from_relational_parent: (Document doc) -> untyped

  def record_id: (untyped _base) -> untyped

  # Ensure that the association on the base is correct, for the cases
  # where we have multiple belongs to definitions and were are setting
  # different parents in memory in order.
  #
  # _@return_ — If the association changed.
  #
  # Set the base association.
  # ```ruby
  # binding.set_base_association
  # ```
  def set_base_association: () -> bool

  # Bind the provided document with the base from the parent association.
  #
  # _@param_ `doc` — The document to unbind.
  #
  # Bind the document with the base.
  # ```ruby
  # unbinding.unbind_from_relational_parent(doc)
  # ```
  def unbind_from_relational_parent: (Document doc) -> untyped

  # Begin the assignment of attributes. While in this block embedded
  # documents will not autosave themselves in order to allow the document to
  # be in a valid state.
  #
  # _@return_ — The yielded value.
  #
  # Execute the assignment.
  # ```ruby
  # _assigning do
  #   person.attributes = { :addresses => [ address ] }
  # end
  # ```
  def _assigning: () -> Object

  # Is the current thread in assigning mode?
  #
  # _@return_ — If the thread is assigning.
  #
  # Is the current thread in assigning mode?
  # ```ruby
  # proxy._assigning?
  # ```
  def _assigning?: () -> bool

  # Execute a block in binding mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in binding mode.
  # ```ruby
  # binding do
  #   relation.push(doc)
  # end
  # ```
  def _binding: () -> Object

  # Is the current thread in binding mode?
  #
  # _@return_ — If the thread is binding.
  #
  # Is the current thread in binding mode?
  # ```ruby
  # proxy.binding?
  # ```
  def _binding?: () -> bool

  # Execute a block in building mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in building mode.
  # ```ruby
  # _building do
  #   relation.push(doc)
  # end
  # ```
  def _building: () -> Object

  # Is the current thread in building mode?
  #
  # _@return_ — If the thread is building.
  #
  # Is the current thread in building mode?
  # ```ruby
  # proxy._building?
  # ```
  def _building?: () -> bool

  # Is the current thread in creating mode?
  #
  # _@return_ — If the thread is creating.
  #
  # Is the current thread in creating mode?
  # ```ruby
  # proxy.creating?
  # ```
  def _creating?: () -> bool

  # Execute a block in loading mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in loading mode.
  # ```ruby
  # _loading do
  #   relation.push(doc)
  # end
  # ```
  def _loading: () -> Object

  # Is the current thread in loading mode?
  #
  # _@return_ — If the thread is loading.
  #
  # Is the current thread in loading mode?
  # ```ruby
  # proxy._loading?
  # ```
  def _loading?: () -> bool
end

# This module is responsible for defining the build and create methods used
# in one to one associations.
#
# @example Methods that get created.
#
#   class Person
#     include Mongoid::Document
#     embeds_one :name
#   end
#
#   # The following methods get created:
#   person.build_name({ :first_name => "Durran" })
#   person.create_name({ :first_name => "Durran" })
#
# @since 2.0.0.rc.1
module Mongoid::Association::Builders
  extend ActiveSupport::Concern

  # Returns the value of attribute _base.
  #
  # Returns the value of attribute _target.
  #
  # Returns the value of attribute _association.
  #
  # Parse out the attributes and the options from the args passed to a
  # build_ or create_ methods.
  #
  # _@param_ `args` — The arguments.
  #
  # _@return_ — The attributes and options.
  #
  # Parse the args.
  # ```ruby
  # doc.parse_args(:name => "Joe")
  # ```
  def parse_args: () -> untyped
                | () -> untyped
                | () -> untyped
                | (*::Array[untyped] args) -> ::Array[::Hash[untyped, untyped]]

  # Defines a builder method. This is defined as #build_name.
  #
  # _@param_ `association` — The association metadata for the association.
  #
  # _@return_ — The class being set up.
  #
  # ```ruby
  # Person.define_builder!(association)
  # ```
  def self.define_builder!: (Association association) -> Class

  # Defines a creator method. This is defined as #create_name.
  # After the object is built it will immediately save.
  #
  # _@param_ `association` — The association metadata for the association.
  #
  # _@return_ — The class being set up.
  #
  # ```ruby
  # Person.define_creator!(association)
  # ```
  def self.define_creator!: (Association association) -> Class
end

# This module contains all the behavior related to accessing associations
# through the getters and setters, and how to delegate to builders to
# create new ones.
module Mongoid::Association::Accessors
  extend ActiveSupport::Concern

  def __build__: (String | Symbol name, ::Hash[untyped, untyped] | BSON::ObjectId object, Association association, ?::Hash[untyped, untyped]? selected_fields) -> Proxy

  # Create an association from an object and association metadata.
  #
  # _@param_ `object` — The association target.
  #
  # _@param_ `association` — The association metadata.
  #
  # _@param_ `selected_fields` — Fields which were retrieved via #only. If selected_fields is specified, fields not listed in it will not be accessible in the created association document.
  #
  # _@return_ — The association.
  #
  # Create the association.
  # ```ruby
  # person.create_relation(document, association)
  # ```
  def create_relation: (Document | ::Array[Document] object, Association association, ?::Hash[untyped, untyped]? selected_fields) -> Proxy

  # Resets the criteria inside the association proxy. Used by many-to-many
  # associations to keep the underlying ids array in sync.
  #
  # _@param_ `name` — The name of the association.
  #
  # Reset the association criteria.
  # ```ruby
  # person.reset_relation_criteria(:preferences)
  # ```
  def reset_relation_criteria: (Symbol name) -> untyped

  # Set the supplied association to an instance variable on the class with the
  # provided name. Used as a helper just for code cleanliness.
  #
  # _@param_ `name` — The name of the association.
  #
  # _@param_ `relation` — The association to set.
  #
  # _@return_ — The association.
  #
  # Set the proxy on the document.
  # ```ruby
  # person.set(:addresses, addresses)
  # ```
  def set_relation: (String | Symbol name, Proxy relation) -> Proxy

  def get_relation: (Symbol name, Association association, Object object, ?bool reload) -> Proxy

  # Returns a subset of __selected_fields attribute applicable to the
  # (embedded) association with the given key, or nil if no projection
  # is to be performed.
  #
  # For example, if __selected_fields is {'a' => 1, 'b.c' => 2, 'b.c.f' => 3},
  # and assoc_key is 'b', return value would be {'c' => 2, 'c.f' => 3}.
  #
  # _@param_ `assoc_key`
  def _mongoid_filter_selected_fields: (String assoc_key) -> ::Hash[untyped, untyped]?

  def needs_no_database_query?: (untyped object, untyped association) -> bool

  # Is the current code executing without autobuild functionality?
  #
  # _@return_ — If autobuild is disabled.
  #
  # Is autobuild disabled?
  # ```ruby
  # document.without_autobuild?
  # ```
  def without_autobuild?: () -> bool

  # Yield to the block with autobuild functionality turned off.
  #
  # _@return_ — The result of the yield.
  #
  # Execute without autobuild.
  # ```ruby
  # document.without_autobuild do
  #   document.name
  # end
  # ```
  def without_autobuild: () -> Object

  # Parse out the attributes and the options from the args passed to a
  # build_ or create_ methods.
  #
  # _@param_ `args` — The arguments.
  #
  # _@return_ — The attributes and options.
  #
  # Parse the args.
  # ```ruby
  # doc.parse_args(:name => "Joe")
  # ```
  def parse_args: (*::Array[untyped] args) -> ::Array[::Hash[untyped, untyped]]

  # Adds the existence check for associations.
  #
  # _@param_ `association` — The association.
  #
  # _@return_ — The model being set up.
  #
  # Add the existence check.
  # ```ruby
  # Person.define_existence_check!(association)
  # ```
  #
  # Check if an association exists.
  # ```ruby
  # person = Person.new
  # person.has_game?
  # person.game?
  # ```
  def self.define_existence_check!: (Association association) -> Class

  # Defines the getter for the association. Nothing too special here: just
  # return the instance variable for the association if it exists or build
  # the thing.
  #
  # _@param_ `association` — The association metadata for the association.
  #
  # _@return_ — The class being set up.
  #
  # Set up the getter for the association.
  # ```ruby
  # Person.define_getter!(association)
  # ```
  def self.define_getter!: (Association association) -> Class

  # Defines the getter for the ids of documents in the association. Should
  # be specify only for referenced many associations.
  #
  # _@param_ `association` — The association metadata for the association.
  #
  # _@return_ — The class being set up.
  #
  # Set up the ids getter for the association.
  # ```ruby
  # Person.define_ids_getter!(association)
  # ```
  def self.define_ids_getter!: (Association association) -> Class

  # Defines the setter for the association. This does a few things based on
  # some conditions. If there is an existing association, a target
  # substitution will take place, otherwise a new association will be
  # created with the supplied target.
  #
  # _@param_ `association` — The association metadata for the association.
  #
  # _@return_ — The class being set up.
  #
  # Set up the setter for the association.
  # ```ruby
  # Person.define_setter!(association)
  # ```
  def self.define_setter!: (Association association) -> Class

  # Defines the setter method that allows you to set documents
  # in this association by their ids. The defined setter, finds
  # documents with given ids and invokes regular association setter
  # with found documents. Ids setters should be defined only for
  # referenced many associations.
  #
  #  @param [ Association ] association The association for the association.
  #
  #  @return [ Class ] The class being set up.
  #
  # Set up the id_setter for the association.
  # ```ruby
  # Person.define_ids_setter!(association)
  # ```
  def self.define_ids_setter!: (untyped association) -> untyped

  # Defines a builder method for an embeds_one association. This is
  # defined as #build_name.
  #
  # _@param_ `association` — The association for the association.
  #
  # _@return_ — The class being set up.
  #
  # ```ruby
  # Person.define_builder!(association)
  # ```
  def self.define_builder!: (Association association) -> Class

  # Defines a creator method for an embeds_one association. This is
  # defined as #create_name. After the object is built it will
  # immediately save.
  #
  # _@param_ `association` — The association for the association.
  #
  # _@return_ — The class being set up.
  #
  # ```ruby
  # Person.define_creator!(association)
  # ```
  def self.define_creator!: (Association association) -> Class
end

# This module defines the behavior for setting up cascading deletes and
# nullifies for associations, and how to delegate to the appropriate strategy.
module Mongoid::Association::Depending
  extend ActiveSupport::Concern

  # Attempt to add the cascading information for the document to know how
  # to handle associated documents on a removal.
  #
  # _@param_ `association` — The association metadata.
  #
  # _@return_ — The class of the document.
  #
  # Set up cascading information
  # ```ruby
  # Mongoid::Association::Depending.define_dependency!(association)
  # ```
  def self.define_dependency!: (Association association) -> Class

  def self.validate!: (untyped association) -> untyped

  # Perform all cascading deletes, destroys, or nullifies. Will delegate to
  # the appropriate strategy to perform the operation.
  #
  # Execute cascades.
  # ```ruby
  # document.apply_delete_dependencies!
  # ```
  def apply_delete_dependencies!: () -> untyped

  def _dependent_delete_all!: (untyped association) -> untyped

  def _dependent_destroy!: (untyped association) -> untyped

  def _dependent_nullify!: (untyped association) -> untyped

  def _dependent_restrict_with_exception!: (untyped association) -> untyped

  def _dependent_restrict_with_error!: (untyped association) -> untyped
end

Mongoid::Association::Mongoid::Association::Depending::STRATEGIES: untyped

# This module provides behaviors shared between Association types.
#
# @since 7.0
module Mongoid::Association::Relatable
  include Mongoid::Association::Constrainable

  include Mongoid::Association::Options

  def initialize: (Class _class, Symbol name, ?::Hash[untyped, untyped] opts) { () -> untyped } -> void

  # Compare this association to another.
  #
  # _@return_ — The object to compare to this association.
  def ==: (untyped other) -> Object

  # Get the callbacks for a given type.
  #
  # _@param_ `callback_type` — The type of callback type.
  #
  # _@return_ — A list of the callbacks, either method
  # names or Procs.
  def get_callbacks: (Symbol callback_type) -> ::Array[Proc | Symbol]

  # Get the type setter.
  #
  # _@return_ — The type setter method.
  #
  # _@note_ — Only relevant for polymorphic associations that take the :as option.
  def type_setter: () -> String

  # Whether trying to bind an object using this association should raise
  # an error.
  #
  # _@param_ `doc` — The document to be bound.
  #
  # _@return_ — Whether the document can be bound.
  def bindable?: (Document doc) -> bool

  # Get the inverse names.
  #
  # _@param_ `other` — The other model class or model object to use when determining inverses.
  #
  # _@return_ — The list of inverse names.
  def inverses: (?Object? other) -> ::Array[Symbol]

  # Get the inverse's association metadata.
  #
  # _@param_ `other` — The other model class or model object to use when determining inverses.
  #
  # _@return_ — The inverse's association metadata.
  def inverse_association: (?Object? other) -> Association

  # Get the inverse type.
  #
  # _@return_ — Default is nil for an association.
  def inverse_type: () -> nil

  # The class name, possibly unqualified or :: prefixed, of the association
  # object(s).
  #
  # This method returns the class name as it is used in the association
  # definition. If :class_name option is given in the association, the
  # exact value of that option is returned here. If :class_name option is
  # not given, the name of the class is calculated from association name
  # but is not resolved to the actual class.
  #
  # The class name returned by this method may not correspond to a defined
  # class, either because the corresponding class has not been loaded yet,
  # or because the association references a non-existent class altogether.
  # To obtain the association class, use +relation_class+ method.
  #
  # _@return_ — The association objects' class name.
  #
  # _@note_ — The return value of this method should not be used to determine
  # whether two associations have the same target class, because the
  # return value is not always a fully qualified class name. To compare
  # classes, retrieve the class instance of the association target using
  # the +relation_class+ method.
  def relation_class_name: () -> String

  # The class of the association object(s).
  #
  # This method returns the class instance corresponding to
  # +relation_class_name+, resolved relative to the host document class.
  #
  # If the class does not exist, this method raises NameError. This can
  # happen because the target class has not yet been defined. Note that
  # polymorphic associations generally do not have a well defined target
  # class because the target class can change from one object to another,
  # and calling this method on a polymorphic association will generally
  # fail with a NameError or produce misleading results (if a class does
  # happen to be defined with the same name as the association name).
  #
  # _@return_ — The association objects' class.
  def relation_class: () -> String

  # The class name of the object owning this association.
  #
  # _@return_ — The owning objects' class name.
  def inverse_class_name: () -> String

  # The class of the object owning this association.
  #
  # _@return_ — The owning objects' class.
  def inverse_class: () -> String

  # The foreign key field if this association stores a foreign key.
  # Otherwise, the primary key.
  #
  # _@return_ — The primary key.
  def key: () -> (Symbol | String)

  # The name of the setter on this object for assigning an associated object.
  #
  # _@return_ — The setter name.
  def setter: () -> String

  # The name of the inverse setter method.
  #
  # _@return_ — The name of the inverse setter.
  def inverse_setter: (?untyped other) -> String

  # The name of the foreign key setter method.
  #
  # _@return_ — The name of the foreign key setter.
  def foreign_key_setter: () -> String

  # The atomic path for this association.
  #
  # _@return_ — The atomic path object.
  def path: (untyped document) -> Mongoid::Atomic::Paths::Root

  # Gets the setter for the field that sets the type of document on a
  # polymorphic association.
  #
  # _@return_ — The name of the setter.
  #
  # Get the inverse type setter.
  # ```ruby
  # association.inverse_type_setter
  # ```
  def inverse_type_setter: () -> String

  # Get the name of the method to check if the foreign key has changed.
  #
  # _@return_ — The foreign key check.
  #
  # Get the foreign key check method.
  # ```ruby
  # association.foreign_key_check
  # ```
  def foreign_key_check: () -> String

  # Create an association proxy object using the owner and target.
  #
  # _@param_ `owner` — The document this association hangs off of.
  #
  # _@param_ `target` — The target (parent) of the association.
  def create_relation: (Document owner, Document | ::Array[Document] target) -> Proxy

  # Whether the dependent method is destructive.
  #
  # _@return_ — If the dependent method is destructive.
  def destructive?: () -> bool

  # Get the counter cache column name.
  #
  # _@return_ — The counter cache column name.
  def counter_cache_column_name: () -> String

  # Get the extension.
  #
  # _@return_ — The extension module, if one has been defined.
  def extension: () -> Module

  # Get the inverse name.
  #
  # _@return_ — The inverse name.
  def inverse: (?untyped other) -> Symbol

  # Whether the associated object(s) should be validated.
  #
  # _@return_ — If the associated object(s)
  # should be validated.
  def validate?: () -> bool

  # Gets the model classes with inverse associations of this model. This is used to determine
  # the classes on the other end of polymorphic associations with models.
  def inverse_association_classes: () -> untyped

  def setup_index!: () -> untyped

  def define_touchable!: () -> untyped

  def define_autosaver!: () -> untyped

  def define_builder!: () -> untyped

  def define_creator!: () -> untyped

  def define_getter!: () -> untyped

  def define_setter!: () -> untyped

  def define_existence_check!: () -> untyped

  def define_ids_getter!: () -> untyped

  def define_ids_setter!: () -> untyped

  def define_counter_cache_callbacks!: () -> untyped

  def define_dependency!: () -> untyped

  def validate!: () -> untyped

  def polymorph!: () -> untyped

  def create_extension!: () { () -> untyped } -> untyped

  def default_inverse: () -> untyped

  # Returns an array of classes/modules forming the namespace hierarchy
  # where symbols referenced in the provided class/module would be looked
  # up by Ruby. For example, if mod is Foo::Bar, this method would return
  # [Foo::Bar, Foo, Object].
  def namespace_hierarchy: (untyped mod) -> untyped

  # Resolves the given class/module name in the context of the specified
  # module, as Ruby would when a constant is referenced in the source.
  #
  # _@note_ — This method can swallow exceptions produced during class loading,
  # because it rescues NameError internally. Since this method attempts
  # to load classes, failure during the loading process may also lead to
  # there being incomplete class definitions.
  def resolve_name: (untyped mod, untyped name) -> untyped

  # Returns the name of the parent to a polymorphic child.
  #
  # _@return_ — The name.
  def as: () -> (String | Symbol)

  # Specify what happens to the associated object when the owner is destroyed.
  #
  # _@return_ — The dependent option.
  def dependent: () -> String

  # The custom sorting options on the association.
  #
  # _@return_ — The custom sorting options.
  def order: () -> Criteria::Queryable::Key

  # Whether to index the primary or foreign key field.
  def indexed?: () -> bool

  # Whether the association is autobuilding.
  def autobuilding?: () -> bool

  # Is the association cyclic.
  #
  # _@return_ — Whether the association is cyclic.
  def cyclic?: () -> bool

  # The name the owning object uses to refer to this association.
  #
  # _@return_ — The inverse_of option.
  def inverse_of: () -> String

  # Mongoid assumes that the field used to hold the primary key of the association is id.
  # You can override this and explicitly specify the primary key with the :primary_key option.
  #
  # _@return_ — The primary key.
  def primary_key: () -> (Symbol | String)

  # Options to save any loaded members and destroy members that are marked for destruction
  # when the parent object is saved.
  #
  # _@return_ — The autosave option.
  def autosave: () -> bool

  # Whether the association is counter-cached.
  def counter_cached?: () -> bool

  # Whether this association is polymorphic.
  #
  # _@return_ — Whether the association is polymorphic.
  def polymorphic?: () -> bool

  # Whether the association has callbacks cascaded down from the parent.
  #
  # _@return_ — Whether callbacks are cascaded.
  def cascading_callbacks?: () -> bool

  # The store_as option.
  #
  # _@return_ — Default is nil.
  def store_as: () -> nil

  # Whether the association has forced nil inverse (So no foreign keys are saved).
  #
  # _@return_ — Default is false.
  def forced_nil_inverse?: () -> bool

  # The field for saving the associated object's type.
  #
  # _@return_ — Default is nil.
  def type: () -> nil

  # The field for saving the associated object's type.
  #
  # _@return_ — Default is nil.
  def touch_field: () -> nil

  def touchable?: () -> bool

  # Convert the supplied object to the appropriate type to set as the
  # foreign key for an association.
  #
  # _@param_ `object` — The object to convert.
  #
  # _@return_ — The object cast to the correct type.
  #
  # Convert the object.
  # ```ruby
  # constraint.convert("12345")
  # ```
  def convert_to_foreign_key: (Object object) -> Object

  def convert_polymorphic: (untyped object) -> untyped
end

Mongoid::Association::Mongoid::Association::Relatable::SHARED_OPTIONS: untyped

Mongoid::Association::Mongoid::Association::Relatable::PRIMARY_KEY_DEFAULT: untyped

module Mongoid::Association::Marshalable
  # The name of the association.
  #
  # _@return_ — The name of the association.
  #
  # The options on this association.
  #
  # _@return_ — The options.
  #
  # Provides the data needed to Marshal.dump an association proxy.
  #
  # _@return_ — The dumped data.
  #
  # Dump the proxy.
  # ```ruby
  # Marshal.dump(proxy)
  # ```
  def marshal_dump: () -> Symbol
                  | () -> ::Hash[untyped, untyped]
                  | () -> ::Array[Object]

  # Takes the provided data and sets it back on the proxy.
  #
  # _@param_ `data` — The data to set on the proxy.
  #
  # _@return_ — The loaded data.
  #
  # Load the proxy.
  # ```ruby
  # Marshal.load(proxy)
  # ```
  def marshal_load: (::Array[Object] data) -> ::Array[Object]
end

# The reflections module provides convenience methods that can retrieve
# useful information about associations.
module Mongoid::Association::Reflections
  extend ActiveSupport::Concern

  # Returns the association metadata for the supplied name.
  #
  # _@param_ `name` — The name of the association to find.
  #
  # _@return_ — The matching association metadata.
  #
  # Find association metadata by name.
  # ```ruby
  # person.reflect_on_association(:addresses)
  # ```
  def reflect_on_association: (String | Symbol name) -> Association

  # Returns all association metadata for the supplied macros.
  #
  # _@param_ `macros` — The association macros.
  #
  # _@return_ — The matching association metadata.
  #
  # Find multiple association metadata by macro.
  # ```ruby
  # person.reflect_on_all_associations(:embeds_many)
  # ```
  def reflect_on_all_association: (*::Array[Symbol] macros) -> ::Array[Association]
end

module Mongoid::Association::Mongoid::Association::Reflections::ClassMethods
  # Returns the association metadata for the supplied name.
  #
  # _@param_ `name` — The name of the association to find.
  #
  # _@return_ — The matching association metadata.
  #
  # Find association metadata by name.
  # ```ruby
  # Person.reflect_on_association(:addresses)
  # ```
  def reflect_on_association: (String | Symbol name) -> Association

  # Returns all association metadata for the supplied macros.
  #
  # _@param_ `macros` — The association macros.
  #
  # _@return_ — The matching association metadata.
  #
  # Find multiple association metadata by macro.
  # ```ruby
  # Person.reflect_on_all_associations(:embeds_many)
  # ```
  def reflect_on_all_associations: (*::Array[Symbol] macros) -> ::Array[Association]
end

# Used for converting foreign key values to the correct type based on the
# types of ids that the document stores.
module Mongoid::Association::Constrainable
  # Convert the supplied object to the appropriate type to set as the
  # foreign key for an association.
  #
  # _@param_ `object` — The object to convert.
  #
  # _@return_ — The object cast to the correct type.
  #
  # Convert the object.
  # ```ruby
  # constraint.convert("12345")
  # ```
  def convert_to_foreign_key: (Object object) -> Object

  def convert_polymorphic: (untyped object) -> untyped
end

# This module defines the eager loading behavior for criteria.
#
# @since 7.0
module Mongoid::Association::EagerLoadable
  def eager_loadable?: () -> bool

  def eager_load: (untyped docs) -> untyped

  def preload: (untyped relations, untyped docs) -> untyped
end

module Mongoid::Association::Embedded
end

# This module provides convenience macros for using cyclic embedded
# associations.
module Mongoid::Association::Mongoid::Association::Embedded::Cyclic
  extend ActiveSupport::Concern
end

module Mongoid::Association::Mongoid::Association::Embedded::Mongoid::Association::Mongoid::Association::Embedded::Cyclic::ClassMethods
  # Create a cyclic embedded association that creates a tree hierarchy for
  # the document and many embedded child documents.
  #
  # This provides the default nomenclature for accessing a parent document
  # or its children.
  #
  # Set up a recursive embeds many.
  # ```ruby
  #
  # class Role
  #   include Mongoid::Document
  #   recursively_embeds_many
  # end
  # ```
  #
  # The previous example is a shorcut for this.
  # ```ruby
  #
  # class Role
  #   include Mongoid::Document
  #   embeds_many :child_roles, :class_name => "Role", :cyclic => true
  #   embedded_in :parent_role, :class_name => "Role", :cyclic => true
  # end
  # ```
  def recursively_embeds_many: (?untyped options) -> untyped

  # Create a cyclic embedded association that creates a single self
  # referencing relationship for a parent and a single child.
  #
  # This provides the default nomenclature for accessing a parent document
  # or its children.
  #
  # Set up a recursive embeds one.
  # ```ruby
  #
  # class Role
  #   include Mongoid::Document
  #   recursively_embeds_one
  # end
  # ```
  #
  # The previous example is a shorcut for this.
  # ```ruby
  #
  # class Role
  #   include Mongoid::Document
  #   embeds_one :child_role, :class_name => "Role", :cyclic => true
  #   embedded_in :parent_role, :class_name => "Role", :cyclic => true
  # end
  # ```
  def recursively_embeds_one: (?untyped options) -> untyped

  # Determines the parent name given the class.
  #
  # _@return_ — "parent_" plus the class name underscored.
  #
  # Determine the parent name.
  # ```ruby
  # Role.cyclic_parent_name
  # ```
  def cyclic_parent_name: () -> String

  # Determines the child name given the class.
  #
  # _@param_ `many` — Is the a many association?
  #
  # _@return_ — "child_" plus the class name underscored in
  # singular or plural form.
  #
  # Determine the child name.
  # ```ruby
  # Role.cyclic_child_name
  # ```
  def cyclic_child_name: (?bool many) -> String
end

# Contains behavior for executing operations in batch on embedded
# documents.
module Mongoid::Association::Mongoid::Association::Embedded::Batchable
  include Mongoid::Positional

  # Insert new documents as a batch push ($push with $each). This ensures that
  # all callbacks are run at the appropriate time and only 1 request is
  # made to the database.
  #
  # _@param_ `docs` — The docs to add.
  #
  # _@return_ — The inserts.
  #
  # Execute the batch push.
  # ```ruby
  # batchable.batch_insert([ doc_one, doc_two ])
  # ```
  def batch_insert: (::Array[Document] docs) -> ::Array[::Hash[untyped, untyped]]

  # Clear all of the docs out of the association in a single swipe.
  #
  # _@param_ `docs` — The docs to clear.
  #
  # _@return_ — The empty array.
  #
  # Clear all docs.
  # ```ruby
  # batchable.batch_clear(docs)
  # ```
  def batch_clear: (::Array[Document] docs) -> ::Array[untyped]

  # Batch remove the provided documents as a $pullAll.
  #
  # _@param_ `docs` — The docs to remove.
  #
  # _@param_ `method` — Delete or destroy.
  #
  # Batch remove the documents.
  # ```ruby
  # batchable.batch_remove([ doc_one, doc_two ])
  # ```
  def batch_remove: (::Array[Document] docs, ?Symbol method) -> untyped

  # Batch replace the provided documents as a $set.
  #
  # _@param_ `docs` — The docs to replace with.
  #
  # _@return_ — The inserts.
  #
  # Batch replace the documents.
  # ```ruby
  # batchable.batch_replace([ doc_one, doc_two ])
  # ```
  def batch_replace: (::Array[Document] docs) -> ::Array[::Hash[untyped, untyped]]

  # Add the atomic sets to the base document.
  #
  # _@param_ `sets` — The atomic sets.
  #
  # Add the atomic sets.
  # ```ruby
  # batchable.add_atomic_sets([{ field: value }])
  # ```
  def add_atomic_sets: (::Array[::Hash[untyped, untyped]] sets) -> untyped

  # Perform a batch persist of the provided documents with a $set.
  #
  # _@param_ `docs` — The docs to persist.
  #
  # _@return_ — The inserts.
  #
  # Perform a batch $set.
  # ```ruby
  # batchable.execute_batch_set(docs)
  # ```
  def execute_batch_set: (::Array[Document] docs) -> ::Array[::Hash[untyped, untyped]]

  # Perform a batch persist of the provided documents with $push and $each.
  #
  # _@param_ `docs` — The docs to persist.
  #
  # _@return_ — The inserts.
  #
  # Perform a batch push.
  # ```ruby
  # batchable.execute_batch_push(docs)
  # ```
  def execute_batch_push: (::Array[Document] docs) -> ::Array[::Hash[untyped, untyped]]

  # Are we in a state to be able to batch insert?
  #
  # _@return_ — If inserts can be performed.
  #
  # Can inserts be performed?
  # ```ruby
  # batchable.insertable?
  # ```
  def insertable?: () -> bool

  # Are the inserts currently valid?
  #
  # _@return_ — If inserts are currently valid.
  #
  # Are the inserts currently valid.
  # ```ruby
  # batchable.inserts_valid
  # ```
  def inserts_valid: () -> bool

  # Set the inserts valid flag.
  #
  # _@param_ `value` — The flag.
  #
  # _@return_ — The flag.
  #
  # Set the flag.
  # ```ruby
  # batchable.inserts_valid = true
  # ```
  def inserts_valid=: (bool value) -> bool

  # Normalize the documents, in case they were provided as an array of
  # hashes.
  #
  # _@param_ `docs` — The docs to normalize.
  #
  # _@return_ — The docs.
  #
  # Normalize the docs.
  # ```ruby
  # batchable.normalize_docs(docs)
  # ```
  def normalize_docs: (::Array[::Hash[untyped, untyped] | Document] docs) -> ::Array[Document]

  # Get the atomic path.
  #
  # _@return_ — The atomic path.
  #
  # Get the atomic path.
  # ```ruby
  # batchable.path
  # ```
  def path: () -> String

  # Set the atomic path.
  #
  # _@param_ `value` — The path.
  #
  # _@return_ — The path.
  #
  # Set the atomic path.
  # ```ruby
  # batchable.path = "addresses"
  # ```
  def path=: (String value) -> String

  # Get the selector for executing atomic operations on the collection.
  #
  # _@return_ — The atomic selector.
  #
  # Get the selector.
  # ```ruby
  # batchable.selector
  # ```
  def selector: () -> ::Hash[untyped, untyped]

  # Pre processes the batch insert for the provided documents.
  #
  # _@param_ `docs` — The documents.
  #
  # _@return_ — The documents as an array of hashes.
  #
  # Pre process the documents.
  # ```ruby
  # batchable.pre_process_batch_insert(docs)
  # ```
  def pre_process_batch_insert: (::Array[Document] docs) -> ::Array[::Hash[untyped, untyped]]

  # Pre process the batch removal.
  #
  # _@param_ `docs` — The documents.
  #
  # _@param_ `method` — Delete or destroy.
  #
  # _@return_ — The documents as hashes.
  #
  # Pre process the documents.
  # ```ruby
  # batchable.pre_process_batch_remove(docs, :delete)
  # ```
  def pre_process_batch_remove: (::Array[Document] docs, Symbol method) -> ::Array[::Hash[untyped, untyped]]

  # sord warn - Documents wasn't able to be resolved to a constant in this project
  # Post process the documents after batch insert.
  #
  # _@param_ `docs` — The inserted docs.
  #
  # _@return_ — The document enum.
  #
  # Post process the documents.
  # ```ruby
  # batchable.post_process_batch_insert(docs)
  # ```
  def post_process_batch_insert: (::Array[Document] docs) -> ::Enumerable[untyped]

  # Post process the batch removal.
  #
  # _@param_ `docs` — The documents.
  #
  # _@param_ `method` — Delete or destroy.
  #
  # _@return_ — The documents.
  #
  # Post process the documents.
  # ```ruby
  # batchable.post_process_batch_remove(docs, :delete)
  # ```
  def post_process_batch_remove: (::Array[Document] docs, Symbol method) -> ::Array[Document]

  # Takes the provided selector and atomic operations and replaces the
  # indexes of the embedded documents with the positional operator when
  # needed.
  #
  # _@param_ `selector` — The selector.
  #
  # _@param_ `operations` — The update operations.
  #
  # _@param_ `processed` — The processed update operations.
  #
  # _@return_ — The new operations.
  #
  # Process the operations.
  # ```ruby
  # positionally(
  #   { "_id" => 1, "addresses._id" => 2 },
  #   { "$set" => { "addresses.0.street" => "hobrecht" }}
  # )
  # ```
  #
  # _@note_ — The only time we can accurately know when to use the positional
  # operator is at the exact time we are going to persist something. So
  # we can tell by the selector that we are sending if it is actually
  # possible to use the positional operator at all. For example, if the
  # selector is: { "_id" => 1 }, then we could not use the positional
  # operator for updating embedded documents since there would never be a
  # match - we base whether we can based on the number of levels deep the
  # selector goes, and if the id values are not nil.
  def positionally: (::Hash[untyped, untyped] selector, ::Hash[untyped, untyped] operations, ?::Hash[untyped, untyped] processed) -> ::Hash[untyped, untyped]

  def process_operations: (untyped keys, untyped operations, untyped processed) -> untyped

  def process_updates: (untyped keys, untyped update, ?untyped updates) -> untyped

  def replace_index: (untyped keys, untyped position) -> untyped
end

# The EmbedsOne type association.
#
# @since 7.0
class Mongoid::Association::Mongoid::Association::Embedded::EmbedsOne
  include Mongoid::Association::Relatable

  include Mongoid::Association::Embedded::EmbedsOne::Buildable

  # Setup the instance methods, fields, etc. on the association owning class.
  def setup!: () -> self

  # The field key used to store the association object.
  #
  # _@return_ — The field name.
  def store_as: () -> String

  # The key that is used to get the attributes for the associated object.
  #
  # _@return_ — The name of the field used to store the association.
  def key: () -> String

  # Is this association type embedded?
  #
  # _@return_ — Always true.
  def embedded?: () -> bool

  # Get the default validation setting for the association. Determines if
  # by default a validates associated will occur.
  #
  # _@return_ — The validation default.
  #
  # Get the validation default.
  # ```ruby
  # Proxy.validation_default
  # ```
  def validation_default: () -> bool

  # Does this association type store the foreign key?
  #
  # _@return_ — Always false.
  def stores_foreign_key?: () -> bool

  # The primary key
  #
  # _@return_ — Not relevant for this association
  def primary_key: () -> nil

  # Get the association proxy class for this association type.
  #
  # _@return_ — The proxy class.
  def relation: () -> Association::Embedded::EmbedsMany::Proxy

  # Is this association polymorphic?
  #
  # _@return_ — Whether this association is polymorphic.
  def polymorphic?: () -> bool

  # The field used to store the type of the related object.
  #
  # _@return_ — The field for storing the associated object's type.
  #
  # _@note_ — Only relevant if the association is polymorphic.
  def type: () -> String?

  # The nested builder object.
  #
  # _@param_ `attributes` — The attributes to use to build the association object.
  #
  # _@param_ `options` — The options for the association.
  #
  # _@return_ — The Nested Builder object.
  def nested_builder: (::Hash[untyped, untyped] attributes, ::Hash[untyped, untyped] options) -> Association::Nested::One

  def setup_instance_methods!: () -> untyped

  def relation_complements: () -> untyped

  def polymorphic_inverses: (?untyped other) -> untyped

  def determine_inverses: (untyped other) -> untyped

  def build: (Document base, Document object, ?String? _type, ?::Hash[untyped, untyped]? selected_fields) -> Document

  # Begin the assignment of attributes. While in this block embedded
  # documents will not autosave themselves in order to allow the document to
  # be in a valid state.
  #
  # _@return_ — The yielded value.
  #
  # Execute the assignment.
  # ```ruby
  # _assigning do
  #   person.attributes = { :addresses => [ address ] }
  # end
  # ```
  def _assigning: () -> Object

  # Is the current thread in assigning mode?
  #
  # _@return_ — If the thread is assigning.
  #
  # Is the current thread in assigning mode?
  # ```ruby
  # proxy._assigning?
  # ```
  def _assigning?: () -> bool

  # Execute a block in binding mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in binding mode.
  # ```ruby
  # binding do
  #   relation.push(doc)
  # end
  # ```
  def _binding: () -> Object

  # Is the current thread in binding mode?
  #
  # _@return_ — If the thread is binding.
  #
  # Is the current thread in binding mode?
  # ```ruby
  # proxy.binding?
  # ```
  def _binding?: () -> bool

  # Execute a block in building mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in building mode.
  # ```ruby
  # _building do
  #   relation.push(doc)
  # end
  # ```
  def _building: () -> Object

  # Is the current thread in building mode?
  #
  # _@return_ — If the thread is building.
  #
  # Is the current thread in building mode?
  # ```ruby
  # proxy._building?
  # ```
  def _building?: () -> bool

  # Is the current thread in creating mode?
  #
  # _@return_ — If the thread is creating.
  #
  # Is the current thread in creating mode?
  # ```ruby
  # proxy.creating?
  # ```
  def _creating?: () -> bool

  # Execute a block in loading mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in loading mode.
  # ```ruby
  # _loading do
  #   relation.push(doc)
  # end
  # ```
  def _loading: () -> Object

  # Is the current thread in loading mode?
  #
  # _@return_ — If the thread is loading.
  #
  # Is the current thread in loading mode?
  # ```ruby
  # proxy._loading?
  # ```
  def _loading?: () -> bool

  def initialize: (Class _class, Symbol name, ?::Hash[untyped, untyped] opts) { () -> untyped } -> void

  # Compare this association to another.
  #
  # _@return_ — The object to compare to this association.
  def ==: (untyped other) -> Object

  # Get the callbacks for a given type.
  #
  # _@param_ `callback_type` — The type of callback type.
  #
  # _@return_ — A list of the callbacks, either method
  # names or Procs.
  def get_callbacks: (Symbol callback_type) -> ::Array[Proc | Symbol]

  # Get the type setter.
  #
  # _@return_ — The type setter method.
  #
  # _@note_ — Only relevant for polymorphic associations that take the :as option.
  def type_setter: () -> String

  # Whether trying to bind an object using this association should raise
  # an error.
  #
  # _@param_ `doc` — The document to be bound.
  #
  # _@return_ — Whether the document can be bound.
  def bindable?: (Document doc) -> bool

  # Get the inverse names.
  #
  # _@param_ `other` — The other model class or model object to use when determining inverses.
  #
  # _@return_ — The list of inverse names.
  def inverses: (?Object? other) -> ::Array[Symbol]

  # Get the inverse's association metadata.
  #
  # _@param_ `other` — The other model class or model object to use when determining inverses.
  #
  # _@return_ — The inverse's association metadata.
  def inverse_association: (?Object? other) -> Association

  # Get the inverse type.
  #
  # _@return_ — Default is nil for an association.
  def inverse_type: () -> nil

  # The class name, possibly unqualified or :: prefixed, of the association
  # object(s).
  #
  # This method returns the class name as it is used in the association
  # definition. If :class_name option is given in the association, the
  # exact value of that option is returned here. If :class_name option is
  # not given, the name of the class is calculated from association name
  # but is not resolved to the actual class.
  #
  # The class name returned by this method may not correspond to a defined
  # class, either because the corresponding class has not been loaded yet,
  # or because the association references a non-existent class altogether.
  # To obtain the association class, use +relation_class+ method.
  #
  # _@return_ — The association objects' class name.
  #
  # _@note_ — The return value of this method should not be used to determine
  # whether two associations have the same target class, because the
  # return value is not always a fully qualified class name. To compare
  # classes, retrieve the class instance of the association target using
  # the +relation_class+ method.
  def relation_class_name: () -> String

  # The class of the association object(s).
  #
  # This method returns the class instance corresponding to
  # +relation_class_name+, resolved relative to the host document class.
  #
  # If the class does not exist, this method raises NameError. This can
  # happen because the target class has not yet been defined. Note that
  # polymorphic associations generally do not have a well defined target
  # class because the target class can change from one object to another,
  # and calling this method on a polymorphic association will generally
  # fail with a NameError or produce misleading results (if a class does
  # happen to be defined with the same name as the association name).
  #
  # _@return_ — The association objects' class.
  def relation_class: () -> String

  # The class name of the object owning this association.
  #
  # _@return_ — The owning objects' class name.
  def inverse_class_name: () -> String

  # The class of the object owning this association.
  #
  # _@return_ — The owning objects' class.
  def inverse_class: () -> String

  # The name of the setter on this object for assigning an associated object.
  #
  # _@return_ — The setter name.
  def setter: () -> String

  # The name of the inverse setter method.
  #
  # _@return_ — The name of the inverse setter.
  def inverse_setter: (?untyped other) -> String

  # The name of the foreign key setter method.
  #
  # _@return_ — The name of the foreign key setter.
  def foreign_key_setter: () -> String

  # The atomic path for this association.
  #
  # _@return_ — The atomic path object.
  def path: (untyped document) -> Mongoid::Atomic::Paths::Root

  # Gets the setter for the field that sets the type of document on a
  # polymorphic association.
  #
  # _@return_ — The name of the setter.
  #
  # Get the inverse type setter.
  # ```ruby
  # association.inverse_type_setter
  # ```
  def inverse_type_setter: () -> String

  # Get the name of the method to check if the foreign key has changed.
  #
  # _@return_ — The foreign key check.
  #
  # Get the foreign key check method.
  # ```ruby
  # association.foreign_key_check
  # ```
  def foreign_key_check: () -> String

  # Create an association proxy object using the owner and target.
  #
  # _@param_ `owner` — The document this association hangs off of.
  #
  # _@param_ `target` — The target (parent) of the association.
  def create_relation: (Document owner, Document | ::Array[Document] target) -> Proxy

  # Whether the dependent method is destructive.
  #
  # _@return_ — If the dependent method is destructive.
  def destructive?: () -> bool

  # Get the counter cache column name.
  #
  # _@return_ — The counter cache column name.
  def counter_cache_column_name: () -> String

  # Get the extension.
  #
  # _@return_ — The extension module, if one has been defined.
  def extension: () -> Module

  # Get the inverse name.
  #
  # _@return_ — The inverse name.
  def inverse: (?untyped other) -> Symbol

  # Whether the associated object(s) should be validated.
  #
  # _@return_ — If the associated object(s)
  # should be validated.
  def validate?: () -> bool

  # Gets the model classes with inverse associations of this model. This is used to determine
  # the classes on the other end of polymorphic associations with models.
  def inverse_association_classes: () -> untyped

  def setup_index!: () -> untyped

  def define_touchable!: () -> untyped

  def define_autosaver!: () -> untyped

  def define_builder!: () -> untyped

  def define_creator!: () -> untyped

  def define_getter!: () -> untyped

  def define_setter!: () -> untyped

  def define_existence_check!: () -> untyped

  def define_ids_getter!: () -> untyped

  def define_ids_setter!: () -> untyped

  def define_counter_cache_callbacks!: () -> untyped

  def define_dependency!: () -> untyped

  def validate!: () -> untyped

  def polymorph!: () -> untyped

  def create_extension!: () { () -> untyped } -> untyped

  def default_inverse: () -> untyped

  # Returns an array of classes/modules forming the namespace hierarchy
  # where symbols referenced in the provided class/module would be looked
  # up by Ruby. For example, if mod is Foo::Bar, this method would return
  # [Foo::Bar, Foo, Object].
  def namespace_hierarchy: (untyped mod) -> untyped

  # Resolves the given class/module name in the context of the specified
  # module, as Ruby would when a constant is referenced in the source.
  #
  # _@note_ — This method can swallow exceptions produced during class loading,
  # because it rescues NameError internally. Since this method attempts
  # to load classes, failure during the loading process may also lead to
  # there being incomplete class definitions.
  def resolve_name: (untyped mod, untyped name) -> untyped

  # Returns the name of the parent to a polymorphic child.
  #
  # _@return_ — The name.
  def as: () -> (String | Symbol)

  # Specify what happens to the associated object when the owner is destroyed.
  #
  # _@return_ — The dependent option.
  def dependent: () -> String

  # The custom sorting options on the association.
  #
  # _@return_ — The custom sorting options.
  def order: () -> Criteria::Queryable::Key

  # Whether to index the primary or foreign key field.
  def indexed?: () -> bool

  # Whether the association is autobuilding.
  def autobuilding?: () -> bool

  # Is the association cyclic.
  #
  # _@return_ — Whether the association is cyclic.
  def cyclic?: () -> bool

  # The name the owning object uses to refer to this association.
  #
  # _@return_ — The inverse_of option.
  def inverse_of: () -> String

  # Options to save any loaded members and destroy members that are marked for destruction
  # when the parent object is saved.
  #
  # _@return_ — The autosave option.
  def autosave: () -> bool

  # Whether the association is counter-cached.
  def counter_cached?: () -> bool

  # Whether the association has callbacks cascaded down from the parent.
  #
  # _@return_ — Whether callbacks are cascaded.
  def cascading_callbacks?: () -> bool

  # Whether the association has forced nil inverse (So no foreign keys are saved).
  #
  # _@return_ — Default is false.
  def forced_nil_inverse?: () -> bool

  # The field for saving the associated object's type.
  #
  # _@return_ — Default is nil.
  def touch_field: () -> nil

  def touchable?: () -> bool

  # Convert the supplied object to the appropriate type to set as the
  # foreign key for an association.
  #
  # _@param_ `object` — The object to convert.
  #
  # _@return_ — The object cast to the correct type.
  #
  # Convert the object.
  # ```ruby
  # constraint.convert("12345")
  # ```
  def convert_to_foreign_key: (Object object) -> Object

  def convert_polymorphic: (untyped object) -> untyped
end

Mongoid::Association::Mongoid::Association::Embedded::Mongoid::Association::Mongoid::Association::Embedded::EmbedsOne::ASSOCIATION_OPTIONS: untyped

Mongoid::Association::Mongoid::Association::Embedded::Mongoid::Association::Mongoid::Association::Embedded::EmbedsOne::VALID_OPTIONS: untyped

Mongoid::Association::Mongoid::Association::Embedded::Mongoid::Association::Mongoid::Association::Embedded::EmbedsOne::SHARED_OPTIONS: untyped

Mongoid::Association::Mongoid::Association::Embedded::Mongoid::Association::Mongoid::Association::Embedded::EmbedsOne::PRIMARY_KEY_DEFAULT: untyped

class Mongoid::Association::Mongoid::Association::Embedded::Mongoid::Association::Mongoid::Association::Embedded::EmbedsOne::Proxy < Mongoid::Association::One
  # Instantiate a new embeds_one association.
  #
  # _@param_ `base` — The document this association hangs off of.
  #
  # _@param_ `target` — The child document in the association.
  #
  # _@param_ `association` — The association metadata.
  #
  # Create the new proxy.
  # ```ruby
  # One.new(person, name, association)
  # ```
  def initialize: (Document base, Document target, Association association) -> void

  # Substitutes the supplied target documents for the existing document
  # in the association.
  #
  # _@param_ `replacement` — A document to replace the target.
  #
  # _@return_ — The association or nil.
  #
  # Substitute the new document.
  # ```ruby
  # person.name.substitute(new_name)
  # ```
  def substitute: (Document replacement) -> Document?

  # sord warn - Binding wasn't able to be resolved to a constant in this project
  # Instantiate the binding associated with this association.
  #
  # _@return_ — The association's binding.
  #
  # Get the binding.
  # ```ruby
  # relation.binding([ address ])
  # ```
  def binding: () -> Binding

  # Are we able to persist this association?
  #
  # _@return_ — If the association is persistable.
  #
  # Can we persist the association?
  # ```ruby
  # relation.persistable?
  # ```
  def persistable?: () -> bool

  # Returns true if the association is an embedded one. In this case
  # always true.
  #
  # _@return_ — true.
  #
  # Is this association embedded?
  # ```ruby
  # Association::Embedded::EmbedsOne.embedded?
  # ```
  def self.embedded?: () -> bool

  # Get the path calculator for the supplied document.
  #
  # _@param_ `document` — The document to calculate on.
  #
  # _@return_ — The embedded one atomic path calculator.
  #
  # Get the path calculator.
  # ```ruby
  # Proxy.path(document)
  # ```
  def self.path: (Document document) -> Mongoid::Atomic::Paths::Embedded::One
end

Mongoid::Association::Mongoid::Association::Embedded::Mongoid::Association::Mongoid::Association::Embedded::EmbedsOne::Mongoid::Association::Mongoid::Association::Embedded::Mongoid::Association::Mongoid::Association::Embedded::EmbedsOne::Proxy::VALID_OPTIONS: untyped

# Binding class for all embeds_one associations.
#
# @since 7.0
class Mongoid::Association::Mongoid::Association::Embedded::Mongoid::Association::Mongoid::Association::Embedded::EmbedsOne::Binding
  include Mongoid::Association::Bindable

  # Binds the base object to the inverse of the association. This is so we
  # are referenced to the actual objects themselves on both sides.
  #
  # This case sets the association metadata on the inverse object as well as the
  # document itself.
  #
  # Bind the document.
  # ```ruby
  # person.name.bind(:continue => true)
  # person.name = Name.new
  # ```
  def bind_one: () -> untyped

  # Unbinds the base object and the inverse, caused by setting the
  # reference to nil.
  #
  # Unbind the document.
  # ```ruby
  # person.name.unbind(:continue => true)
  # person.name = nil
  # ```
  def unbind_one: () -> untyped

  # Create the new binding.
  #
  # _@param_ `base` — The base of the binding.
  #
  # _@param_ `target` — The target of the binding.
  #
  # _@param_ `association` — The association metadata.
  #
  # Initialize a binding.
  # ```ruby
  # Binding.new(base, target, association)
  # ```
  def initialize: (Document base, Document | ::Array[Document] target, Association association) -> void

  # Execute the provided block inside a binding.
  #
  # _@return_ — The result of the yield.
  #
  # Execute the binding block.
  # ```ruby
  # binding.binding do
  #   base.foreign_key = 1
  # end
  # ```
  def binding: () -> Object

  # Check if the inverse is properly defined.
  #
  # _@param_ `doc` — The document getting bound.
  #
  # Check the inverse definition.
  # ```ruby
  # binding.check_inverse!(doc)
  # ```
  def check_inverse!: (Document doc) -> untyped

  # Set the id of the related document in the foreign key field on the
  # keyed document.
  #
  # _@param_ `keyed` — The document that stores the foreign key.
  #
  # _@param_ `id` — The id of the bound document.
  #
  # Bind the foreign key.
  # ```ruby
  # binding.bind_foreign_key(post, person._id)
  # ```
  def bind_foreign_key: (Document keyed, Object id) -> untyped

  # Set the type of the related document on the foreign type field, used
  # when associations are polymorphic.
  #
  # _@param_ `typed` — The document that stores the type field.
  #
  # _@param_ `name` — The name of the model.
  #
  # Bind the polymorphic type.
  # ```ruby
  # binding.bind_polymorphic_type(post, "Person")
  # ```
  def bind_polymorphic_type: (Document typed, String name) -> untyped

  # Set the type of the related document on the foreign type field, used
  # when associations are polymorphic.
  #
  # _@param_ `typed` — The document that stores the type field.
  #
  # _@param_ `name` — The name of the model.
  #
  # Bind the polymorphic type.
  # ```ruby
  # binding.bind_polymorphic_inverse_type(post, "Person")
  # ```
  def bind_polymorphic_inverse_type: (Document typed, String name) -> untyped

  # Bind the inverse document to the child document so that the in memory
  # instances are the same.
  #
  # _@param_ `doc` — The base document.
  #
  # _@param_ `inverse` — The inverse document.
  #
  # Bind the inverse.
  # ```ruby
  # binding.bind_inverse(post, person)
  # ```
  def bind_inverse: (Document doc, Document inverse) -> untyped

  # Bind the provided document with the base from the parent association.
  #
  # _@param_ `doc` — The document to bind.
  #
  # Bind the document with the base.
  # ```ruby
  # binding.bind_from_relational_parent(doc)
  # ```
  def bind_from_relational_parent: (Document doc) -> untyped

  def record_id: (untyped _base) -> untyped

  # Ensure that the association on the base is correct, for the cases
  # where we have multiple belongs to definitions and were are setting
  # different parents in memory in order.
  #
  # _@return_ — If the association changed.
  #
  # Set the base association.
  # ```ruby
  # binding.set_base_association
  # ```
  def set_base_association: () -> bool

  # Bind the provided document with the base from the parent association.
  #
  # _@param_ `doc` — The document to unbind.
  #
  # Bind the document with the base.
  # ```ruby
  # unbinding.unbind_from_relational_parent(doc)
  # ```
  def unbind_from_relational_parent: (Document doc) -> untyped

  # Begin the assignment of attributes. While in this block embedded
  # documents will not autosave themselves in order to allow the document to
  # be in a valid state.
  #
  # _@return_ — The yielded value.
  #
  # Execute the assignment.
  # ```ruby
  # _assigning do
  #   person.attributes = { :addresses => [ address ] }
  # end
  # ```
  def _assigning: () -> Object

  # Is the current thread in assigning mode?
  #
  # _@return_ — If the thread is assigning.
  #
  # Is the current thread in assigning mode?
  # ```ruby
  # proxy._assigning?
  # ```
  def _assigning?: () -> bool

  # Execute a block in binding mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in binding mode.
  # ```ruby
  # binding do
  #   relation.push(doc)
  # end
  # ```
  def _binding: () -> Object

  # Is the current thread in binding mode?
  #
  # _@return_ — If the thread is binding.
  #
  # Is the current thread in binding mode?
  # ```ruby
  # proxy.binding?
  # ```
  def _binding?: () -> bool

  # Execute a block in building mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in building mode.
  # ```ruby
  # _building do
  #   relation.push(doc)
  # end
  # ```
  def _building: () -> Object

  # Is the current thread in building mode?
  #
  # _@return_ — If the thread is building.
  #
  # Is the current thread in building mode?
  # ```ruby
  # proxy._building?
  # ```
  def _building?: () -> bool

  # Is the current thread in creating mode?
  #
  # _@return_ — If the thread is creating.
  #
  # Is the current thread in creating mode?
  # ```ruby
  # proxy.creating?
  # ```
  def _creating?: () -> bool

  # Execute a block in loading mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in loading mode.
  # ```ruby
  # _loading do
  #   relation.push(doc)
  # end
  # ```
  def _loading: () -> Object

  # Is the current thread in loading mode?
  #
  # _@return_ — If the thread is loading.
  #
  # Is the current thread in loading mode?
  # ```ruby
  # proxy._loading?
  # ```
  def _loading?: () -> bool
end

# Builder class for embeds_one associations.
#
# @since 7.0
module Mongoid::Association::Mongoid::Association::Embedded::Mongoid::Association::Mongoid::Association::Embedded::EmbedsOne::Buildable
  include Mongoid::Threaded::Lifecycle

  def build: (Document base, Document object, ?String? _type, ?::Hash[untyped, untyped]? selected_fields) -> Document

  # Begin the assignment of attributes. While in this block embedded
  # documents will not autosave themselves in order to allow the document to
  # be in a valid state.
  #
  # _@return_ — The yielded value.
  #
  # Execute the assignment.
  # ```ruby
  # _assigning do
  #   person.attributes = { :addresses => [ address ] }
  # end
  # ```
  def _assigning: () -> Object

  # Is the current thread in assigning mode?
  #
  # _@return_ — If the thread is assigning.
  #
  # Is the current thread in assigning mode?
  # ```ruby
  # proxy._assigning?
  # ```
  def _assigning?: () -> bool

  # Execute a block in binding mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in binding mode.
  # ```ruby
  # binding do
  #   relation.push(doc)
  # end
  # ```
  def _binding: () -> Object

  # Is the current thread in binding mode?
  #
  # _@return_ — If the thread is binding.
  #
  # Is the current thread in binding mode?
  # ```ruby
  # proxy.binding?
  # ```
  def _binding?: () -> bool

  # Execute a block in building mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in building mode.
  # ```ruby
  # _building do
  #   relation.push(doc)
  # end
  # ```
  def _building: () -> Object

  # Is the current thread in building mode?
  #
  # _@return_ — If the thread is building.
  #
  # Is the current thread in building mode?
  # ```ruby
  # proxy._building?
  # ```
  def _building?: () -> bool

  # Is the current thread in creating mode?
  #
  # _@return_ — If the thread is creating.
  #
  # Is the current thread in creating mode?
  # ```ruby
  # proxy.creating?
  # ```
  def _creating?: () -> bool

  # Execute a block in loading mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in loading mode.
  # ```ruby
  # _loading do
  #   relation.push(doc)
  # end
  # ```
  def _loading: () -> Object

  # Is the current thread in loading mode?
  #
  # _@return_ — If the thread is loading.
  #
  # Is the current thread in loading mode?
  # ```ruby
  # proxy._loading?
  # ```
  def _loading?: () -> bool
end

# The EmbeddedIn type association.
#
# @since 7.0
class Mongoid::Association::Mongoid::Association::Embedded::EmbeddedIn
  include Mongoid::Association::Relatable

  include Mongoid::Association::Embedded::EmbeddedIn::Buildable

  # Setup the instance methods, fields, etc. on the association owning class.
  def setup!: () -> self

  # Is this association type embedded?
  #
  # _@return_ — Always true.
  def embedded?: () -> bool

  # The primary key
  #
  # _@return_ — Not relevant for this association
  def primary_key: () -> nil

  # Does this association type store the foreign key?
  #
  # _@return_ — Always false.
  def stores_foreign_key?: () -> bool

  # The default for validating the association object.
  #
  # _@return_ — Always false.
  def validation_default: () -> bool

  # The key that is used to get the attributes for the associated object.
  #
  # _@return_ — The name of the association.
  def key: () -> String

  # Get the association proxy class for this association type.
  #
  # _@return_ — The proxy class.
  def relation: () -> Association::Embedded::EmbeddedIn::Proxy

  # Is this association polymorphic?
  #
  # _@return_ — Whether this association is polymorphic.
  def polymorphic?: () -> bool

  # The nested builder object.
  #
  # _@param_ `attributes` — The attributes to use to build the association object.
  #
  # _@param_ `options` — The options for the association.
  #
  # _@return_ — The Nested Builder object.
  def nested_builder: (::Hash[untyped, untyped] attributes, ::Hash[untyped, untyped] options) -> Association::Nested::One

  def setup_instance_methods!: () -> untyped

  def relation_complements: () -> untyped

  def polymorphic_inverses: (?untyped other) -> untyped

  def determine_inverses: (untyped other) -> untyped

  def build: (Object base, Object object, ?String? `type`, ?::Hash[untyped, untyped]? selected_fields) -> Document

  # Begin the assignment of attributes. While in this block embedded
  # documents will not autosave themselves in order to allow the document to
  # be in a valid state.
  #
  # _@return_ — The yielded value.
  #
  # Execute the assignment.
  # ```ruby
  # _assigning do
  #   person.attributes = { :addresses => [ address ] }
  # end
  # ```
  def _assigning: () -> Object

  # Is the current thread in assigning mode?
  #
  # _@return_ — If the thread is assigning.
  #
  # Is the current thread in assigning mode?
  # ```ruby
  # proxy._assigning?
  # ```
  def _assigning?: () -> bool

  # Execute a block in binding mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in binding mode.
  # ```ruby
  # binding do
  #   relation.push(doc)
  # end
  # ```
  def _binding: () -> Object

  # Is the current thread in binding mode?
  #
  # _@return_ — If the thread is binding.
  #
  # Is the current thread in binding mode?
  # ```ruby
  # proxy.binding?
  # ```
  def _binding?: () -> bool

  # Execute a block in building mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in building mode.
  # ```ruby
  # _building do
  #   relation.push(doc)
  # end
  # ```
  def _building: () -> Object

  # Is the current thread in building mode?
  #
  # _@return_ — If the thread is building.
  #
  # Is the current thread in building mode?
  # ```ruby
  # proxy._building?
  # ```
  def _building?: () -> bool

  # Is the current thread in creating mode?
  #
  # _@return_ — If the thread is creating.
  #
  # Is the current thread in creating mode?
  # ```ruby
  # proxy.creating?
  # ```
  def _creating?: () -> bool

  # Execute a block in loading mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in loading mode.
  # ```ruby
  # _loading do
  #   relation.push(doc)
  # end
  # ```
  def _loading: () -> Object

  # Is the current thread in loading mode?
  #
  # _@return_ — If the thread is loading.
  #
  # Is the current thread in loading mode?
  # ```ruby
  # proxy._loading?
  # ```
  def _loading?: () -> bool

  def initialize: (Class _class, Symbol name, ?::Hash[untyped, untyped] opts) { () -> untyped } -> void

  # Compare this association to another.
  #
  # _@return_ — The object to compare to this association.
  def ==: (untyped other) -> Object

  # Get the callbacks for a given type.
  #
  # _@param_ `callback_type` — The type of callback type.
  #
  # _@return_ — A list of the callbacks, either method
  # names or Procs.
  def get_callbacks: (Symbol callback_type) -> ::Array[Proc | Symbol]

  # Get the type setter.
  #
  # _@return_ — The type setter method.
  #
  # _@note_ — Only relevant for polymorphic associations that take the :as option.
  def type_setter: () -> String

  # Whether trying to bind an object using this association should raise
  # an error.
  #
  # _@param_ `doc` — The document to be bound.
  #
  # _@return_ — Whether the document can be bound.
  def bindable?: (Document doc) -> bool

  # Get the inverse names.
  #
  # _@param_ `other` — The other model class or model object to use when determining inverses.
  #
  # _@return_ — The list of inverse names.
  def inverses: (?Object? other) -> ::Array[Symbol]

  # Get the inverse's association metadata.
  #
  # _@param_ `other` — The other model class or model object to use when determining inverses.
  #
  # _@return_ — The inverse's association metadata.
  def inverse_association: (?Object? other) -> Association

  # Get the inverse type.
  #
  # _@return_ — Default is nil for an association.
  def inverse_type: () -> nil

  # The class name, possibly unqualified or :: prefixed, of the association
  # object(s).
  #
  # This method returns the class name as it is used in the association
  # definition. If :class_name option is given in the association, the
  # exact value of that option is returned here. If :class_name option is
  # not given, the name of the class is calculated from association name
  # but is not resolved to the actual class.
  #
  # The class name returned by this method may not correspond to a defined
  # class, either because the corresponding class has not been loaded yet,
  # or because the association references a non-existent class altogether.
  # To obtain the association class, use +relation_class+ method.
  #
  # _@return_ — The association objects' class name.
  #
  # _@note_ — The return value of this method should not be used to determine
  # whether two associations have the same target class, because the
  # return value is not always a fully qualified class name. To compare
  # classes, retrieve the class instance of the association target using
  # the +relation_class+ method.
  def relation_class_name: () -> String

  # The class of the association object(s).
  #
  # This method returns the class instance corresponding to
  # +relation_class_name+, resolved relative to the host document class.
  #
  # If the class does not exist, this method raises NameError. This can
  # happen because the target class has not yet been defined. Note that
  # polymorphic associations generally do not have a well defined target
  # class because the target class can change from one object to another,
  # and calling this method on a polymorphic association will generally
  # fail with a NameError or produce misleading results (if a class does
  # happen to be defined with the same name as the association name).
  #
  # _@return_ — The association objects' class.
  def relation_class: () -> String

  # The class name of the object owning this association.
  #
  # _@return_ — The owning objects' class name.
  def inverse_class_name: () -> String

  # The class of the object owning this association.
  #
  # _@return_ — The owning objects' class.
  def inverse_class: () -> String

  # The name of the setter on this object for assigning an associated object.
  #
  # _@return_ — The setter name.
  def setter: () -> String

  # The name of the inverse setter method.
  #
  # _@return_ — The name of the inverse setter.
  def inverse_setter: (?untyped other) -> String

  # The name of the foreign key setter method.
  #
  # _@return_ — The name of the foreign key setter.
  def foreign_key_setter: () -> String

  # The atomic path for this association.
  #
  # _@return_ — The atomic path object.
  def path: (untyped document) -> Mongoid::Atomic::Paths::Root

  # Gets the setter for the field that sets the type of document on a
  # polymorphic association.
  #
  # _@return_ — The name of the setter.
  #
  # Get the inverse type setter.
  # ```ruby
  # association.inverse_type_setter
  # ```
  def inverse_type_setter: () -> String

  # Get the name of the method to check if the foreign key has changed.
  #
  # _@return_ — The foreign key check.
  #
  # Get the foreign key check method.
  # ```ruby
  # association.foreign_key_check
  # ```
  def foreign_key_check: () -> String

  # Create an association proxy object using the owner and target.
  #
  # _@param_ `owner` — The document this association hangs off of.
  #
  # _@param_ `target` — The target (parent) of the association.
  def create_relation: (Document owner, Document | ::Array[Document] target) -> Proxy

  # Whether the dependent method is destructive.
  #
  # _@return_ — If the dependent method is destructive.
  def destructive?: () -> bool

  # Get the counter cache column name.
  #
  # _@return_ — The counter cache column name.
  def counter_cache_column_name: () -> String

  # Get the extension.
  #
  # _@return_ — The extension module, if one has been defined.
  def extension: () -> Module

  # Get the inverse name.
  #
  # _@return_ — The inverse name.
  def inverse: (?untyped other) -> Symbol

  # Whether the associated object(s) should be validated.
  #
  # _@return_ — If the associated object(s)
  # should be validated.
  def validate?: () -> bool

  # Gets the model classes with inverse associations of this model. This is used to determine
  # the classes on the other end of polymorphic associations with models.
  def inverse_association_classes: () -> untyped

  def setup_index!: () -> untyped

  def define_touchable!: () -> untyped

  def define_autosaver!: () -> untyped

  def define_builder!: () -> untyped

  def define_creator!: () -> untyped

  def define_getter!: () -> untyped

  def define_setter!: () -> untyped

  def define_existence_check!: () -> untyped

  def define_ids_getter!: () -> untyped

  def define_ids_setter!: () -> untyped

  def define_counter_cache_callbacks!: () -> untyped

  def define_dependency!: () -> untyped

  def validate!: () -> untyped

  def polymorph!: () -> untyped

  def create_extension!: () { () -> untyped } -> untyped

  def default_inverse: () -> untyped

  # Returns an array of classes/modules forming the namespace hierarchy
  # where symbols referenced in the provided class/module would be looked
  # up by Ruby. For example, if mod is Foo::Bar, this method would return
  # [Foo::Bar, Foo, Object].
  def namespace_hierarchy: (untyped mod) -> untyped

  # Resolves the given class/module name in the context of the specified
  # module, as Ruby would when a constant is referenced in the source.
  #
  # _@note_ — This method can swallow exceptions produced during class loading,
  # because it rescues NameError internally. Since this method attempts
  # to load classes, failure during the loading process may also lead to
  # there being incomplete class definitions.
  def resolve_name: (untyped mod, untyped name) -> untyped

  # Returns the name of the parent to a polymorphic child.
  #
  # _@return_ — The name.
  def as: () -> (String | Symbol)

  # Specify what happens to the associated object when the owner is destroyed.
  #
  # _@return_ — The dependent option.
  def dependent: () -> String

  # The custom sorting options on the association.
  #
  # _@return_ — The custom sorting options.
  def order: () -> Criteria::Queryable::Key

  # Whether to index the primary or foreign key field.
  def indexed?: () -> bool

  # Whether the association is autobuilding.
  def autobuilding?: () -> bool

  # Is the association cyclic.
  #
  # _@return_ — Whether the association is cyclic.
  def cyclic?: () -> bool

  # The name the owning object uses to refer to this association.
  #
  # _@return_ — The inverse_of option.
  def inverse_of: () -> String

  # Options to save any loaded members and destroy members that are marked for destruction
  # when the parent object is saved.
  #
  # _@return_ — The autosave option.
  def autosave: () -> bool

  # Whether the association is counter-cached.
  def counter_cached?: () -> bool

  # Whether the association has callbacks cascaded down from the parent.
  #
  # _@return_ — Whether callbacks are cascaded.
  def cascading_callbacks?: () -> bool

  # The store_as option.
  #
  # _@return_ — Default is nil.
  def store_as: () -> nil

  # Whether the association has forced nil inverse (So no foreign keys are saved).
  #
  # _@return_ — Default is false.
  def forced_nil_inverse?: () -> bool

  # The field for saving the associated object's type.
  #
  # _@return_ — Default is nil.
  def type: () -> nil

  # The field for saving the associated object's type.
  #
  # _@return_ — Default is nil.
  def touch_field: () -> nil

  def touchable?: () -> bool

  # Convert the supplied object to the appropriate type to set as the
  # foreign key for an association.
  #
  # _@param_ `object` — The object to convert.
  #
  # _@return_ — The object cast to the correct type.
  #
  # Convert the object.
  # ```ruby
  # constraint.convert("12345")
  # ```
  def convert_to_foreign_key: (Object object) -> Object

  def convert_polymorphic: (untyped object) -> untyped
end

Mongoid::Association::Mongoid::Association::Embedded::Mongoid::Association::Mongoid::Association::Embedded::EmbeddedIn::ASSOCIATION_OPTIONS: untyped

Mongoid::Association::Mongoid::Association::Embedded::Mongoid::Association::Mongoid::Association::Embedded::EmbeddedIn::VALID_OPTIONS: untyped

Mongoid::Association::Mongoid::Association::Embedded::Mongoid::Association::Mongoid::Association::Embedded::EmbeddedIn::SHARED_OPTIONS: untyped

Mongoid::Association::Mongoid::Association::Embedded::Mongoid::Association::Mongoid::Association::Embedded::EmbeddedIn::PRIMARY_KEY_DEFAULT: untyped

class Mongoid::Association::Mongoid::Association::Embedded::Mongoid::Association::Mongoid::Association::Embedded::EmbeddedIn::Proxy < Mongoid::Association::One
  # Instantiate a new embedded_in association.
  #
  # _@param_ `base` — The document the association hangs off of.
  #
  # _@param_ `target` — The target (parent) of the association.
  #
  # _@param_ `association` — The association metadata.
  #
  # _@return_ — The proxy.
  #
  # Create the new association.
  # ```ruby
  # Association::Embedded::EmbeddedIn.new(person, address, association)
  # ```
  def initialize: (Document base, Document target, Association association) -> void

  # Substitutes the supplied target documents for the existing document
  # in the association.
  #
  # _@param_ `replacement` — A document to replace the target.
  #
  # _@return_ — The association or nil.
  #
  # Substitute the new document.
  # ```ruby
  # person.name.substitute(new_name)
  # ```
  def substitute: (Document replacement) -> Document?

  # sord warn - Binding wasn't able to be resolved to a constant in this project
  # Instantiate the binding associated with this association.
  #
  # _@return_ — A binding object.
  #
  # Get the binding.
  # ```ruby
  # binding([ address ])
  # ```
  def binding: () -> Binding

  # Characterize the document.
  #
  # _@param_ `document` — The document to set the association metadata on.
  #
  # Set the base association.
  # ```ruby
  # object.characterize_one(document)
  # ```
  def characterize_one: (Document document) -> untyped

  # Are we able to persist this association?
  #
  # _@return_ — If the association is persistable.
  #
  # Can we persist the association?
  # ```ruby
  # relation.persistable?
  # ```
  def persistable?: () -> bool

  # Returns true if the association is an embedded one. In this case
  # always true.
  #
  # _@return_ — true.
  #
  # Is this association embedded?
  # ```ruby
  # Association::Embedded::EmbeddedIn.embedded?
  # ```
  def self.embedded?: () -> bool

  # sord infer - Root was resolved to Mongoid::Atomic::Paths::Root
  # Get the path calculator for the supplied document.
  #
  # _@param_ `document` — The document to calculate on.
  #
  # _@return_ — The root atomic path calculator.
  #
  # Get the path calculator.
  # ```ruby
  # Proxy.path(document)
  # ```
  def self.path: (Document document) -> Mongoid::Atomic::Paths::Root
end

# The Binding object for embedded_in associations.
#
# @since 7.0
class Mongoid::Association::Mongoid::Association::Embedded::Mongoid::Association::Mongoid::Association::Embedded::EmbeddedIn::Binding
  include Mongoid::Association::Bindable

  # Binds the base object to the inverse of the association. This is so we
  # are referenced to the actual objects themselves on both sides.
  #
  # This case sets the association metadata on the inverse object as well as the
  # document itself.
  #
  # Bind the documents.
  # ```ruby
  # name.person.bind(:continue => true)
  # name.person = Person.new
  # ```
  def bind_one: () -> untyped

  # Unbinds the base object and the inverse, caused by setting the
  # reference to nil.
  #
  # Unbind the document.
  # ```ruby
  # name.person.unbind(:continue => true)
  # name.person = nil
  # ```
  def unbind_one: () -> untyped

  # Create the new binding.
  #
  # _@param_ `base` — The base of the binding.
  #
  # _@param_ `target` — The target of the binding.
  #
  # _@param_ `association` — The association metadata.
  #
  # Initialize a binding.
  # ```ruby
  # Binding.new(base, target, association)
  # ```
  def initialize: (Document base, Document | ::Array[Document] target, Association association) -> void

  # Execute the provided block inside a binding.
  #
  # _@return_ — The result of the yield.
  #
  # Execute the binding block.
  # ```ruby
  # binding.binding do
  #   base.foreign_key = 1
  # end
  # ```
  def binding: () -> Object

  # Check if the inverse is properly defined.
  #
  # _@param_ `doc` — The document getting bound.
  #
  # Check the inverse definition.
  # ```ruby
  # binding.check_inverse!(doc)
  # ```
  def check_inverse!: (Document doc) -> untyped

  # Set the id of the related document in the foreign key field on the
  # keyed document.
  #
  # _@param_ `keyed` — The document that stores the foreign key.
  #
  # _@param_ `id` — The id of the bound document.
  #
  # Bind the foreign key.
  # ```ruby
  # binding.bind_foreign_key(post, person._id)
  # ```
  def bind_foreign_key: (Document keyed, Object id) -> untyped

  # Set the type of the related document on the foreign type field, used
  # when associations are polymorphic.
  #
  # _@param_ `typed` — The document that stores the type field.
  #
  # _@param_ `name` — The name of the model.
  #
  # Bind the polymorphic type.
  # ```ruby
  # binding.bind_polymorphic_type(post, "Person")
  # ```
  def bind_polymorphic_type: (Document typed, String name) -> untyped

  # Set the type of the related document on the foreign type field, used
  # when associations are polymorphic.
  #
  # _@param_ `typed` — The document that stores the type field.
  #
  # _@param_ `name` — The name of the model.
  #
  # Bind the polymorphic type.
  # ```ruby
  # binding.bind_polymorphic_inverse_type(post, "Person")
  # ```
  def bind_polymorphic_inverse_type: (Document typed, String name) -> untyped

  # Bind the inverse document to the child document so that the in memory
  # instances are the same.
  #
  # _@param_ `doc` — The base document.
  #
  # _@param_ `inverse` — The inverse document.
  #
  # Bind the inverse.
  # ```ruby
  # binding.bind_inverse(post, person)
  # ```
  def bind_inverse: (Document doc, Document inverse) -> untyped

  # Bind the provided document with the base from the parent association.
  #
  # _@param_ `doc` — The document to bind.
  #
  # Bind the document with the base.
  # ```ruby
  # binding.bind_from_relational_parent(doc)
  # ```
  def bind_from_relational_parent: (Document doc) -> untyped

  def record_id: (untyped _base) -> untyped

  # Ensure that the association on the base is correct, for the cases
  # where we have multiple belongs to definitions and were are setting
  # different parents in memory in order.
  #
  # _@return_ — If the association changed.
  #
  # Set the base association.
  # ```ruby
  # binding.set_base_association
  # ```
  def set_base_association: () -> bool

  # Bind the provided document with the base from the parent association.
  #
  # _@param_ `doc` — The document to unbind.
  #
  # Bind the document with the base.
  # ```ruby
  # unbinding.unbind_from_relational_parent(doc)
  # ```
  def unbind_from_relational_parent: (Document doc) -> untyped

  # Begin the assignment of attributes. While in this block embedded
  # documents will not autosave themselves in order to allow the document to
  # be in a valid state.
  #
  # _@return_ — The yielded value.
  #
  # Execute the assignment.
  # ```ruby
  # _assigning do
  #   person.attributes = { :addresses => [ address ] }
  # end
  # ```
  def _assigning: () -> Object

  # Is the current thread in assigning mode?
  #
  # _@return_ — If the thread is assigning.
  #
  # Is the current thread in assigning mode?
  # ```ruby
  # proxy._assigning?
  # ```
  def _assigning?: () -> bool

  # Execute a block in binding mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in binding mode.
  # ```ruby
  # binding do
  #   relation.push(doc)
  # end
  # ```
  def _binding: () -> Object

  # Is the current thread in binding mode?
  #
  # _@return_ — If the thread is binding.
  #
  # Is the current thread in binding mode?
  # ```ruby
  # proxy.binding?
  # ```
  def _binding?: () -> bool

  # Execute a block in building mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in building mode.
  # ```ruby
  # _building do
  #   relation.push(doc)
  # end
  # ```
  def _building: () -> Object

  # Is the current thread in building mode?
  #
  # _@return_ — If the thread is building.
  #
  # Is the current thread in building mode?
  # ```ruby
  # proxy._building?
  # ```
  def _building?: () -> bool

  # Is the current thread in creating mode?
  #
  # _@return_ — If the thread is creating.
  #
  # Is the current thread in creating mode?
  # ```ruby
  # proxy.creating?
  # ```
  def _creating?: () -> bool

  # Execute a block in loading mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in loading mode.
  # ```ruby
  # _loading do
  #   relation.push(doc)
  # end
  # ```
  def _loading: () -> Object

  # Is the current thread in loading mode?
  #
  # _@return_ — If the thread is loading.
  #
  # Is the current thread in loading mode?
  # ```ruby
  # proxy._loading?
  # ```
  def _loading?: () -> bool
end

# The Builder behavior for embedded_in associations.
#
# @since 7.0
module Mongoid::Association::Mongoid::Association::Embedded::Mongoid::Association::Mongoid::Association::Embedded::EmbeddedIn::Buildable
  include Mongoid::Threaded::Lifecycle

  def build: (Object base, Object object, ?String? `type`, ?::Hash[untyped, untyped]? selected_fields) -> Document

  # Begin the assignment of attributes. While in this block embedded
  # documents will not autosave themselves in order to allow the document to
  # be in a valid state.
  #
  # _@return_ — The yielded value.
  #
  # Execute the assignment.
  # ```ruby
  # _assigning do
  #   person.attributes = { :addresses => [ address ] }
  # end
  # ```
  def _assigning: () -> Object

  # Is the current thread in assigning mode?
  #
  # _@return_ — If the thread is assigning.
  #
  # Is the current thread in assigning mode?
  # ```ruby
  # proxy._assigning?
  # ```
  def _assigning?: () -> bool

  # Execute a block in binding mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in binding mode.
  # ```ruby
  # binding do
  #   relation.push(doc)
  # end
  # ```
  def _binding: () -> Object

  # Is the current thread in binding mode?
  #
  # _@return_ — If the thread is binding.
  #
  # Is the current thread in binding mode?
  # ```ruby
  # proxy.binding?
  # ```
  def _binding?: () -> bool

  # Execute a block in building mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in building mode.
  # ```ruby
  # _building do
  #   relation.push(doc)
  # end
  # ```
  def _building: () -> Object

  # Is the current thread in building mode?
  #
  # _@return_ — If the thread is building.
  #
  # Is the current thread in building mode?
  # ```ruby
  # proxy._building?
  # ```
  def _building?: () -> bool

  # Is the current thread in creating mode?
  #
  # _@return_ — If the thread is creating.
  #
  # Is the current thread in creating mode?
  # ```ruby
  # proxy.creating?
  # ```
  def _creating?: () -> bool

  # Execute a block in loading mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in loading mode.
  # ```ruby
  # _loading do
  #   relation.push(doc)
  # end
  # ```
  def _loading: () -> Object

  # Is the current thread in loading mode?
  #
  # _@return_ — If the thread is loading.
  #
  # Is the current thread in loading mode?
  # ```ruby
  # proxy._loading?
  # ```
  def _loading?: () -> bool
end

# The EmbedsMany type association.
#
# @since 7.0
class Mongoid::Association::Mongoid::Association::Embedded::EmbedsMany
  include Mongoid::Association::Relatable

  include Mongoid::Association::Embedded::EmbedsMany::Buildable

  # Setup the instance methods, fields, etc. on the association owning class.
  def setup!: () -> self

  # The field key used to store the list of association objects.
  #
  # _@return_ — The field name.
  def store_as: () -> String

  # The key that is used to get the attributes for the associated object.
  #
  # _@return_ — The name of the field used to store the association.
  def key: () -> String

  # Is this association type embedded?
  #
  # _@return_ — Always true.
  def embedded?: () -> bool

  # Get the default validation setting for the association. Determines if
  # by default a validates associated will occur.
  #
  # _@return_ — Always true.
  #
  # Get the validation default.
  # ```ruby
  # Proxy.validation_default
  # ```
  def validation_default: () -> bool

  # Does this association type store the foreign key?
  #
  # _@return_ — Always false.
  def stores_foreign_key?: () -> bool

  # The primary key
  #
  # _@return_ — Not relevant for this association
  def primary_key: () -> nil

  # Get the association proxy class for this association type.
  #
  # _@return_ — The proxy class.
  def relation: () -> Association::Embedded::EmbedsMany::Proxy

  # Is this association polymorphic?
  #
  # _@return_ — Whether this association is polymorphic.
  def polymorphic?: () -> bool

  # The field used to store the type of the related object.
  #
  # _@return_ — The field for storing the associated object's type.
  #
  # _@note_ — Only relevant if the association is polymorphic.
  def type: () -> String?

  # The nested builder object.
  #
  # _@param_ `attributes` — The attributes to use to build the association object.
  #
  # _@param_ `options` — The options for the association.
  #
  # _@return_ — The Nested Builder object.
  def nested_builder: (::Hash[untyped, untyped] attributes, ::Hash[untyped, untyped] options) -> Association::Nested::Many

  # Get the path calculator for the supplied document.
  #
  # _@param_ `document` — The document to calculate on.
  #
  # _@return_ — The embedded many atomic path calculator.
  #
  # Get the path calculator.
  # ```ruby
  # Proxy.path(document)
  # ```
  def path: (Document document) -> Mongoid::Atomic::Paths::Embedded::Many

  # Get a criteria object for searching given a parent and children documents.
  #
  # _@param_ `base` — The base document.
  #
  # _@param_ `target` — The children documents.
  def criteria: (Document base, Document target) -> untyped

  def apply_ordering: (untyped criteria) -> untyped

  def setup_instance_methods!: () -> untyped

  def relation_complements: () -> untyped

  def polymorphic_inverses: (?untyped other) -> untyped

  def determine_inverses: (untyped other) -> untyped

  def build: (Object base, Object object, ?String? `type`, ?::Hash[untyped, untyped]? selected_fields) -> ::Array[Document]

  # Begin the assignment of attributes. While in this block embedded
  # documents will not autosave themselves in order to allow the document to
  # be in a valid state.
  #
  # _@return_ — The yielded value.
  #
  # Execute the assignment.
  # ```ruby
  # _assigning do
  #   person.attributes = { :addresses => [ address ] }
  # end
  # ```
  def _assigning: () -> Object

  # Is the current thread in assigning mode?
  #
  # _@return_ — If the thread is assigning.
  #
  # Is the current thread in assigning mode?
  # ```ruby
  # proxy._assigning?
  # ```
  def _assigning?: () -> bool

  # Execute a block in binding mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in binding mode.
  # ```ruby
  # binding do
  #   relation.push(doc)
  # end
  # ```
  def _binding: () -> Object

  # Is the current thread in binding mode?
  #
  # _@return_ — If the thread is binding.
  #
  # Is the current thread in binding mode?
  # ```ruby
  # proxy.binding?
  # ```
  def _binding?: () -> bool

  # Execute a block in building mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in building mode.
  # ```ruby
  # _building do
  #   relation.push(doc)
  # end
  # ```
  def _building: () -> Object

  # Is the current thread in building mode?
  #
  # _@return_ — If the thread is building.
  #
  # Is the current thread in building mode?
  # ```ruby
  # proxy._building?
  # ```
  def _building?: () -> bool

  # Is the current thread in creating mode?
  #
  # _@return_ — If the thread is creating.
  #
  # Is the current thread in creating mode?
  # ```ruby
  # proxy.creating?
  # ```
  def _creating?: () -> bool

  # Execute a block in loading mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in loading mode.
  # ```ruby
  # _loading do
  #   relation.push(doc)
  # end
  # ```
  def _loading: () -> Object

  # Is the current thread in loading mode?
  #
  # _@return_ — If the thread is loading.
  #
  # Is the current thread in loading mode?
  # ```ruby
  # proxy._loading?
  # ```
  def _loading?: () -> bool

  def initialize: (Class _class, Symbol name, ?::Hash[untyped, untyped] opts) { () -> untyped } -> void

  # Compare this association to another.
  #
  # _@return_ — The object to compare to this association.
  def ==: (untyped other) -> Object

  # Get the callbacks for a given type.
  #
  # _@param_ `callback_type` — The type of callback type.
  #
  # _@return_ — A list of the callbacks, either method
  # names or Procs.
  def get_callbacks: (Symbol callback_type) -> ::Array[Proc | Symbol]

  # Get the type setter.
  #
  # _@return_ — The type setter method.
  #
  # _@note_ — Only relevant for polymorphic associations that take the :as option.
  def type_setter: () -> String

  # Whether trying to bind an object using this association should raise
  # an error.
  #
  # _@param_ `doc` — The document to be bound.
  #
  # _@return_ — Whether the document can be bound.
  def bindable?: (Document doc) -> bool

  # Get the inverse names.
  #
  # _@param_ `other` — The other model class or model object to use when determining inverses.
  #
  # _@return_ — The list of inverse names.
  def inverses: (?Object? other) -> ::Array[Symbol]

  # Get the inverse's association metadata.
  #
  # _@param_ `other` — The other model class or model object to use when determining inverses.
  #
  # _@return_ — The inverse's association metadata.
  def inverse_association: (?Object? other) -> Association

  # Get the inverse type.
  #
  # _@return_ — Default is nil for an association.
  def inverse_type: () -> nil

  # The class name, possibly unqualified or :: prefixed, of the association
  # object(s).
  #
  # This method returns the class name as it is used in the association
  # definition. If :class_name option is given in the association, the
  # exact value of that option is returned here. If :class_name option is
  # not given, the name of the class is calculated from association name
  # but is not resolved to the actual class.
  #
  # The class name returned by this method may not correspond to a defined
  # class, either because the corresponding class has not been loaded yet,
  # or because the association references a non-existent class altogether.
  # To obtain the association class, use +relation_class+ method.
  #
  # _@return_ — The association objects' class name.
  #
  # _@note_ — The return value of this method should not be used to determine
  # whether two associations have the same target class, because the
  # return value is not always a fully qualified class name. To compare
  # classes, retrieve the class instance of the association target using
  # the +relation_class+ method.
  def relation_class_name: () -> String

  # The class of the association object(s).
  #
  # This method returns the class instance corresponding to
  # +relation_class_name+, resolved relative to the host document class.
  #
  # If the class does not exist, this method raises NameError. This can
  # happen because the target class has not yet been defined. Note that
  # polymorphic associations generally do not have a well defined target
  # class because the target class can change from one object to another,
  # and calling this method on a polymorphic association will generally
  # fail with a NameError or produce misleading results (if a class does
  # happen to be defined with the same name as the association name).
  #
  # _@return_ — The association objects' class.
  def relation_class: () -> String

  # The class name of the object owning this association.
  #
  # _@return_ — The owning objects' class name.
  def inverse_class_name: () -> String

  # The class of the object owning this association.
  #
  # _@return_ — The owning objects' class.
  def inverse_class: () -> String

  # The name of the setter on this object for assigning an associated object.
  #
  # _@return_ — The setter name.
  def setter: () -> String

  # The name of the inverse setter method.
  #
  # _@return_ — The name of the inverse setter.
  def inverse_setter: (?untyped other) -> String

  # The name of the foreign key setter method.
  #
  # _@return_ — The name of the foreign key setter.
  def foreign_key_setter: () -> String

  # Gets the setter for the field that sets the type of document on a
  # polymorphic association.
  #
  # _@return_ — The name of the setter.
  #
  # Get the inverse type setter.
  # ```ruby
  # association.inverse_type_setter
  # ```
  def inverse_type_setter: () -> String

  # Get the name of the method to check if the foreign key has changed.
  #
  # _@return_ — The foreign key check.
  #
  # Get the foreign key check method.
  # ```ruby
  # association.foreign_key_check
  # ```
  def foreign_key_check: () -> String

  # Create an association proxy object using the owner and target.
  #
  # _@param_ `owner` — The document this association hangs off of.
  #
  # _@param_ `target` — The target (parent) of the association.
  def create_relation: (Document owner, Document | ::Array[Document] target) -> Proxy

  # Whether the dependent method is destructive.
  #
  # _@return_ — If the dependent method is destructive.
  def destructive?: () -> bool

  # Get the counter cache column name.
  #
  # _@return_ — The counter cache column name.
  def counter_cache_column_name: () -> String

  # Get the extension.
  #
  # _@return_ — The extension module, if one has been defined.
  def extension: () -> Module

  # Get the inverse name.
  #
  # _@return_ — The inverse name.
  def inverse: (?untyped other) -> Symbol

  # Whether the associated object(s) should be validated.
  #
  # _@return_ — If the associated object(s)
  # should be validated.
  def validate?: () -> bool

  # Gets the model classes with inverse associations of this model. This is used to determine
  # the classes on the other end of polymorphic associations with models.
  def inverse_association_classes: () -> untyped

  def setup_index!: () -> untyped

  def define_touchable!: () -> untyped

  def define_autosaver!: () -> untyped

  def define_builder!: () -> untyped

  def define_creator!: () -> untyped

  def define_getter!: () -> untyped

  def define_setter!: () -> untyped

  def define_existence_check!: () -> untyped

  def define_ids_getter!: () -> untyped

  def define_ids_setter!: () -> untyped

  def define_counter_cache_callbacks!: () -> untyped

  def define_dependency!: () -> untyped

  def validate!: () -> untyped

  def polymorph!: () -> untyped

  def create_extension!: () { () -> untyped } -> untyped

  def default_inverse: () -> untyped

  # Returns an array of classes/modules forming the namespace hierarchy
  # where symbols referenced in the provided class/module would be looked
  # up by Ruby. For example, if mod is Foo::Bar, this method would return
  # [Foo::Bar, Foo, Object].
  def namespace_hierarchy: (untyped mod) -> untyped

  # Resolves the given class/module name in the context of the specified
  # module, as Ruby would when a constant is referenced in the source.
  #
  # _@note_ — This method can swallow exceptions produced during class loading,
  # because it rescues NameError internally. Since this method attempts
  # to load classes, failure during the loading process may also lead to
  # there being incomplete class definitions.
  def resolve_name: (untyped mod, untyped name) -> untyped

  # Returns the name of the parent to a polymorphic child.
  #
  # _@return_ — The name.
  def as: () -> (String | Symbol)

  # Specify what happens to the associated object when the owner is destroyed.
  #
  # _@return_ — The dependent option.
  def dependent: () -> String

  # The custom sorting options on the association.
  #
  # _@return_ — The custom sorting options.
  def order: () -> Criteria::Queryable::Key

  # Whether to index the primary or foreign key field.
  def indexed?: () -> bool

  # Whether the association is autobuilding.
  def autobuilding?: () -> bool

  # Is the association cyclic.
  #
  # _@return_ — Whether the association is cyclic.
  def cyclic?: () -> bool

  # The name the owning object uses to refer to this association.
  #
  # _@return_ — The inverse_of option.
  def inverse_of: () -> String

  # Options to save any loaded members and destroy members that are marked for destruction
  # when the parent object is saved.
  #
  # _@return_ — The autosave option.
  def autosave: () -> bool

  # Whether the association is counter-cached.
  def counter_cached?: () -> bool

  # Whether the association has callbacks cascaded down from the parent.
  #
  # _@return_ — Whether callbacks are cascaded.
  def cascading_callbacks?: () -> bool

  # Whether the association has forced nil inverse (So no foreign keys are saved).
  #
  # _@return_ — Default is false.
  def forced_nil_inverse?: () -> bool

  # The field for saving the associated object's type.
  #
  # _@return_ — Default is nil.
  def touch_field: () -> nil

  def touchable?: () -> bool

  # Convert the supplied object to the appropriate type to set as the
  # foreign key for an association.
  #
  # _@param_ `object` — The object to convert.
  #
  # _@return_ — The object cast to the correct type.
  #
  # Convert the object.
  # ```ruby
  # constraint.convert("12345")
  # ```
  def convert_to_foreign_key: (Object object) -> Object

  def convert_polymorphic: (untyped object) -> untyped
end

Mongoid::Association::Mongoid::Association::Embedded::Mongoid::Association::Mongoid::Association::Embedded::EmbedsMany::ASSOCIATION_OPTIONS: untyped

Mongoid::Association::Mongoid::Association::Embedded::Mongoid::Association::Mongoid::Association::Embedded::EmbedsMany::VALID_OPTIONS: untyped

Mongoid::Association::Mongoid::Association::Embedded::Mongoid::Association::Mongoid::Association::Embedded::EmbedsMany::SHARED_OPTIONS: untyped

Mongoid::Association::Mongoid::Association::Embedded::Mongoid::Association::Mongoid::Association::Embedded::EmbedsMany::PRIMARY_KEY_DEFAULT: untyped

class Mongoid::Association::Mongoid::Association::Embedded::Mongoid::Association::Mongoid::Association::Embedded::EmbedsMany::Proxy < Mongoid::Association::Many
  include Mongoid::Association::Embedded::Batchable

  # Appends a document or array of documents to the association. Will set
  # the parent and update the index in the process.
  #
  # _@param_ `args` — Any number of documents.
  #
  # Append a document.
  # ```ruby
  # person.addresses << address
  # ```
  #
  # Push a document.
  # ```ruby
  # person.addresses.push(address)
  # ```
  def <<: (*Document | ::Array[Document] args) -> untyped

  # Get this association as as its representation in the database.
  #
  # _@return_ — The association as stored in the db.
  #
  # Convert the association to an attributes hash.
  # ```ruby
  # person.addresses.as_document
  # ```
  def as_document: () -> ::Array[::Hash[untyped, untyped]]

  # Appends an array of documents to the association. Performs a batch
  # insert of the documents instead of persisting one at a time.
  #
  # _@param_ `docs` — The docs to add.
  #
  # _@return_ — The documents.
  #
  # Concat with other documents.
  # ```ruby
  # person.addresses.concat([ address_one, address_two ])
  # ```
  def concat: (::Array[Document] docs) -> ::Array[Document]

  # Builds a new document in the association and appends it to the target.
  # Takes an optional type if you want to specify a subclass.
  #
  # _@param_ `attributes` — The attributes to build the document with.
  #
  # _@param_ `type` — Optional class to build the document with.
  #
  # _@return_ — The new document.
  #
  # Build a new document on the association.
  # ```ruby
  # person.people.build(:name => "Bozo")
  # ```
  def build: (?::Hash[untyped, untyped] attributes, ?Class? `type`) -> Document

  # Clear the association. Will delete the documents from the db if they are
  # already persisted.
  #
  # _@return_ — The empty association.
  #
  # Clear the association.
  # ```ruby
  # person.addresses.clear
  # ```
  def clear: () -> self

  # Returns a count of the number of documents in the association that have
  # actually been persisted to the database.
  #
  # Use #size if you want the total number of documents.
  #
  # _@return_ — The total number of persisted embedded docs, as
  # flagged by the #persisted? method.
  #
  # Get the count of persisted documents.
  # ```ruby
  # person.addresses.count
  # ```
  def count: () -> Integer

  # Delete the supplied document from the target. This method is proxied
  # in order to reindex the array after the operation occurs.
  #
  # _@param_ `document` — The document to be deleted.
  #
  # _@return_ — The deleted document or nil if nothing deleted.
  #
  # Delete the document from the association.
  # ```ruby
  # person.addresses.delete(address)
  # ```
  def delete: (Document document) -> Document?

  # Delete all the documents in the association without running callbacks.
  #
  # _@param_ `conditions` — Conditions on which documents to delete.
  #
  # _@return_ — The number of documents deleted.
  #
  # Delete all documents from the association.
  # ```ruby
  # person.addresses.delete_all
  # ```
  #
  # Conditionally delete documents from the association.
  # ```ruby
  # person.addresses.delete_all({ :street => "Bond" })
  # ```
  def delete_all: (?::Hash[untyped, untyped] conditions) -> Integer

  # Delete all the documents for which the provided block returns true.
  #
  # _@return_ — The association or an enumerator if no
  # block was provided.
  #
  # Delete the matching documents.
  # ```ruby
  # person.addresses.delete_if do |doc|
  #   doc.state == "GA"
  # end
  # ```
  def delete_if: () -> (Many | ::Enumerator[untyped])

  # Destroy all the documents in the association whilst running callbacks.
  #
  # _@param_ `conditions` — Conditions on which documents to destroy.
  #
  # _@return_ — The number of documents destroyed.
  #
  # Destroy all documents from the association.
  # ```ruby
  # person.addresses.destroy_all
  # ```
  #
  # Conditionally destroy documents from the association.
  # ```ruby
  # person.addresses.destroy_all({ :street => "Bond" })
  # ```
  def destroy_all: (?::Hash[untyped, untyped] conditions) -> Integer

  # Determine if any documents in this association exist in the database.
  #
  # _@return_ — True is persisted documents exist, false if not.
  #
  # Are there persisted documents?
  # ```ruby
  # person.posts.exists?
  # ```
  def exists?: () -> bool

  # Finds a document in this association through several different
  # methods.
  #
  # _@param_ `args` — Various arguments.
  #
  # _@return_ — A single or multiple documents.
  #
  # Find a document by its id.
  # ```ruby
  # person.addresses.find(BSON::ObjectId.new)
  # ```
  #
  # Find documents for multiple ids.
  # ```ruby
  # person.addresses.find([ BSON::ObjectId.new, BSON::ObjectId.new ])
  # ```
  def find: (*::Array[Object] args) -> (::Array[Document] | Document)

  # Instantiate a new embeds_many association.
  #
  # _@param_ `base` — The document this association hangs off of.
  #
  # _@param_ `target` — The child documents of the association.
  #
  # _@param_ `association` — The association metadata
  #
  # _@return_ — The proxy.
  #
  # Create the new association.
  # ```ruby
  # Many.new(person, addresses, association)
  # ```
  def initialize: (Document base, ::Array[Document] target, Association association) -> void

  # Get all the documents in the association that are loaded into memory.
  #
  # _@return_ — The documents in memory.
  #
  # Get the in memory documents.
  # ```ruby
  # relation.in_memory
  # ```
  def in_memory: () -> ::Array[Document]

  # Pop documents off the association. This can be a single document or
  # multiples, and will automatically persist the changes.
  #
  # _@param_ `count` — The number of documents to pop, or 1 if not provided.
  #
  # _@return_ — The popped document(s).
  #
  # Pop a single document.
  # ```ruby
  # relation.pop
  # ```
  #
  # Pop multiple documents.
  # ```ruby
  # relation.pop(3)
  # ```
  def pop: (?Integer? count) -> (Document | ::Array[Document])

  # Shift documents off the association. This can be a single document or
  # multiples, and will automatically persist the changes.
  #
  # _@param_ `count` — The number of documents to shift, or 1 if not provided.
  #
  # _@return_ — The shifted document(s).
  #
  # Shift a single document.
  # ```ruby
  # relation.shift
  # ```
  #
  # Shift multiple documents.
  # ```ruby
  # relation.shift(3)
  # ```
  def shift: (?Integer? count) -> (Document | ::Array[Document])

  # Substitutes the supplied target documents for the existing documents
  # in the relation.
  #
  # _@param_ `docs` — The replacement docs.
  #
  # _@return_ — The proxied association.
  #
  # Substitute the association's target.
  # ```ruby
  # person.addresses.substitute([ address ])
  # ```
  def substitute: (::Array[Document] docs) -> Many

  # Return the association with all previous scoping removed. This is the
  # exact representation of the docs in the database.
  #
  # _@return_ — The unscoped association.
  #
  # Get the unscoped documents.
  # ```ruby
  # person.addresses.unscoped
  # ```
  def unscoped: () -> Criteria

  def object_already_related?: (untyped document) -> bool

  # Appends the document to the target array, updating the index on the
  # document at the same time.
  #
  # _@param_ `document` — The document to append to the target.
  #
  # Append to the document.
  # ```ruby
  # relation.append(document)
  # ```
  def append: (Document document) -> untyped

  # sord warn - Binding wasn't able to be resolved to a constant in this project
  # Instantiate the binding associated with this association.
  #
  # _@return_ — The many binding.
  #
  # Create the binding.
  # ```ruby
  # relation.binding([ address ])
  # ```
  def binding: () -> Binding

  # Returns the +Criteria+ object for the target class with its
  # documents set to the list of target documents in the association.
  #
  # _@return_ — A new criteria.
  def criteria: () -> Criteria

  # Deletes one document from the target and unscoped.
  #
  # _@param_ `document` — The document to delete.
  #
  # Delete one document.
  # ```ruby
  # relation.delete_one(doc)
  # ```
  def delete_one: (Document document) -> untyped

  # Integrate the document into the association. will set its metadata and
  # attempt to bind the inverse.
  #
  # _@param_ `document` — The document to integrate.
  #
  # Integrate the document.
  # ```ruby
  # relation.integrate(document)
  # ```
  def integrate: (Document document) -> untyped

  # If the target array does not respond to the supplied method then try to
  # find a named scope or criteria on the class and send the call there.
  #
  # If the method exists on the array, use the default proxy behavior.
  #
  # _@param_ `name` — The name of the method.
  #
  # _@param_ `args` — The method args
  #
  # _@param_ `block` — Optional block to pass.
  #
  # _@return_ — A Criteria or return value from the target.
  def method_missing: (Symbol | String name, *::Array[untyped] args) { () -> untyped } -> (Criteria | Object)

  # Are we able to persist this association?
  #
  # _@return_ — If the association is persistable.
  #
  # Can we persist the association?
  # ```ruby
  # relation.persistable?
  # ```
  def persistable?: () -> bool

  # Reindex all the target elements. This is useful when performing
  # operations on the proxied target directly and the indices need to
  # match that on the database side.
  #
  # Reindex the association.
  # ```ruby
  # person.addresses.reindex
  # ```
  def reindex: () -> untyped

  # Apply the association ordering and default scoping (defined on
  # association's target class) to the provided documents.
  #
  # _@param_ `docs` — The documents to scope.
  #
  # _@return_ — The scoped docs.
  #
  # Apply scoping.
  # ```ruby
  # person.addresses.scope(target)
  # ```
  def scope: (::Array[Document] docs) -> ::Array[Document]

  # Remove all documents from the association, either with a delete or a
  # destroy depending on what this was called through.
  #
  # _@param_ `conditions` — Conditions to filter by.
  #
  # _@param_ `method` — :delete or :destroy.
  #
  # _@return_ — The number of documents removed.
  #
  # Destroy documents from the association.
  # ```ruby
  # relation.remove_all({ :num => 1 }, true)
  # ```
  def remove_all: (?::Hash[untyped, untyped] conditions, ?bool method) -> Integer

  # Get the internal unscoped documents.
  #
  # _@return_ — The unscoped documents.
  #
  # Get the unscoped documents.
  # ```ruby
  # relation._unscoped
  # ```
  def _unscoped: () -> ::Array[Document]

  # Set the internal unscoped documents.
  #
  # _@param_ `docs` — The documents.
  #
  # _@return_ — The unscoped docs.
  #
  # Set the unscoped documents.
  # ```ruby
  # relation._unscoped = docs
  # ```
  def _unscoped=: (::Array[Document] docs) -> ::Array[Document]

  def as_attributes: () -> untyped

  # Returns true if the association is an embedded one. In this case
  # always true.
  #
  # _@return_ — true.
  #
  # Is the association embedded?
  # ```ruby
  # Association::Embedded::EmbedsMany.embedded?
  # ```
  def self.embedded?: () -> bool

  # Returns the suffix of the foreign key field, either "_id" or "_ids".
  #
  # _@return_ — nil.
  #
  # Get the suffix for the foreign key.
  # ```ruby
  # Association::Embedded::EmbedsMany.foreign_key_suffix
  # ```
  def self.foreign_key_suffix: () -> nil

  # Insert new documents as a batch push ($push with $each). This ensures that
  # all callbacks are run at the appropriate time and only 1 request is
  # made to the database.
  #
  # _@param_ `docs` — The docs to add.
  #
  # _@return_ — The inserts.
  #
  # Execute the batch push.
  # ```ruby
  # batchable.batch_insert([ doc_one, doc_two ])
  # ```
  def batch_insert: (::Array[Document] docs) -> ::Array[::Hash[untyped, untyped]]

  # Clear all of the docs out of the association in a single swipe.
  #
  # _@param_ `docs` — The docs to clear.
  #
  # _@return_ — The empty array.
  #
  # Clear all docs.
  # ```ruby
  # batchable.batch_clear(docs)
  # ```
  def batch_clear: (::Array[Document] docs) -> ::Array[untyped]

  # Batch remove the provided documents as a $pullAll.
  #
  # _@param_ `docs` — The docs to remove.
  #
  # _@param_ `method` — Delete or destroy.
  #
  # Batch remove the documents.
  # ```ruby
  # batchable.batch_remove([ doc_one, doc_two ])
  # ```
  def batch_remove: (::Array[Document] docs, ?Symbol method) -> untyped

  # Batch replace the provided documents as a $set.
  #
  # _@param_ `docs` — The docs to replace with.
  #
  # _@return_ — The inserts.
  #
  # Batch replace the documents.
  # ```ruby
  # batchable.batch_replace([ doc_one, doc_two ])
  # ```
  def batch_replace: (::Array[Document] docs) -> ::Array[::Hash[untyped, untyped]]

  # Add the atomic sets to the base document.
  #
  # _@param_ `sets` — The atomic sets.
  #
  # Add the atomic sets.
  # ```ruby
  # batchable.add_atomic_sets([{ field: value }])
  # ```
  def add_atomic_sets: (::Array[::Hash[untyped, untyped]] sets) -> untyped

  # Perform a batch persist of the provided documents with a $set.
  #
  # _@param_ `docs` — The docs to persist.
  #
  # _@return_ — The inserts.
  #
  # Perform a batch $set.
  # ```ruby
  # batchable.execute_batch_set(docs)
  # ```
  def execute_batch_set: (::Array[Document] docs) -> ::Array[::Hash[untyped, untyped]]

  # Perform a batch persist of the provided documents with $push and $each.
  #
  # _@param_ `docs` — The docs to persist.
  #
  # _@return_ — The inserts.
  #
  # Perform a batch push.
  # ```ruby
  # batchable.execute_batch_push(docs)
  # ```
  def execute_batch_push: (::Array[Document] docs) -> ::Array[::Hash[untyped, untyped]]

  # Are we in a state to be able to batch insert?
  #
  # _@return_ — If inserts can be performed.
  #
  # Can inserts be performed?
  # ```ruby
  # batchable.insertable?
  # ```
  def insertable?: () -> bool

  # Are the inserts currently valid?
  #
  # _@return_ — If inserts are currently valid.
  #
  # Are the inserts currently valid.
  # ```ruby
  # batchable.inserts_valid
  # ```
  def inserts_valid: () -> bool

  # Set the inserts valid flag.
  #
  # _@param_ `value` — The flag.
  #
  # _@return_ — The flag.
  #
  # Set the flag.
  # ```ruby
  # batchable.inserts_valid = true
  # ```
  def inserts_valid=: (bool value) -> bool

  # Normalize the documents, in case they were provided as an array of
  # hashes.
  #
  # _@param_ `docs` — The docs to normalize.
  #
  # _@return_ — The docs.
  #
  # Normalize the docs.
  # ```ruby
  # batchable.normalize_docs(docs)
  # ```
  def normalize_docs: (::Array[::Hash[untyped, untyped] | Document] docs) -> ::Array[Document]

  # Get the atomic path.
  #
  # _@return_ — The atomic path.
  #
  # Get the atomic path.
  # ```ruby
  # batchable.path
  # ```
  def path: () -> String

  # Set the atomic path.
  #
  # _@param_ `value` — The path.
  #
  # _@return_ — The path.
  #
  # Set the atomic path.
  # ```ruby
  # batchable.path = "addresses"
  # ```
  def path=: (String value) -> String

  # Get the selector for executing atomic operations on the collection.
  #
  # _@return_ — The atomic selector.
  #
  # Get the selector.
  # ```ruby
  # batchable.selector
  # ```
  def selector: () -> ::Hash[untyped, untyped]

  # Pre processes the batch insert for the provided documents.
  #
  # _@param_ `docs` — The documents.
  #
  # _@return_ — The documents as an array of hashes.
  #
  # Pre process the documents.
  # ```ruby
  # batchable.pre_process_batch_insert(docs)
  # ```
  def pre_process_batch_insert: (::Array[Document] docs) -> ::Array[::Hash[untyped, untyped]]

  # Pre process the batch removal.
  #
  # _@param_ `docs` — The documents.
  #
  # _@param_ `method` — Delete or destroy.
  #
  # _@return_ — The documents as hashes.
  #
  # Pre process the documents.
  # ```ruby
  # batchable.pre_process_batch_remove(docs, :delete)
  # ```
  def pre_process_batch_remove: (::Array[Document] docs, Symbol method) -> ::Array[::Hash[untyped, untyped]]

  # sord warn - Documents wasn't able to be resolved to a constant in this project
  # Post process the documents after batch insert.
  #
  # _@param_ `docs` — The inserted docs.
  #
  # _@return_ — The document enum.
  #
  # Post process the documents.
  # ```ruby
  # batchable.post_process_batch_insert(docs)
  # ```
  def post_process_batch_insert: (::Array[Document] docs) -> ::Enumerable[untyped]

  # Post process the batch removal.
  #
  # _@param_ `docs` — The documents.
  #
  # _@param_ `method` — Delete or destroy.
  #
  # _@return_ — The documents.
  #
  # Post process the documents.
  # ```ruby
  # batchable.post_process_batch_remove(docs, :delete)
  # ```
  def post_process_batch_remove: (::Array[Document] docs, Symbol method) -> ::Array[Document]

  # Takes the provided selector and atomic operations and replaces the
  # indexes of the embedded documents with the positional operator when
  # needed.
  #
  # _@param_ `selector` — The selector.
  #
  # _@param_ `operations` — The update operations.
  #
  # _@param_ `processed` — The processed update operations.
  #
  # _@return_ — The new operations.
  #
  # Process the operations.
  # ```ruby
  # positionally(
  #   { "_id" => 1, "addresses._id" => 2 },
  #   { "$set" => { "addresses.0.street" => "hobrecht" }}
  # )
  # ```
  #
  # _@note_ — The only time we can accurately know when to use the positional
  # operator is at the exact time we are going to persist something. So
  # we can tell by the selector that we are sending if it is actually
  # possible to use the positional operator at all. For example, if the
  # selector is: { "_id" => 1 }, then we could not use the positional
  # operator for updating embedded documents since there would never be a
  # match - we base whether we can based on the number of levels deep the
  # selector goes, and if the id values are not nil.
  def positionally: (::Hash[untyped, untyped] selector, ::Hash[untyped, untyped] operations, ?::Hash[untyped, untyped] processed) -> ::Hash[untyped, untyped]

  def process_operations: (untyped keys, untyped operations, untyped processed) -> untyped

  def process_updates: (untyped keys, untyped update, ?untyped updates) -> untyped

  def replace_index: (untyped keys, untyped position) -> untyped
end

# Binding class for all embeds_many associations.
#
# @since 7.0
class Mongoid::Association::Mongoid::Association::Embedded::Mongoid::Association::Mongoid::Association::Embedded::EmbedsMany::Binding
  include Mongoid::Association::Bindable

  # Binds a single document with the inverse association. Used
  # specifically when appending to the proxy.
  #
  # _@param_ `doc` — The single document to bind.
  #
  # Bind one document.
  # ```ruby
  # person.addresses.bind_one(address)
  # ```
  def bind_one: (Document doc) -> untyped

  # Unbind a single document.
  #
  # _@param_ `doc` — The single document to unbind.
  #
  # Unbind the document.
  # ```ruby
  # person.addresses.unbind_one(document)
  # ```
  def unbind_one: (Document doc) -> untyped

  # Create the new binding.
  #
  # _@param_ `base` — The base of the binding.
  #
  # _@param_ `target` — The target of the binding.
  #
  # _@param_ `association` — The association metadata.
  #
  # Initialize a binding.
  # ```ruby
  # Binding.new(base, target, association)
  # ```
  def initialize: (Document base, Document | ::Array[Document] target, Association association) -> void

  # Execute the provided block inside a binding.
  #
  # _@return_ — The result of the yield.
  #
  # Execute the binding block.
  # ```ruby
  # binding.binding do
  #   base.foreign_key = 1
  # end
  # ```
  def binding: () -> Object

  # Check if the inverse is properly defined.
  #
  # _@param_ `doc` — The document getting bound.
  #
  # Check the inverse definition.
  # ```ruby
  # binding.check_inverse!(doc)
  # ```
  def check_inverse!: (Document doc) -> untyped

  # Set the id of the related document in the foreign key field on the
  # keyed document.
  #
  # _@param_ `keyed` — The document that stores the foreign key.
  #
  # _@param_ `id` — The id of the bound document.
  #
  # Bind the foreign key.
  # ```ruby
  # binding.bind_foreign_key(post, person._id)
  # ```
  def bind_foreign_key: (Document keyed, Object id) -> untyped

  # Set the type of the related document on the foreign type field, used
  # when associations are polymorphic.
  #
  # _@param_ `typed` — The document that stores the type field.
  #
  # _@param_ `name` — The name of the model.
  #
  # Bind the polymorphic type.
  # ```ruby
  # binding.bind_polymorphic_type(post, "Person")
  # ```
  def bind_polymorphic_type: (Document typed, String name) -> untyped

  # Set the type of the related document on the foreign type field, used
  # when associations are polymorphic.
  #
  # _@param_ `typed` — The document that stores the type field.
  #
  # _@param_ `name` — The name of the model.
  #
  # Bind the polymorphic type.
  # ```ruby
  # binding.bind_polymorphic_inverse_type(post, "Person")
  # ```
  def bind_polymorphic_inverse_type: (Document typed, String name) -> untyped

  # Bind the inverse document to the child document so that the in memory
  # instances are the same.
  #
  # _@param_ `doc` — The base document.
  #
  # _@param_ `inverse` — The inverse document.
  #
  # Bind the inverse.
  # ```ruby
  # binding.bind_inverse(post, person)
  # ```
  def bind_inverse: (Document doc, Document inverse) -> untyped

  # Bind the provided document with the base from the parent association.
  #
  # _@param_ `doc` — The document to bind.
  #
  # Bind the document with the base.
  # ```ruby
  # binding.bind_from_relational_parent(doc)
  # ```
  def bind_from_relational_parent: (Document doc) -> untyped

  def record_id: (untyped _base) -> untyped

  # Ensure that the association on the base is correct, for the cases
  # where we have multiple belongs to definitions and were are setting
  # different parents in memory in order.
  #
  # _@return_ — If the association changed.
  #
  # Set the base association.
  # ```ruby
  # binding.set_base_association
  # ```
  def set_base_association: () -> bool

  # Bind the provided document with the base from the parent association.
  #
  # _@param_ `doc` — The document to unbind.
  #
  # Bind the document with the base.
  # ```ruby
  # unbinding.unbind_from_relational_parent(doc)
  # ```
  def unbind_from_relational_parent: (Document doc) -> untyped

  # Begin the assignment of attributes. While in this block embedded
  # documents will not autosave themselves in order to allow the document to
  # be in a valid state.
  #
  # _@return_ — The yielded value.
  #
  # Execute the assignment.
  # ```ruby
  # _assigning do
  #   person.attributes = { :addresses => [ address ] }
  # end
  # ```
  def _assigning: () -> Object

  # Is the current thread in assigning mode?
  #
  # _@return_ — If the thread is assigning.
  #
  # Is the current thread in assigning mode?
  # ```ruby
  # proxy._assigning?
  # ```
  def _assigning?: () -> bool

  # Execute a block in binding mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in binding mode.
  # ```ruby
  # binding do
  #   relation.push(doc)
  # end
  # ```
  def _binding: () -> Object

  # Is the current thread in binding mode?
  #
  # _@return_ — If the thread is binding.
  #
  # Is the current thread in binding mode?
  # ```ruby
  # proxy.binding?
  # ```
  def _binding?: () -> bool

  # Execute a block in building mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in building mode.
  # ```ruby
  # _building do
  #   relation.push(doc)
  # end
  # ```
  def _building: () -> Object

  # Is the current thread in building mode?
  #
  # _@return_ — If the thread is building.
  #
  # Is the current thread in building mode?
  # ```ruby
  # proxy._building?
  # ```
  def _building?: () -> bool

  # Is the current thread in creating mode?
  #
  # _@return_ — If the thread is creating.
  #
  # Is the current thread in creating mode?
  # ```ruby
  # proxy.creating?
  # ```
  def _creating?: () -> bool

  # Execute a block in loading mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in loading mode.
  # ```ruby
  # _loading do
  #   relation.push(doc)
  # end
  # ```
  def _loading: () -> Object

  # Is the current thread in loading mode?
  #
  # _@return_ — If the thread is loading.
  #
  # Is the current thread in loading mode?
  # ```ruby
  # proxy._loading?
  # ```
  def _loading?: () -> bool
end

# Builder class for embeds_many associations.
#
# @since 7.0
module Mongoid::Association::Mongoid::Association::Embedded::Mongoid::Association::Mongoid::Association::Embedded::EmbedsMany::Buildable
  include Mongoid::Threaded::Lifecycle

  def build: (Object base, Object object, ?String? `type`, ?::Hash[untyped, untyped]? selected_fields) -> ::Array[Document]

  # Begin the assignment of attributes. While in this block embedded
  # documents will not autosave themselves in order to allow the document to
  # be in a valid state.
  #
  # _@return_ — The yielded value.
  #
  # Execute the assignment.
  # ```ruby
  # _assigning do
  #   person.attributes = { :addresses => [ address ] }
  # end
  # ```
  def _assigning: () -> Object

  # Is the current thread in assigning mode?
  #
  # _@return_ — If the thread is assigning.
  #
  # Is the current thread in assigning mode?
  # ```ruby
  # proxy._assigning?
  # ```
  def _assigning?: () -> bool

  # Execute a block in binding mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in binding mode.
  # ```ruby
  # binding do
  #   relation.push(doc)
  # end
  # ```
  def _binding: () -> Object

  # Is the current thread in binding mode?
  #
  # _@return_ — If the thread is binding.
  #
  # Is the current thread in binding mode?
  # ```ruby
  # proxy.binding?
  # ```
  def _binding?: () -> bool

  # Execute a block in building mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in building mode.
  # ```ruby
  # _building do
  #   relation.push(doc)
  # end
  # ```
  def _building: () -> Object

  # Is the current thread in building mode?
  #
  # _@return_ — If the thread is building.
  #
  # Is the current thread in building mode?
  # ```ruby
  # proxy._building?
  # ```
  def _building?: () -> bool

  # Is the current thread in creating mode?
  #
  # _@return_ — If the thread is creating.
  #
  # Is the current thread in creating mode?
  # ```ruby
  # proxy.creating?
  # ```
  def _creating?: () -> bool

  # Execute a block in loading mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in loading mode.
  # ```ruby
  # _loading do
  #   relation.push(doc)
  # end
  # ```
  def _loading: () -> Object

  # Is the current thread in loading mode?
  #
  # _@return_ — If the thread is loading.
  #
  # Is the current thread in loading mode?
  # ```ruby
  # proxy._loading?
  # ```
  def _loading?: () -> bool
end

module Mongoid::Association::Referenced
end

module Mongoid::Association::Mongoid::Association::Referenced::Eager
end

# Base class for eager load preload functions.
#
# @since 4.0.0
class Mongoid::Association::Mongoid::Association::Referenced::Mongoid::Association::Mongoid::Association::Referenced::Eager::Base
  # Instantiate the eager load class.
  #
  # _@param_ `associations` — Associations to eager load
  #
  # _@param_ `docs` — Documents to preload the associations
  #
  # _@return_ — The eager load preloader
  #
  # Create the new belongs to eager load preloader.
  # ```ruby
  # BelongsTo.new(association, parent_docs)
  # ```
  def initialize: (::Array[Association] associations, ::Array[Document] docs) -> void

  # Run the preloader.
  #
  # _@return_ — The list of documents given.
  #
  # Preload the associations into the documents.
  # ```ruby
  # loader.run
  # ```
  def run: () -> ::Array[untyped]

  # Preload the current association.
  #
  # This method should be implemented in the subclass
  #
  # Preload the current association into the documents.
  # ```ruby
  # loader.preload
  # ```
  def preload: () -> untyped

  # Retrieves the documents referenced by the association, and
  # yields each one sequentially to the provided block. If the
  # association is not polymorphic, all documents are retrieved in
  # a single query. If the association is polymorphic, one query is
  # issued per association target class.
  def each_loaded_document: () { () -> untyped } -> untyped

  # Retrieves the documents of the specified class, that have the
  # foreign key included in the specified list of keys.
  #
  # When the documents are retrieved, the set of inclusions applied
  # is the set of inclusions applied to the host document minus the
  # association that is being eagerly loaded.
  def each_loaded_document_of_class: (untyped cls, untyped keys) -> untyped

  # sord infer - ObjectId was resolved to BSON::ObjectId
  # Set the pre-loaded document into its parent.
  #
  # _@param_ `id` — parent`s id
  #
  # _@param_ `element` — to push into the parent
  #
  # Set docs into parent with pk = "foo"
  # ```ruby
  # loader.set_on_parent("foo", docs)
  # ```
  def set_on_parent: (BSON::ObjectId id, Document | ::Array[untyped] element) -> untyped

  # Return a hash with the current documents grouped by key.
  #
  # Documents that do not have a value for the association being loaded
  # are not returned.
  #
  # _@return_ — hash with grouped documents.
  #
  # Return a hash with the current documents grouped by key.
  # ```ruby
  # loader.grouped_docs
  # ```
  def grouped_docs: () -> ::Hash[untyped, untyped]

  # Group the documents and return the keys.
  #
  # This method omits nil keys (i.e. keys from documents that do not
  # have a value for the association being loaded).
  #
  # _@return_ — keys, ids
  #
  # ```ruby
  # loader.keys_from_docs
  # ```
  def keys_from_docs: () -> ::Array[untyped]

  # Return the key to group the current documents.
  #
  # This method should be implemented in the subclass
  #
  # _@return_ — Key to group by the current documents.
  #
  # Return the key for group
  # ```ruby
  # loader.group_by_key
  # ```
  def group_by_key: () -> Symbol

  # Set the pre-loaded document into its parent.
  #
  # _@param_ `doc` — The object to set the association on
  #
  # _@param_ `element` — to set into the parent
  #
  # Set docs into parent using the current association name.
  # ```ruby
  # loader.set_relation(doc, docs)
  # ```
  def set_relation: (Document doc, Document | ::Array[untyped] element) -> untyped

  # Shift the current association metadata
  #
  # _@return_ — The association object.
  #
  # Shift the current association.
  # ```ruby
  # loader.shift_association
  # ```
  def shift_association: () -> Association
end

# The has_one association.
#
# @since 7.0
class Mongoid::Association::Mongoid::Association::Referenced::HasOne
  include Mongoid::Association::Relatable

  include Mongoid::Association::Referenced::HasOne::Buildable

  # The list of association complements.
  #
  # _@return_ — The association complements.
  def relation_complements: () -> ::Array[Association]

  # Setup the instance methods, fields, etc. on the association owning class.
  def setup!: () -> self

  # Get the foreign key field for saving the association reference.
  #
  # _@return_ — The foreign key field for saving the
  # association reference.
  def foreign_key: () -> String

  # Is this association type embedded?
  #
  # _@return_ — Always false.
  def embedded?: () -> bool

  # The default for validation the association object.
  #
  # _@return_ — Always true.
  def validation_default: () -> bool

  # sord warn - Association::HasOne::Proxy wasn't able to be resolved to a constant in this project
  # Get the association proxy class for this association type.
  #
  # _@return_ — The proxy class.
  def relation: () -> Mongoid::Association::Referenced::HasOne::Proxy

  # The nested builder object.
  #
  # _@param_ `attributes` — The attributes to use to build the association object.
  #
  # _@param_ `options` — The options for the association.
  #
  # _@return_ — The Nested Builder object.
  def nested_builder: (::Hash[untyped, untyped] attributes, ::Hash[untyped, untyped] options) -> Association::Nested::Many

  # Is this association polymorphic?
  #
  # _@return_ — Whether this association is polymorphic.
  def polymorphic?: () -> bool

  # The type of this association if it's polymorphic.
  #
  # _@return_ — The type field.
  #
  # _@note_ — Only relevant for polymorphic associations.
  def type: () -> String?

  # Whether trying to bind an object using this association should raise
  # an error.
  #
  # _@param_ `doc` — The document to be bound.
  #
  # _@return_ — Whether the document can be bound.
  def bindable?: (Document doc) -> bool

  def stores_foreign_key?: () -> bool

  # sord infer - Root was resolved to Mongoid::Atomic::Paths::Root
  # Get the path calculator for the supplied document.
  #
  # _@param_ `document` — The document to calculate on.
  #
  # _@return_ — The root atomic path calculator.
  #
  # Get the path calculator.
  # ```ruby
  # Proxy.path(document)
  # ```
  def path: (Document document) -> Mongoid::Atomic::Paths::Root

  # Setup the instance methods on the class having this association type.
  def setup_instance_methods!: () -> self

  def default_foreign_key_field: () -> untyped

  def polymorphic_inverses: (untyped other) -> untyped

  def determine_inverses: (untyped other) -> untyped

  def default_primary_key: () -> untyped

  def build: (Object base, Object object, ?String? `type`, ?nil selected_fields) -> Document

  def clear_associated: (untyped object) -> untyped

  def query_criteria: (untyped object, untyped base) -> untyped

  def execute_query: (untyped object, untyped base) -> untyped

  def with_polymorphic_criterion: (untyped criteria, untyped base) -> untyped

  def query?: (untyped object) -> bool

  def initialize: (Class _class, Symbol name, ?::Hash[untyped, untyped] opts) { () -> untyped } -> void

  # Compare this association to another.
  #
  # _@return_ — The object to compare to this association.
  def ==: (untyped other) -> Object

  # Get the callbacks for a given type.
  #
  # _@param_ `callback_type` — The type of callback type.
  #
  # _@return_ — A list of the callbacks, either method
  # names or Procs.
  def get_callbacks: (Symbol callback_type) -> ::Array[Proc | Symbol]

  # Get the type setter.
  #
  # _@return_ — The type setter method.
  #
  # _@note_ — Only relevant for polymorphic associations that take the :as option.
  def type_setter: () -> String

  # Get the inverse names.
  #
  # _@param_ `other` — The other model class or model object to use when determining inverses.
  #
  # _@return_ — The list of inverse names.
  def inverses: (?Object? other) -> ::Array[Symbol]

  # Get the inverse's association metadata.
  #
  # _@param_ `other` — The other model class or model object to use when determining inverses.
  #
  # _@return_ — The inverse's association metadata.
  def inverse_association: (?Object? other) -> Association

  # Get the inverse type.
  #
  # _@return_ — Default is nil for an association.
  def inverse_type: () -> nil

  # The class name, possibly unqualified or :: prefixed, of the association
  # object(s).
  #
  # This method returns the class name as it is used in the association
  # definition. If :class_name option is given in the association, the
  # exact value of that option is returned here. If :class_name option is
  # not given, the name of the class is calculated from association name
  # but is not resolved to the actual class.
  #
  # The class name returned by this method may not correspond to a defined
  # class, either because the corresponding class has not been loaded yet,
  # or because the association references a non-existent class altogether.
  # To obtain the association class, use +relation_class+ method.
  #
  # _@return_ — The association objects' class name.
  #
  # _@note_ — The return value of this method should not be used to determine
  # whether two associations have the same target class, because the
  # return value is not always a fully qualified class name. To compare
  # classes, retrieve the class instance of the association target using
  # the +relation_class+ method.
  def relation_class_name: () -> String

  # The class of the association object(s).
  #
  # This method returns the class instance corresponding to
  # +relation_class_name+, resolved relative to the host document class.
  #
  # If the class does not exist, this method raises NameError. This can
  # happen because the target class has not yet been defined. Note that
  # polymorphic associations generally do not have a well defined target
  # class because the target class can change from one object to another,
  # and calling this method on a polymorphic association will generally
  # fail with a NameError or produce misleading results (if a class does
  # happen to be defined with the same name as the association name).
  #
  # _@return_ — The association objects' class.
  def relation_class: () -> String

  # The class name of the object owning this association.
  #
  # _@return_ — The owning objects' class name.
  def inverse_class_name: () -> String

  # The class of the object owning this association.
  #
  # _@return_ — The owning objects' class.
  def inverse_class: () -> String

  # The foreign key field if this association stores a foreign key.
  # Otherwise, the primary key.
  #
  # _@return_ — The primary key.
  def key: () -> (Symbol | String)

  # The name of the setter on this object for assigning an associated object.
  #
  # _@return_ — The setter name.
  def setter: () -> String

  # The name of the inverse setter method.
  #
  # _@return_ — The name of the inverse setter.
  def inverse_setter: (?untyped other) -> String

  # The name of the foreign key setter method.
  #
  # _@return_ — The name of the foreign key setter.
  def foreign_key_setter: () -> String

  # Gets the setter for the field that sets the type of document on a
  # polymorphic association.
  #
  # _@return_ — The name of the setter.
  #
  # Get the inverse type setter.
  # ```ruby
  # association.inverse_type_setter
  # ```
  def inverse_type_setter: () -> String

  # Get the name of the method to check if the foreign key has changed.
  #
  # _@return_ — The foreign key check.
  #
  # Get the foreign key check method.
  # ```ruby
  # association.foreign_key_check
  # ```
  def foreign_key_check: () -> String

  # Create an association proxy object using the owner and target.
  #
  # _@param_ `owner` — The document this association hangs off of.
  #
  # _@param_ `target` — The target (parent) of the association.
  def create_relation: (Document owner, Document | ::Array[Document] target) -> Proxy

  # Whether the dependent method is destructive.
  #
  # _@return_ — If the dependent method is destructive.
  def destructive?: () -> bool

  # Get the counter cache column name.
  #
  # _@return_ — The counter cache column name.
  def counter_cache_column_name: () -> String

  # Get the extension.
  #
  # _@return_ — The extension module, if one has been defined.
  def extension: () -> Module

  # Get the inverse name.
  #
  # _@return_ — The inverse name.
  def inverse: (?untyped other) -> Symbol

  # Whether the associated object(s) should be validated.
  #
  # _@return_ — If the associated object(s)
  # should be validated.
  def validate?: () -> bool

  # Gets the model classes with inverse associations of this model. This is used to determine
  # the classes on the other end of polymorphic associations with models.
  def inverse_association_classes: () -> untyped

  def setup_index!: () -> untyped

  def define_touchable!: () -> untyped

  def define_autosaver!: () -> untyped

  def define_builder!: () -> untyped

  def define_creator!: () -> untyped

  def define_getter!: () -> untyped

  def define_setter!: () -> untyped

  def define_existence_check!: () -> untyped

  def define_ids_getter!: () -> untyped

  def define_ids_setter!: () -> untyped

  def define_counter_cache_callbacks!: () -> untyped

  def define_dependency!: () -> untyped

  def validate!: () -> untyped

  def polymorph!: () -> untyped

  def create_extension!: () { () -> untyped } -> untyped

  def default_inverse: () -> untyped

  # Returns an array of classes/modules forming the namespace hierarchy
  # where symbols referenced in the provided class/module would be looked
  # up by Ruby. For example, if mod is Foo::Bar, this method would return
  # [Foo::Bar, Foo, Object].
  def namespace_hierarchy: (untyped mod) -> untyped

  # Resolves the given class/module name in the context of the specified
  # module, as Ruby would when a constant is referenced in the source.
  #
  # _@note_ — This method can swallow exceptions produced during class loading,
  # because it rescues NameError internally. Since this method attempts
  # to load classes, failure during the loading process may also lead to
  # there being incomplete class definitions.
  def resolve_name: (untyped mod, untyped name) -> untyped

  # Returns the name of the parent to a polymorphic child.
  #
  # _@return_ — The name.
  def as: () -> (String | Symbol)

  # Specify what happens to the associated object when the owner is destroyed.
  #
  # _@return_ — The dependent option.
  def dependent: () -> String

  # The custom sorting options on the association.
  #
  # _@return_ — The custom sorting options.
  def order: () -> Criteria::Queryable::Key

  # Whether to index the primary or foreign key field.
  def indexed?: () -> bool

  # Whether the association is autobuilding.
  def autobuilding?: () -> bool

  # Is the association cyclic.
  #
  # _@return_ — Whether the association is cyclic.
  def cyclic?: () -> bool

  # The name the owning object uses to refer to this association.
  #
  # _@return_ — The inverse_of option.
  def inverse_of: () -> String

  # Mongoid assumes that the field used to hold the primary key of the association is id.
  # You can override this and explicitly specify the primary key with the :primary_key option.
  #
  # _@return_ — The primary key.
  def primary_key: () -> (Symbol | String)

  # Options to save any loaded members and destroy members that are marked for destruction
  # when the parent object is saved.
  #
  # _@return_ — The autosave option.
  def autosave: () -> bool

  # Whether the association is counter-cached.
  def counter_cached?: () -> bool

  # Whether the association has callbacks cascaded down from the parent.
  #
  # _@return_ — Whether callbacks are cascaded.
  def cascading_callbacks?: () -> bool

  # The store_as option.
  #
  # _@return_ — Default is nil.
  def store_as: () -> nil

  # Whether the association has forced nil inverse (So no foreign keys are saved).
  #
  # _@return_ — Default is false.
  def forced_nil_inverse?: () -> bool

  # The field for saving the associated object's type.
  #
  # _@return_ — Default is nil.
  def touch_field: () -> nil

  def touchable?: () -> bool

  # Convert the supplied object to the appropriate type to set as the
  # foreign key for an association.
  #
  # _@param_ `object` — The object to convert.
  #
  # _@return_ — The object cast to the correct type.
  #
  # Convert the object.
  # ```ruby
  # constraint.convert("12345")
  # ```
  def convert_to_foreign_key: (Object object) -> Object

  def convert_polymorphic: (untyped object) -> untyped
end

Mongoid::Association::Mongoid::Association::Referenced::Mongoid::Association::Mongoid::Association::Referenced::HasOne::ASSOCIATION_OPTIONS: untyped

Mongoid::Association::Mongoid::Association::Referenced::Mongoid::Association::Mongoid::Association::Referenced::HasOne::VALID_OPTIONS: untyped

Mongoid::Association::Mongoid::Association::Referenced::Mongoid::Association::Mongoid::Association::Referenced::HasOne::FOREIGN_KEY_SUFFIX: untyped

Mongoid::Association::Mongoid::Association::Referenced::Mongoid::Association::Mongoid::Association::Referenced::HasOne::SHARED_OPTIONS: untyped

Mongoid::Association::Mongoid::Association::Referenced::Mongoid::Association::Mongoid::Association::Referenced::HasOne::PRIMARY_KEY_DEFAULT: untyped

class Mongoid::Association::Mongoid::Association::Referenced::Mongoid::Association::Mongoid::Association::Referenced::HasOne::Eager < Mongoid::Association::Referenced::Eager::Base
  def preload: () -> untyped

  def group_by_key: () -> untyped

  def key: () -> untyped
end

# This class defines the behavior for all associations that are a
# one-to-one between documents in different collections.
class Mongoid::Association::Mongoid::Association::Referenced::Mongoid::Association::Mongoid::Association::Referenced::HasOne::Proxy < Mongoid::Association::One
  # Instantiate a new references_one association. Will set the foreign key
  # and the base on the inverse object.
  #
  # _@param_ `base` — The document this association hangs off of.
  #
  # _@param_ `target` — The target (child) of the association.
  #
  # _@param_ `association` — The association metadata.
  #
  # Create the new association.
  # ```ruby
  # Referenced::One.new(base, target, association)
  # ```
  def initialize: (Document base, Document target, Association association) -> void

  # Removes the association between the base document and the target
  # document by deleting the foreign key and the reference, orphaning
  # the target document in the process.
  #
  # Nullify the association.
  # ```ruby
  # person.game.nullify
  # ```
  def nullify: () -> untyped

  # Substitutes the supplied target document for the existing document
  # in the association. If the new target is nil, perform the necessary
  # deletion.
  #
  # _@param_ `replacement` — The replacement target.
  #
  # _@return_ — The association.
  #
  # Replace the association.
  # ```ruby
  # person.game.substitute(new_game)
  # ```
  def substitute: (::Array[Document] replacement) -> One

  # sord warn - Binding wasn't able to be resolved to a constant in this project
  # Instantiate the binding associated with this association.
  #
  # _@return_ — The binding object.
  #
  # Get the binding.
  # ```ruby
  # relation.binding([ address ])
  # ```
  def binding: () -> Binding

  # Are we able to persist this association?
  #
  # _@return_ — If the association is persistable.
  #
  # Can we persist the association?
  # ```ruby
  # relation.persistable?
  # ```
  def persistable?: () -> bool

  def self.eager_loader: (untyped association, untyped docs) -> untyped

  # Returns true if the association is an embedded one. In this case
  # always false.
  #
  # _@return_ — Always false.
  #
  # Is this association embedded?
  # ```ruby
  # Referenced::One.embedded?
  # ```
  def self.embedded?: () -> bool
end

# Binding class for has_one associations.
#
# @since 7.0
class Mongoid::Association::Mongoid::Association::Referenced::Mongoid::Association::Mongoid::Association::Referenced::HasOne::Binding
  include Mongoid::Association::Bindable

  # Binds the base object to the inverse of the association. This is so we
  # are referenced to the actual objects themselves on both sides.
  #
  # This case sets the association metadata on the inverse object as well as the
  # document itself.
  #
  # Bind the document.
  # ```ruby
  # person.game.bind(:continue => true)
  # person.game = Game.new
  # ```
  def bind_one: () -> untyped

  # Unbinds the base object and the inverse, caused by setting the
  # reference to nil.
  #
  # Unbind the document.
  # ```ruby
  # person.game.unbind(:continue => true)
  # person.game = nil
  # ```
  def unbind_one: () -> untyped

  # Create the new binding.
  #
  # _@param_ `base` — The base of the binding.
  #
  # _@param_ `target` — The target of the binding.
  #
  # _@param_ `association` — The association metadata.
  #
  # Initialize a binding.
  # ```ruby
  # Binding.new(base, target, association)
  # ```
  def initialize: (Document base, Document | ::Array[Document] target, Association association) -> void

  # Execute the provided block inside a binding.
  #
  # _@return_ — The result of the yield.
  #
  # Execute the binding block.
  # ```ruby
  # binding.binding do
  #   base.foreign_key = 1
  # end
  # ```
  def binding: () -> Object

  # Check if the inverse is properly defined.
  #
  # _@param_ `doc` — The document getting bound.
  #
  # Check the inverse definition.
  # ```ruby
  # binding.check_inverse!(doc)
  # ```
  def check_inverse!: (Document doc) -> untyped

  # Set the id of the related document in the foreign key field on the
  # keyed document.
  #
  # _@param_ `keyed` — The document that stores the foreign key.
  #
  # _@param_ `id` — The id of the bound document.
  #
  # Bind the foreign key.
  # ```ruby
  # binding.bind_foreign_key(post, person._id)
  # ```
  def bind_foreign_key: (Document keyed, Object id) -> untyped

  # Set the type of the related document on the foreign type field, used
  # when associations are polymorphic.
  #
  # _@param_ `typed` — The document that stores the type field.
  #
  # _@param_ `name` — The name of the model.
  #
  # Bind the polymorphic type.
  # ```ruby
  # binding.bind_polymorphic_type(post, "Person")
  # ```
  def bind_polymorphic_type: (Document typed, String name) -> untyped

  # Set the type of the related document on the foreign type field, used
  # when associations are polymorphic.
  #
  # _@param_ `typed` — The document that stores the type field.
  #
  # _@param_ `name` — The name of the model.
  #
  # Bind the polymorphic type.
  # ```ruby
  # binding.bind_polymorphic_inverse_type(post, "Person")
  # ```
  def bind_polymorphic_inverse_type: (Document typed, String name) -> untyped

  # Bind the inverse document to the child document so that the in memory
  # instances are the same.
  #
  # _@param_ `doc` — The base document.
  #
  # _@param_ `inverse` — The inverse document.
  #
  # Bind the inverse.
  # ```ruby
  # binding.bind_inverse(post, person)
  # ```
  def bind_inverse: (Document doc, Document inverse) -> untyped

  # Bind the provided document with the base from the parent association.
  #
  # _@param_ `doc` — The document to bind.
  #
  # Bind the document with the base.
  # ```ruby
  # binding.bind_from_relational_parent(doc)
  # ```
  def bind_from_relational_parent: (Document doc) -> untyped

  def record_id: (untyped _base) -> untyped

  # Ensure that the association on the base is correct, for the cases
  # where we have multiple belongs to definitions and were are setting
  # different parents in memory in order.
  #
  # _@return_ — If the association changed.
  #
  # Set the base association.
  # ```ruby
  # binding.set_base_association
  # ```
  def set_base_association: () -> bool

  # Bind the provided document with the base from the parent association.
  #
  # _@param_ `doc` — The document to unbind.
  #
  # Bind the document with the base.
  # ```ruby
  # unbinding.unbind_from_relational_parent(doc)
  # ```
  def unbind_from_relational_parent: (Document doc) -> untyped

  # Begin the assignment of attributes. While in this block embedded
  # documents will not autosave themselves in order to allow the document to
  # be in a valid state.
  #
  # _@return_ — The yielded value.
  #
  # Execute the assignment.
  # ```ruby
  # _assigning do
  #   person.attributes = { :addresses => [ address ] }
  # end
  # ```
  def _assigning: () -> Object

  # Is the current thread in assigning mode?
  #
  # _@return_ — If the thread is assigning.
  #
  # Is the current thread in assigning mode?
  # ```ruby
  # proxy._assigning?
  # ```
  def _assigning?: () -> bool

  # Execute a block in binding mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in binding mode.
  # ```ruby
  # binding do
  #   relation.push(doc)
  # end
  # ```
  def _binding: () -> Object

  # Is the current thread in binding mode?
  #
  # _@return_ — If the thread is binding.
  #
  # Is the current thread in binding mode?
  # ```ruby
  # proxy.binding?
  # ```
  def _binding?: () -> bool

  # Execute a block in building mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in building mode.
  # ```ruby
  # _building do
  #   relation.push(doc)
  # end
  # ```
  def _building: () -> Object

  # Is the current thread in building mode?
  #
  # _@return_ — If the thread is building.
  #
  # Is the current thread in building mode?
  # ```ruby
  # proxy._building?
  # ```
  def _building?: () -> bool

  # Is the current thread in creating mode?
  #
  # _@return_ — If the thread is creating.
  #
  # Is the current thread in creating mode?
  # ```ruby
  # proxy.creating?
  # ```
  def _creating?: () -> bool

  # Execute a block in loading mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in loading mode.
  # ```ruby
  # _loading do
  #   relation.push(doc)
  # end
  # ```
  def _loading: () -> Object

  # Is the current thread in loading mode?
  #
  # _@return_ — If the thread is loading.
  #
  # Is the current thread in loading mode?
  # ```ruby
  # proxy._loading?
  # ```
  def _loading?: () -> bool
end

# The Builder behavior for has_one associations.
#
# @since 7.0
module Mongoid::Association::Mongoid::Association::Referenced::Mongoid::Association::Mongoid::Association::Referenced::HasOne::Buildable
  def build: (Object base, Object object, ?String? `type`, ?nil selected_fields) -> Document

  def clear_associated: (untyped object) -> untyped

  def query_criteria: (untyped object, untyped base) -> untyped

  def execute_query: (untyped object, untyped base) -> untyped

  def with_polymorphic_criterion: (untyped criteria, untyped base) -> untyped

  def query?: (untyped object) -> bool
end

# The has_many association.
#
# @since 7.0
class Mongoid::Association::Mongoid::Association::Referenced::HasMany
  include Mongoid::Association::Relatable

  include Mongoid::Association::Referenced::HasMany::Buildable

  # The list of association complements.
  #
  # _@return_ — The association complements.
  def relation_complements: () -> ::Array[Association]

  # Setup the instance methods, fields, etc. on the association owning class.
  def setup!: () -> self

  # Setup the instance methods on the class having this association type.
  def setup_instance_methods!: () -> self

  # Get the foreign key field on the inverse for saving the association reference.
  #
  # _@return_ — The foreign key field on the inverse for saving the
  # association reference.
  def foreign_key: () -> String

  # Is this association type embedded?
  #
  # _@return_ — Always false.
  def embedded?: () -> bool

  # The default for validation the association object.
  #
  # _@return_ — Always true.
  def validation_default: () -> bool

  # Does this association type store the foreign key?
  #
  # _@return_ — Always true.
  def stores_foreign_key?: () -> bool

  # sord warn - Association::HasMany::Proxy wasn't able to be resolved to a constant in this project
  # Get the association proxy class for this association type.
  #
  # _@return_ — The proxy class.
  def relation: () -> Mongoid::Association::Referenced::HasMany::Proxy

  # The criteria used for querying this association.
  #
  # _@return_ — The criteria used for querying this association.
  def criteria: (untyped base) -> Mongoid::Criteria

  # The type of this association if it's polymorphic.
  #
  # _@return_ — The type field.
  #
  # _@note_ — Only relevant for polymorphic associations.
  def type: () -> String?

  # Add polymorphic query criteria to a Criteria object, if this association is
  #  polymorphic.
  #
  # _@param_ `criteria` — The criteria object to add to.
  #
  # _@param_ `object_class` — The object class.
  #
  # _@return_ — The criteria object.
  def add_polymorphic_criterion: (Mongoid::Criteria criteria, Class object_class) -> Mongoid::Criteria

  # Is this association polymorphic?
  #
  # _@return_ — Whether this association is polymorphic.
  def polymorphic?: () -> bool

  # Whether trying to bind an object using this association should raise
  # an error.
  #
  # _@param_ `doc` — The document to be bound.
  #
  # _@return_ — Whether the document can be bound.
  def bindable?: (Document doc) -> bool

  # The nested builder object.
  #
  # _@param_ `attributes` — The attributes to use to build the association object.
  #
  # _@param_ `options` — The options for the association.
  #
  # _@return_ — The Nested Builder object.
  def nested_builder: (::Hash[untyped, untyped] attributes, ::Hash[untyped, untyped] options) -> Association::Nested::Many

  # sord infer - Root was resolved to Mongoid::Atomic::Paths::Root
  # Get the path calculator for the supplied document.
  #
  # _@param_ `document` — The document to calculate on.
  #
  # _@return_ — The root atomic path calculator.
  #
  # Get the path calculator.
  # ```ruby
  # Proxy.path(document)
  # ```
  def path: (Document document) -> Mongoid::Atomic::Paths::Root

  def default_foreign_key_field: () -> untyped

  def polymorphic_inverses: (untyped other) -> untyped

  def determine_inverses: (untyped other) -> untyped

  def default_primary_key: () -> untyped

  def query_criteria: (untyped object, untyped base) -> untyped

  def with_polymorphic_criterion: (untyped criteria, untyped base) -> untyped

  def with_ordering: (untyped criteria) -> untyped

  def with_inverse_field_criterion: (untyped criteria) -> untyped

  def build: (Object base, Object object, ?String? `type`, ?nil selected_fields) -> Document

  def query?: (untyped object) -> bool

  def initialize: (Class _class, Symbol name, ?::Hash[untyped, untyped] opts) { () -> untyped } -> void

  # Compare this association to another.
  #
  # _@return_ — The object to compare to this association.
  def ==: (untyped other) -> Object

  # Get the callbacks for a given type.
  #
  # _@param_ `callback_type` — The type of callback type.
  #
  # _@return_ — A list of the callbacks, either method
  # names or Procs.
  def get_callbacks: (Symbol callback_type) -> ::Array[Proc | Symbol]

  # Get the type setter.
  #
  # _@return_ — The type setter method.
  #
  # _@note_ — Only relevant for polymorphic associations that take the :as option.
  def type_setter: () -> String

  # Get the inverse names.
  #
  # _@param_ `other` — The other model class or model object to use when determining inverses.
  #
  # _@return_ — The list of inverse names.
  def inverses: (?Object? other) -> ::Array[Symbol]

  # Get the inverse's association metadata.
  #
  # _@param_ `other` — The other model class or model object to use when determining inverses.
  #
  # _@return_ — The inverse's association metadata.
  def inverse_association: (?Object? other) -> Association

  # Get the inverse type.
  #
  # _@return_ — Default is nil for an association.
  def inverse_type: () -> nil

  # The class name, possibly unqualified or :: prefixed, of the association
  # object(s).
  #
  # This method returns the class name as it is used in the association
  # definition. If :class_name option is given in the association, the
  # exact value of that option is returned here. If :class_name option is
  # not given, the name of the class is calculated from association name
  # but is not resolved to the actual class.
  #
  # The class name returned by this method may not correspond to a defined
  # class, either because the corresponding class has not been loaded yet,
  # or because the association references a non-existent class altogether.
  # To obtain the association class, use +relation_class+ method.
  #
  # _@return_ — The association objects' class name.
  #
  # _@note_ — The return value of this method should not be used to determine
  # whether two associations have the same target class, because the
  # return value is not always a fully qualified class name. To compare
  # classes, retrieve the class instance of the association target using
  # the +relation_class+ method.
  def relation_class_name: () -> String

  # The class of the association object(s).
  #
  # This method returns the class instance corresponding to
  # +relation_class_name+, resolved relative to the host document class.
  #
  # If the class does not exist, this method raises NameError. This can
  # happen because the target class has not yet been defined. Note that
  # polymorphic associations generally do not have a well defined target
  # class because the target class can change from one object to another,
  # and calling this method on a polymorphic association will generally
  # fail with a NameError or produce misleading results (if a class does
  # happen to be defined with the same name as the association name).
  #
  # _@return_ — The association objects' class.
  def relation_class: () -> String

  # The class name of the object owning this association.
  #
  # _@return_ — The owning objects' class name.
  def inverse_class_name: () -> String

  # The class of the object owning this association.
  #
  # _@return_ — The owning objects' class.
  def inverse_class: () -> String

  # The foreign key field if this association stores a foreign key.
  # Otherwise, the primary key.
  #
  # _@return_ — The primary key.
  def key: () -> (Symbol | String)

  # The name of the setter on this object for assigning an associated object.
  #
  # _@return_ — The setter name.
  def setter: () -> String

  # The name of the inverse setter method.
  #
  # _@return_ — The name of the inverse setter.
  def inverse_setter: (?untyped other) -> String

  # The name of the foreign key setter method.
  #
  # _@return_ — The name of the foreign key setter.
  def foreign_key_setter: () -> String

  # Gets the setter for the field that sets the type of document on a
  # polymorphic association.
  #
  # _@return_ — The name of the setter.
  #
  # Get the inverse type setter.
  # ```ruby
  # association.inverse_type_setter
  # ```
  def inverse_type_setter: () -> String

  # Get the name of the method to check if the foreign key has changed.
  #
  # _@return_ — The foreign key check.
  #
  # Get the foreign key check method.
  # ```ruby
  # association.foreign_key_check
  # ```
  def foreign_key_check: () -> String

  # Create an association proxy object using the owner and target.
  #
  # _@param_ `owner` — The document this association hangs off of.
  #
  # _@param_ `target` — The target (parent) of the association.
  def create_relation: (Document owner, Document | ::Array[Document] target) -> Proxy

  # Whether the dependent method is destructive.
  #
  # _@return_ — If the dependent method is destructive.
  def destructive?: () -> bool

  # Get the counter cache column name.
  #
  # _@return_ — The counter cache column name.
  def counter_cache_column_name: () -> String

  # Get the extension.
  #
  # _@return_ — The extension module, if one has been defined.
  def extension: () -> Module

  # Get the inverse name.
  #
  # _@return_ — The inverse name.
  def inverse: (?untyped other) -> Symbol

  # Whether the associated object(s) should be validated.
  #
  # _@return_ — If the associated object(s)
  # should be validated.
  def validate?: () -> bool

  # Gets the model classes with inverse associations of this model. This is used to determine
  # the classes on the other end of polymorphic associations with models.
  def inverse_association_classes: () -> untyped

  def setup_index!: () -> untyped

  def define_touchable!: () -> untyped

  def define_autosaver!: () -> untyped

  def define_builder!: () -> untyped

  def define_creator!: () -> untyped

  def define_getter!: () -> untyped

  def define_setter!: () -> untyped

  def define_existence_check!: () -> untyped

  def define_ids_getter!: () -> untyped

  def define_ids_setter!: () -> untyped

  def define_counter_cache_callbacks!: () -> untyped

  def define_dependency!: () -> untyped

  def validate!: () -> untyped

  def polymorph!: () -> untyped

  def create_extension!: () { () -> untyped } -> untyped

  def default_inverse: () -> untyped

  # Returns an array of classes/modules forming the namespace hierarchy
  # where symbols referenced in the provided class/module would be looked
  # up by Ruby. For example, if mod is Foo::Bar, this method would return
  # [Foo::Bar, Foo, Object].
  def namespace_hierarchy: (untyped mod) -> untyped

  # Resolves the given class/module name in the context of the specified
  # module, as Ruby would when a constant is referenced in the source.
  #
  # _@note_ — This method can swallow exceptions produced during class loading,
  # because it rescues NameError internally. Since this method attempts
  # to load classes, failure during the loading process may also lead to
  # there being incomplete class definitions.
  def resolve_name: (untyped mod, untyped name) -> untyped

  # Returns the name of the parent to a polymorphic child.
  #
  # _@return_ — The name.
  def as: () -> (String | Symbol)

  # Specify what happens to the associated object when the owner is destroyed.
  #
  # _@return_ — The dependent option.
  def dependent: () -> String

  # The custom sorting options on the association.
  #
  # _@return_ — The custom sorting options.
  def order: () -> Criteria::Queryable::Key

  # Whether to index the primary or foreign key field.
  def indexed?: () -> bool

  # Whether the association is autobuilding.
  def autobuilding?: () -> bool

  # Is the association cyclic.
  #
  # _@return_ — Whether the association is cyclic.
  def cyclic?: () -> bool

  # The name the owning object uses to refer to this association.
  #
  # _@return_ — The inverse_of option.
  def inverse_of: () -> String

  # Mongoid assumes that the field used to hold the primary key of the association is id.
  # You can override this and explicitly specify the primary key with the :primary_key option.
  #
  # _@return_ — The primary key.
  def primary_key: () -> (Symbol | String)

  # Options to save any loaded members and destroy members that are marked for destruction
  # when the parent object is saved.
  #
  # _@return_ — The autosave option.
  def autosave: () -> bool

  # Whether the association is counter-cached.
  def counter_cached?: () -> bool

  # Whether the association has callbacks cascaded down from the parent.
  #
  # _@return_ — Whether callbacks are cascaded.
  def cascading_callbacks?: () -> bool

  # The store_as option.
  #
  # _@return_ — Default is nil.
  def store_as: () -> nil

  # Whether the association has forced nil inverse (So no foreign keys are saved).
  #
  # _@return_ — Default is false.
  def forced_nil_inverse?: () -> bool

  # The field for saving the associated object's type.
  #
  # _@return_ — Default is nil.
  def touch_field: () -> nil

  def touchable?: () -> bool

  # Convert the supplied object to the appropriate type to set as the
  # foreign key for an association.
  #
  # _@param_ `object` — The object to convert.
  #
  # _@return_ — The object cast to the correct type.
  #
  # Convert the object.
  # ```ruby
  # constraint.convert("12345")
  # ```
  def convert_to_foreign_key: (Object object) -> Object

  def convert_polymorphic: (untyped object) -> untyped
end

Mongoid::Association::Mongoid::Association::Referenced::Mongoid::Association::Mongoid::Association::Referenced::HasMany::ASSOCIATION_OPTIONS: untyped

Mongoid::Association::Mongoid::Association::Referenced::Mongoid::Association::Mongoid::Association::Referenced::HasMany::VALID_OPTIONS: untyped

Mongoid::Association::Mongoid::Association::Referenced::Mongoid::Association::Mongoid::Association::Referenced::HasMany::FOREIGN_KEY_SUFFIX: untyped

Mongoid::Association::Mongoid::Association::Referenced::Mongoid::Association::Mongoid::Association::Referenced::HasMany::SHARED_OPTIONS: untyped

Mongoid::Association::Mongoid::Association::Referenced::Mongoid::Association::Mongoid::Association::Referenced::HasMany::PRIMARY_KEY_DEFAULT: untyped

# Eager class for has_many associations.
class Mongoid::Association::Mongoid::Association::Referenced::Mongoid::Association::Mongoid::Association::Referenced::HasMany::Eager < Mongoid::Association::Referenced::Eager::Base
  def preload: () -> untyped

  def set_relation: (untyped doc, untyped element) -> untyped

  def group_by_key: () -> untyped

  def key: () -> untyped
end

# This class defines the behavior for all associations that are a
# one-to-many between documents in different collections.
class Mongoid::Association::Mongoid::Association::Referenced::Mongoid::Association::Mongoid::Association::Referenced::HasMany::Proxy < Mongoid::Association::Many
  extend Forwardable

  # Appends a document or array of documents to the association. Will set
  # the parent and update the index in the process.
  #
  # _@param_ `args` — Any number of documents.
  #
  # _@return_ — The loaded docs.
  #
  # Append a document.
  # ```ruby
  # person.posts << post
  # ```
  #
  # Push a document.
  # ```ruby
  # person.posts.push(post)
  # ```
  #
  # Concat with other documents.
  # ```ruby
  # person.posts.concat([ post_one, post_two ])
  # ```
  def <<: (*Document | ::Array[Document] args) -> ::Array[Document]

  # Appends an array of documents to the association. Performs a batch
  # insert of the documents instead of persisting one at a time.
  #
  # _@param_ `documents` — The docs to add.
  #
  # _@return_ — The documents.
  #
  # Concat with other documents.
  # ```ruby
  # person.posts.concat([ post_one, post_two ])
  # ```
  def concat: (::Array[Document] documents) -> ::Array[Document]

  # Build a new document from the attributes and append it to this
  # association without saving.
  #
  # _@param_ `attributes` — The attributes of the new document.
  #
  # _@param_ `type` — The optional subclass to build.
  #
  # _@return_ — The new document.
  #
  # Build a new document on the association.
  # ```ruby
  # person.posts.build(:title => "A new post")
  # ```
  def build: (?::Hash[untyped, untyped] attributes, ?Class? `type`) -> Document

  # Delete the document from the association. This will set the foreign key
  # on the document to nil. If the dependent options on the association are
  # :delete_all or :destroy the appropriate removal will occur.
  #
  # _@param_ `document` — The document to remove.
  #
  # _@return_ — The matching document.
  #
  # Delete the document.
  # ```ruby
  # person.posts.delete(post)
  # ```
  def delete: (Document document) -> Document

  # Deletes all related documents from the database given the supplied
  # conditions.
  #
  # _@param_ `conditions` — Optional conditions to delete with.
  #
  # _@return_ — The number of documents deleted.
  #
  # Delete all documents in the association.
  # ```ruby
  # person.posts.delete_all
  # ```
  #
  # Conditonally delete all documents in the association.
  # ```ruby
  # person.posts.delete_all({ :title => "Testing" })
  # ```
  def delete_all: (?::Hash[untyped, untyped]? conditions) -> Integer

  # Destroys all related documents from the database given the supplied
  # conditions.
  #
  # _@param_ `conditions` — Optional conditions to destroy with.
  #
  # _@return_ — The number of documents destroyd.
  #
  # Destroy all documents in the association.
  # ```ruby
  # person.posts.destroy_all
  # ```
  #
  # Conditonally destroy all documents in the association.
  # ```ruby
  # person.posts.destroy_all({ :title => "Testing" })
  # ```
  def destroy_all: (?::Hash[untyped, untyped]? conditions) -> Integer

  # Iterate over each document in the association and yield to the provided
  # block.
  #
  # _@return_ — The loaded docs.
  #
  # Iterate over the documents.
  # ```ruby
  # person.posts.each do |post|
  #   post.save
  # end
  # ```
  #
  # _@note_ — This will load the entire association into memory.
  def each: () -> ::Array[Document]

  # Determine if any documents in this association exist in the database.
  #
  # If the association contains documents but all of the documents
  # exist only in the application, i.e. have not been persisted to the
  # database, this method returns false.
  #
  # This method queries the database on each invocation even if the
  # association is already loaded into memory.
  #
  # _@return_ — True is persisted documents exist, false if not.
  #
  # Are there persisted documents?
  # ```ruby
  # person.posts.exists?
  # ```
  def exists?: () -> bool

  # Find the matchind document on the association, either based on id or
  # conditions.
  #
  # _@param_ `args` — The ids.
  #
  # _@return_ — The matching document(s).
  #
  # Find by an id.
  # ```ruby
  # person.posts.find(BSON::ObjectId.new)
  # ```
  #
  # Find by multiple ids.
  # ```ruby
  # person.posts.find([ BSON::ObjectId.new, BSON::ObjectId.new ])
  # ```
  #
  # _@note_ — This will keep matching documents in memory for iteration
  # later.
  def find: (*BSON::ObjectId | ::Array[BSON::ObjectId] args) -> (Document | Criteria)

  # Instantiate a new references_many association. Will set the foreign key
  # and the base on the inverse object.
  #
  # _@param_ `base` — The document this association hangs off of.
  #
  # _@param_ `target` — The target of the association.
  #
  # _@param_ `association` — The association metadata.
  #
  # Create the new association.
  # ```ruby
  # Referenced::Many.new(base, target, association)
  # ```
  def initialize: (Document base, ::Array[Document] target, Association association) -> void

  # Removes all associations between the base document and the target
  # documents by deleting the foreign keys and the references, orphaning
  # the target documents in the process.
  #
  # Nullify the association.
  # ```ruby
  # person.posts.nullify
  # ```
  def nullify: () -> untyped

  # Clear the association. Will delete the documents from the db if they are
  # already persisted.
  #
  # _@return_ — The association emptied.
  #
  # Clear the association.
  # ```ruby
  # person.posts.clear
  # ```
  def purge: () -> Many

  # Substitutes the supplied target documents for the existing documents
  # in the association. If the new target is nil, perform the necessary
  # deletion.
  #
  # _@param_ `replacement` — The replacement target.
  #
  # _@return_ — The association.
  #
  # Replace the association.
  # ```ruby
  # person.posts.substitute([ new_post ])
  # ```
  def substitute: (::Array[Document] replacement) -> Many

  # Get a criteria for the documents without the default scoping
  # applied.
  #
  # _@return_ — The unscoped criteria.
  #
  # Get the unscoped criteria.
  # ```ruby
  # person.posts.unscoped
  # ```
  def unscoped: () -> Criteria

  # Appends the document to the target array, updating the index on the
  # document at the same time.
  #
  # _@param_ `document` — The document to append to the target.
  #
  # Append the document to the association.
  # ```ruby
  # relation.append(document)
  # ```
  def append: (Document document) -> untyped

  # Execute before/after add callbacks around the block unless the objects
  # already have a persisted association.
  #
  # _@param_ `document` — The document to append to the target.
  #
  # _@param_ `already_related` — Whether the document is already related to the target.
  #
  # Execute before/after add callbacks around the block.
  # ```ruby
  # relation.with_add_callbacks(document, false)
  # ```
  def with_add_callbacks: (Document document, bool already_related) -> untyped

  # Whether the document and the base already have a persisted association.
  #
  # _@param_ `document` — The document to possibly append to the target.
  #
  # _@return_ — Whether the document is already related to the base and the
  # association is persisted.
  #
  # Is the document already related to the base.
  # ```ruby
  # relation.already_related?(document)
  # ```
  def already_related?: (Document document) -> bool

  # sord warn - Binding wasn't able to be resolved to a constant in this project
  # Instantiate the binding associated with this association.
  #
  # _@return_ — The binding.
  #
  # Get the binding.
  # ```ruby
  # relation.binding([ address ])
  # ```
  def binding: () -> Binding

  # sord warn - Collection wasn't able to be resolved to a constant in this project
  # Get the collection of the association in question.
  #
  # _@return_ — The collection of the association.
  #
  # Get the collection of the association.
  # ```ruby
  # relation.collection
  # ```
  def collection: () -> Mongo::Collection

  # Returns the criteria object for the target class with its documents set
  # to target.
  #
  # _@return_ — A new criteria.
  #
  # Get a criteria for the association.
  # ```ruby
  # relation.criteria
  # ```
  def criteria: () -> Criteria

  # Perform the necessary cascade operations for documents that just got
  # deleted or nullified.
  #
  # _@param_ `document` — The document to cascade on.
  #
  # _@return_ — If the association is destructive.
  #
  # Cascade the change.
  # ```ruby
  # relation.cascade!(document)
  # ```
  def cascade!: (Document document) -> bool

  # If the target array does not respond to the supplied method then try to
  # find a named scope or criteria on the class and send the call there.
  #
  # If the method exists on the array, use the default proxy behavior.
  #
  # _@param_ `name` — The name of the method.
  #
  # _@param_ `args` — The method args
  #
  # _@param_ `block` — Optional block to pass.
  #
  # _@return_ — A Criteria or return value from the target.
  def method_missing: (Symbol | String name, *::Array[untyped] args) { () -> untyped } -> (Criteria | Object)

  # Persist all the delayed batch inserts.
  #
  # _@param_ `docs` — The delayed inserts.
  #
  # _@param_ `inserts` — The raw insert document.
  #
  # Persist the delayed batch inserts.
  # ```ruby
  # relation.persist_delayed([ doc ])
  # ```
  def persist_delayed: (::Array[Document] docs, ::Array[::Hash[untyped, untyped]] inserts) -> untyped

  # Are we able to persist this association?
  #
  # _@return_ — If the association is persistable.
  #
  # Can we persist the association?
  # ```ruby
  # relation.persistable?
  # ```
  def persistable?: () -> bool

  # Deletes all related documents from the database given the supplied
  # conditions.
  #
  # _@param_ `conditions` — Optional conditions to delete with.
  #
  # _@param_ `method` — The deletion method to call.
  #
  # _@return_ — The number of documents deleted.
  #
  # Delete all documents in the association.
  # ```ruby
  # person.posts.delete_all
  # ```
  #
  # Conditonally delete all documents in the association.
  # ```ruby
  # person.posts.delete_all({ :title => "Testing" })
  # ```
  def remove_all: (?::Hash[untyped, untyped]? conditions, ?Symbol method) -> Integer

  # Remove all the documents in the proxy that do not have the provided
  # ids.
  #
  # _@param_ `ids` — The ids.
  #
  # Remove all documents without the ids.
  # ```ruby
  # proxy.remove_not_in([ id ])
  # ```
  def remove_not_in: (::Array[Object] ids) -> untyped

  # Save a persisted document immediately or delay a new document for
  # batch insert.
  #
  # _@param_ `doc` — The document.
  #
  # _@param_ `inserts` — The inserts.
  #
  # Save or delay the document.
  # ```ruby
  # relation.save_or_delay(doc, [])
  # ```
  def save_or_delay: (Document doc, untyped docs, ::Array[Document] inserts) -> untyped

  def self.eager_loader: (untyped association, untyped docs) -> untyped

  # Returns true if the association is an embedded one. In this case
  # always false.
  #
  # _@return_ — Always false.
  #
  # Is this association embedded?
  # ```ruby
  # Referenced::Many.embedded?
  # ```
  def self.embedded?: () -> bool
end

# Binding class for has_many associations.
class Mongoid::Association::Mongoid::Association::Referenced::Mongoid::Association::Mongoid::Association::Referenced::HasMany::Binding
  include Mongoid::Association::Bindable

  # Binds a single document with the inverse association. Used
  # specifically when appending to the proxy.
  #
  # Bind one document.
  # ```ruby
  # person.posts.bind_one(post)
  # ```
  def bind_one: (untyped doc) -> untyped

  # Unbind a single document.
  #
  # Unbind the document.
  # ```ruby
  # person.posts.unbind_one(document)
  # ```
  def unbind_one: (untyped doc) -> untyped

  # Create the new binding.
  #
  # _@param_ `base` — The base of the binding.
  #
  # _@param_ `target` — The target of the binding.
  #
  # _@param_ `association` — The association metadata.
  #
  # Initialize a binding.
  # ```ruby
  # Binding.new(base, target, association)
  # ```
  def initialize: (Document base, Document | ::Array[Document] target, Association association) -> void

  # Execute the provided block inside a binding.
  #
  # _@return_ — The result of the yield.
  #
  # Execute the binding block.
  # ```ruby
  # binding.binding do
  #   base.foreign_key = 1
  # end
  # ```
  def binding: () -> Object

  # Check if the inverse is properly defined.
  #
  # _@param_ `doc` — The document getting bound.
  #
  # Check the inverse definition.
  # ```ruby
  # binding.check_inverse!(doc)
  # ```
  def check_inverse!: (Document doc) -> untyped

  # Set the id of the related document in the foreign key field on the
  # keyed document.
  #
  # _@param_ `keyed` — The document that stores the foreign key.
  #
  # _@param_ `id` — The id of the bound document.
  #
  # Bind the foreign key.
  # ```ruby
  # binding.bind_foreign_key(post, person._id)
  # ```
  def bind_foreign_key: (Document keyed, Object id) -> untyped

  # Set the type of the related document on the foreign type field, used
  # when associations are polymorphic.
  #
  # _@param_ `typed` — The document that stores the type field.
  #
  # _@param_ `name` — The name of the model.
  #
  # Bind the polymorphic type.
  # ```ruby
  # binding.bind_polymorphic_type(post, "Person")
  # ```
  def bind_polymorphic_type: (Document typed, String name) -> untyped

  # Set the type of the related document on the foreign type field, used
  # when associations are polymorphic.
  #
  # _@param_ `typed` — The document that stores the type field.
  #
  # _@param_ `name` — The name of the model.
  #
  # Bind the polymorphic type.
  # ```ruby
  # binding.bind_polymorphic_inverse_type(post, "Person")
  # ```
  def bind_polymorphic_inverse_type: (Document typed, String name) -> untyped

  # Bind the inverse document to the child document so that the in memory
  # instances are the same.
  #
  # _@param_ `doc` — The base document.
  #
  # _@param_ `inverse` — The inverse document.
  #
  # Bind the inverse.
  # ```ruby
  # binding.bind_inverse(post, person)
  # ```
  def bind_inverse: (Document doc, Document inverse) -> untyped

  # Bind the provided document with the base from the parent association.
  #
  # _@param_ `doc` — The document to bind.
  #
  # Bind the document with the base.
  # ```ruby
  # binding.bind_from_relational_parent(doc)
  # ```
  def bind_from_relational_parent: (Document doc) -> untyped

  def record_id: (untyped _base) -> untyped

  # Ensure that the association on the base is correct, for the cases
  # where we have multiple belongs to definitions and were are setting
  # different parents in memory in order.
  #
  # _@return_ — If the association changed.
  #
  # Set the base association.
  # ```ruby
  # binding.set_base_association
  # ```
  def set_base_association: () -> bool

  # Bind the provided document with the base from the parent association.
  #
  # _@param_ `doc` — The document to unbind.
  #
  # Bind the document with the base.
  # ```ruby
  # unbinding.unbind_from_relational_parent(doc)
  # ```
  def unbind_from_relational_parent: (Document doc) -> untyped

  # Begin the assignment of attributes. While in this block embedded
  # documents will not autosave themselves in order to allow the document to
  # be in a valid state.
  #
  # _@return_ — The yielded value.
  #
  # Execute the assignment.
  # ```ruby
  # _assigning do
  #   person.attributes = { :addresses => [ address ] }
  # end
  # ```
  def _assigning: () -> Object

  # Is the current thread in assigning mode?
  #
  # _@return_ — If the thread is assigning.
  #
  # Is the current thread in assigning mode?
  # ```ruby
  # proxy._assigning?
  # ```
  def _assigning?: () -> bool

  # Execute a block in binding mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in binding mode.
  # ```ruby
  # binding do
  #   relation.push(doc)
  # end
  # ```
  def _binding: () -> Object

  # Is the current thread in binding mode?
  #
  # _@return_ — If the thread is binding.
  #
  # Is the current thread in binding mode?
  # ```ruby
  # proxy.binding?
  # ```
  def _binding?: () -> bool

  # Execute a block in building mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in building mode.
  # ```ruby
  # _building do
  #   relation.push(doc)
  # end
  # ```
  def _building: () -> Object

  # Is the current thread in building mode?
  #
  # _@return_ — If the thread is building.
  #
  # Is the current thread in building mode?
  # ```ruby
  # proxy._building?
  # ```
  def _building?: () -> bool

  # Is the current thread in creating mode?
  #
  # _@return_ — If the thread is creating.
  #
  # Is the current thread in creating mode?
  # ```ruby
  # proxy.creating?
  # ```
  def _creating?: () -> bool

  # Execute a block in loading mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in loading mode.
  # ```ruby
  # _loading do
  #   relation.push(doc)
  # end
  # ```
  def _loading: () -> Object

  # Is the current thread in loading mode?
  #
  # _@return_ — If the thread is loading.
  #
  # Is the current thread in loading mode?
  # ```ruby
  # proxy._loading?
  # ```
  def _loading?: () -> bool
end

# The Builder behavior for has_many associations.
#
# @since 7.0
module Mongoid::Association::Mongoid::Association::Referenced::Mongoid::Association::Mongoid::Association::Referenced::HasMany::Buildable
  def build: (Object base, Object object, ?String? `type`, ?nil selected_fields) -> Document

  def query?: (untyped object) -> bool
end

# This class is the wrapper for all referenced associations that have a
# target that can be a criteria or array of _loaded documents. This
# handles both cases or a combination of the two.
class Mongoid::Association::Mongoid::Association::Referenced::Mongoid::Association::Mongoid::Association::Referenced::HasMany::Enumerable
  include ::Enumerable

  extend Forwardable

  # Check if the enumerable is equal to the other object.
  #
  # _@param_ `other` — The other enumerable.
  #
  # _@return_ — If the objects are equal.
  #
  # Check equality.
  # ```ruby
  # enumerable == []
  # ```
  def ==: (::Enumerable[untyped] other) -> bool

  # Check equality of the enumerable against the provided object for case
  # statements.
  #
  # _@param_ `other` — The object to check.
  #
  # _@return_ — If the objects are equal in a case.
  #
  # Check case equality.
  # ```ruby
  # enumerable === Array
  # ```
  def ===: (Object other) -> bool

  # Append a document to the enumerable.
  #
  # _@param_ `document` — The document to append.
  #
  # _@return_ — The document.
  #
  # Append the document.
  # ```ruby
  # enumerable << document
  # ```
  def <<: (Document document) -> Document

  # Clears out all the documents in this enumerable. If passed a block it
  # will yield to each document that is in memory.
  #
  # _@return_ — The cleared out _added docs.
  #
  # Clear out the enumerable.
  # ```ruby
  # enumerable.clear
  # ```
  #
  # Clear out the enumerable with a block.
  # ```ruby
  # enumerable.clear do |doc|
  #   doc.unbind
  # end
  # ```
  def clear: () -> ::Array[Document]

  # Clones each document in the enumerable.
  #
  # _@return_ — An array clone of the enumerable.
  #
  # Clone the enumerable.
  # ```ruby
  # enumerable.clone
  # ```
  #
  # _@note_ — This loads all documents into memory.
  def clone: () -> ::Array[Document]

  # Delete the supplied document from the enumerable.
  #
  # _@param_ `document` — The document to delete.
  #
  # _@return_ — The deleted document.
  #
  # Delete the document.
  # ```ruby
  # enumerable.delete(document)
  # ```
  def delete: (Document document) -> Document

  # Deletes every document in the enumerable for where the block returns
  # true.
  #
  # _@return_ — The remaining docs.
  #
  # Delete all matching documents.
  # ```ruby
  # enumerable.delete_if do |doc|
  #   dod._id == _id
  # end
  # ```
  #
  # _@note_ — This operation loads all documents from the database.
  def delete_if: () { () -> untyped } -> ::Array[Document]

  # Iterating over this enumerable has to handle a few different
  # scenarios.
  #
  # If the enumerable has its criteria _loaded into memory then it yields
  # to all the _loaded docs and all the _added docs.
  #
  # If the enumerable has not _loaded the criteria then it iterates over
  # the cursor while loading the documents and then iterates over the
  # _added docs.
  #
  # If no block is passed then it returns an enumerator containing all
  # docs.
  #
  # _@return_ — That the enumerable is now _loaded.
  #
  # Iterate over the enumerable.
  # ```ruby
  # enumerable.each do |doc|
  #   puts doc
  # end
  # ```
  #
  # return an enumerator containing all the docs
  # ```ruby
  #
  # a = enumerable.each
  # ```
  def each: () -> bool

  # Is the enumerable empty? Will determine if the count is zero based on
  # whether or not it is _loaded.
  #
  # _@return_ — If the enumerable is empty.
  #
  # Is the enumerable empty?
  # ```ruby
  # enumerable.empty?
  # ```
  def empty?: () -> bool

  # sord infer - argument name in single @param inferred as "*args"
  # Returns whether the association has any documents, optionally
  # subject to the provided filters.
  #
  # This method returns true if the association has any persisted
  # documents and if it has any not yet persisted documents.
  #
  # If the association is already loaded, this method inspects the
  # loaded documents and does not query the database. If the
  # association is not loaded, the argument-less and block-less
  # version does not load the association; the other versions
  # (that delegate to Enumerable) may or may not load the association
  # completely depending on whether it is iterated to completion.
  #
  # This method can take a parameter and a block. The behavior with
  # either the paramater or the block is delegated to the standard
  # library Enumerable module.
  #
  # Note that when Enumerable's any? method is invoked with both
  # a block and a pattern, it only uses the pattern.
  #
  # _@param_ `condition` — The condition that documents must satisfy. See Enumerable documentation for details.
  #
  # _@return_ — If the association has any documents.
  def any?: (*Object args) -> bool

  # Get the first document in the enumerable. Will check the persisted
  # documents first. Does not load the entire enumerable.
  #
  # _@param_ `opts` — The options for the query returning the first document.
  #
  # _@return_ — The first document found.
  #
  # Get the first document.
  # ```ruby
  # enumerable.first
  # ```
  #
  # _@note_ — Automatically adding a sort on _id when no other sort is
  # defined on the criteria has the potential to cause bad performance issues.
  # If you experience unexpected poor performance when using #first or #last,
  # use the option { id_sort: :none }.
  # Be aware that #first/#last won't guarantee order in this case.
  def first: (?::Hash[untyped, untyped] opts) -> Document

  # Initialize the new enumerable either with a criteria or an array.
  #
  # _@param_ `target` — The wrapped object.
  #
  # Initialize the enumerable with a criteria.
  # ```ruby
  # Enumberable.new(Post.where(:person_id => id))
  # ```
  #
  # Initialize the enumerable with an array.
  # ```ruby
  # Enumerable.new([ post ])
  # ```
  def initialize: (Criteria | ::Array[Document] target, ?untyped base, ?untyped association) -> void

  # Does the target include the provided document?
  #
  # _@param_ `doc` — The document to check.
  #
  # _@return_ — If the document is in the target.
  #
  # Does the target include the document?
  # ```ruby
  # enumerable.include?(document)
  # ```
  def include?: (Document doc) -> bool

  # Inspection will just inspect the entries for nice array-style
  # printing.
  #
  # _@return_ — The inspected enum.
  #
  # Inspect the enumerable.
  # ```ruby
  # enumerable.inspect
  # ```
  def inspect: () -> String

  # Return all the documents in the enumerable that have been _loaded or
  # _added.
  #
  # _@return_ — The in memory docs.
  #
  # Get the in memory docs.
  # ```ruby
  # enumerable.in_memory
  # ```
  #
  # _@note_ — When passed a block it yields to each document.
  def in_memory: () -> ::Array[Document]

  # Get the last document in the enumerable. Will check the new
  # documents first. Does not load the entire enumerable.
  #
  # _@param_ `opts` — The options for the query returning the first document.
  #
  # _@return_ — The last document found.
  #
  # Get the last document.
  # ```ruby
  # enumerable.last
  # ```
  #
  # _@note_ — Automatically adding a sort on _id when no other sort is
  # defined on the criteria has the potential to cause bad performance issues.
  # If you experience unexpected poor performance when using #first or #last,
  # use the option { id_sort: :none }.
  # Be aware that #first/#last won't guarantee order in this case.
  def last: (?::Hash[untyped, untyped] opts) -> Document

  # Has the enumerable been _loaded? This will be true if the criteria has
  # been executed or we manually load the entire thing.
  #
  # _@return_ — If the enumerable has been _loaded.
  #
  # Is the enumerable _loaded?
  # ```ruby
  # enumerable._loaded?
  # ```
  def _loaded?: () -> bool

  # Provides the data needed to Marshal.dump an enumerable proxy.
  #
  # _@return_ — The dumped data.
  #
  # Dump the proxy.
  # ```ruby
  # Marshal.dump(proxy)
  # ```
  def marshal_dump: () -> ::Array[Object]

  # Loads the data needed to Marshal.load an enumerable proxy.
  #
  # _@return_ — The dumped data.
  #
  # Load the proxy.
  # ```ruby
  # Marshal.load(proxy)
  # ```
  def marshal_load: (untyped data) -> ::Array[Object]

  # Reset the enumerable back to its persisted state.
  #
  # _@return_ — Always false.
  #
  # Reset the enumerable.
  # ```ruby
  # enumerable.reset
  # ```
  def reset: () -> bool

  # Resets the underlying unloaded criteria object with a new one. Used
  # my HABTM associations to keep the underlying array in sync.
  #
  # _@param_ `criteria` — The criteria to replace with.
  #
  # Reset the unloaded documents.
  # ```ruby
  # enumerable.reset_unloaded(criteria)
  # ```
  def reset_unloaded: (Criteria criteria) -> untyped

  # Does this enumerable respond to the provided method?
  #
  # _@param_ `name` — The name of the method.
  #
  # _@param_ `include_private` — Whether to include private methods.
  #
  # _@return_ — Whether the enumerable responds.
  #
  # Does the enumerable respond to the method?
  # ```ruby
  # enumerable.respond_to?(:sum)
  # ```
  def respond_to?: (String | Symbol name, ?bool include_private) -> bool

  # Gets the total size of this enumerable. This is a combination of all
  # the persisted and unpersisted documents.
  #
  # _@return_ — The size of the enumerable.
  #
  # Get the size.
  # ```ruby
  # enumerable.size
  # ```
  def size: () -> Integer

  # Send #to_json to the entries.
  #
  # _@param_ `options` — Optional parameters.
  #
  # _@return_ — The entries all _loaded as a string.
  #
  # Get the enumerable as json.
  # ```ruby
  # enumerable.to_json
  # ```
  def to_json: (?::Hash[untyped, untyped] options) -> String

  # Send #as_json to the entries, without encoding.
  #
  # _@param_ `options` — Optional parameters.
  #
  # _@return_ — The entries all _loaded as a hash.
  #
  # Get the enumerable as json.
  # ```ruby
  # enumerable.as_json
  # ```
  def as_json: (?::Hash[untyped, untyped] options) -> ::Hash[untyped, untyped]

  # Return all the unique documents in the enumerable.
  #
  # _@return_ — The unique documents.
  #
  # Get all the unique documents.
  # ```ruby
  # enumerable.uniq
  # ```
  #
  # _@note_ — This operation loads all documents from the database.
  def uniq: () -> ::Array[Document]

  def set_base: (untyped document) -> untyped

  def method_missing: (untyped name, *untyped args) { () -> untyped } -> untyped

  def unloaded_documents: () -> untyped
end

# This module handles the behavior for synchronizing foreign keys between
# both sides of a many to many associations.
module Mongoid::Association::Mongoid::Association::Referenced::Syncable
  # The three main instance variables are collections of documents.
  #
  # The three main instance variables are collections of documents.
  #
  # The three main instance variables are collections of documents.
  #
  # The three main instance variables are collections of documents.
  #
  # The three main instance variables are collections of documents.
  #
  # The three main instance variables are collections of documents.
  #
  # Is the document able to be synced on the inverse side? This is only if
  # the key has changed and the association bindings have not been run.
  #
  # _@param_ `association` — The association metadata.
  #
  # _@return_ — If we can sync.
  #
  # Are the foreign keys syncable?
  # ```ruby
  # document._syncable?(association)
  # ```
  def _syncable?: () -> untyped
                | () -> untyped
                | () -> untyped
                | () -> untyped
                | () -> untyped
                | () -> untyped
                | (Association association) -> bool

  # Get the synced foreign keys.
  #
  # _@return_ — The synced foreign keys.
  #
  # Get the synced foreign keys.
  # ```ruby
  # document._synced
  # ```
  def _synced: () -> ::Hash[untyped, untyped]

  # Has the document been synced for the foreign key?
  #
  # _@param_ `foreign_key` — The foreign key.
  #
  # _@return_ — If we can sync.
  #
  # Has the document been synced?
  # ```ruby
  # document._synced?
  # ```
  def _synced?: (String foreign_key) -> bool

  # Update the inverse keys on destroy.
  #
  # _@param_ `association` — The association.
  #
  # _@return_ — The updated values.
  #
  # Update the inverse keys.
  # ```ruby
  # document.remove_inverse_keys(association)
  # ```
  def remove_inverse_keys: (Association association) -> Object

  # Update the inverse keys for the association.
  #
  # _@param_ `association` — The document association.
  #
  # _@return_ — The updated values.
  #
  # Update the inverse keys
  # ```ruby
  # document.update_inverse_keys(association)
  # ```
  def update_inverse_keys: (Association association) -> Object
end

module Mongoid::Association::Mongoid::Association::Referenced::Mongoid::Association::Mongoid::Association::Referenced::Syncable::ClassMethods
  # Set up the syncing of many to many foreign keys.
  #
  # _@param_ `association` — The association metadata.
  #
  # Set up the syncing.
  # ```ruby
  # Person._synced(association)
  # ```
  def _synced: (Association association) -> untyped

  # Set up the sync of inverse keys that needs to happen on a save.
  #
  # If the foreign key field has changed and the document is not
  # synced, $addToSet the new ids, $pull the ones no longer in the
  # array from the inverse side.
  #
  # _@param_ `association` — The association metadata.
  #
  # _@return_ — The class getting set up.
  #
  # Set up the save syncing.
  # ```ruby
  # Person.synced_save(association)
  # ```
  def synced_save: (Association association) -> Class

  # Set up the sync of inverse keys that needs to happen on a destroy.
  #
  # _@param_ `association` — The association metadata.
  #
  # _@return_ — The class getting set up.
  #
  # Set up the destroy syncing.
  # ```ruby
  # Person.synced_destroy(association)
  # ```
  def synced_destroy: (Association association) -> Class
end

module Mongoid::Association::Mongoid::Association::Referenced::AutoSave
  extend ActiveSupport::Concern

  # Used to prevent infinite loops in associated autosaves.
  #
  # _@return_ — Has the document already been autosaved?
  #
  # Is the document autosaved?
  # ```ruby
  # document.autosaved?
  # ```
  def autosaved?: () -> bool

  # Begin the associated autosave.
  #
  # Begin autosave.
  # ```ruby
  # document.__autosaving__
  # ```
  def __autosaving__: () -> untyped

  # Check if there is changes for auto-saving
  #
  #   document.changed_for_autosave?
  #
  # Return true if there is changes on self or in
  # ```ruby
  # autosaved associations.
  # ```
  def changed_for_autosave?: (untyped doc) -> bool

  # Define the autosave method on an association's owning class for
  # an associated object.
  #
  # _@param_ `association` — The association for which autosaving is enabled.
  #
  # _@return_ — The association's owner class.
  #
  # Define the autosave method:
  # ```ruby
  # Association::Referenced::Autosave.define_autosave!(association)
  # ```
  def self.define_autosave!: (Association association) -> Class
end

# The BelongsTo type association.
#
# @since 7.0
class Mongoid::Association::Mongoid::Association::Referenced::BelongsTo
  include Mongoid::Association::Relatable

  include Mongoid::Association::Referenced::BelongsTo::Buildable

  # The list of association complements.
  #
  # _@return_ — The association complements.
  def relation_complements: () -> ::Array[Association]

  # Setup the instance methods, fields, etc. on the association owning class.
  def setup!: () -> self

  # Does this association type store the foreign key?
  #
  # _@return_ — Always true.
  def stores_foreign_key?: () -> bool

  # Is this association type embedded?
  #
  # _@return_ — Always false.
  def embedded?: () -> bool

  # The default for validation the association object.
  #
  # _@return_ — Always false.
  def validation_default: () -> bool

  # Get the foreign key field for saving the association reference.
  #
  # _@return_ — The foreign key field for saving the association reference.
  def foreign_key: () -> String

  # sord warn - Association::BelongsTo::Proxy wasn't able to be resolved to a constant in this project
  # Get the association proxy class for this association type.
  #
  # _@return_ — The proxy class.
  def relation: () -> Mongoid::Association::Referenced::BelongsTo::Proxy

  # Is this association polymorphic?
  #
  # _@return_ — Whether this association is polymorphic.
  def polymorphic?: () -> bool

  # The name of the field used to store the type of polymorphic association.
  #
  # _@return_ — The field used to store the type of polymorphic association.
  def inverse_type: () -> String

  # The nested builder object.
  #
  # _@param_ `attributes` — The attributes to use to build the association object.
  #
  # _@param_ `options` — The options for the association.
  #
  # _@return_ — The Nested Builder object.
  def nested_builder: (::Hash[untyped, untyped] attributes, ::Hash[untyped, untyped] options) -> Association::Nested::One

  # sord infer - Root was resolved to Mongoid::Atomic::Paths::Root
  # Get the path calculator for the supplied document.
  #
  # _@param_ `document` — The document to calculate on.
  #
  # _@return_ — The root atomic path calculator.
  #
  # Get the path calculator.
  # ```ruby
  # association.path(document)
  # ```
  def path: (Document document) -> Mongoid::Atomic::Paths::Root

  def setup_instance_methods!: () -> untyped

  def index_spec: () -> untyped

  def default_primary_key: () -> untyped

  def default_foreign_key_field: () -> untyped

  def polymorph!: () -> untyped

  def polymorphic_inverses: (?untyped other) -> untyped

  def determine_inverses: (untyped other) -> untyped

  # If set to true, then the associated object will be validated when this object is saved
  def require_association?: () -> bool

  def create_foreign_key_field!: () -> untyped

  def build: (Object base, Object object, ?String? `type`, ?nil selected_fields) -> Document

  def execute_query: (untyped object, untyped `type`) -> untyped

  def query_criteria: (untyped object, untyped `type`) -> untyped

  def query?: (untyped object) -> bool

  def initialize: (Class _class, Symbol name, ?::Hash[untyped, untyped] opts) { () -> untyped } -> void

  # Compare this association to another.
  #
  # _@return_ — The object to compare to this association.
  def ==: (untyped other) -> Object

  # Get the callbacks for a given type.
  #
  # _@param_ `callback_type` — The type of callback type.
  #
  # _@return_ — A list of the callbacks, either method
  # names or Procs.
  def get_callbacks: (Symbol callback_type) -> ::Array[Proc | Symbol]

  # Get the type setter.
  #
  # _@return_ — The type setter method.
  #
  # _@note_ — Only relevant for polymorphic associations that take the :as option.
  def type_setter: () -> String

  # Whether trying to bind an object using this association should raise
  # an error.
  #
  # _@param_ `doc` — The document to be bound.
  #
  # _@return_ — Whether the document can be bound.
  def bindable?: (Document doc) -> bool

  # Get the inverse names.
  #
  # _@param_ `other` — The other model class or model object to use when determining inverses.
  #
  # _@return_ — The list of inverse names.
  def inverses: (?Object? other) -> ::Array[Symbol]

  # Get the inverse's association metadata.
  #
  # _@param_ `other` — The other model class or model object to use when determining inverses.
  #
  # _@return_ — The inverse's association metadata.
  def inverse_association: (?Object? other) -> Association

  # The class name, possibly unqualified or :: prefixed, of the association
  # object(s).
  #
  # This method returns the class name as it is used in the association
  # definition. If :class_name option is given in the association, the
  # exact value of that option is returned here. If :class_name option is
  # not given, the name of the class is calculated from association name
  # but is not resolved to the actual class.
  #
  # The class name returned by this method may not correspond to a defined
  # class, either because the corresponding class has not been loaded yet,
  # or because the association references a non-existent class altogether.
  # To obtain the association class, use +relation_class+ method.
  #
  # _@return_ — The association objects' class name.
  #
  # _@note_ — The return value of this method should not be used to determine
  # whether two associations have the same target class, because the
  # return value is not always a fully qualified class name. To compare
  # classes, retrieve the class instance of the association target using
  # the +relation_class+ method.
  def relation_class_name: () -> String

  # The class of the association object(s).
  #
  # This method returns the class instance corresponding to
  # +relation_class_name+, resolved relative to the host document class.
  #
  # If the class does not exist, this method raises NameError. This can
  # happen because the target class has not yet been defined. Note that
  # polymorphic associations generally do not have a well defined target
  # class because the target class can change from one object to another,
  # and calling this method on a polymorphic association will generally
  # fail with a NameError or produce misleading results (if a class does
  # happen to be defined with the same name as the association name).
  #
  # _@return_ — The association objects' class.
  def relation_class: () -> String

  # The class name of the object owning this association.
  #
  # _@return_ — The owning objects' class name.
  def inverse_class_name: () -> String

  # The class of the object owning this association.
  #
  # _@return_ — The owning objects' class.
  def inverse_class: () -> String

  # The foreign key field if this association stores a foreign key.
  # Otherwise, the primary key.
  #
  # _@return_ — The primary key.
  def key: () -> (Symbol | String)

  # The name of the setter on this object for assigning an associated object.
  #
  # _@return_ — The setter name.
  def setter: () -> String

  # The name of the inverse setter method.
  #
  # _@return_ — The name of the inverse setter.
  def inverse_setter: (?untyped other) -> String

  # The name of the foreign key setter method.
  #
  # _@return_ — The name of the foreign key setter.
  def foreign_key_setter: () -> String

  # Gets the setter for the field that sets the type of document on a
  # polymorphic association.
  #
  # _@return_ — The name of the setter.
  #
  # Get the inverse type setter.
  # ```ruby
  # association.inverse_type_setter
  # ```
  def inverse_type_setter: () -> String

  # Get the name of the method to check if the foreign key has changed.
  #
  # _@return_ — The foreign key check.
  #
  # Get the foreign key check method.
  # ```ruby
  # association.foreign_key_check
  # ```
  def foreign_key_check: () -> String

  # Create an association proxy object using the owner and target.
  #
  # _@param_ `owner` — The document this association hangs off of.
  #
  # _@param_ `target` — The target (parent) of the association.
  def create_relation: (Document owner, Document | ::Array[Document] target) -> Proxy

  # Whether the dependent method is destructive.
  #
  # _@return_ — If the dependent method is destructive.
  def destructive?: () -> bool

  # Get the counter cache column name.
  #
  # _@return_ — The counter cache column name.
  def counter_cache_column_name: () -> String

  # Get the extension.
  #
  # _@return_ — The extension module, if one has been defined.
  def extension: () -> Module

  # Get the inverse name.
  #
  # _@return_ — The inverse name.
  def inverse: (?untyped other) -> Symbol

  # Whether the associated object(s) should be validated.
  #
  # _@return_ — If the associated object(s)
  # should be validated.
  def validate?: () -> bool

  # Gets the model classes with inverse associations of this model. This is used to determine
  # the classes on the other end of polymorphic associations with models.
  def inverse_association_classes: () -> untyped

  def setup_index!: () -> untyped

  def define_touchable!: () -> untyped

  def define_autosaver!: () -> untyped

  def define_builder!: () -> untyped

  def define_creator!: () -> untyped

  def define_getter!: () -> untyped

  def define_setter!: () -> untyped

  def define_existence_check!: () -> untyped

  def define_ids_getter!: () -> untyped

  def define_ids_setter!: () -> untyped

  def define_counter_cache_callbacks!: () -> untyped

  def define_dependency!: () -> untyped

  def validate!: () -> untyped

  def create_extension!: () { () -> untyped } -> untyped

  def default_inverse: () -> untyped

  # Returns an array of classes/modules forming the namespace hierarchy
  # where symbols referenced in the provided class/module would be looked
  # up by Ruby. For example, if mod is Foo::Bar, this method would return
  # [Foo::Bar, Foo, Object].
  def namespace_hierarchy: (untyped mod) -> untyped

  # Resolves the given class/module name in the context of the specified
  # module, as Ruby would when a constant is referenced in the source.
  #
  # _@note_ — This method can swallow exceptions produced during class loading,
  # because it rescues NameError internally. Since this method attempts
  # to load classes, failure during the loading process may also lead to
  # there being incomplete class definitions.
  def resolve_name: (untyped mod, untyped name) -> untyped

  # Returns the name of the parent to a polymorphic child.
  #
  # _@return_ — The name.
  def as: () -> (String | Symbol)

  # Specify what happens to the associated object when the owner is destroyed.
  #
  # _@return_ — The dependent option.
  def dependent: () -> String

  # The custom sorting options on the association.
  #
  # _@return_ — The custom sorting options.
  def order: () -> Criteria::Queryable::Key

  # Whether to index the primary or foreign key field.
  def indexed?: () -> bool

  # Whether the association is autobuilding.
  def autobuilding?: () -> bool

  # Is the association cyclic.
  #
  # _@return_ — Whether the association is cyclic.
  def cyclic?: () -> bool

  # The name the owning object uses to refer to this association.
  #
  # _@return_ — The inverse_of option.
  def inverse_of: () -> String

  # Mongoid assumes that the field used to hold the primary key of the association is id.
  # You can override this and explicitly specify the primary key with the :primary_key option.
  #
  # _@return_ — The primary key.
  def primary_key: () -> (Symbol | String)

  # Options to save any loaded members and destroy members that are marked for destruction
  # when the parent object is saved.
  #
  # _@return_ — The autosave option.
  def autosave: () -> bool

  # Whether the association is counter-cached.
  def counter_cached?: () -> bool

  # Whether the association has callbacks cascaded down from the parent.
  #
  # _@return_ — Whether callbacks are cascaded.
  def cascading_callbacks?: () -> bool

  # The store_as option.
  #
  # _@return_ — Default is nil.
  def store_as: () -> nil

  # Whether the association has forced nil inverse (So no foreign keys are saved).
  #
  # _@return_ — Default is false.
  def forced_nil_inverse?: () -> bool

  # The field for saving the associated object's type.
  #
  # _@return_ — Default is nil.
  def type: () -> nil

  # The field for saving the associated object's type.
  #
  # _@return_ — Default is nil.
  def touch_field: () -> nil

  def touchable?: () -> bool

  # Convert the supplied object to the appropriate type to set as the
  # foreign key for an association.
  #
  # _@param_ `object` — The object to convert.
  #
  # _@return_ — The object cast to the correct type.
  #
  # Convert the object.
  # ```ruby
  # constraint.convert("12345")
  # ```
  def convert_to_foreign_key: (Object object) -> Object

  def convert_polymorphic: (untyped object) -> untyped
end

Mongoid::Association::Mongoid::Association::Referenced::Mongoid::Association::Mongoid::Association::Referenced::BelongsTo::ASSOCIATION_OPTIONS: untyped

Mongoid::Association::Mongoid::Association::Referenced::Mongoid::Association::Mongoid::Association::Referenced::BelongsTo::VALID_OPTIONS: untyped

Mongoid::Association::Mongoid::Association::Referenced::Mongoid::Association::Mongoid::Association::Referenced::BelongsTo::FOREIGN_KEY_FIELD_TYPE: untyped

Mongoid::Association::Mongoid::Association::Referenced::Mongoid::Association::Mongoid::Association::Referenced::BelongsTo::FOREIGN_KEY_SUFFIX: untyped

Mongoid::Association::Mongoid::Association::Referenced::Mongoid::Association::Mongoid::Association::Referenced::BelongsTo::SHARED_OPTIONS: untyped

Mongoid::Association::Mongoid::Association::Referenced::Mongoid::Association::Mongoid::Association::Referenced::BelongsTo::PRIMARY_KEY_DEFAULT: untyped

# Eager class for belongs_to associations.
class Mongoid::Association::Mongoid::Association::Referenced::Mongoid::Association::Mongoid::Association::Referenced::BelongsTo::Eager < Mongoid::Association::Referenced::Eager::Base
  def preload: () -> untyped

  # Retrieves the documents referenced by the association, and
  # yields each one sequentially to the provided block. If the
  # association is not polymorphic, all documents are retrieved in
  # a single query. If the association is polymorphic, one query is
  # issued per association target class.
  def each_loaded_document: () { () -> untyped } -> untyped

  # Returns a map from association target class name to foreign key
  # values for the documents of that association target class,
  # as referenced by this association.
  def keys_by_type_from_docs: () -> untyped

  def group_by_key: () -> untyped

  def key: () -> untyped
end

# This class handles all behavior for associations that are either
# one-to-many or one-to-one, where the foreign key is stored on this side
# of the association and the reference is to document(s) in another
# collection.
class Mongoid::Association::Mongoid::Association::Referenced::Mongoid::Association::Mongoid::Association::Referenced::BelongsTo::Proxy < Mongoid::Association::One
  include Mongoid::Evolvable

  # Instantiate a new belongs_to association proxy.
  #
  # _@param_ `base` — The document this association hangs off of.
  #
  # _@param_ `target` — The target (parent) of the association.
  #
  # _@param_ `association` — The association object.
  #
  # Create the new proxy.
  # ```ruby
  # Association::BelongsTo::Proxy.new(game, person, association)
  # ```
  def initialize: (Document base, Document | ::Array[Document] target, Association association) -> void

  # Removes the association between the base document and the target
  # document by deleting the foreign key and the reference, orphaning
  # the target document in the process.
  #
  # Nullify the association.
  # ```ruby
  # person.game.nullify
  # ```
  def nullify: () -> untyped

  # Substitutes the supplied target documents for the existing document
  # in the association.
  #
  # _@param_ `replacement` — The replacement.
  #
  # _@return_ — The association or nil.
  #
  # Substitute the association.
  # ```ruby
  # name.substitute(new_name)
  # ```
  def substitute: (Document | ::Array[Document] replacement) -> self?

  # sord warn - Binding wasn't able to be resolved to a constant in this project
  # Instantiate the binding associated with this association.
  #
  # _@return_ — The binding object.
  #
  # Get the binding object.
  # ```ruby
  # binding([ address ])
  # ```
  def binding: () -> Binding

  # Normalize the value provided as a replacement for substitution.
  #
  # _@param_ `replacement` — The replacement object.
  #
  # _@return_ — The document.
  #
  # Normalize the substitute.
  # ```ruby
  # proxy.normalize(id)
  # ```
  def normalize: (Document | Object replacement) -> Document

  # Are we able to persist this association?
  #
  # _@return_ — If the association is persistable.
  #
  # Can we persist the association?
  # ```ruby
  # relation.persistable?
  # ```
  def persistable?: () -> bool

  # Get the Eager object for this type of association.
  #
  # _@param_ `association` — The association object.
  #
  # _@param_ `docs` — The array of documents.
  #
  # Get the eager loader object
  # ```ruby
  # ```
  def self.eager_loader: (Association association, ::Array[Document] docs) -> untyped

  # Returns true if the association is an embedded one. In this case
  # always false.
  #
  # _@return_ — Always false.
  #
  # Is this association embedded?
  # ```ruby
  # Association::BelongsTo::Proxy.embedded?
  # ```
  def self.embedded?: () -> bool

  # Evolve the document into an object id.
  #
  # _@return_ — The document's id.
  #
  # Evolve the document.
  # ```ruby
  # document.__evolve_object_id__
  # ```
  def __evolve_object_id__: () -> Object
end

# Binding class for belongs_to associations.
class Mongoid::Association::Mongoid::Association::Referenced::Mongoid::Association::Mongoid::Association::Referenced::BelongsTo::Binding
  include Mongoid::Association::Bindable

  # Binds the base object to the inverse of the association. This is so we
  # are referenced to the actual objects themselves on both sides.
  #
  # This case sets the association on the inverse object as well as the
  # document itself.
  #
  # Bind the documents.
  # ```ruby
  # game.person.bind(:continue => true)
  # game.person = Person.new
  # ```
  def bind_one: () -> untyped

  # Unbinds the base object and the inverse, caused by setting the
  # reference to nil.
  #
  # Unbind the document.
  # ```ruby
  # game.person.unbind(:continue => true)
  # game.person = nil
  # ```
  def unbind_one: () -> untyped

  # Check for problems with multiple inverse definitions.
  #
  # _@param_ `doc` — The document to check.
  #
  # Check for inverses errors.
  # ```ruby
  # binding.check_inverses!(doc)
  # ```
  def check_polymorphic_inverses!: (Document doc) -> untyped

  # Create the new binding.
  #
  # _@param_ `base` — The base of the binding.
  #
  # _@param_ `target` — The target of the binding.
  #
  # _@param_ `association` — The association metadata.
  #
  # Initialize a binding.
  # ```ruby
  # Binding.new(base, target, association)
  # ```
  def initialize: (Document base, Document | ::Array[Document] target, Association association) -> void

  # Execute the provided block inside a binding.
  #
  # _@return_ — The result of the yield.
  #
  # Execute the binding block.
  # ```ruby
  # binding.binding do
  #   base.foreign_key = 1
  # end
  # ```
  def binding: () -> Object

  # Check if the inverse is properly defined.
  #
  # _@param_ `doc` — The document getting bound.
  #
  # Check the inverse definition.
  # ```ruby
  # binding.check_inverse!(doc)
  # ```
  def check_inverse!: (Document doc) -> untyped

  # Set the id of the related document in the foreign key field on the
  # keyed document.
  #
  # _@param_ `keyed` — The document that stores the foreign key.
  #
  # _@param_ `id` — The id of the bound document.
  #
  # Bind the foreign key.
  # ```ruby
  # binding.bind_foreign_key(post, person._id)
  # ```
  def bind_foreign_key: (Document keyed, Object id) -> untyped

  # Set the type of the related document on the foreign type field, used
  # when associations are polymorphic.
  #
  # _@param_ `typed` — The document that stores the type field.
  #
  # _@param_ `name` — The name of the model.
  #
  # Bind the polymorphic type.
  # ```ruby
  # binding.bind_polymorphic_type(post, "Person")
  # ```
  def bind_polymorphic_type: (Document typed, String name) -> untyped

  # Set the type of the related document on the foreign type field, used
  # when associations are polymorphic.
  #
  # _@param_ `typed` — The document that stores the type field.
  #
  # _@param_ `name` — The name of the model.
  #
  # Bind the polymorphic type.
  # ```ruby
  # binding.bind_polymorphic_inverse_type(post, "Person")
  # ```
  def bind_polymorphic_inverse_type: (Document typed, String name) -> untyped

  # Bind the inverse document to the child document so that the in memory
  # instances are the same.
  #
  # _@param_ `doc` — The base document.
  #
  # _@param_ `inverse` — The inverse document.
  #
  # Bind the inverse.
  # ```ruby
  # binding.bind_inverse(post, person)
  # ```
  def bind_inverse: (Document doc, Document inverse) -> untyped

  # Bind the provided document with the base from the parent association.
  #
  # _@param_ `doc` — The document to bind.
  #
  # Bind the document with the base.
  # ```ruby
  # binding.bind_from_relational_parent(doc)
  # ```
  def bind_from_relational_parent: (Document doc) -> untyped

  def record_id: (untyped _base) -> untyped

  # Ensure that the association on the base is correct, for the cases
  # where we have multiple belongs to definitions and were are setting
  # different parents in memory in order.
  #
  # _@return_ — If the association changed.
  #
  # Set the base association.
  # ```ruby
  # binding.set_base_association
  # ```
  def set_base_association: () -> bool

  # Bind the provided document with the base from the parent association.
  #
  # _@param_ `doc` — The document to unbind.
  #
  # Bind the document with the base.
  # ```ruby
  # unbinding.unbind_from_relational_parent(doc)
  # ```
  def unbind_from_relational_parent: (Document doc) -> untyped

  # Begin the assignment of attributes. While in this block embedded
  # documents will not autosave themselves in order to allow the document to
  # be in a valid state.
  #
  # _@return_ — The yielded value.
  #
  # Execute the assignment.
  # ```ruby
  # _assigning do
  #   person.attributes = { :addresses => [ address ] }
  # end
  # ```
  def _assigning: () -> Object

  # Is the current thread in assigning mode?
  #
  # _@return_ — If the thread is assigning.
  #
  # Is the current thread in assigning mode?
  # ```ruby
  # proxy._assigning?
  # ```
  def _assigning?: () -> bool

  # Execute a block in binding mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in binding mode.
  # ```ruby
  # binding do
  #   relation.push(doc)
  # end
  # ```
  def _binding: () -> Object

  # Is the current thread in binding mode?
  #
  # _@return_ — If the thread is binding.
  #
  # Is the current thread in binding mode?
  # ```ruby
  # proxy.binding?
  # ```
  def _binding?: () -> bool

  # Execute a block in building mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in building mode.
  # ```ruby
  # _building do
  #   relation.push(doc)
  # end
  # ```
  def _building: () -> Object

  # Is the current thread in building mode?
  #
  # _@return_ — If the thread is building.
  #
  # Is the current thread in building mode?
  # ```ruby
  # proxy._building?
  # ```
  def _building?: () -> bool

  # Is the current thread in creating mode?
  #
  # _@return_ — If the thread is creating.
  #
  # Is the current thread in creating mode?
  # ```ruby
  # proxy.creating?
  # ```
  def _creating?: () -> bool

  # Execute a block in loading mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in loading mode.
  # ```ruby
  # _loading do
  #   relation.push(doc)
  # end
  # ```
  def _loading: () -> Object

  # Is the current thread in loading mode?
  #
  # _@return_ — If the thread is loading.
  #
  # Is the current thread in loading mode?
  # ```ruby
  # proxy._loading?
  # ```
  def _loading?: () -> bool
end

# The Builder behavior for belongs_to associations.
#
# @since 7.0
module Mongoid::Association::Mongoid::Association::Referenced::Mongoid::Association::Mongoid::Association::Referenced::BelongsTo::Buildable
  def build: (Object base, Object object, ?String? `type`, ?nil selected_fields) -> Document

  def execute_query: (untyped object, untyped `type`) -> untyped

  def query_criteria: (untyped object, untyped `type`) -> untyped

  def query?: (untyped object) -> bool
end

module Mongoid::Association::Mongoid::Association::Referenced::CounterCache
  extend ActiveSupport::Concern

  # Reset the given counter using the .count() query from the
  # db. This method is usuful in case that a counter got
  # corrupted, or a new counter was added to the collection.
  #
  # _@param_ `counters` — One or more counter caches to reset
  #
  # Reset the given counter cache
  # ```ruby
  # post.reset_counters(:comments)
  # ```
  def reset_counters: (*Symbol | ::Array[untyped] counters) -> untyped

  # Add the callbacks responsible for update the counter cache field.
  #
  # _@param_ `association` — The association.
  #
  # _@return_ — The association's owning class.
  #
  # Add the touchable.
  # ```ruby
  # Mongoid::Association::Referenced::CounterCache.define_callbacks!(association)
  # ```
  def self.define_callbacks!: (Association association) -> Class
end

module Mongoid::Association::Mongoid::Association::Referenced::Mongoid::Association::Mongoid::Association::Referenced::CounterCache::ClassMethods
  # Reset the given counter using the .count() query from the
  # db. This method is usuful in case that a counter got
  # corrupted, or a new counter was added to the collection.
  #
  # _@param_ `id` — The id of the object that will be reset.
  #
  # _@param_ `counters` — One or more counter caches to reset
  #
  # Reset the given counter cache
  # ```ruby
  # Post.reset_counters('50e0edd97c71c17ea9000001', :comments)
  # ```
  def reset_counters: (String id, *Symbol | ::Array[untyped] counters) -> untyped

  # Update the given counters by the value factor. It uses the
  # atomic $inc command.
  #
  # _@param_ `id` — The id of the object to update.
  #
  # _@param_ `counters`
  #
  # Add 5 to comments counter and remove 2 from likes
  # ```ruby
  # counter.
  # Post.update_counters('50e0edd97c71c17ea9000001',
  #            :comments_count => 5, :likes_count => -2)
  # ```
  def update_counters: (String id, ::Hash[untyped, untyped] counters) -> untyped

  # Increment the counter name from the entries that match the
  # id by one. This method is used on associations callbacks
  # when counter_cache is enabled
  #
  # _@param_ `counter_name` — Counter cache name
  #
  # _@param_ `id` — The id of the object that will have its counter incremented.
  #
  # Increment comments counter
  # ```ruby
  # Post.increment_counter(:comments_count, '50e0edd97c71c17ea9000001')
  # ```
  def increment_counter: (Symbol counter_name, String id) -> untyped

  # Decrement the counter name from the entries that match the
  # id by one. This method is used on associations callbacks
  # when counter_cache is enabled
  #
  # _@param_ `counter_name` — Counter cache name
  #
  # _@param_ `id` — The id of the object that will have its counter decremented.
  #
  # Decrement comments counter
  # ```ruby
  # Post.decrement_counter(:comments_count, '50e0edd97c71c17ea9000001')
  # ```
  def decrement_counter: (Symbol counter_name, String id) -> untyped
end

module Mongoid::Association::Mongoid::Association::Referenced::NestedAttributes
end

class Mongoid::Association::Mongoid::Association::Referenced::Mongoid::Association::Mongoid::Association::Referenced::NestedAttributes::One
  # Builds the association depending on the attributes and the options
  # passed to the macro.
  #
  # _@param_ `parent` — The parent document.
  #
  # _@return_ — The built document.
  #
  # Build a 1-1 nested document.
  # ```ruby
  # one.build(person, as: :admin)
  # ```
  #
  # _@note_ — This attempts to perform 3 operations, either one of an update of
  # the existing association, a replacement of the association with a new
  # document, or a removal of the association.
  def build: (Document parent) -> Document

  # Create the new builder for nested attributes on one-to-one
  # associations.
  #
  # _@param_ `association` — The association metadata.
  #
  # _@param_ `attributes` — The attributes hash to attempt to set.
  #
  # _@param_ `options` — The options defined.
  #
  # Instantiate the builder.
  # ```ruby
  # One.new(association, attributes)
  # ```
  def initialize: (Association association, ::Hash[untyped, untyped] attributes, ::Hash[untyped, untyped] options) -> void

  # Is the id in the attribtues acceptable for allowing an update to
  # the existing association?
  #
  # _@return_ — If the id part of the logic will allow an update.
  #
  # Is the id acceptable?
  # ```ruby
  # one.acceptable_id?
  # ```
  def acceptable_id?: () -> bool

  # Can the existing association be deleted?
  #
  # _@return_ — If the association should be deleted.
  #
  # Can the existing object be deleted?
  # ```ruby
  # one.delete?
  # ```
  def delete?: () -> bool

  # Can the existing association potentially be destroyed?
  #
  # _@return_ — If the association can potentially be
  # destroyed.
  #
  # Is the object destroyable?
  # ```ruby
  # one.destroyable?({ :_destroy => "1" })
  # ```
  def destroyable?: () -> bool

  # Is the document to be replaced?
  #
  # _@return_ — If the document should be replaced.
  #
  # Is the document to be replaced?
  # ```ruby
  # one.replace?
  # ```
  def replace?: () -> bool

  # Should the document be updated?
  #
  # _@return_ — If the object should have its attributes updated.
  #
  # Should the document be updated?
  # ```ruby
  # one.update?
  # ```
  def update?: () -> bool
end

# The HasAndBelongsToMany type association.
#
# @since 7.0
class Mongoid::Association::Mongoid::Association::Referenced::HasAndBelongsToMany
  include Mongoid::Association::Relatable

  include Mongoid::Association::Referenced::HasAndBelongsToMany::Buildable

  # Returns the value of attribute destroy.
  #
  # The list of association complements.
  #
  # _@return_ — The association complements.
  def relation_complements: () -> untyped
                          | () -> ::Array[Association]

  # Setup the instance methods, fields, etc. on the association owning class.
  def setup!: () -> self

  # Is this association type embedded?
  #
  # _@return_ — Always false.
  def embedded?: () -> bool

  # The default for validation the association object.
  #
  # _@return_ — Always false.
  def validation_default: () -> bool

  # Are ids only saved on this side of the association?
  #
  # _@return_ — Whether this association has a forced nil inverse.
  def forced_nil_inverse?: () -> bool

  # Does this association type store the foreign key?
  #
  # _@return_ — Always true.
  def stores_foreign_key?: () -> bool

  # sord warn - Association::HasAndBelongsToMany::Proxy wasn't able to be resolved to a constant in this project
  # Get the association proxy class for this association type.
  #
  # _@return_ — The proxy class.
  def relation: () -> Mongoid::Association::Referenced::HasAndBelongsToMany::Proxy

  # Get the foreign key field for saving the association reference.
  #
  # _@return_ — The foreign key field for saving the association reference.
  def foreign_key: () -> String

  # The criteria used for querying this association.
  #
  # _@return_ — The criteria used for querying this association.
  def criteria: (untyped base, ?untyped id_list) -> Mongoid::Criteria

  # Get the foreign key field on the inverse.
  #
  # _@return_ — The foreign key field for saving the association reference
  # on the inverse side.
  def inverse_foreign_key: () -> String

  # Whether trying to bind an object using this association should raise
  # an error.
  #
  # _@param_ `doc` — The document to be bound.
  #
  # _@return_ — Whether the document can be bound.
  def bindable?: (Document doc) -> bool

  # Get the foreign key setter on the inverse.
  #
  # _@return_ — The foreign key setter for saving the association reference
  # on the inverse side.
  def inverse_foreign_key_setter: () -> String

  # The nested builder object.
  #
  # _@param_ `attributes` — The attributes to use to build the association object.
  #
  # _@param_ `options` — The options for the association.
  #
  # _@return_ — The Nested Builder object.
  def nested_builder: (::Hash[untyped, untyped] attributes, ::Hash[untyped, untyped] options) -> Association::Nested::One

  # sord infer - Root was resolved to Mongoid::Atomic::Paths::Root
  # Get the path calculator for the supplied document.
  #
  # _@param_ `document` — The document to calculate on.
  #
  # _@return_ — The root atomic path calculator.
  #
  # Get the path calculator.
  # ```ruby
  # association.path(document)
  # ```
  def path: (Document document) -> Mongoid::Atomic::Paths::Root

  def setup_instance_methods!: () -> untyped

  def index_spec: () -> untyped

  def default_primary_key: () -> untyped

  def default_foreign_key_field: () -> untyped

  def setup_syncing!: () -> untyped

  def synced_destroy: () -> untyped

  def synced_save: () -> untyped

  def create_foreign_key_field!: () -> untyped

  def determine_inverses: (untyped other) -> untyped

  def with_ordering: (untyped criteria) -> untyped

  def query_criteria: (untyped id_list) -> untyped

  def build: (Object base, Object object, ?String? `type`, ?nil selected_fields) -> ::Array[Document]

  def query?: (untyped object) -> bool

  def initialize: (Class _class, Symbol name, ?::Hash[untyped, untyped] opts) { () -> untyped } -> void

  # Compare this association to another.
  #
  # _@return_ — The object to compare to this association.
  def ==: (untyped other) -> Object

  # Get the callbacks for a given type.
  #
  # _@param_ `callback_type` — The type of callback type.
  #
  # _@return_ — A list of the callbacks, either method
  # names or Procs.
  def get_callbacks: (Symbol callback_type) -> ::Array[Proc | Symbol]

  # Get the type setter.
  #
  # _@return_ — The type setter method.
  #
  # _@note_ — Only relevant for polymorphic associations that take the :as option.
  def type_setter: () -> String

  # Get the inverse names.
  #
  # _@param_ `other` — The other model class or model object to use when determining inverses.
  #
  # _@return_ — The list of inverse names.
  def inverses: (?Object? other) -> ::Array[Symbol]

  # Get the inverse's association metadata.
  #
  # _@param_ `other` — The other model class or model object to use when determining inverses.
  #
  # _@return_ — The inverse's association metadata.
  def inverse_association: (?Object? other) -> Association

  # Get the inverse type.
  #
  # _@return_ — Default is nil for an association.
  def inverse_type: () -> nil

  # The class name, possibly unqualified or :: prefixed, of the association
  # object(s).
  #
  # This method returns the class name as it is used in the association
  # definition. If :class_name option is given in the association, the
  # exact value of that option is returned here. If :class_name option is
  # not given, the name of the class is calculated from association name
  # but is not resolved to the actual class.
  #
  # The class name returned by this method may not correspond to a defined
  # class, either because the corresponding class has not been loaded yet,
  # or because the association references a non-existent class altogether.
  # To obtain the association class, use +relation_class+ method.
  #
  # _@return_ — The association objects' class name.
  #
  # _@note_ — The return value of this method should not be used to determine
  # whether two associations have the same target class, because the
  # return value is not always a fully qualified class name. To compare
  # classes, retrieve the class instance of the association target using
  # the +relation_class+ method.
  def relation_class_name: () -> String

  # The class of the association object(s).
  #
  # This method returns the class instance corresponding to
  # +relation_class_name+, resolved relative to the host document class.
  #
  # If the class does not exist, this method raises NameError. This can
  # happen because the target class has not yet been defined. Note that
  # polymorphic associations generally do not have a well defined target
  # class because the target class can change from one object to another,
  # and calling this method on a polymorphic association will generally
  # fail with a NameError or produce misleading results (if a class does
  # happen to be defined with the same name as the association name).
  #
  # _@return_ — The association objects' class.
  def relation_class: () -> String

  # The class name of the object owning this association.
  #
  # _@return_ — The owning objects' class name.
  def inverse_class_name: () -> String

  # The class of the object owning this association.
  #
  # _@return_ — The owning objects' class.
  def inverse_class: () -> String

  # The foreign key field if this association stores a foreign key.
  # Otherwise, the primary key.
  #
  # _@return_ — The primary key.
  def key: () -> (Symbol | String)

  # The name of the setter on this object for assigning an associated object.
  #
  # _@return_ — The setter name.
  def setter: () -> String

  # The name of the inverse setter method.
  #
  # _@return_ — The name of the inverse setter.
  def inverse_setter: (?untyped other) -> String

  # The name of the foreign key setter method.
  #
  # _@return_ — The name of the foreign key setter.
  def foreign_key_setter: () -> String

  # Gets the setter for the field that sets the type of document on a
  # polymorphic association.
  #
  # _@return_ — The name of the setter.
  #
  # Get the inverse type setter.
  # ```ruby
  # association.inverse_type_setter
  # ```
  def inverse_type_setter: () -> String

  # Get the name of the method to check if the foreign key has changed.
  #
  # _@return_ — The foreign key check.
  #
  # Get the foreign key check method.
  # ```ruby
  # association.foreign_key_check
  # ```
  def foreign_key_check: () -> String

  # Create an association proxy object using the owner and target.
  #
  # _@param_ `owner` — The document this association hangs off of.
  #
  # _@param_ `target` — The target (parent) of the association.
  def create_relation: (Document owner, Document | ::Array[Document] target) -> Proxy

  # Whether the dependent method is destructive.
  #
  # _@return_ — If the dependent method is destructive.
  def destructive?: () -> bool

  # Get the counter cache column name.
  #
  # _@return_ — The counter cache column name.
  def counter_cache_column_name: () -> String

  # Get the extension.
  #
  # _@return_ — The extension module, if one has been defined.
  def extension: () -> Module

  # Get the inverse name.
  #
  # _@return_ — The inverse name.
  def inverse: (?untyped other) -> Symbol

  # Whether the associated object(s) should be validated.
  #
  # _@return_ — If the associated object(s)
  # should be validated.
  def validate?: () -> bool

  # Gets the model classes with inverse associations of this model. This is used to determine
  # the classes on the other end of polymorphic associations with models.
  def inverse_association_classes: () -> untyped

  def setup_index!: () -> untyped

  def define_touchable!: () -> untyped

  def define_autosaver!: () -> untyped

  def define_builder!: () -> untyped

  def define_creator!: () -> untyped

  def define_getter!: () -> untyped

  def define_setter!: () -> untyped

  def define_existence_check!: () -> untyped

  def define_ids_getter!: () -> untyped

  def define_ids_setter!: () -> untyped

  def define_counter_cache_callbacks!: () -> untyped

  def define_dependency!: () -> untyped

  def validate!: () -> untyped

  def polymorph!: () -> untyped

  def create_extension!: () { () -> untyped } -> untyped

  def default_inverse: () -> untyped

  # Returns an array of classes/modules forming the namespace hierarchy
  # where symbols referenced in the provided class/module would be looked
  # up by Ruby. For example, if mod is Foo::Bar, this method would return
  # [Foo::Bar, Foo, Object].
  def namespace_hierarchy: (untyped mod) -> untyped

  # Resolves the given class/module name in the context of the specified
  # module, as Ruby would when a constant is referenced in the source.
  #
  # _@note_ — This method can swallow exceptions produced during class loading,
  # because it rescues NameError internally. Since this method attempts
  # to load classes, failure during the loading process may also lead to
  # there being incomplete class definitions.
  def resolve_name: (untyped mod, untyped name) -> untyped

  # Returns the name of the parent to a polymorphic child.
  #
  # _@return_ — The name.
  def as: () -> (String | Symbol)

  # Specify what happens to the associated object when the owner is destroyed.
  #
  # _@return_ — The dependent option.
  def dependent: () -> String

  # The custom sorting options on the association.
  #
  # _@return_ — The custom sorting options.
  def order: () -> Criteria::Queryable::Key

  # Whether to index the primary or foreign key field.
  def indexed?: () -> bool

  # Whether the association is autobuilding.
  def autobuilding?: () -> bool

  # Is the association cyclic.
  #
  # _@return_ — Whether the association is cyclic.
  def cyclic?: () -> bool

  # The name the owning object uses to refer to this association.
  #
  # _@return_ — The inverse_of option.
  def inverse_of: () -> String

  # Mongoid assumes that the field used to hold the primary key of the association is id.
  # You can override this and explicitly specify the primary key with the :primary_key option.
  #
  # _@return_ — The primary key.
  def primary_key: () -> (Symbol | String)

  # Options to save any loaded members and destroy members that are marked for destruction
  # when the parent object is saved.
  #
  # _@return_ — The autosave option.
  def autosave: () -> bool

  # Whether the association is counter-cached.
  def counter_cached?: () -> bool

  # Whether this association is polymorphic.
  #
  # _@return_ — Whether the association is polymorphic.
  def polymorphic?: () -> bool

  # Whether the association has callbacks cascaded down from the parent.
  #
  # _@return_ — Whether callbacks are cascaded.
  def cascading_callbacks?: () -> bool

  # The store_as option.
  #
  # _@return_ — Default is nil.
  def store_as: () -> nil

  # The field for saving the associated object's type.
  #
  # _@return_ — Default is nil.
  def type: () -> nil

  # The field for saving the associated object's type.
  #
  # _@return_ — Default is nil.
  def touch_field: () -> nil

  def touchable?: () -> bool

  # Convert the supplied object to the appropriate type to set as the
  # foreign key for an association.
  #
  # _@param_ `object` — The object to convert.
  #
  # _@return_ — The object cast to the correct type.
  #
  # Convert the object.
  # ```ruby
  # constraint.convert("12345")
  # ```
  def convert_to_foreign_key: (Object object) -> Object

  def convert_polymorphic: (untyped object) -> untyped
end

Mongoid::Association::Mongoid::Association::Referenced::Mongoid::Association::Mongoid::Association::Referenced::HasAndBelongsToMany::ASSOCIATION_OPTIONS: untyped

Mongoid::Association::Mongoid::Association::Referenced::Mongoid::Association::Mongoid::Association::Referenced::HasAndBelongsToMany::VALID_OPTIONS: untyped

Mongoid::Association::Mongoid::Association::Referenced::Mongoid::Association::Mongoid::Association::Referenced::HasAndBelongsToMany::FOREIGN_KEY_FIELD_TYPE: untyped

Mongoid::Association::Mongoid::Association::Referenced::Mongoid::Association::Mongoid::Association::Referenced::HasAndBelongsToMany::FOREIGN_KEY_SUFFIX: untyped

Mongoid::Association::Mongoid::Association::Referenced::Mongoid::Association::Mongoid::Association::Referenced::HasAndBelongsToMany::SHARED_OPTIONS: untyped

Mongoid::Association::Mongoid::Association::Referenced::Mongoid::Association::Mongoid::Association::Referenced::HasAndBelongsToMany::PRIMARY_KEY_DEFAULT: untyped

# Eager class for has_and_belongs_to_many associations.
class Mongoid::Association::Mongoid::Association::Referenced::Mongoid::Association::Mongoid::Association::Referenced::HasAndBelongsToMany::Eager < Mongoid::Association::Referenced::Eager::Base
  def preload: () -> untyped

  def keys_from_docs: () -> untyped

  def set_relation: (untyped doc, untyped element) -> untyped

  def group_by_key: () -> untyped

  def key: () -> untyped
end

# This class defines the behavior for all associations that are a
# many-to-many between documents in different collections.
class Mongoid::Association::Mongoid::Association::Referenced::Mongoid::Association::Mongoid::Association::Referenced::HasAndBelongsToMany::Proxy < Mongoid::Association::Referenced::HasMany::Proxy
  # Appends a document or array of documents to the association. Will set
  # the parent and update the index in the process.
  #
  # _@param_ `args` — Any number of documents.
  #
  # _@return_ — The loaded docs.
  #
  # Append a document.
  # ```ruby
  # person.posts << post
  # ```
  #
  # Push a document.
  # ```ruby
  # person.posts.push(post)
  # ```
  #
  # Concat with other documents.
  # ```ruby
  # person.posts.concat([ post_one, post_two ])
  # ```
  def <<: (*Document | ::Array[Document] args) -> ::Array[Document]

  # Appends an array of documents to the association. Performs a batch
  # insert of the documents instead of persisting one at a time.
  #
  # _@param_ `documents` — The docs to add.
  #
  # _@return_ — The documents.
  #
  # Concat with other documents.
  # ```ruby
  # person.posts.concat([ post_one, post_two ])
  # ```
  def concat: (::Array[Document] documents) -> ::Array[Document]

  # Build a new document from the attributes and append it to this
  # association without saving.
  #
  # _@param_ `attributes` — The attributes of the new document.
  #
  # _@param_ `type` — The optional subclass to build.
  #
  # _@return_ — The new document.
  #
  # Build a new document on the association.
  # ```ruby
  # person.posts.build(:title => "A new post")
  # ```
  def build: (?::Hash[untyped, untyped] attributes, ?Class? `type`) -> Document

  # Delete the document from the association. This will set the foreign key
  # on the document to nil. If the dependent options on the association are
  # :delete_all or :destroy the appropriate removal will occur.
  #
  # _@param_ `document` — The document to remove.
  #
  # _@return_ — The matching document.
  #
  # Delete the document.
  # ```ruby
  # person.posts.delete(post)
  # ```
  def delete: (Document document) -> Document

  # Removes all associations between the base document and the target
  # documents by deleting the foreign keys and the references, orphaning
  # the target documents in the process.
  #
  # _@param_ `replacement` — The replacement documents.
  #
  # Nullify the association.
  # ```ruby
  # person.preferences.nullify
  # ```
  def nullify: (?::Array[Document] replacement) -> untyped

  # Substitutes the supplied target documents for the existing documents
  # in the association. If the new target is nil, perform the necessary
  # deletion.
  #
  # person.preferences.substitute([ new_post ])
  #
  # _@param_ `replacement` — The replacement target.
  #
  # _@return_ — The association.
  #
  # Replace the association.
  # ```ruby
  # ```
  def substitute: (::Array[Document] replacement) -> Many

  # Get a criteria for the documents without the default scoping
  # applied.
  #
  # _@return_ — The unscoped criteria.
  #
  # Get the unscoped criteria.
  # ```ruby
  # person.preferences.unscoped
  # ```
  def unscoped: () -> Criteria

  # Appends the document to the target array, updating the index on the
  # document at the same time.
  #
  # _@param_ `document` — The document to append to the target.
  #
  # Append the document to the association.
  # ```ruby
  # relation.append(document)
  # ```
  def append: (Document document) -> untyped

  # sord warn - Binding wasn't able to be resolved to a constant in this project
  # Instantiate the binding associated with this association.
  #
  # _@return_ — The binding.
  #
  # Get the binding.
  # ```ruby
  # relation.binding([ address ])
  # ```
  def binding: () -> Binding

  # Determine if the child document should be persisted.
  #
  # _@param_ `doc` — The document.
  #
  # _@return_ — If the document can be persisted.
  #
  # Is the child persistable?
  # ```ruby
  # relation.child_persistable?(doc)
  # ```
  def child_persistable?: (Document doc) -> bool

  # Returns the criteria object for the target class with its documents set
  # to target.
  #
  # _@return_ — A new criteria.
  #
  # Get a criteria for the association.
  # ```ruby
  # relation.criteria
  # ```
  def criteria: (?untyped id_list) -> Criteria

  # Flag the base as unsynced with respect to the foreign key.
  #
  # _@param_ `doc` — The document to flag.
  #
  # _@param_ `key` — The key to flag on the document.
  #
  # _@return_ — true.
  #
  # Flag as unsynced.
  # ```ruby
  # relation.unsynced(doc, :preference_ids)
  # ```
  def unsynced: (Document doc, Symbol key) -> bool

  # Get the Eager object for this type of association.
  #
  # _@param_ `association` — The association object.
  #
  # _@param_ `docs` — The array of documents.
  #
  # Get the eager loader object
  # ```ruby
  # ```
  def self.eager_loader: (Association association, ::Array[Document] docs) -> untyped

  # Returns true if the association is an embedded one. In this case
  # always false.
  #
  # _@return_ — Always false.
  #
  # Is this association embedded?
  # ```ruby
  # Referenced::ManyToMany.embedded?
  # ```
  def self.embedded?: () -> bool
end

# Binding class for all has_and_belongs_to_many associations.
class Mongoid::Association::Mongoid::Association::Referenced::Mongoid::Association::Mongoid::Association::Referenced::HasAndBelongsToMany::Binding
  include Mongoid::Association::Bindable

  # Binds a single document with the inverse association. Used
  # specifically when appending to the proxy.
  #
  # _@param_ `doc` — The single document to bind.
  #
  # Bind one document.
  # ```ruby
  # person.preferences.bind_one(preference)
  # ```
  def bind_one: (Document doc) -> untyped

  # Unbind a single document.
  #
  # Unbind the document.
  # ```ruby
  # person.preferences.unbind_one(document)
  # ```
  def unbind_one: (untyped doc) -> untyped

  # Find the inverse id referenced by inverse_keys
  def inverse_record_id: (untyped doc) -> untyped

  def determine_inverse_association: (untyped doc) -> untyped

  # Create the new binding.
  #
  # _@param_ `base` — The base of the binding.
  #
  # _@param_ `target` — The target of the binding.
  #
  # _@param_ `association` — The association metadata.
  #
  # Initialize a binding.
  # ```ruby
  # Binding.new(base, target, association)
  # ```
  def initialize: (Document base, Document | ::Array[Document] target, Association association) -> void

  # Execute the provided block inside a binding.
  #
  # _@return_ — The result of the yield.
  #
  # Execute the binding block.
  # ```ruby
  # binding.binding do
  #   base.foreign_key = 1
  # end
  # ```
  def binding: () -> Object

  # Check if the inverse is properly defined.
  #
  # _@param_ `doc` — The document getting bound.
  #
  # Check the inverse definition.
  # ```ruby
  # binding.check_inverse!(doc)
  # ```
  def check_inverse!: (Document doc) -> untyped

  # Set the id of the related document in the foreign key field on the
  # keyed document.
  #
  # _@param_ `keyed` — The document that stores the foreign key.
  #
  # _@param_ `id` — The id of the bound document.
  #
  # Bind the foreign key.
  # ```ruby
  # binding.bind_foreign_key(post, person._id)
  # ```
  def bind_foreign_key: (Document keyed, Object id) -> untyped

  # Set the type of the related document on the foreign type field, used
  # when associations are polymorphic.
  #
  # _@param_ `typed` — The document that stores the type field.
  #
  # _@param_ `name` — The name of the model.
  #
  # Bind the polymorphic type.
  # ```ruby
  # binding.bind_polymorphic_type(post, "Person")
  # ```
  def bind_polymorphic_type: (Document typed, String name) -> untyped

  # Set the type of the related document on the foreign type field, used
  # when associations are polymorphic.
  #
  # _@param_ `typed` — The document that stores the type field.
  #
  # _@param_ `name` — The name of the model.
  #
  # Bind the polymorphic type.
  # ```ruby
  # binding.bind_polymorphic_inverse_type(post, "Person")
  # ```
  def bind_polymorphic_inverse_type: (Document typed, String name) -> untyped

  # Bind the inverse document to the child document so that the in memory
  # instances are the same.
  #
  # _@param_ `doc` — The base document.
  #
  # _@param_ `inverse` — The inverse document.
  #
  # Bind the inverse.
  # ```ruby
  # binding.bind_inverse(post, person)
  # ```
  def bind_inverse: (Document doc, Document inverse) -> untyped

  # Bind the provided document with the base from the parent association.
  #
  # _@param_ `doc` — The document to bind.
  #
  # Bind the document with the base.
  # ```ruby
  # binding.bind_from_relational_parent(doc)
  # ```
  def bind_from_relational_parent: (Document doc) -> untyped

  def record_id: (untyped _base) -> untyped

  # Ensure that the association on the base is correct, for the cases
  # where we have multiple belongs to definitions and were are setting
  # different parents in memory in order.
  #
  # _@return_ — If the association changed.
  #
  # Set the base association.
  # ```ruby
  # binding.set_base_association
  # ```
  def set_base_association: () -> bool

  # Bind the provided document with the base from the parent association.
  #
  # _@param_ `doc` — The document to unbind.
  #
  # Bind the document with the base.
  # ```ruby
  # unbinding.unbind_from_relational_parent(doc)
  # ```
  def unbind_from_relational_parent: (Document doc) -> untyped

  # Begin the assignment of attributes. While in this block embedded
  # documents will not autosave themselves in order to allow the document to
  # be in a valid state.
  #
  # _@return_ — The yielded value.
  #
  # Execute the assignment.
  # ```ruby
  # _assigning do
  #   person.attributes = { :addresses => [ address ] }
  # end
  # ```
  def _assigning: () -> Object

  # Is the current thread in assigning mode?
  #
  # _@return_ — If the thread is assigning.
  #
  # Is the current thread in assigning mode?
  # ```ruby
  # proxy._assigning?
  # ```
  def _assigning?: () -> bool

  # Execute a block in binding mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in binding mode.
  # ```ruby
  # binding do
  #   relation.push(doc)
  # end
  # ```
  def _binding: () -> Object

  # Is the current thread in binding mode?
  #
  # _@return_ — If the thread is binding.
  #
  # Is the current thread in binding mode?
  # ```ruby
  # proxy.binding?
  # ```
  def _binding?: () -> bool

  # Execute a block in building mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in building mode.
  # ```ruby
  # _building do
  #   relation.push(doc)
  # end
  # ```
  def _building: () -> Object

  # Is the current thread in building mode?
  #
  # _@return_ — If the thread is building.
  #
  # Is the current thread in building mode?
  # ```ruby
  # proxy._building?
  # ```
  def _building?: () -> bool

  # Is the current thread in creating mode?
  #
  # _@return_ — If the thread is creating.
  #
  # Is the current thread in creating mode?
  # ```ruby
  # proxy.creating?
  # ```
  def _creating?: () -> bool

  # Execute a block in loading mode.
  #
  # _@return_ — The return value of the block.
  #
  # Execute in loading mode.
  # ```ruby
  # _loading do
  #   relation.push(doc)
  # end
  # ```
  def _loading: () -> Object

  # Is the current thread in loading mode?
  #
  # _@return_ — If the thread is loading.
  #
  # Is the current thread in loading mode?
  # ```ruby
  # proxy._loading?
  # ```
  def _loading?: () -> bool
end

# The Builder behavior for has_and_belongs_to_many associations.
#
# @since 7.0
module Mongoid::Association::Mongoid::Association::Referenced::Mongoid::Association::Mongoid::Association::Referenced::HasAndBelongsToMany::Buildable
  def build: (Object base, Object object, ?String? `type`, ?nil selected_fields) -> ::Array[Document]

  def query?: (untyped object) -> bool
end

# Contains general behavior for persistence operations.
#
# @since 2.0.0
module Mongoid::Persistable
  include Mongoid::Persistable::Creatable

  include Mongoid::Persistable::Deletable

  include Mongoid::Persistable::Destroyable

  include Mongoid::Persistable::Incrementable

  include Mongoid::Persistable::Logical

  include Mongoid::Persistable::Poppable

  include Mongoid::Positional

  include Mongoid::Persistable::Pullable

  include Mongoid::Persistable::Pushable

  include Mongoid::Persistable::Renamable

  include Mongoid::Persistable::Savable

  include Mongoid::Persistable::Settable

  include Mongoid::Persistable::Updatable

  include Mongoid::Persistable::Upsertable

  include Mongoid::Persistable::Unsettable

  extend ActiveSupport::Concern

  # Execute operations atomically (in a single database call) for everything
  # that would happen inside the block. This method supports nesting further
  # calls to atomically, which will behave according to the options described
  # below.
  #
  # An option join_context can be given which, when true, will merge the
  # operations declared by the given block with the atomically block wrapping
  # the current invocation for the same document, if one exists. If this
  # block or any other block sharing the same context raises before
  # persisting, then all the operations of that context will not be
  # persisted, and will also be reset in memory.
  #
  # When join_context is false, the given block of operations will be
  # persisted independently of other contexts. Failures in other contexts will
  # not affect this one, so long as this block was able to run and persist
  # changes.
  #
  # The default value of join_context is set by the global configuration
  # option join_contexts, whose own default is false.
  #
  # _@param_ `join_context` — Join the context (i.e. merge declared atomic operations) of the atomically block wrapping this one for the same document, if one exists.
  #
  # _@return_ — If the operation succeeded.
  #
  # Execute the operations atomically.
  # ```ruby
  # document.atomically do
  #   document.set(name: "Tool").inc(likes: 10)
  # end
  # ```
  #
  # Execute some inner operations atomically, but independently from the outer operations.
  # ```ruby
  #
  # document.atomically do
  #   document.inc likes: 10
  #   document.atomically join_context: false do
  #     # The following is persisted to the database independently.
  #     document.unset :origin
  #   end
  #   document.atomically join_context: true do
  #     # The following is persisted along with the other outer operations.
  #     document.inc member_count: 3
  #   end
  #   document.set name: "Tool"
  # end
  # ```
  def atomically: (?join_context: bool? join_context) -> bool

  # Raise an error if validation failed.
  #
  # Raise the validation error.
  # ```ruby
  # Person.fail_due_to_validation!(person)
  # ```
  def fail_due_to_validation!: () -> untyped

  # Raise an error if a callback failed.
  #
  # _@param_ `method` — The method being called.
  #
  # Raise the callback error.
  # ```ruby
  # Person.fail_due_to_callback!(person, :create!)
  # ```
  def fail_due_to_callback!: (Symbol method) -> untyped

  # Are we executing an atomically block on the current document?
  #
  # _@return_ — If we are current executing atomically.
  #
  # Are we executing atomically?
  # ```ruby
  # document.executing_atomically?
  # ```
  def executing_atomically?: () -> bool

  # Post process the persistence operation.
  #
  # _@param_ `result` — The result of the operation.
  #
  # _@param_ `options` — The options.
  #
  # _@return_ — true.
  #
  # Post process the persistence operation.
  # ```ruby
  # document.post_process_persist(true)
  # ```
  def post_process_persist: (Object result, ?::Hash[untyped, untyped] options) -> bool

  # Prepare an atomic persistence operation. Yields an empty hash to be sent
  # to the update.
  #
  # _@return_ — The result of the operation.
  #
  # Prepare the atomic operation.
  # ```ruby
  # document.prepare_atomic_operation do |coll, selector, opts|
  #   ...
  # end
  # ```
  def prepare_atomic_operation: () -> Object

  # Process the atomic operations - this handles the common behavior of
  # iterating through each op, getting the aliased field name, and removing
  # appropriate dirty changes.
  #
  # _@param_ `operations` — The atomic operations.
  #
  # _@return_ — The operations.
  #
  # Process the atomic operations.
  # ```ruby
  # document.process_atomic_operations(pulls) do |field, value|
  #   ...
  # end
  # ```
  def process_atomic_operations: (::Hash[untyped, untyped] operations) -> ::Hash[untyped, untyped]

  # Remove the dirty changes for all fields changed in the current atomic
  # context.
  #
  # Remove the current atomic context's dirty changes.
  # ```ruby
  # document._mongoid_remove_atomic_context_changes
  # ```
  def _mongoid_remove_atomic_context_changes: () -> untyped

  # Reset the attributes for all fields changed in the current atomic
  # context.
  #
  # Reset the current atomic context's changed attributes.
  # ```ruby
  # document._mongoid_reset_atomic_context_changes!
  # ```
  def _mongoid_reset_atomic_context_changes!: () -> untyped

  # Push a new atomic context onto the stack.
  #
  # Push a new atomic context onto the stack.
  # ```ruby
  # document._mongoid_push_atomic_context
  # ```
  def _mongoid_push_atomic_context: () -> untyped

  # Pop an atomic context off the stack.
  #
  # Pop an atomic context off the stack.
  # ```ruby
  # document._mongoid_pop_atomic_context
  # ```
  def _mongoid_pop_atomic_context: () -> untyped

  # Return the current atomic context's changed fields.
  #
  # _@return_ — The changed fields.
  #
  # Return the current atomic context's changed fields.
  # ```ruby
  # document._mongoid_atomic_context_changed_fields
  # ```
  def _mongoid_atomic_context_changed_fields: () -> ::Array[untyped]

  # If we are in an atomically block, add the operations to the delayed group,
  # otherwise persist immediately.
  #
  # _@param_ `operation` — The operation.
  #
  # Persist immediately or delay the operations.
  # ```ruby
  # document.persist_or_delay_atomic_operation(ops)
  # ```
  def persist_or_delay_atomic_operation: (::Hash[untyped, untyped] operation) -> untyped

  # Persist the atomic operations.
  #
  # _@param_ `operations` — The atomic operations.
  #
  # Persist the atomic operations.
  # ```ruby
  # persist_atomic_operations(ops)
  # ```
  def persist_atomic_operations: (::Hash[untyped, untyped] operations) -> untyped

  # Perform an $unset operation on the provided fields and in the
  # values in the document in memory.
  #
  # _@param_ `fields` — The names of the fields to unset.
  #
  # _@return_ — The document.
  #
  # Unset the values.
  # ```ruby
  # document.unset(:first_name, :last_name, :middle)
  # ```
  def unset: (*::Array[String | Symbol] fields) -> Document

  # Perform an upsert of the document. If the document does not exist in the
  # database, then Mongo will insert a new one, otherwise the fields will get
  # overwritten with new values on the existing document.
  #
  # _@param_ `options` — The validation options.
  #
  # _@return_ — True.
  #
  # Upsert the document.
  # ```ruby
  # document.upsert
  # ```
  def upsert: (?::Hash[untyped, untyped] options) -> bool

  # Prepare the upsert for execution.
  #
  # _@param_ `options` — The options hash.
  #
  # _@return_ — If the operation succeeded.
  #
  # Prepare the upsert
  # ```ruby
  # document.prepare_upsert do
  #   collection.find(selector).update(as_document)
  # end
  # ```
  def prepare_upsert: (?::Hash[untyped, untyped] options) -> bool

  # Update a single attribute and persist the entire document.
  # This skips validation but fires the callbacks.
  #
  # _@param_ `name` — The name of the attribute.
  #
  # _@param_ `value` — The new value of the attribute.a
  #
  # _@return_ — True if save was successfull, false if not.
  #
  # Update the attribute.
  # ```ruby
  # person.update_attribute(:title, "Sir")
  # ```
  def update_attribute: (Symbol | String name, Object value) -> bool

  # Update the document attributes in the database.
  #
  # _@param_ `attributes` — The attributes to update.
  #
  # _@return_ — True if validation passed, false if not.
  #
  # Update the document's attributes
  # ```ruby
  # document.update(:title => "Sir")
  # ```
  def update: (?::Hash[untyped, untyped] attributes) -> bool

  # Update the document attributes in the database and raise an error if
  # validation failed.
  #
  # _@param_ `attributes` — The attributes to update.
  #
  # _@return_ — True if validation passed.
  #
  # Update the document's attributes.
  # ```ruby
  # document.update!(:title => "Sir")
  # ```
  def update!: (?::Hash[untyped, untyped] attributes) -> bool

  # Initialize the atomic updates.
  #
  # _@return_ — The updates and conflicts.
  #
  # Initialize the atomic updates.
  # ```ruby
  # document.init_atomic_updates
  # ```
  def init_atomic_updates: () -> ::Array[::Hash[untyped, untyped]]

  # Prepare the update for execution. Validates and runs callbacks, etc.
  #
  # _@param_ `options` — The options.
  #
  # _@return_ — The result of the update.
  #
  # Prepare for update.
  # ```ruby
  # document.prepare_update do
  #   collection.update(atomic_selector)
  # end
  # ```
  def prepare_update: (?::Hash[untyped, untyped] options) -> bool

  # Update the document in the database.
  #
  # _@param_ `options` — Options to pass to update.
  #
  # _@return_ — True if succeeded, false if not.
  #
  # Update an existing document.
  # ```ruby
  # document.update
  # ```
  def update_document: (?::Hash[untyped, untyped] options) -> bool

  # Perform a $set operation on the provided field/value pairs and set the
  # values in the document in memory.
  #
  # The key can be a dotted sequence of keys, in which case the
  # top level field is treated as a nested hash and any missing keys
  # are created automatically:
  #
  # Performing a nested set like this merges values of intermediate keys:
  #
  # If the top level field was not a hash, its original value is discarded
  # and the field is replaced with a hash.
  #
  # Note that unlike MongoDB's $set, Mongoid's set writes out the entire
  # field even when setting a subset of the field via the nested hash
  # semantics. This means performing a $set with nested hash semantics
  # can overwrite other hash keys within the top level field in the database.
  #
  # _@param_ `setters` — The field/value pairs to set.
  #
  # _@return_ — The document.
  #
  # Set the values.
  # ```ruby
  # document.set(title: "sir", dob: Date.new(1970, 1, 1))
  # ```
  #
  # Set the values using nested hash semantics.
  # ```ruby
  # document.set('author.title' => 'Sir')
  # # => document.author == {'title' => 'Sir'}
  # ```
  #
  # Nested hash value merging.
  # ```ruby
  # document.set('author.title' => 'Sir')
  # document.set('author.name' => 'Linus Torvalds')
  # # => document.author == {'title' => 'Sir', 'name' => 'Linus Torvalds'}
  # ```
  #
  # Nested hash overwriting a non-hash value.
  # ```ruby
  # document.set('author' => 'John Doe')
  # document.set('author.title' => 'Sir')
  # # => document.author == {'title' => 'Sir'}
  # ```
  def set: (::Hash[untyped, untyped] setters) -> Document

  # Save the document - will perform an insert if the document is new, and
  # update if not.
  #
  # _@param_ `options` — Options to pass to the save.
  #
  # _@return_ — True is success, false if not.
  #
  # Save the document.
  # ```ruby
  # document.save
  # ```
  def save: (?::Hash[untyped, untyped] options) -> bool

  # Save the document - will perform an insert if the document is new, and
  # update if not. If a validation error occurs an error will get raised.
  #
  # _@param_ `options` — Options to pass to the save.
  #
  # _@return_ — True if validation passed.
  #
  # Save the document.
  # ```ruby
  # document.save!
  # ```
  def save!: (?::Hash[untyped, untyped] options) -> bool

  # Rename fields from one value to another via $rename.
  #
  # _@param_ `renames` — The rename pairs of old name/new name.
  #
  # _@return_ — The document.
  #
  # Rename the fields.
  # ```ruby
  # document.rename(title: "salutation", name: "nombre")
  # ```
  #
  # _@note_ — This does not work for fields in embeds many associations.
  def rename: (::Hash[untyped, untyped] renames) -> Document

  # Add the single values to the arrays only if the value does not already
  # exist in the array.
  #
  # _@param_ `adds` — The field/value pairs to add.
  #
  # _@return_ — The document.
  #
  # Add the values to the sets.
  # ```ruby
  # document.add_to_set(names: "James", aliases: "Bond")
  # ```
  def add_to_set: (::Hash[untyped, untyped] adds) -> Document

  # Push a single value or multiple values onto arrays.
  #
  # _@param_ `pushes` — The $push operations.
  #
  # _@return_ — The document.
  #
  # Push a single value onto arrays.
  # ```ruby
  # document.push(names: "James", aliases: "007")
  # ```
  #
  # Push multiple values onto arrays.
  # ```ruby
  # document.push(names: [ "James", "Bond" ])
  # ```
  def push: (::Hash[untyped, untyped] pushes) -> Document

  # Pull single values from the provided arrays.
  #
  # _@param_ `pulls` — The field/value pull pairs.
  #
  # _@return_ — The document.
  #
  # Pull a value from the array.
  # ```ruby
  # document.pull(names: "Jeff", levels: 5)
  # ```
  #
  # _@note_ — If duplicate values are found they will all be pulled.
  def pull: (::Hash[untyped, untyped] pulls) -> Document

  # Pull multiple values from the provided array fields.
  #
  # _@param_ `pulls` — The pull all operations.
  #
  # _@return_ — The document.
  #
  # Pull values from the arrays.
  # ```ruby
  # document.pull_all(names: [ "Jeff", "Bob" ], levels: [ 5, 6 ])
  # ```
  def pull_all: (::Hash[untyped, untyped] pulls) -> Document

  # Takes the provided selector and atomic operations and replaces the
  # indexes of the embedded documents with the positional operator when
  # needed.
  #
  # _@param_ `selector` — The selector.
  #
  # _@param_ `operations` — The update operations.
  #
  # _@param_ `processed` — The processed update operations.
  #
  # _@return_ — The new operations.
  #
  # Process the operations.
  # ```ruby
  # positionally(
  #   { "_id" => 1, "addresses._id" => 2 },
  #   { "$set" => { "addresses.0.street" => "hobrecht" }}
  # )
  # ```
  #
  # _@note_ — The only time we can accurately know when to use the positional
  # operator is at the exact time we are going to persist something. So
  # we can tell by the selector that we are sending if it is actually
  # possible to use the positional operator at all. For example, if the
  # selector is: { "_id" => 1 }, then we could not use the positional
  # operator for updating embedded documents since there would never be a
  # match - we base whether we can based on the number of levels deep the
  # selector goes, and if the id values are not nil.
  def positionally: (::Hash[untyped, untyped] selector, ::Hash[untyped, untyped] operations, ?::Hash[untyped, untyped] processed) -> ::Hash[untyped, untyped]

  def process_operations: (untyped keys, untyped operations, untyped processed) -> untyped

  def process_updates: (untyped keys, untyped update, ?untyped updates) -> untyped

  def replace_index: (untyped keys, untyped position) -> untyped

  # Pop or shift items from arrays using the $pop operator.
  #
  # _@param_ `pops` — The field/value pop operations.
  #
  # _@return_ — The document.
  #
  # Pop items from an array.
  # ```ruby
  # document.pop(aliases: 1)
  # ```
  #
  # Shift items in the array.
  # ```ruby
  # document.pop(aliases: -1)
  # ```
  #
  # Multiple pops in one call.
  # ```ruby
  # document.pop(names: 1, aliases: 1)
  # ```
  def pop: (::Hash[untyped, untyped] pops) -> Document

  # Performs an atomic $bit operation on the field with the provided hash
  # of bitwise ops to execute in order.
  #
  # _@param_ `operations` — The bitwise operations.
  #
  # _@return_ — The document.
  #
  # Execute the bitwise operations.
  # ```ruby
  # person.bit(age: { :and => 12 }, val: { and: 10, or: 12 })
  # ```
  def bit: (::Hash[untyped, untyped] operations) -> Document

  # Increment the provided fields by the corresponding values. Values can
  # be positive or negative, and if no value exists for the field it will
  # be set with the provided value.
  #
  # _@param_ `increments` — The field/inc increment pairs.
  #
  # _@return_ — The document.
  #
  # Increment the fields.
  # ```ruby
  # document.inc(score: 10, place: 1, lives: -10)
  # ```
  def inc: (::Hash[untyped, untyped] increments) -> Document

  # Remove the document from the database with callbacks.
  #
  # _@param_ `options` — Options to pass to destroy.
  #
  # _@return_ — True if successful, false if not.
  #
  # Destroy a document.
  # ```ruby
  # document.destroy
  # ```
  def destroy: (?::Hash[untyped, untyped]? options) -> bool

  def destroy!: (?untyped options) -> untyped

  # Remove the document from the database.
  #
  # _@param_ `options` — Options to pass to remove.
  #
  # _@return_ — True.
  #
  # Remove the document.
  # ```ruby
  # document.remove
  # ```
  def delete: (?::Hash[untyped, untyped] options) -> TrueClass

  # Get the atomic deletes for the operation.
  #
  # _@return_ — The atomic deletes.
  #
  # Get the atomic deletes.
  # ```ruby
  # document.atomic_deletes
  # ```
  def atomic_deletes: () -> ::Hash[untyped, untyped]

  # Delete the embedded document.
  #
  # _@param_ `options` — The deletion options.
  #
  # _@return_ — If the operation succeeded.
  #
  # Delete the embedded document.
  # ```ruby
  # document.delete_as_embedded
  # ```
  def delete_as_embedded: (?::Hash[untyped, untyped] options) -> bool

  # Delete the root document.
  #
  # _@return_ — If the document was removed.
  #
  # Delete the root document.
  # ```ruby
  # document.delete_as_root
  # ```
  def delete_as_root: () -> bool

  # Are we needing to notify the parent document of the deletion.
  #
  # _@param_ `options` — The delete options.
  #
  # _@return_ — If the parent should be notified.
  #
  # Are we notifying the parent.
  # ```ruby
  # document.notifying_parent?(suppress: true)
  # ```
  def notifying_parent?: (?::Hash[untyped, untyped] options) -> bool

  # Prepare the delete operation.
  #
  # _@return_ — The result of the block.
  #
  # Prepare the delete operation.
  # ```ruby
  # document.prepare_delete do
  #   collection.find(atomic_selector).remove
  # end
  # ```
  def prepare_delete: () -> Object

  # Insert a new document into the database. Will return the document
  # itself whether or not the save was successful.
  #
  # _@param_ `options` — Options to pass to insert.
  #
  # _@return_ — The persisted document.
  #
  # Insert a document.
  # ```ruby
  # document.insert
  # ```
  def insert: (?::Hash[untyped, untyped] options) -> Document

  # Get the atomic insert for embedded documents, either a push or set.
  #
  # _@return_ — The insert ops.
  #
  # Get the inserts.
  # ```ruby
  # document.inserts
  # ```
  def atomic_inserts: () -> ::Hash[untyped, untyped]

  # Insert the embedded document.
  #
  # _@return_ — The document.
  #
  # Insert the document as embedded.
  # ```ruby
  # document.insert_as_embedded
  # ```
  def insert_as_embedded: () -> Document

  # Insert the root document.
  #
  # _@return_ — The document.
  #
  # Insert the document as root.
  # ```ruby
  # document.insert_as_root
  # ```
  def insert_as_root: () -> Document

  # Post process an insert, which sets the new record attribute to false
  # and flags all the children as persisted.
  #
  # _@return_ — true.
  #
  # Post process the insert.
  # ```ruby
  # document.post_process_insert
  # ```
  def post_process_insert: () -> bool

  # Prepare the insert for execution. Validates and runs callbacks, etc.
  #
  # _@param_ `options` — The options.
  #
  # _@return_ — The document.
  #
  # Prepare for insertion.
  # ```ruby
  # document.prepare_insert do
  #   collection.insert(as_document)
  # end
  # ```
  def prepare_insert: (?::Hash[untyped, untyped] options) -> Document
end

Mongoid::Persistable::LIST_OPERATIONS: untyped

# Defines behavior for logical bitwise operations.
#
# @since 4.0.0
module Mongoid::Persistable::Logical
  extend ActiveSupport::Concern

  # Performs an atomic $bit operation on the field with the provided hash
  # of bitwise ops to execute in order.
  #
  # _@param_ `operations` — The bitwise operations.
  #
  # _@return_ — The document.
  #
  # Execute the bitwise operations.
  # ```ruby
  # person.bit(age: { :and => 12 }, val: { and: 10, or: 12 })
  # ```
  def bit: (::Hash[untyped, untyped] operations) -> Document
end

# Defines behavior for persistence operations that save documents.
#
# @since 4.0.0
module Mongoid::Persistable::Savable
  # Save the document - will perform an insert if the document is new, and
  # update if not.
  #
  # _@param_ `options` — Options to pass to the save.
  #
  # _@return_ — True is success, false if not.
  #
  # Save the document.
  # ```ruby
  # document.save
  # ```
  def save: (?::Hash[untyped, untyped] options) -> bool

  # Save the document - will perform an insert if the document is new, and
  # update if not. If a validation error occurs an error will get raised.
  #
  # _@param_ `options` — Options to pass to the save.
  #
  # _@return_ — True if validation passed.
  #
  # Save the document.
  # ```ruby
  # document.save!
  # ```
  def save!: (?::Hash[untyped, untyped] options) -> bool
end

# Defines behavior for $pop operations.
#
# @since 4.0.0
module Mongoid::Persistable::Poppable
  extend ActiveSupport::Concern

  # Pop or shift items from arrays using the $pop operator.
  #
  # _@param_ `pops` — The field/value pop operations.
  #
  # _@return_ — The document.
  #
  # Pop items from an array.
  # ```ruby
  # document.pop(aliases: 1)
  # ```
  #
  # Shift items in the array.
  # ```ruby
  # document.pop(aliases: -1)
  # ```
  #
  # Multiple pops in one call.
  # ```ruby
  # document.pop(names: 1, aliases: 1)
  # ```
  def pop: (::Hash[untyped, untyped] pops) -> Document
end

# Defines behavior for $pull and $pullAll operations.
#
# @since 4.0.0
module Mongoid::Persistable::Pullable
  extend ActiveSupport::Concern

  # Pull single values from the provided arrays.
  #
  # _@param_ `pulls` — The field/value pull pairs.
  #
  # _@return_ — The document.
  #
  # Pull a value from the array.
  # ```ruby
  # document.pull(names: "Jeff", levels: 5)
  # ```
  #
  # _@note_ — If duplicate values are found they will all be pulled.
  def pull: (::Hash[untyped, untyped] pulls) -> Document

  # Pull multiple values from the provided array fields.
  #
  # _@param_ `pulls` — The pull all operations.
  #
  # _@return_ — The document.
  #
  # Pull values from the arrays.
  # ```ruby
  # document.pull_all(names: [ "Jeff", "Bob" ], levels: [ 5, 6 ])
  # ```
  def pull_all: (::Hash[untyped, untyped] pulls) -> Document
end

# Defines behavior for $push and $addToSet operations.
#
# @since 4.0.0
module Mongoid::Persistable::Pushable
  extend ActiveSupport::Concern

  # Add the single values to the arrays only if the value does not already
  # exist in the array.
  #
  # _@param_ `adds` — The field/value pairs to add.
  #
  # _@return_ — The document.
  #
  # Add the values to the sets.
  # ```ruby
  # document.add_to_set(names: "James", aliases: "Bond")
  # ```
  def add_to_set: (::Hash[untyped, untyped] adds) -> Document

  # Push a single value or multiple values onto arrays.
  #
  # _@param_ `pushes` — The $push operations.
  #
  # _@return_ — The document.
  #
  # Push a single value onto arrays.
  # ```ruby
  # document.push(names: "James", aliases: "007")
  # ```
  #
  # Push multiple values onto arrays.
  # ```ruby
  # document.push(names: [ "James", "Bond" ])
  # ```
  def push: (::Hash[untyped, untyped] pushes) -> Document
end

# Defines behavior for $set operations.
#
# @since 4.0.0
module Mongoid::Persistable::Settable
  extend ActiveSupport::Concern

  # Perform a $set operation on the provided field/value pairs and set the
  # values in the document in memory.
  #
  # The key can be a dotted sequence of keys, in which case the
  # top level field is treated as a nested hash and any missing keys
  # are created automatically:
  #
  # Performing a nested set like this merges values of intermediate keys:
  #
  # If the top level field was not a hash, its original value is discarded
  # and the field is replaced with a hash.
  #
  # Note that unlike MongoDB's $set, Mongoid's set writes out the entire
  # field even when setting a subset of the field via the nested hash
  # semantics. This means performing a $set with nested hash semantics
  # can overwrite other hash keys within the top level field in the database.
  #
  # _@param_ `setters` — The field/value pairs to set.
  #
  # _@return_ — The document.
  #
  # Set the values.
  # ```ruby
  # document.set(title: "sir", dob: Date.new(1970, 1, 1))
  # ```
  #
  # Set the values using nested hash semantics.
  # ```ruby
  # document.set('author.title' => 'Sir')
  # # => document.author == {'title' => 'Sir'}
  # ```
  #
  # Nested hash value merging.
  # ```ruby
  # document.set('author.title' => 'Sir')
  # document.set('author.name' => 'Linus Torvalds')
  # # => document.author == {'title' => 'Sir', 'name' => 'Linus Torvalds'}
  # ```
  #
  # Nested hash overwriting a non-hash value.
  # ```ruby
  # document.set('author' => 'John Doe')
  # document.set('author.title' => 'Sir')
  # # => document.author == {'title' => 'Sir'}
  # ```
  def set: (::Hash[untyped, untyped] setters) -> Document
end

# Defines behavior for persistence operations that create new documents.
#
# @since 4.0.0
module Mongoid::Persistable::Creatable
  extend ActiveSupport::Concern

  # Insert a new document into the database. Will return the document
  # itself whether or not the save was successful.
  #
  # _@param_ `options` — Options to pass to insert.
  #
  # _@return_ — The persisted document.
  #
  # Insert a document.
  # ```ruby
  # document.insert
  # ```
  def insert: (?::Hash[untyped, untyped] options) -> Document

  # Get the atomic insert for embedded documents, either a push or set.
  #
  # _@return_ — The insert ops.
  #
  # Get the inserts.
  # ```ruby
  # document.inserts
  # ```
  def atomic_inserts: () -> ::Hash[untyped, untyped]

  # Insert the embedded document.
  #
  # _@return_ — The document.
  #
  # Insert the document as embedded.
  # ```ruby
  # document.insert_as_embedded
  # ```
  def insert_as_embedded: () -> Document

  # Insert the root document.
  #
  # _@return_ — The document.
  #
  # Insert the document as root.
  # ```ruby
  # document.insert_as_root
  # ```
  def insert_as_root: () -> Document

  # Post process an insert, which sets the new record attribute to false
  # and flags all the children as persisted.
  #
  # _@return_ — true.
  #
  # Post process the insert.
  # ```ruby
  # document.post_process_insert
  # ```
  def post_process_insert: () -> bool

  # Prepare the insert for execution. Validates and runs callbacks, etc.
  #
  # _@param_ `options` — The options.
  #
  # _@return_ — The document.
  #
  # Prepare for insertion.
  # ```ruby
  # document.prepare_insert do
  #   collection.insert(as_document)
  # end
  # ```
  def prepare_insert: (?::Hash[untyped, untyped] options) -> Document
end

module Mongoid::Persistable::Mongoid::Persistable::Creatable::ClassMethods
  # Create a new document. This will instantiate a new document and
  # insert it in a single call. Will always return the document
  # whether save passed or not.
  #
  # _@param_ `attributes` — The attributes to create with, or an Array of multiple attributes for multiple documents.
  #
  # _@return_ — The newly created document(s).
  #
  # Create a new document.
  # ```ruby
  # Person.create(:title => "Mr")
  # ```
  #
  # Create multiple new documents.
  # ```ruby
  # Person.create({ title: "Mr" }, { title: "Mrs" })
  # ```
  def create: (?(::Hash[untyped, untyped] | ::Array[untyped])? attributes) { () -> untyped } -> (Document | ::Array[Document])

  # Create a new document. This will instantiate a new document and
  # insert it in a single call. Will always return the document
  # whether save passed or not, and if validation fails an error will be
  # raise.
  #
  # _@param_ `attributes` — The attributes to create with, or an Array of multiple attributes for multiple documents.
  #
  # _@return_ — The newly created document(s).
  #
  # Create a new document.
  # ```ruby
  # Person.create!(:title => "Mr")
  # ```
  #
  # Create multiple new documents.
  # ```ruby
  # Person.create!({ title: "Mr" }, { title: "Mrs" })
  # ```
  def create!: (?(::Hash[untyped, untyped] | ::Array[untyped])? attributes) { () -> untyped } -> (Document | ::Array[Document])
end

# Defines behavior for persistence operations that delete documents.
#
# @since 4.0.0
module Mongoid::Persistable::Deletable
  extend ActiveSupport::Concern

  # Remove the document from the database.
  #
  # _@param_ `options` — Options to pass to remove.
  #
  # _@return_ — True.
  #
  # Remove the document.
  # ```ruby
  # document.remove
  # ```
  def delete: (?::Hash[untyped, untyped] options) -> TrueClass

  # Get the atomic deletes for the operation.
  #
  # _@return_ — The atomic deletes.
  #
  # Get the atomic deletes.
  # ```ruby
  # document.atomic_deletes
  # ```
  def atomic_deletes: () -> ::Hash[untyped, untyped]

  # Delete the embedded document.
  #
  # _@param_ `options` — The deletion options.
  #
  # _@return_ — If the operation succeeded.
  #
  # Delete the embedded document.
  # ```ruby
  # document.delete_as_embedded
  # ```
  def delete_as_embedded: (?::Hash[untyped, untyped] options) -> bool

  # Delete the root document.
  #
  # _@return_ — If the document was removed.
  #
  # Delete the root document.
  # ```ruby
  # document.delete_as_root
  # ```
  def delete_as_root: () -> bool

  # Are we needing to notify the parent document of the deletion.
  #
  # _@param_ `options` — The delete options.
  #
  # _@return_ — If the parent should be notified.
  #
  # Are we notifying the parent.
  # ```ruby
  # document.notifying_parent?(suppress: true)
  # ```
  def notifying_parent?: (?::Hash[untyped, untyped] options) -> bool

  # Prepare the delete operation.
  #
  # _@return_ — The result of the block.
  #
  # Prepare the delete operation.
  # ```ruby
  # document.prepare_delete do
  #   collection.find(atomic_selector).remove
  # end
  # ```
  def prepare_delete: () -> Object
end

module Mongoid::Persistable::Mongoid::Persistable::Deletable::ClassMethods
  # Delete all documents given the supplied conditions. If no conditions
  # are passed, the entire collection will be dropped for performance
  # benefits. Does not fire any callbacks.
  #
  # _@param_ `conditions` — Optional conditions to delete by.
  #
  # _@return_ — The number of documents deleted.
  #
  # Delete matching documents from the collection.
  # ```ruby
  # Person.delete_all({ :title => "Sir" })
  # ```
  #
  # Delete all documents from the collection.
  # ```ruby
  # Person.delete_all
  # ```
  def delete_all: (?::Hash[untyped, untyped] conditions) -> Integer
end

# Defines behavior for $rename operations.
#
# @since 4.0.0
module Mongoid::Persistable::Renamable
  extend ActiveSupport::Concern

  # Rename fields from one value to another via $rename.
  #
  # _@param_ `renames` — The rename pairs of old name/new name.
  #
  # _@return_ — The document.
  #
  # Rename the fields.
  # ```ruby
  # document.rename(title: "salutation", name: "nombre")
  # ```
  #
  # _@note_ — This does not work for fields in embeds many associations.
  def rename: (::Hash[untyped, untyped] renames) -> Document
end

# Defines behavior for persistence operations that update existing
# documents.
#
# @since 4.0.0
module Mongoid::Persistable::Updatable
  # Update a single attribute and persist the entire document.
  # This skips validation but fires the callbacks.
  #
  # _@param_ `name` — The name of the attribute.
  #
  # _@param_ `value` — The new value of the attribute.a
  #
  # _@return_ — True if save was successfull, false if not.
  #
  # Update the attribute.
  # ```ruby
  # person.update_attribute(:title, "Sir")
  # ```
  def update_attribute: (Symbol | String name, Object value) -> bool

  # Update the document attributes in the database.
  #
  # _@param_ `attributes` — The attributes to update.
  #
  # _@return_ — True if validation passed, false if not.
  #
  # Update the document's attributes
  # ```ruby
  # document.update(:title => "Sir")
  # ```
  def update: (?::Hash[untyped, untyped] attributes) -> bool

  # Update the document attributes in the database and raise an error if
  # validation failed.
  #
  # _@param_ `attributes` — The attributes to update.
  #
  # _@return_ — True if validation passed.
  #
  # Update the document's attributes.
  # ```ruby
  # document.update!(:title => "Sir")
  # ```
  def update!: (?::Hash[untyped, untyped] attributes) -> bool

  # Initialize the atomic updates.
  #
  # _@return_ — The updates and conflicts.
  #
  # Initialize the atomic updates.
  # ```ruby
  # document.init_atomic_updates
  # ```
  def init_atomic_updates: () -> ::Array[::Hash[untyped, untyped]]

  # Prepare the update for execution. Validates and runs callbacks, etc.
  #
  # _@param_ `options` — The options.
  #
  # _@return_ — The result of the update.
  #
  # Prepare for update.
  # ```ruby
  # document.prepare_update do
  #   collection.update(atomic_selector)
  # end
  # ```
  def prepare_update: (?::Hash[untyped, untyped] options) -> bool

  # Update the document in the database.
  #
  # _@param_ `options` — Options to pass to update.
  #
  # _@return_ — True if succeeded, false if not.
  #
  # Update an existing document.
  # ```ruby
  # document.update
  # ```
  def update_document: (?::Hash[untyped, untyped] options) -> bool
end

# Defines behavior for $unset operations.
#
# @since 4.0.0
module Mongoid::Persistable::Unsettable
  extend ActiveSupport::Concern

  # Perform an $unset operation on the provided fields and in the
  # values in the document in memory.
  #
  # _@param_ `fields` — The names of the fields to unset.
  #
  # _@return_ — The document.
  #
  # Unset the values.
  # ```ruby
  # document.unset(:first_name, :last_name, :middle)
  # ```
  def unset: (*::Array[String | Symbol] fields) -> Document
end

# Defines behavior for persistence operations that upsert documents.
#
# @since 4.0.0
module Mongoid::Persistable::Upsertable
  # Perform an upsert of the document. If the document does not exist in the
  # database, then Mongo will insert a new one, otherwise the fields will get
  # overwritten with new values on the existing document.
  #
  # _@param_ `options` — The validation options.
  #
  # _@return_ — True.
  #
  # Upsert the document.
  # ```ruby
  # document.upsert
  # ```
  def upsert: (?::Hash[untyped, untyped] options) -> bool

  # Prepare the upsert for execution.
  #
  # _@param_ `options` — The options hash.
  #
  # _@return_ — If the operation succeeded.
  #
  # Prepare the upsert
  # ```ruby
  # document.prepare_upsert do
  #   collection.find(selector).update(as_document)
  # end
  # ```
  def prepare_upsert: (?::Hash[untyped, untyped] options) -> bool
end

# Defines behavior for persistence operations that destroy documents.
#
# @since 4.0.0
module Mongoid::Persistable::Destroyable
  extend ActiveSupport::Concern

  # Remove the document from the database with callbacks.
  #
  # _@param_ `options` — Options to pass to destroy.
  #
  # _@return_ — True if successful, false if not.
  #
  # Destroy a document.
  # ```ruby
  # document.destroy
  # ```
  def destroy: (?::Hash[untyped, untyped]? options) -> bool

  def destroy!: (?untyped options) -> untyped
end

module Mongoid::Persistable::Mongoid::Persistable::Destroyable::ClassMethods
  # Delete all documents given the supplied conditions. If no conditions
  # are passed, the entire collection will be dropped for performance
  # benefits. Fires the destroy callbacks if conditions were passed.
  #
  # _@param_ `conditions` — Optional conditions to destroy by.
  #
  # _@return_ — The number of documents destroyed.
  #
  # Destroy matching documents from the collection.
  # ```ruby
  # Person.destroy_all({ :title => "Sir" })
  # ```
  #
  # Destroy all documents from the collection.
  # ```ruby
  # Person.destroy_all
  # ```
  def destroy_all: (?::Hash[untyped, untyped]? conditions) -> Integer
end

# Defines behavior for $inc operations.
#
# @since 4.0.0
module Mongoid::Persistable::Incrementable
  extend ActiveSupport::Concern

  # Increment the provided fields by the corresponding values. Values can
  # be positive or negative, and if no value exists for the field it will
  # be set with the provided value.
  #
  # _@param_ `increments` — The field/inc increment pairs.
  #
  # _@return_ — The document.
  #
  # Increment the fields.
  # ```ruby
  # document.inc(score: 10, place: 1, lives: -10)
  # ```
  def inc: (::Hash[untyped, untyped] increments) -> Document
end

# A cache of database queries on a per-request basis.
#
# @since 4.0.0
module Mongoid::QueryCache
  # Get the cached queries.
  #
  # _@return_ — The hash of cached queries.
  #
  # Get the cached queries from the current thread.
  # ```ruby
  # QueryCache.cache_table
  # ```
  def self.cache_table: () -> ::Hash[untyped, untyped]

  # Clear the query cache.
  #
  # _@return_ — Always nil.
  #
  # Clear the cache.
  # ```ruby
  # QueryCache.clear_cache
  # ```
  def self.clear_cache: () -> nil

  # Set whether the cache is enabled.
  #
  # _@param_ `value` — The enabled value.
  #
  # Set if the cache is enabled.
  # ```ruby
  # QueryCache.enabled = true
  # ```
  def self.enabled=: (bool value) -> untyped

  # Is the query cache enabled on the current thread?
  #
  # _@return_ — If the cache is enabled.
  #
  # Is the query cache enabled?
  # ```ruby
  # QueryCache.enabled?
  # ```
  def self.enabled?: () -> bool

  # Execute the block while using the query cache.
  #
  # _@return_ — The result of the block.
  #
  # Execute with the cache.
  # ```ruby
  # QueryCache.cache { collection.find }
  # ```
  def self.cache: () { () -> untyped } -> Object

  # Execute the block with the query cache disabled.
  #
  # _@return_ — The result of the block.
  #
  # Execute without the cache.
  # ```ruby
  # QueryCache.uncached { collection.find }
  # ```
  def self.uncached: () { () -> untyped } -> Object
end

# The middleware to be added to a rack application in order to activate the
# query cache.
#
# @since 4.0.0
class Mongoid::QueryCache::Middleware
  # Instantiate the middleware.
  #
  # _@param_ `app` — The rack applciation stack.
  #
  # Create the new middleware.
  # ```ruby
  # Middleware.new(app)
  # ```
  def initialize: (Object app) -> void

  # Execute the request, wrapping in a query cache.
  #
  # _@param_ `env` — The environment.
  #
  # _@return_ — The result of the call.
  #
  # Execute the request.
  # ```ruby
  # middleware.call(env)
  # ```
  def call: (Object env) -> Object
end

# A Cursor that attempts to load documents from memory first before hitting
# the database if the same query has already been executed.
#
# @since 5.0.0
# @deprecated This class is only used with driver versions 2.13 and lower.
class Mongoid::QueryCache::CachedCursor < Mongo::Cursor
  # We iterate over the cached documents if they exist already in the
  # cursor otherwise proceed as normal.
  #
  # Iterate over the documents.
  # ```ruby
  # cursor.each do |doc|
  #   # ...
  # end
  # ```
  def each: () -> untyped

  # Get a human-readable string representation of +Cursor+.
  #
  # _@return_ — A string representation of a +Cursor+ instance.
  #
  # Inspect the cursor.
  # ```ruby
  # cursor.inspect
  # ```
  def inspect: () -> String

  def process: (untyped result) -> untyped
end

Mongoid::QueryCache::Mongoid::QueryCache::CachedCursor::Elem: untyped

# Included to add behavior for clearing out the query cache on certain
# operations.
#
# @since 4.0.0
# @deprecated This module is only used with driver versions 2.13 and lower.
module Mongoid::QueryCache::Base
  def alias_query_cache_clear: (*untyped method_names) -> untyped
end

# Contains enhancements to the Mongo::Collection::View in order to get a
# cached cursor or a regular cursor on iteration.
#
# @since 5.0.0
# @deprecated This module is only used with driver versions 2.13 and lower.
module Mongoid::QueryCache::View
  extend ActiveSupport::Concern

  # Override the default enumeration to handle if the cursor can be cached
  # or not.
  #
  # Iterate over the view.
  # ```ruby
  # view.each do |doc|
  #   # ...
  # end
  # ```
  def each: () -> untyped

  def cached_cursor: () -> untyped

  def cache_key: () -> untyped

  def system_collection?: () -> bool
end

# Adds behavior to the query cache for collections.
#
# @since 5.0.0
# @deprecated This module is only used with driver versions 2.13 and lower.
module Mongoid::QueryCache::Collection
  extend ActiveSupport::Concern
end

# Bypass the query cache when reloading a document.
module Mongoid::QueryCache::Document
  def reload: () -> untyped
end

# Provides behavior around traversing the document graph.
#
# @since 4.0.0
module Mongoid::Traversable
  extend ActiveSupport::Concern

  def _parent: () -> untyped

  def _parent=: (untyped p) -> untyped

  # Get all child +Documents+ to this +Document+, going n levels deep if
  # necessary. This is used when calling update persistence operations from
  # the root document, where changes in the entire tree need to be
  # determined. Note that persistence from the embedded documents will
  # always be preferred, since they are optimized calls... This operation
  # can get expensive in domains with large hierarchies.
  #
  # _@return_ — All child documents in the hierarchy.
  #
  # Get all the document's children.
  # ```ruby
  # person._children
  # ```
  def _children: () -> ::Array[Document]

  # Collect all the children of this document.
  #
  # _@return_ — The children.
  #
  # Collect all the children.
  # ```ruby
  # document.collect_children
  # ```
  def collect_children: () -> ::Array[Document]

  # Marks all children as being persisted.
  #
  # _@return_ — The flagged children.
  #
  # Flag all the children.
  # ```ruby
  # document.flag_children_persisted
  # ```
  def flag_children_persisted: () -> ::Array[Document]

  # Determines if the document is a subclass of another document.
  #
  # _@return_ — True if hereditary, false if not.
  #
  # Check if the document is a subclass
  # ```ruby
  # Square.new.hereditary?
  # ```
  def hereditary?: () -> bool

  # Sets up a child/parent association. This is used for newly created
  # objects so they can be properly added to the graph.
  #
  # _@param_ `document` — The parent document.
  #
  # _@return_ — The parent document.
  #
  # Set the parent document.
  # ```ruby
  # document.parentize(parent)
  # ```
  def parentize: (Document document) -> Document

  # Remove a child document from this parent. If an embeds one then set to
  # nil, otherwise remove from the embeds many.
  #
  # This is called from the +RemoveEmbedded+ persistence command.
  #
  # _@param_ `child` — The child (embedded) document to remove.
  #
  # Remove the child.
  # ```ruby
  # document.remove_child(child)
  # ```
  def remove_child: (Document child) -> untyped

  # After children are persisted we can call this to move all their changes
  # and flag them as persisted in one call.
  #
  # _@return_ — The children.
  #
  # Reset the children.
  # ```ruby
  # document.reset_persisted_children
  # ```
  def reset_persisted_children: () -> ::Array[Document]

  # Resets the memoized children on the object. Called internally when an
  # embedded array changes size.
  #
  # _@return_ — nil.
  #
  # Reset the memoized children.
  # ```ruby
  # document._reset_memoized_children!
  # ```
  def _reset_memoized_children!: () -> nil

  # Return the root document in the object graph. If the current document
  # is the root object in the graph it will return self.
  #
  # _@return_ — The root document in the hierarchy.
  #
  # Get the root document in the hierarchy.
  # ```ruby
  # document._root
  # ```
  def _root: () -> Document

  # Is this document the root document of the hierarchy?
  #
  # _@return_ — If the document is the root.
  #
  # Is the document the root?
  # ```ruby
  # document._root?
  # ```
  def _root?: () -> bool
end

# Module used for prepending to the various discriminator_*= methods
#
# @api private
module Mongoid::Traversable::DiscriminatorAssignment
  def discriminator_key=: (untyped value) -> untyped

  def discriminator_value=: (untyped value) -> untyped
end

# Module used for prepending the discriminator_value method.
#
# A separate module was needed because the subclasses of this class
# need to be manually prepended with the discriminator_value and can't
# rely on being a class_attribute because the .discriminator_value
# method is overriden by every subclass in the inherited method.
#
# @api private
module Mongoid::Traversable::DiscriminatorRetrieval
  # Get the name on the reading side if the discriminator_value is nil
  def discriminator_value: () -> untyped
end

module Mongoid::Traversable::ClassMethods
  # Determines if the document is a subclass of another document.
  #
  # _@return_ — True if hereditary, false if not.
  #
  # Check if the document is a subclass.
  # ```ruby
  # Square.hereditary?
  # ```
  def hereditary?: () -> bool

  # When inheriting, we want to copy the fields from the parent class and
  # set the on the child to start, mimicking the behavior of the old
  # class_inheritable_accessor that was deprecated in Rails edge.
  #
  # _@param_ `subclass` — The inheriting class.
  #
  # Inherit from this class.
  # ```ruby
  # Person.inherited(Doctor)
  # ```
  def inherited: (Class subclass) -> untyped
end

# This module provides additional validations that ActiveModel does not
# provide: validates_associated and validates_uniqueness_of.
module Mongoid::Validatable
  extend ActiveSupport::Concern

  # Begin the associated validation.
  #
  # Begin validation.
  # ```ruby
  # document.begin_validate
  # ```
  def begin_validate: () -> untyped

  # Exit the associated validation.
  #
  # Exit validation.
  # ```ruby
  # document.exit_validate
  # ```
  def exit_validate: () -> untyped

  # Given the provided options, are we performing validations?
  #
  # _@param_ `options` — The options to check.
  #
  # _@return_ — If we are validating.
  #
  # Are we performing validations?
  # ```ruby
  # document.performing_validations?(validate: true)
  # ```
  def performing_validations?: (?::Hash[untyped, untyped] options) -> bool

  # Overrides the default ActiveModel behavior since we need to handle
  # validations of associations slightly different than just calling the
  # getter.
  #
  # _@param_ `attr` — The name of the field or association.
  #
  # _@return_ — The value of the field or the association.
  #
  # Read the value.
  # ```ruby
  # person.read_attribute_for_validation(:addresses)
  # ```
  def read_attribute_for_validation: (Symbol attr) -> Object

  # Determine if the document is valid.
  #
  # _@param_ `context` — The optional validation context.
  #
  # _@return_ — True if valid, false if not.
  #
  # Is the document valid?
  # ```ruby
  # person.valid?
  # ```
  #
  # Is the document valid in a context?
  # ```ruby
  # person.valid?(:create)
  # ```
  def valid?: (?Symbol? context) -> bool

  # Used to prevent infinite loops in associated validations.
  #
  # _@return_ — Has the document already been validated?
  #
  # Is the document validated?
  # ```ruby
  # document.validated?
  # ```
  def validated?: () -> bool

  # Are we currently performing a validation that has a query?
  #
  # _@return_ — If we are validating with a query.
  #
  # Are we validating with a query?
  # ```ruby
  # document.validating_with_query?
  # ```
  def validating_with_query?: () -> bool
end

module Mongoid::Validatable::ClassMethods
  # Adds an associated validator for the association if the validate option
  # was not provided or set to true.
  #
  # _@param_ `association` — The association metadata.
  #
  # Set up validation.
  # ```ruby
  # Person.validates_relation(association)
  # ```
  def validates_relation: (Association association) -> untyped

  # Add validation with the supplied validators forthe provided fields
  # with options.
  #
  # _@param_ `args` — The validator classes and options.
  #
  # Validate with a specific validator.
  # ```ruby
  # validates_with MyValidator, on: :create
  # ```
  #
  # _@note_ — See ActiveModel::Validations::With for full options. This is
  # overridden to add autosave functionality when presence validation is
  # added.
  def validates_with: (*::Array[untyped] | ::Hash[untyped, untyped] args) { () -> untyped } -> untyped

  # Are we currently performing a validation that has a query?
  #
  # _@return_ — If we are validating with a query.
  #
  # Are we validating with a query?
  # ```ruby
  # Model.validating_with_query?
  # ```
  def validating_with_query?: () -> bool
end

# Validates that the specified attributes do or do not match a certain
# regular expression.
#
# @example Set up the format validator.
#
#   class Person
#     include Mongoid::Document
#     field :website
#
#     validates_format_of :website, :with => URI.regexp
#   end
class Mongoid::Validatable::FormatValidator < ActiveModel::Validations::FormatValidator
  include Mongoid::Validatable::Localizable

  # Validates each for localized fields.
  #
  # _@param_ `document` — The document.
  #
  # _@param_ `attribute` — The attribute to validate.
  #
  # _@param_ `value` — The attribute value.
  #
  # Validate localized fields.
  # ```ruby
  # validator.validate_each(model, :name, "value")
  # ```
  def validate_each: (Document document, Symbol | String attribute, Object value) -> untyped
end

# Validates that the specified attributes do or do not match a certain
# length.
#
# @example Set up the length validator.
#
#   class Person
#     include Mongoid::Document
#     field :website
#
#     validates_length_of :website, in: 1..10
#   end
class Mongoid::Validatable::LengthValidator < ActiveModel::Validations::LengthValidator
  include Mongoid::Validatable::Localizable

  # Validates each for localized fields.
  #
  # _@param_ `document` — The document.
  #
  # _@param_ `attribute` — The attribute to validate.
  #
  # _@param_ `value` — The attribute value.
  #
  # Validate localized fields.
  # ```ruby
  # validator.validate_each(model, :name, "value")
  # ```
  def validate_each: (Document document, Symbol | String attribute, Object value) -> untyped
end

module Mongoid::Validatable::Macros
  extend ActiveSupport::Concern

  # Validates whether or not an association is valid or not. Will correctly
  # handle has one and has many associations.
  #
  # _@param_ `args` — The arguments to pass to the validator.
  #
  # ```ruby
  #
  # class Person
  #   include Mongoid::Document
  #   embeds_one :name
  #   embeds_many :addresses
  #
  #   validates_associated :name, :addresses
  # end
  # ```
  def validates_associated: (*::Array[untyped] args) -> untyped

  # Validates whether or not a field is unique against the documents in the
  # database.
  #
  # _@param_ `args` — The arguments to pass to the validator.
  #
  # ```ruby
  #
  # class Person
  #   include Mongoid::Document
  #   field :title
  #
  #   validates_uniqueness_of :title
  # end
  # ```
  def validates_uniqueness_of: (*::Array[untyped] args) -> untyped

  # Validates the format of a field.
  #
  # _@param_ `args` — The names of the fields to validate.
  #
  # ```ruby
  # class Person
  #   include Mongoid::Document
  #   field :title
  #
  #   validates_format_of :title, with: /\A[a-z0-9 \-_]*\z/i
  # end
  # ```
  def validates_format_of: (*::Array[untyped] args) -> untyped

  # Validates the length of a field.
  #
  # _@param_ `args` — The names of the fields to validate.
  #
  # ```ruby
  # class Person
  #   include Mongoid::Document
  #   field :title
  #
  #   validates_length_of :title, minimum: 100
  # end
  # ```
  def validates_length_of: (*::Array[untyped] args) -> untyped

  # Validates whether or not a field is present - meaning nil or empty.
  #
  # _@param_ `args` — The names of the fields to validate.
  #
  # ```ruby
  # class Person
  #   include Mongoid::Document
  #   field :title
  #
  #   validates_presence_of :title
  # end
  # ```
  def validates_presence_of: (*::Array[untyped] args) -> untyped
end

# Validates that the specified attributes are not blank (as defined by
# Object#blank?).
#
# @example Define the presence validator.
#
#   class Person
#     include Mongoid::Document
#     field :title
#
#     validates_presence_of :title
#   end
class Mongoid::Validatable::PresenceValidator < ActiveModel::EachValidator
  # Validate the document for the attribute and value.
  #
  # _@param_ `document` — The document to validate.
  #
  # _@param_ `attribute` — The attribute name.
  #
  # _@param_ `value` — The current value of the field.
  #
  # Validate the document.
  # ```ruby
  # validator.validate_each(doc, :title, "")
  # ```
  def validate_each: (Document document, Symbol attribute, Object value) -> untyped

  # Returns true if the association is blank or the foreign key is blank.
  #
  # _@param_ `doc` — The document.
  #
  # _@param_ `attr` — The attribute.
  #
  # _@param_ `value` — The value.
  #
  # _@return_ — If the doc is missing.
  #
  # Check is the association or fk is blank.
  # ```ruby
  # validator.relation_or_fk_mising(doc, :name, "")
  # ```
  def relation_or_fk_missing?: (Document doc, Symbol attr, Object value) -> bool

  # For guarding against false values.
  #
  # _@param_ `value` — The value.
  #
  # _@return_ — If the value is not present.
  #
  # Is the value not present?
  # ```ruby
  # validator.not_present?(value)
  # ```
  def not_present?: (Object value) -> bool
end

module Mongoid::Validatable::Queryable
  # Wrap the validation inside the an execution block that alert's the
  # client not to clear its persistence options.
  #
  # _@param_ `document` — The document being validated.
  #
  # _@return_ — The result of the yield.
  #
  # Execute the validation with a query.
  # ```ruby
  # with_query(document) do
  #   #...
  # end
  # ```
  def with_query: (Document document) -> Object
end

# Validates whether or not an association is valid or not. Will correctly
# handle has one and has many associations.
#
# @example Set up the association validations.
#
#   class Person
#     include Mongoid::Document
#     embeds_one :name
#     embeds_many :addresses
#
#     validates_associated :name, :addresses
#   end
class Mongoid::Validatable::AssociatedValidator < ActiveModel::EachValidator
  # Validates that the associations provided are either all nil or all
  # valid. If neither is true then the appropriate errors will be added to
  # the parent document.
  #
  # _@param_ `document` — The document to validate.
  #
  # _@param_ `attribute` — The association to validate.
  #
  # _@param_ `value` — The value of the association.
  #
  # Validate the association.
  # ```ruby
  # validator.validate_each(document, :name, name)
  # ```
  def validate_each: (Document document, Symbol attribute, Object value) -> untyped
end

# Validates whether or not a field is unique against the documents in the
# database.
#
# @example Define the uniqueness validator.
#
#   class Person
#     include Mongoid::Document
#     field :title
#
#     validates_uniqueness_of :title
#   end
#
# It is also possible to limit the uniqueness constraint to a set of
# records matching certain conditions:
#   class Person
#     include Mongoid::Document
#     field :title
#     field :active, type: Boolean
#
#     validates_uniqueness_of :title, conditions: -> {where(active: true)}
#   end
class Mongoid::Validatable::UniquenessValidator < ActiveModel::EachValidator
  include Mongoid::Validatable::Queryable

  # Validate the document for uniqueness violations.
  #
  # _@param_ `document` — The document to validate.
  #
  # _@param_ `attribute` — The field to validate on.
  #
  # _@param_ `value` — The value of the field.
  #
  # _@return_ — The errors.
  #
  # Validate the document.
  # ```ruby
  # validate_each(person, :title, "Sir")
  # ```
  def validate_each: (Document document, Symbol attribute, Object value) -> Errors

  # Add the error to the document.
  #
  # _@param_ `document` — The document to validate.
  #
  # _@param_ `attribute` — The name of the attribute.
  #
  # _@param_ `value` — The value of the object.
  #
  # Add the error.
  # ```ruby
  # validator.add_error(doc, :name, "test")
  # ```
  def add_error: (Document document, Symbol attribute, Object value) -> untyped

  # Should the uniqueness validation be case sensitive?
  #
  # _@return_ — If the validation is case sensitive.
  #
  # Is the validation case sensitive?
  # ```ruby
  # validator.case_sensitive?
  # ```
  def case_sensitive?: () -> bool

  def create_criteria: (untyped base, Document document, Symbol attribute, Object value) -> Criteria

  # Get the default criteria for checking uniqueness.
  #
  # _@param_ `document` — The document to validate.
  #
  # _@param_ `attribute` — The name of the attribute.
  #
  # _@param_ `value` — The value of the object.
  #
  # _@return_ — The uniqueness criteria.
  #
  # Get the criteria.
  # ```ruby
  # validator.criterion(person, :title, "Sir")
  # ```
  def criterion: (Document document, Symbol attribute, Object value) -> Criteria

  # Filter the value based on whether the check is case sensitive or not.
  #
  # _@param_ `value` — The value to filter.
  #
  # _@return_ — The value, filtered or not.
  #
  # Filter the value.
  # ```ruby
  # validator.filter("testing")
  # ```
  def filter: (Object value) -> (Object | Regexp)

  # Scope the criteria to the scope options provided.
  #
  # _@param_ `criteria` — The criteria to scope.
  #
  # _@param_ `document` — The document being validated.
  #
  # _@return_ — The scoped criteria.
  #
  # Scope the criteria.
  # ```ruby
  # validator.scope(criteria, document)
  # ```
  def scope: (Criteria criteria, Document document, untyped _attribute) -> Criteria

  # Should validation be skipped?
  #
  # _@param_ `document` — The embedded document.
  #
  # _@return_ — If the validation should be skipped.
  #
  # Should the validation be skipped?
  # ```ruby
  # validator.skip_validation?(doc)
  # ```
  def skip_validation?: (Document document) -> bool

  # Scope reference has changed?
  #
  # _@param_ `document` — The embedded document.
  #
  # _@return_ — If the scope reference has changed.
  #
  # Has scope reference changed?
  # ```ruby
  # validator.scope_value_changed?(doc)
  # ```
  def scope_value_changed?: (Document document) -> bool

  # Get the name of the field and the value to validate. This is for the
  # case when we validate an association via the association name and not the key,
  # we need to send the key name and value to the db, not the association
  # object.
  #
  # _@param_ `document` — The doc getting validated.
  #
  # _@param_ `attribute` — The attribute getting validated.
  #
  # _@param_ `value` — The value of the attribute.
  #
  # _@return_ — The field and value.
  #
  # Get the name and key to validate.
  # ```ruby
  # validator.to_validate(doc, :parent, Parent.new)
  # ```
  def to_validate: (Document document, Symbol attribute, Object value) -> ::Array[Object | Object]

  # Validate an embedded document.
  #
  # _@param_ `document` — The document.
  #
  # _@param_ `attribute` — The attribute name.
  #
  # _@param_ `value` — The value.
  #
  # Validate the embedded document.
  # ```ruby
  # validator.validate_embedded(doc, :name, "test")
  # ```
  def validate_embedded: (Document document, Symbol attribute, Object value) -> untyped

  # Validate a root document.
  #
  # _@param_ `document` — The document.
  #
  # _@param_ `attribute` — The attribute name.
  #
  # _@param_ `value` — The value.
  #
  # Validate the root document.
  # ```ruby
  # validator.validate_root(doc, :name, "test")
  # ```
  def validate_root: (Document document, Symbol attribute, Object value) -> untyped

  # Are we required to validate the document?
  #
  # _@param_ `document` — The document getting validated.
  #
  # _@param_ `attribute` — The attribute to validate.
  #
  # _@return_ — If we need to validate.
  #
  # Is validation needed?
  # ```ruby
  # validator.validation_required?(doc, :field)
  # ```
  def validation_required?: (Document document, Symbol attribute) -> bool

  # Is the attribute localized?
  #
  # _@param_ `document` — The document getting validated.
  #
  # _@param_ `attribute` — The attribute to validate.
  #
  # _@return_ — If the attribute is localized.
  #
  # Is the attribute localized?
  # ```ruby
  # validator.localized?(doc, :field)
  # ```
  def localized?: (Document document, Symbol attribute) -> bool

  # Wrap the validation inside the an execution block that alert's the
  # client not to clear its persistence options.
  #
  # _@param_ `document` — The document being validated.
  #
  # _@return_ — The result of the yield.
  #
  # Execute the validation with a query.
  # ```ruby
  # with_query(document) do
  #   #...
  # end
  # ```
  def with_query: (Document document) -> Object
end

# Adds localization support to validations.
module Mongoid::Validatable::Localizable
  # Validates each for localized fields.
  #
  # _@param_ `document` — The document.
  #
  # _@param_ `attribute` — The attribute to validate.
  #
  # _@param_ `value` — The attribute value.
  #
  # Validate localized fields.
  # ```ruby
  # validator.validate_each(model, :name, "value")
  # ```
  def validate_each: (Document document, Symbol | String attribute, Object value) -> untyped
end

# This module provides the extra behavior for including associations in JSON
# and XML serialization.
#
# @since 4.0.0
module Mongoid::Serializable
  extend ActiveSupport::Concern

  # Gets the document as a serializable hash, used by ActiveModel's JSON
  # serializer.
  #
  # _@param_ `options` — The options to pass.
  #
  # _@return_ — The document, ready to be serialized.
  #
  # Get the serializable hash.
  # ```ruby
  # document.serializable_hash
  # ```
  #
  # Get the serializable hash with options.
  # ```ruby
  # document.serializable_hash(:include => :addresses)
  # ```
  def serializable_hash: (?::Hash[untyped, untyped]? options) -> ::Hash[untyped, untyped]

  # Get the names of all fields that will be serialized.
  #
  # _@return_ — The names of the fields.
  #
  # Get all the field names.
  # ```ruby
  # document.send(:field_names)
  # ```
  def field_names: (untyped options) -> ::Array[String]

  def serialize_attribute: (::Hash[untyped, untyped] attrs, String name, ::Array[String] names, ::Hash[untyped, untyped] options) -> Object

  # For each of the provided include options, get the association needed and
  # provide it in the hash.
  #
  # _@param_ `attributes` — The attributes to serialize.
  #
  # _@param_ `options` — The serialization options.
  #
  # Serialize the included associations.
  # ```ruby
  # document.serialize_relations({}, :include => :addresses)
  # ```
  def serialize_relations: (?::Hash[untyped, untyped] attributes, ?::Hash[untyped, untyped] options) -> untyped

  # Since the inclusions can be a hash, symbol, or array of symbols, this is
  # provided as a convenience to parse out the names.
  #
  # _@param_ `inclusions` — The inclusions.
  #
  # _@return_ — The names of the included associations.
  #
  # Get the association names.
  # ```ruby
  # document.relation_names(:include => [ :addresses ])
  # ```
  def relation_names: (::Hash[untyped, untyped] | Symbol | ::Array[Symbol] inclusions) -> ::Array[Symbol]

  # Since the inclusions can be a hash, symbol, or array of symbols, this is
  # provided as a convenience to parse out the options.
  #
  # _@param_ `inclusions` — The inclusions.
  #
  # _@param_ `options` — The options.
  #
  # _@param_ `name` — The name of the association.
  #
  # _@return_ — The options for the association.
  #
  # Get the association options.
  # ```ruby
  # document.relation_names(:include => [ :addresses ])
  # ```
  def relation_options: (::Hash[untyped, untyped] | Symbol | ::Array[Symbol] inclusions, ::Hash[untyped, untyped] options, Symbol name) -> ::Hash[untyped, untyped]
end

# This module contains all the callback hooks for Mongoid.
#
# @since 4.0.0
module Mongoid::Interceptable
  extend ActiveSupport::Concern

  # Is the provided type of callback executable by this document?
  #
  # _@param_ `kind` — The type of callback.
  #
  # _@return_ — If the callback can be executed.
  #
  # Is the callback executable?
  # ```ruby
  # document.callback_executable?(:save)
  # ```
  def callback_executable?: (Symbol kind) -> bool

  # Is the document currently in a state that could potentially require
  # callbacks to be executed?
  #
  # _@param_ `kind` — The callback kind.
  #
  # _@return_ — If the document is in a callback state.
  #
  # Is the document in a callback state?
  # ```ruby
  # document.in_callback_state?(:update)
  # ```
  def in_callback_state?: (Symbol kind) -> bool

  # Run only the after callbacks for the specific event.
  #
  # _@param_ `kinds` — The events that are occurring.
  #
  # _@return_ — The result of the chain executing.
  #
  # Run only the after save callbacks.
  # ```ruby
  # model.run_after_callbacks(:save)
  # ```
  #
  # _@note_ — ActiveSupport does not allow this type of behavior by default, so
  # Mongoid has to get around it and implement itself.
  def run_after_callbacks: (*::Array[Symbol] kinds) -> Object

  # Run only the before callbacks for the specific event.
  #
  # _@param_ `kinds` — The events that are occurring.
  #
  # _@return_ — The result of the chain executing.
  #
  # Run only the before save callbacks.
  # ```ruby
  # model.run_before_callbacks(:save, :create)
  # ```
  #
  # _@note_ — ActiveSupport does not allow this type of behavior by default, so
  # Mongoid has to get around it and implement itself.
  def run_before_callbacks: (*::Array[Symbol] kinds) -> Object

  # Run the callbacks for the document. This overrides active support's
  # functionality to cascade callbacks to embedded documents that have been
  # flagged as such.
  #
  # _@param_ `kind` — The type of callback to execute.
  #
  # _@param_ `args` — Any options.
  #
  # _@return_ — The document
  #
  # Run the callbacks.
  # ```ruby
  # run_callbacks :save do
  #   save!
  # end
  # ```
  def run_callbacks: (Symbol kind, *::Array[untyped] args) { () -> untyped } -> Document

  # We need to hook into this for autosave, since we don't want it firing if
  # the before callbacks were halted.
  #
  # _@return_ — If a before callback was halted.
  #
  # Was a before callback halted?
  # ```ruby
  # document.before_callback_halted?
  # ```
  def before_callback_halted?: () -> bool

  # Get all the child embedded documents that are flagged as cascadable.
  #
  # _@param_ `kind` — The type of callback.
  #
  # _@return_ — The children.
  #
  # Get all the cascading children.
  # ```ruby
  # document.cascadable_children(:update)
  # ```
  def cascadable_children: (Symbol kind, ?untyped children) -> ::Array[Document]

  # Determine if the child should fire the callback.
  #
  # _@param_ `kind` — The type of callback.
  #
  # _@param_ `child` — The child document.
  #
  # _@return_ — If the child should fire the callback.
  #
  # Should the child fire the callback?
  # ```ruby
  # document.cascadable_child?(:update, doc)
  # ```
  def cascadable_child?: (Symbol kind, Document child, untyped association) -> bool

  # Get the name of the callback that the child should fire. This changes
  # depending on whether or not the child is new. A persisted parent with a
  # new child would fire :update from the parent, but needs to fire :create
  # on the child.
  #
  # _@param_ `kind` — The type of callback.
  #
  # _@param_ `child` — The child document
  #
  # _@return_ — The name of the callback.
  #
  # Get the callback type.
  # ```ruby
  # document.child_callback_type(:update, doc)
  # ```
  def child_callback_type: (Symbol kind, Document child) -> Symbol

  # We need to hook into this for autosave, since we don't want it firing if
  # the before callbacks were halted.
  #
  # _@param_ `filter` — The callback that halted.
  #
  # _@param_ `name` — The name of the callback that was halted (requires Rails 6.1+)
  #
  # Hook into the halt.
  # ```ruby
  # document.halted_callback_hook(filter)
  # ```
  def halted_callback_hook: (Symbol filter, ?Symbol? name) -> untyped

  # Run only the callbacks for the target location (before, after, around)
  # and kind (save, update, create).
  #
  # _@param_ `place` — The time to run, :before, :after, :around.
  #
  # _@param_ `kind` — The type of callback, :save, :create, :update.
  #
  # _@return_ — The result of the chain execution.
  #
  # Run the targeted callbacks.
  # ```ruby
  # model.run_targeted_callbacks(:before, :save)
  # ```
  def run_targeted_callbacks: (Symbol place, Symbol kind) -> Object
end

Mongoid::Interceptable::CALLBACKS: untyped

module Mongoid::Extensions
end

module Mongoid::Extensions::Set
  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # _@return_ — The object mongoized.
  #
  # Mongoize the object.
  # ```ruby
  # set.mongoize
  # ```
  def mongoize: () -> ::Array[untyped]
end

module Mongoid::Extensions::Mongoid::Extensions::Set::ClassMethods
  # Convert the object from its mongo friendly ruby type to this type.
  #
  # _@param_ `object` — The object to demongoize.
  #
  # _@return_ — The set.
  #
  # Demongoize the object.
  # ```ruby
  # Set.demongoize([1, 2, 3])
  # ```
  def demongoize: (::Array[untyped] object) -> ::Set[untyped]

  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # _@param_ `object` — The object to mongoize.
  #
  # _@return_ — The object mongoized.
  #
  # Mongoize the object.
  # ```ruby
  # Set.mongoize(Set.new([1,2,3]))
  # ```
  def mongoize: (::Set[untyped] object) -> ::Array[untyped]
end

module Mongoid::Extensions::Date
  # sord warn - ActiveSupport::TimeWithZone wasn't able to be resolved to a constant in this project
  # Convert the date into a time.
  #
  # _@return_ — Local time in the
  # configured default time zone corresponding to local midnight of
  # this date.
  #
  # Convert the date to a time.
  # ```ruby
  # Date.new(2018, 11, 1).__mongoize_time__
  # # => Thu, 01 Nov 2018 00:00:00 EDT -04:00
  # ```
  def __mongoize_time__: () -> (Time | ActiveSupport::TimeWithZone)

  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # _@return_ — The object mongoized.
  #
  # Mongoize the object.
  # ```ruby
  # date.mongoize
  # ```
  def mongoize: () -> Time
end

Mongoid::Extensions::Mongoid::Extensions::Date::EPOCH: untyped

module Mongoid::Extensions::Mongoid::Extensions::Date::ClassMethods
  # Convert the object from its mongo friendly ruby type to this type.
  #
  # _@param_ `object` — The time from Mongo.
  #
  # _@return_ — The object as a date.
  #
  # Demongoize the object.
  # ```ruby
  # Date.demongoize(object)
  # ```
  def demongoize: (Time object) -> Date

  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # _@param_ `object` — The object to mongoize.
  #
  # _@return_ — The object mongoized.
  #
  # Mongoize the object.
  # ```ruby
  # Date.mongoize("2012-1-1")
  # ```
  def mongoize: (Object object) -> Time
end

module Mongoid::Extensions::Hash
  # Evolves each value in the hash to an object id if it is convertable.
  #
  # _@return_ — The converted hash.
  #
  # Convert the hash values.
  # ```ruby
  # { field: id }.__evolve_object_id__
  # ```
  def __evolve_object_id__: () -> ::Hash[untyped, untyped]

  # Mongoizes each value in the hash to an object id if it is convertable.
  #
  # _@return_ — The converted hash.
  #
  # Convert the hash values.
  # ```ruby
  # { field: id }.__mongoize_object_id__
  # ```
  def __mongoize_object_id__: () -> ::Hash[untyped, untyped]

  # Consolidate the key/values in the hash under an atomic $set.
  #
  # _@return_ — A new consolidated hash.
  #
  # Consolidate the hash.
  # ```ruby
  # { name: "Placebo" }.__consolidate__
  # ```
  def __consolidate__: (untyped klass) -> ::Hash[untyped, untyped]

  # Checks whether conditions given in this hash are known to be
  # unsatisfiable, i.e., querying with this hash will always return no
  # documents.
  #
  # This method only handles condition shapes that Mongoid itself uses when
  # it builds association queries. It does not guarantee that a false
  # return value means the condition can produce a non-empty document set -
  # only that if the return value is true, the condition always produces
  # an empty document set.
  #
  # _@return_ — Whether hash contains known unsatisfiable
  # conditions.
  #
  # Unsatisfiable conditions
  # ```ruby
  # {'_id' => {'$in' => []}}._mongoid_unsatisfiable_criteria?
  # # => true
  # ```
  #
  # Conditions which could be satisfiable
  # ```ruby
  # {'_id' => '123'}._mongoid_unsatisfiable_criteria?
  # # => false
  # ```
  #
  # Conditions which are unsatisfiable that this method does not handle
  # ```ruby
  # {'foo' => {'$in' => []}}._mongoid_unsatisfiable_criteria?
  # # => false
  # ```
  def _mongoid_unsatisfiable_criteria?: () -> bool

  # Deletes an id value from the hash.
  #
  # _@return_ — The deleted value, or nil.
  #
  # Delete an id value.
  # ```ruby
  # {}.delete_id
  # ```
  def delete_id: () -> Object

  # Get the id attribute from this hash, whether it's prefixed with an
  # underscore or is a symbol.
  #
  # _@return_ — The value of the id.
  #
  # Extract the id.
  # ```ruby
  # { :_id => 1 }.extract_id
  # ```
  def extract_id: () -> Object

  # Fetch a nested value via dot syntax.
  #
  # _@param_ `string` — the dot syntax string.
  #
  # _@return_ — The matching value.
  #
  # Fetch a nested value via dot syntax.
  # ```ruby
  # { "name" => { "en" => "test" }}.__nested__("name.en")
  # ```
  def __nested__: (String string) -> Object

  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # _@return_ — The object.
  #
  # Mongoize the object.
  # ```ruby
  # object.mongoize
  # ```
  def mongoize: () -> ::Hash[untyped, untyped]

  # Can the size of this object change?
  #
  # _@return_ — true.
  #
  # Is the hash resizable?
  # ```ruby
  # {}.resizable?
  # ```
  def resizable?: () -> bool

  # Convert this hash to a criteria. Will iterate over each keys in the
  # hash which must correspond to method on a criteria object. The hash
  # must also include a "klass" key.
  #
  # _@return_ — The criteria.
  #
  # Convert the hash to a criteria.
  # ```ruby
  # { klass: Band, where: { name: "Depeche Mode" }.to_criteria
  # ```
  def to_criteria: () -> Criteria

  def mongoize_for: (String operator, Class klass, String | Symbol key, Object value) -> Object
end

module Mongoid::Extensions::Mongoid::Extensions::Hash::ClassMethods
  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # _@param_ `object` — The object to mongoize.
  #
  # _@return_ — The object mongoized.
  #
  # Mongoize the object.
  # ```ruby
  # Hash.mongoize([ 1, 2, 3 ])
  # ```
  def mongoize: (Object object) -> ::Hash[untyped, untyped]

  # Can the size of this object change?
  #
  # _@return_ — true.
  #
  # Is the hash resizable?
  # ```ruby
  # {}.resizable?
  # ```
  def resizable?: () -> bool
end

module Mongoid::Extensions::Time
  # Mongoizes a Time into a time.
  #
  # Time always mongoize into Time instances
  # (which are themselves).
  #
  # _@return_ — self.
  def __mongoize_time__: () -> Time

  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # _@return_ — The object mongoized.
  #
  # Mongoize the object.
  # ```ruby
  # time.mongoize
  # ```
  def mongoize: () -> Time
end

Mongoid::Extensions::Mongoid::Extensions::Time::EPOCH: untyped

module Mongoid::Extensions::Mongoid::Extensions::Time::ClassMethods
  # Get the configured time to use when converting - either the time zone
  # or the time.
  #
  # _@return_ — The configured time.
  #
  # Get the configured time.
  # ```ruby
  # ::Time.configured
  # ```
  def configured: () -> Time

  # Convert the object from its mongo friendly ruby type to this type.
  #
  # _@param_ `object` — The time from Mongo.
  #
  # _@return_ — The object as a date.
  #
  # Demongoize the object.
  # ```ruby
  # Time.demongoize(object)
  # ```
  def demongoize: (Time object) -> Time

  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # _@param_ `object` — The object to mongoize.
  #
  # _@return_ — The object mongoized.
  #
  # Mongoize the object.
  # ```ruby
  # Time.mongoize("2012-1-1")
  # ```
  def mongoize: (Object object) -> Time
end

module Mongoid::Extensions::Array
  # Evolve the array into an array of object ids.
  #
  # _@return_ — The converted array.
  #
  # Evolve the array to object ids.
  # ```ruby
  # [ id ].__evolve_object_id__
  # ```
  def __evolve_object_id__: () -> ::Array[BSON::ObjectId]

  # Get the array of args as arguments for a find query.
  #
  # _@return_ — The array of args.
  #
  # Get the array as find args.
  # ```ruby
  # [ 1, 2, 3 ].__find_args__
  # ```
  def __find_args__: () -> ::Array[untyped]

  # Mongoize the array into an array of object ids.
  #
  # _@return_ — The converted array.
  #
  # Evolve the array to object ids.
  # ```ruby
  # [ id ].__mongoize_object_id__
  # ```
  def __mongoize_object_id__: () -> ::Array[BSON::ObjectId]

  # sord warn - ActiveSupport::TimeWithZone wasn't able to be resolved to a constant in this project
  # Converts the array for storing as a time.
  #
  # _@return_ — Local time in the
  # configured default time zone corresponding to date/time components
  # in this array.
  #
  # Convert the array to a time.
  # ```ruby
  # [ 2010, 1, 1 ].__mongoize_time__
  # # => 2010-01-01 00:00:00 -0500
  # ```
  #
  # _@note_ — Returns a local time in the default time zone.
  def __mongoize_time__: () -> (Time | ActiveSupport::TimeWithZone)

  # Checks whether conditions given in this array are known to be
  # unsatisfiable, i.e., querying with this array will always return no
  # documents.
  #
  # This method used to assume that the array is the list of criteria
  # to be used with an $and operator. This assumption is no longer made;
  # therefore, since the interpretation of conditions in the array differs
  # between $and, $or and $nor operators, this method now always returns
  # false.
  #
  # This method is deprecated. Mongoid now uses
  # +_mongoid_unsatisfiable_criteria?+ internally; this method is retained
  # for backwards compatibility only. It always returns false.
  #
  # _@return_ — Always false.
  #
  # _@deprecated_ — 
  def blank_criteria?: () -> bool

  # Is the array a set of multiple arguments in a method?
  #
  # _@return_ — If the array is multi args.
  #
  # Is this multi args?
  # ```ruby
  # [ 1, 2, 3 ].multi_arged?
  # ```
  def multi_arged?: () -> bool

  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # _@return_ — The object.
  #
  # Mongoize the object.
  # ```ruby
  # object.mongoize
  # ```
  def mongoize: () -> ::Array[untyped]

  # Delete the first object in the array that is equal to the supplied
  # object and return it. This is much faster than performing a standard
  # delete for large arrays ince it attempt to delete multiple in the
  # other.
  #
  # _@param_ `object` — The object to delete.
  #
  # _@return_ — The deleted object.
  #
  # Delete the first object.
  # ```ruby
  # [ "1", "2", "1" ].delete_one("1")
  # ```
  def delete_one: (Object object) -> Object

  # Is the object's size changable?
  #
  # _@return_ — true.
  #
  # Is the object resizable?
  # ```ruby
  # object.resizable?
  # ```
  def resizable?: () -> bool
end

module Mongoid::Extensions::Mongoid::Extensions::Array::ClassMethods
  # Convert the provided object to a proper array of foreign keys.
  #
  # _@param_ `association` — The association metadata.
  #
  # _@param_ `object` — The object to convert.
  #
  # _@return_ — The array of ids.
  #
  # Mongoize the object.
  # ```ruby
  # Array.__mongoize_fk__(constraint, object)
  # ```
  def __mongoize_fk__: (Association association, Object object) -> ::Array[untyped]

  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # _@param_ `object` — The object to mongoize.
  #
  # _@return_ — The object mongoized.
  #
  # Mongoize the object.
  # ```ruby
  # Array.mongoize([ 1, 2, 3 ])
  # ```
  def mongoize: (Object object) -> ::Array[untyped]

  # Is the object's size changable?
  #
  # _@return_ — true.
  #
  # Is the object resizable?
  # ```ruby
  # Array.resizable?
  # ```
  def resizable?: () -> bool
end

module Mongoid::Extensions::Float
  # sord warn - ActiveSupport::TimeWithZone wasn't able to be resolved to a constant in this project
  # Converts the float into a time as the number of seconds since the epoch.
  #
  # _@return_ — The time.
  #
  # Convert the float into a time.
  # ```ruby
  # 1335532685.117847.__mongoize_time__
  # ```
  def __mongoize_time__: () -> (Time | ActiveSupport::TimeWithZone)

  # Is the float a number?
  #
  # _@return_ — Always true.
  #
  # Is the object a number?.
  # ```ruby
  # object.numeric?
  # ```
  def numeric?: () -> bool
end

module Mongoid::Extensions::Mongoid::Extensions::Float::ClassMethods
  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # _@param_ `object` — The object to mongoize.
  #
  # _@return_ — The object mongoized.
  #
  # Mongoize the object.
  # ```ruby
  # Float.mongoize("123.11")
  # ```
  def mongoize: (Object object) -> String
end

module Mongoid::Extensions::Range
  # Get the range as arguments for a find.
  #
  # _@return_ — The range as an array.
  #
  # Get the range as find args.
  # ```ruby
  # range.__find_args__
  # ```
  def __find_args__: () -> ::Array[untyped]

  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # _@return_ — The object mongoized.
  #
  # Mongoize the object.
  # ```ruby
  # range.mongoize
  # ```
  def mongoize: () -> ::Hash[untyped, untyped]

  # Is this a resizable object.
  #
  # _@return_ — True.
  #
  # Is this resizable?
  # ```ruby
  # range.resizable?
  # ```
  def resizable?: () -> bool
end

module Mongoid::Extensions::Mongoid::Extensions::Range::ClassMethods
  # Convert the object from its mongo friendly ruby type to this type.
  #
  # _@param_ `object` — The object to demongoize.
  #
  # _@return_ — The range.
  #
  # Demongoize the object.
  # ```ruby
  # Range.demongoize({ "min" => 1, "max" => 5 })
  # ```
  def demongoize: (::Hash[untyped, untyped] object) -> ::Range[untyped]

  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # _@param_ `object` — The object to mongoize.
  #
  # _@return_ — The object mongoized.
  #
  # Mongoize the object.
  # ```ruby
  # Range.mongoize(1..3)
  # ```
  def mongoize: (::Range[untyped] object) -> ::Hash[untyped, untyped]
end

module Mongoid::Extensions::Module
  # Redefine the method. Will undef the method if it exists or simply
  # just define it.
  #
  # _@param_ `name` — The name of the method.
  #
  # _@param_ `block` — The method body.
  #
  # _@return_ — The new method.
  #
  # Redefine the method.
  # ```ruby
  # Object.re_define_method("exists?") do
  #   self
  # end
  # ```
  def re_define_method: (String | Symbol name) { () -> untyped } -> Method
end

module Mongoid::Extensions::Object
  # Evolve a plain object into an object id.
  #
  # _@return_ — self.
  #
  # Evolve the object.
  # ```ruby
  # object.__evolve_object_id__
  # ```
  def __evolve_object_id__: () -> Object

  # Convert the object to args for a find query.
  #
  # _@return_ — self.
  #
  # Convert the object to args.
  # ```ruby
  # object.__find_args__
  # ```
  def __find_args__: () -> Object

  # Mongoize a plain object into a time.
  #
  # _@return_ — self.
  #
  # Mongoize the object.
  # ```ruby
  # object.__mongoize_time__
  # ```
  #
  # _@note_ — This method should not be used, because it does not
  # return correct results for non-Time objects. Override
  # __mongoize_time__ in classes that are time-like to return an
  # instance of Time or ActiveSupport::TimeWithZone.
  #
  # _@deprecated_ — 
  def __mongoize_time__: () -> Object

  # Try to form a setter from this object.
  #
  # _@return_ — The object as a string plus =.
  #
  # Try to form a setter.
  # ```ruby
  # object.__setter__
  # ```
  def __setter__: () -> String

  # Get the value of the object as a mongo friendy sort value.
  #
  # _@return_ — self.
  #
  # Get the object as sort criteria.
  # ```ruby
  # object.__sortable__
  # ```
  def __sortable__: () -> Object

  # Conversion of an object to an $inc-able value.
  #
  # _@return_ — The object.
  #
  # Convert the object.
  # ```ruby
  # 1.__to_inc__
  # ```
  def __to_inc__: () -> Object

  # Checks whether conditions given in this object are known to be
  # unsatisfiable, i.e., querying with this object will always return no
  # documents.
  #
  # This method is deprecated. Mongoid now uses
  # +_mongoid_unsatisfiable_criteria?+ internally; this method is retained
  # for backwards compatibility only. It always returns false.
  #
  # _@return_ — Always false.
  #
  # _@deprecated_ — 
  def blank_criteria?: () -> bool

  # Do or do not, there is no try. -- Yoda.
  #
  # _@param_ `name` — The method name.
  #
  # _@param_ `args` — The arguments.
  #
  # _@return_ — The result of the method call or nil if the
  # method does not exist.
  #
  # Do or do not.
  # ```ruby
  # object.do_or_do_not(:use, "The Force")
  # ```
  def do_or_do_not: (String | Symbol name, *::Array[untyped] args) -> Object?

  # Get the value for an instance variable or false if it doesn't exist.
  #
  # _@param_ `name` — The name of the variable.
  #
  # _@return_ — The value or false.
  #
  # Get the value for an instance var.
  # ```ruby
  # document.ivar("person")
  # ```
  def ivar: (String name) -> (Object | bool)

  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # _@return_ — The object.
  #
  # Mongoize the object.
  # ```ruby
  # object.mongoize
  # ```
  def mongoize: () -> Object

  # Is the object multi args.
  #
  # _@return_ — false.
  #
  # Is the object multi args?
  # ```ruby
  # object.multi_arged?
  # ```
  def multi_arged?: () -> bool

  # Is the object a number?
  #
  # _@return_ — Always false.
  #
  # Is the object a number?.
  # ```ruby
  # object.numeric?
  # ```
  def numeric?: () -> bool

  # Remove the instance variable for the provided name.
  #
  # _@param_ `name` — The name of the variable.
  #
  # _@return_ — If the variable was defined.
  #
  # Remove the instance variable
  # ```ruby
  # document.remove_ivar("person")
  # ```
  def remove_ivar: (String name) -> bool

  # Is the object's size changable? Only returns true for arrays and hashes
  # currently.
  #
  # _@return_ — false.
  #
  # Is the object resizable?
  # ```ruby
  # object.resizable?
  # ```
  def resizable?: () -> bool

  # Get the substitutable version of an object.
  #
  # _@return_ — self.
  #
  # Get the substitutable.
  # ```ruby
  # object.substitutable
  # ```
  def substitutable: () -> Object

  # You must unlearn what you have learned. -- Yoda
  #
  # _@param_ `name` — The method name.
  #
  # _@param_ `args` — The arguments.
  #
  # _@return_ — The result of the method call or nil if the
  # method does not exist. Nil if the object is frozen.
  #
  # You must perform this execution.
  # ```ruby
  # object.you_must(:use, "The Force")
  # ```
  def you_must: (String | Symbol name, *::Array[untyped] args) -> Object?
end

module Mongoid::Extensions::Mongoid::Extensions::Object::ClassMethods
  # Convert the provided object to a foreign key, given the metadata key
  # contstraint.
  #
  # _@param_ `association` — The association metadata.
  #
  # _@param_ `object` — The object to convert.
  #
  # _@return_ — The converted object.
  #
  # Convert the object to a fk.
  # ```ruby
  # Object.__mongoize_fk__(association, object)
  # ```
  def __mongoize_fk__: (Association association, Object object) -> Object

  # Convert the object from its mongo friendly ruby type to this type.
  #
  # _@param_ `object` — The object to demongoize.
  #
  # _@return_ — The object.
  #
  # Demongoize the object.
  # ```ruby
  # Object.demongoize(object)
  # ```
  def demongoize: (Object object) -> Object

  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # _@param_ `object` — The object to mongoize.
  #
  # _@return_ — The object mongoized.
  #
  # Mongoize the object.
  # ```ruby
  # Object.mongoize("123.11")
  # ```
  def mongoize: (Object object) -> Object
end

module Mongoid::Extensions::Regexp
end

module Mongoid::Extensions::Mongoid::Extensions::Regexp::ClassMethods
  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # _@param_ `object` — The object to mongoize.
  #
  # _@return_ — The object mongoized.
  #
  # Mongoize the object.
  # ```ruby
  # Regexp.mongoize(/\A[abc]/)
  # ```
  def mongoize: (Regexp | String object) -> Regexp
end

module Mongoid::Extensions::String
  # Evolve the string into an object id if possible.
  #
  # _@return_ — The evolved string.
  #
  # Evolve the string.
  # ```ruby
  # "test".__evolve_object_id__
  # ```
  def __evolve_object_id__: () -> (String | BSON::ObjectId)

  # Mongoize the string into an object id if possible.
  #
  # _@return_ — The mongoized string.
  #
  # Evolve the string.
  # ```ruby
  # "test".__mongoize_object_id__
  # ```
  def __mongoize_object_id__: () -> (String | BSON::ObjectId)?

  # sord warn - ActiveSupport::TimeWithZone wasn't able to be resolved to a constant in this project
  # Mongoize the string for storage.
  #
  # _@return_ — Local time in the
  # configured default time zone corresponding to this string.
  #
  # Mongoize the string.
  # ```ruby
  # "2012-01-01".__mongoize_time__
  # # => 2012-01-01 00:00:00 -0500
  # ```
  #
  # _@note_ — Returns a local time in the default time zone.
  def __mongoize_time__: () -> (Time | ActiveSupport::TimeWithZone)

  # Convert the string to a collection friendly name.
  #
  # _@return_ — The string in collection friendly form.
  #
  # Collectionize the string.
  # ```ruby
  # "namespace/model".collectionize
  # ```
  def collectionize: () -> String

  # Is the string a valid value for a Mongoid id?
  #
  # _@return_ — If the string is id or _id.
  #
  # Is the string an id value?
  # ```ruby
  # "_id".mongoid_id?
  # ```
  def mongoid_id?: () -> bool

  # Is the string a number? The literals "NaN", "Infinity", and "-Infinity"
  # are counted as numbers.
  #
  # _@return_ — If the string is a number.
  #
  # Is the string a number.
  # ```ruby
  # "1234.23".numeric?
  # ```
  def numeric?: () -> bool

  # Get the string as a getter string.
  #
  # _@return_ — The string stripped of "=".
  #
  # Get the reader/getter
  # ```ruby
  # "model=".reader
  # ```
  def reader: () -> String

  # Is this string a writer?
  #
  # _@return_ — If the string contains "=".
  #
  # Is the string a setter method?
  # ```ruby
  # "model=".writer?
  # ```
  def writer?: () -> bool

  # Is this string a valid_method_name?
  #
  # _@return_ — If the string contains a valid Ruby identifier.
  #
  # Is the string a valid Ruby idenfier for use as a method name
  # ```ruby
  # "model=".valid_method_name?
  # ```
  def valid_method_name?: () -> bool

  # Does the string end with _before_type_cast?
  #
  # _@return_ — If the string ends with "_before_type_cast"
  #
  # Is the string a setter method?
  # ```ruby
  # "price_before_type_cast".before_type_cast?
  # ```
  def before_type_cast?: () -> bool

  # Is the object not to be converted to bson on criteria creation?
  #
  # _@return_ — If the object is unconvertable.
  #
  # Is the object unconvertable?
  # ```ruby
  # object.unconvertable_to_bson?
  # ```
  def unconvertable_to_bson?: () -> bool

  # If the string is a legal object id, convert it.
  #
  # _@return_ — The string or the id.
  #
  # Convert to the object id.
  # ```ruby
  # string.convert_to_object_id
  # ```
  def convert_to_object_id: () -> (String | BSON::ObjectId)
end

module Mongoid::Extensions::Mongoid::Extensions::String::ClassMethods
  # Returns the value of attribute unconvertable_to_bson.
  #
  # Convert the object from its mongo friendly ruby type to this type.
  #
  # _@param_ `object` — The object to demongoize.
  #
  # _@return_ — The object.
  #
  # Demongoize the object.
  # ```ruby
  # String.demongoize(object)
  # ```
  def demongoize: () -> untyped
                | () -> untyped
                | (Object object) -> String

  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # _@param_ `object` — The object to mongoize.
  #
  # _@return_ — The object mongoized.
  #
  # Mongoize the object.
  # ```ruby
  # String.mongoize("123.11")
  # ```
  def mongoize: (Object object) -> String
end

module Mongoid::Extensions::Symbol
  # Is the symbol a valid value for a Mongoid id?
  #
  # _@return_ — If the symbol is :id or :_id.
  #
  # Is the string an id value?
  # ```ruby
  # :_id.mongoid_id?
  # ```
  def mongoid_id?: () -> bool
end

module Mongoid::Extensions::Mongoid::Extensions::Symbol::ClassMethods
  # Convert the object from its mongo friendly ruby type to this type.
  #
  # _@param_ `object` — The object to demongoize.
  #
  # _@return_ — The object.
  #
  # Demongoize the object.
  # ```ruby
  # Symbol.demongoize(object)
  # ```
  def demongoize: (Object object) -> Symbol

  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # _@param_ `object` — The object to mongoize.
  #
  # _@return_ — The object mongoized.
  #
  # Mongoize the object.
  # ```ruby
  # Symbol.mongoize("123.11")
  # ```
  def mongoize: (Object object) -> Symbol
end

module Mongoid::Extensions::Integer
  # sord warn - ActiveSupport::TimeWithZone wasn't able to be resolved to a constant in this project
  # Converts the integer into a time as the number of seconds since the epoch.
  #
  # _@return_ — The time.
  #
  # Convert the integer to a time.
  # ```ruby
  # 1335532685.__mongoize_time__
  # ```
  def __mongoize_time__: () -> (Time | ActiveSupport::TimeWithZone)

  # Is the integer a number?
  #
  # _@return_ — Always true.
  #
  # Is the object a number?.
  # ```ruby
  # object.numeric?
  # ```
  def numeric?: () -> bool

  # Is the object not to be converted to bson on criteria creation?
  #
  # _@return_ — If the object is unconvertable.
  #
  # Is the object unconvertable?
  # ```ruby
  # object.unconvertable_to_bson?
  # ```
  def unconvertable_to_bson?: () -> bool
end

module Mongoid::Extensions::Mongoid::Extensions::Integer::ClassMethods
  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # _@return_ — The object mongoized.
  #
  # Mongoize the object.
  # ```ruby
  # BigDecimal.mongoize("123.11")
  # ```
  def mongoize: (untyped object) -> String
end

module Mongoid::Extensions::DateTime
  # sord warn - ActiveSupport::TimeWithZone wasn't able to be resolved to a constant in this project
  # Mongoize the date time into a time.
  #
  # _@return_ — The mongoized time.
  #
  # Mongoize the date time.
  # ```ruby
  # date_time.__mongoize_time__
  # ```
  def __mongoize_time__: () -> (Time | ActiveSupport::TimeWithZone)

  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # _@return_ — The object mongoized.
  #
  # Mongoize the object.
  # ```ruby
  # date_time.mongoize
  # ```
  def mongoize: () -> Time
end

module Mongoid::Extensions::Mongoid::Extensions::DateTime::ClassMethods
  # Convert the object from its mongo friendly ruby type to this type.
  #
  # _@param_ `object` — The time from Mongo.
  #
  # _@return_ — The object as a date.
  #
  # Demongoize the object.
  # ```ruby
  # DateTime.demongoize(object)
  # ```
  def demongoize: (Time object) -> DateTime

  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # _@param_ `object` — The object to convert.
  #
  # _@return_ — The object mongoized.
  #
  # Mongoize the object.
  # ```ruby
  # DateTime.mongoize("2012-1-1")
  # ```
  def mongoize: (Object object) -> Time
end

module Mongoid::Extensions::NilClass
  # Try to form a setter from this object.
  #
  # _@return_ — Always nil.
  #
  # Try to form a setter.
  # ```ruby
  # object.__setter__
  # ```
  def __setter__: () -> nil

  # Get the name of a nil collection.
  #
  # _@return_ — A blank string.
  #
  # Get the nil name.
  # ```ruby
  # nil.collectionize
  # ```
  def collectionize: () -> String
end

module Mongoid::Extensions::ObjectId
  # Evolve the object id.
  #
  # _@return_ — self.
  #
  # Evolve the object id.
  # ```ruby
  # object_id.__evolve_object_id__
  # ```
  def __evolve_object_id__: () -> BSON::ObjectId
end

module Mongoid::Extensions::Mongoid::Extensions::ObjectId::ClassMethods
  # Evolve the object into a mongo-friendly value to query with.
  #
  # _@param_ `object` — The object to evolve.
  #
  # _@return_ — The object id.
  #
  # Evolve the object.
  # ```ruby
  # ObjectId.evolve(id)
  # ```
  def evolve: (Object object) -> BSON::ObjectId

  # Convert the object into a mongo-friendly value to store.
  #
  # _@param_ `object` — The object to convert.
  #
  # _@return_ — The object id.
  #
  # Convert the object.
  # ```ruby
  # ObjectId.mongoize(id)
  # ```
  def mongoize: (Object object) -> BSON::ObjectId
end

module Mongoid::Extensions::Decimal128
  # sord warn - BSON::Decimal128 wasn't able to be resolved to a constant in this project
  # Evolve the decimal128.
  #
  # _@return_ — self.
  #
  # Evolve the decimal128.
  # ```ruby
  # decimal128.__evolve_decimal128__
  # ```
  def __evolve_decimal128__: () -> BSON::Decimal128
end

module Mongoid::Extensions::Mongoid::Extensions::Decimal128::ClassMethods
  # sord warn - BSON::Decimal128 wasn't able to be resolved to a constant in this project
  # Evolve the object into a mongo-friendly value to query with.
  #
  # _@param_ `object` — The object to evolve.
  #
  # _@return_ — The decimal128.
  #
  # Evolve the object.
  # ```ruby
  # Decimal128.evolve(dec)
  # ```
  def evolve: (Object object) -> BSON::Decimal128
end

module Mongoid::Extensions::TrueClass
  # Get the value of the object as a mongo friendy sort value.
  #
  # _@return_ — 1.
  #
  # Get the object as sort criteria.
  # ```ruby
  # object.__sortable__
  # ```
  def __sortable__: () -> Integer

  # Is the passed value a boolean?
  #
  # _@param_ `other` — The class to check.
  #
  # _@return_ — If the other is a boolean.
  #
  # Is the value a boolean type?
  # ```ruby
  # true.is_a?(Boolean)
  # ```
  def is_a?: (Class other) -> bool
end

module Mongoid::Extensions::BigDecimal
  # Convert the big decimal to an $inc-able value.
  #
  # _@return_ — The big decimal as a float.
  #
  # Convert the big decimal.
  # ```ruby
  # bd.__to_inc__
  # ```
  def __to_inc__: () -> Float

  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # _@return_ — The object.
  #
  # Mongoize the object.
  # ```ruby
  # object.mongoize
  # ```
  def mongoize: () -> Object

  # Is the BigDecimal a number?
  #
  # _@return_ — Always true.
  #
  # Is the object a number?.
  # ```ruby
  # object.numeric?
  # ```
  def numeric?: () -> bool
end

module Mongoid::Extensions::Mongoid::Extensions::BigDecimal::ClassMethods
  # Convert the object from its mongo friendly ruby type to this type.
  #
  # _@param_ `object` — The object to demongoize.
  #
  # _@return_ — A BigDecimal derived from the object or nil.
  #
  # Demongoize the object.
  # ```ruby
  # Object.demongoize(object)
  # ```
  def demongoize: (Object object) -> BigDecimal?

  # Mongoize an object of any type to how it's stored in the db as a String.
  #
  # _@param_ `object` — The object to Mongoize
  #
  # _@return_ — A String representing the object or nil.
  #
  # Mongoize the object.
  # ```ruby
  # BigDecimal.mongoize(123)
  # ```
  def mongoize: (Object object) -> String?
end

module Mongoid::Extensions::FalseClass
  # Get the value of the object as a mongo friendy sort value.
  #
  # _@return_ — 0.
  #
  # Get the object as sort criteria.
  # ```ruby
  # object.__sortable__
  # ```
  def __sortable__: () -> Integer

  # Is the passed value a boolean?
  #
  # _@param_ `other` — The class to check.
  #
  # _@return_ — If the other is a boolean.
  #
  # Is the value a boolean type?
  # ```ruby
  # false.is_a?(Boolean)
  # ```
  def is_a?: (Class other) -> bool
end

module Mongoid::Extensions::TimeWithZone
  # sord warn - ActiveSupport::TimeWithZone wasn't able to be resolved to a constant in this project
  # Mongoizes an ActiveSupport::TimeWithZone into a time.
  #
  # TimeWithZone always mongoize into TimeWithZone instances
  # (which are themselves).
  #
  # _@return_ — self.
  def __mongoize_time__: () -> ActiveSupport::TimeWithZone

  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # _@return_ — The object mongoized.
  #
  # Mongoize the object.
  # ```ruby
  # date_time.mongoize
  # ```
  def mongoize: () -> Time
end

module Mongoid::Extensions::Mongoid::Extensions::TimeWithZone::ClassMethods
  # Convert the object from its mongo friendly ruby type to this type.
  #
  # _@param_ `object` — The time from Mongo.
  #
  # _@return_ — The object as a date.
  #
  # Demongoize the object.
  # ```ruby
  # TimeWithZone.demongoize(object)
  # ```
  def demongoize: (Time object) -> TimeWithZone

  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # _@param_ `object` — The object to convert.
  #
  # _@return_ — The object mongoized.
  #
  # Mongoize the object.
  # ```ruby
  # TimeWithZone.mongoize("2012-1-1")
  # ```
  def mongoize: (Object object) -> Time
end

module Mongoid::Tasks
end

module Mongoid::Tasks::Database
  extend Mongoid::Tasks::Database

  # Create indexes for each model given the provided globs and the class is
  # not embedded.
  #
  # _@return_ — The indexed models.
  #
  # Create all the indexes.
  # ```ruby
  # Mongoid::Tasks::Database.create_indexes
  # ```
  def create_indexes: (?untyped models) -> ::Array[Class]

  # Return the list of indexes by model that exist in the database but aren't
  # specified on the models.
  #
  # _@return_ — The list of undefined indexes by model.
  #
  # Return the list of unused indexes.
  # ```ruby
  # Mongoid::Tasks::Database.undefined_indexes
  # ```
  def undefined_indexes: (?untyped models) -> ::Array[::Hash[untyped, untyped]]

  # Remove indexes that exist in the database but aren't specified on the
  # models.
  #
  # _@return_ — The list of indexes that were removed by model.
  #
  # Remove undefined indexes.
  # ```ruby
  # Mongoid::Tasks::Database.remove_undefined_indexes
  # ```
  def remove_undefined_indexes: (?untyped models) -> ::Hash[Class, [ ::Hash[untyped, untyped] ]]

  # Remove indexes for each model given the provided globs and the class is
  # not embedded.
  #
  # _@return_ — The un-indexed models.
  #
  # Remove all the indexes.
  # ```ruby
  # Mongoid::Tasks::Database.remove_indexes
  # ```
  def remove_indexes: (?untyped models) -> ::Array[Class]

  # Shard collections for models that declare shard keys.
  #
  # Returns the model classes that have had their collections sharded,
  # including model classes whose collections had already been sharded
  # prior to the invocation of this method.
  #
  # _@return_ — The sharded models
  #
  # Shard all collections
  # ```ruby
  # Mongoid::Tasks::Database.shard_collections
  # ```
  def shard_collections: (?untyped models) -> ::Array[Class]

  def logger: () -> untyped

  # Create indexes for each model given the provided globs and the class is
  # not embedded.
  #
  # _@return_ — The indexed models.
  #
  # Create all the indexes.
  # ```ruby
  # Mongoid::Tasks::Database.create_indexes
  # ```
  def self.create_indexes: (?untyped models) -> ::Array[Class]

  # Return the list of indexes by model that exist in the database but aren't
  # specified on the models.
  #
  # _@return_ — The list of undefined indexes by model.
  #
  # Return the list of unused indexes.
  # ```ruby
  # Mongoid::Tasks::Database.undefined_indexes
  # ```
  def self.undefined_indexes: (?untyped models) -> ::Array[::Hash[untyped, untyped]]

  # Remove indexes that exist in the database but aren't specified on the
  # models.
  #
  # _@return_ — The list of indexes that were removed by model.
  #
  # Remove undefined indexes.
  # ```ruby
  # Mongoid::Tasks::Database.remove_undefined_indexes
  # ```
  def self.remove_undefined_indexes: (?untyped models) -> ::Hash[Class, [ ::Hash[untyped, untyped] ]]

  # Remove indexes for each model given the provided globs and the class is
  # not embedded.
  #
  # _@return_ — The un-indexed models.
  #
  # Remove all the indexes.
  # ```ruby
  # Mongoid::Tasks::Database.remove_indexes
  # ```
  def self.remove_indexes: (?untyped models) -> ::Array[Class]

  # Shard collections for models that declare shard keys.
  #
  # Returns the model classes that have had their collections sharded,
  # including model classes whose collections had already been sharded
  # prior to the invocation of this method.
  #
  # _@return_ — The sharded models
  #
  # Shard all collections
  # ```ruby
  # Mongoid::Tasks::Database.shard_collections
  # ```
  def self.shard_collections: (?untyped models) -> ::Array[Class]

  def self.logger: () -> untyped
end

module Mongoid::Errors
end

# This error is raised when calling #save! or .create! on a model when one
# of the callbacks returns false.
class Mongoid::Errors::Callback < Mongoid::Errors::MongoidError
  # Create the new callbacks error.
  #
  # _@param_ `klass` — The class of the document.
  #
  # _@param_ `method` — The name of the method.
  #
  # Create the new callbacks error.
  # ```ruby
  # Callbacks.new(Post, :create!)
  # ```
  def initialize: (Class klass, Symbol method) -> void
end

Mongoid::Errors::Mongoid::Errors::Callback::BASE_KEY: untyped

# This error is raised when trying to persist an embedded document
# when there is no parent set.
class Mongoid::Errors::NoParent < Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # _@param_ `klass` — The class of the embedded document.
  #
  # Create the new error.
  # ```ruby
  # NoParent.new(klass)
  # ```
  def initialize: (Class klass) -> void
end

Mongoid::Errors::Mongoid::Errors::NoParent::BASE_KEY: untyped

# This error is raised when attempting to eager load a many to many
# association.
#
# @deprecated No longer used by Mongoid per MONGOID-4841.
class Mongoid::Errors::EagerLoad < Mongoid::Errors::MongoidError
  # Create the new eager load error.
  #
  # _@param_ `name` — The name of the association.
  #
  # Create the new eager load error.
  # ```ruby
  # EagerLoad.new(:preferences)
  # ```
  def initialize: (Symbol name) -> void
end

Mongoid::Errors::Mongoid::Errors::EagerLoad::BASE_KEY: untyped

# Used when trying to persist data when metadata has not been set.
class Mongoid::Errors::NoMetadata < Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # _@param_ `klass` — The document class.
  #
  # Create the error.
  # ```ruby
  # NoMetadata.new(Address)
  # ```
  def initialize: (Class klass) -> void
end

Mongoid::Errors::Mongoid::Errors::NoMetadata::BASE_KEY: untyped

# Raised when a persistence method ending in ! fails validation. The message
# will contain the full error messages from the +Document+ in question.
#
# @example Create the error.
#   Validations.new(person.errors)
class Mongoid::Errors::Validations < Mongoid::Errors::MongoidError
  def initialize: (untyped document) -> void
end

Mongoid::Errors::Mongoid::Errors::Validations::BASE_KEY: untyped

# Raised when invalid arguments are passed to #find.
class Mongoid::Errors::InvalidFind < Mongoid::Errors::MongoidError
  # Returns the value of attribute document.
  #
  # Create the new invalid find error.
  #
  # Create the error.
  # ```ruby
  # InvalidFind.new
  # ```
  def initialize: () -> untyped
                | () -> void
end

Mongoid::Errors::Mongoid::Errors::InvalidFind::BASE_KEY: untyped

# Used when attempting to get embedded paths with incorrect root path set.
class Mongoid::Errors::InvalidPath < Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # _@param_ `klass` — The document class.
  #
  # Create the error.
  # ```ruby
  # InvalidPath.new(Address)
  # ```
  def initialize: (Class klass) -> void
end

Mongoid::Errors::Mongoid::Errors::InvalidPath::BASE_KEY: untyped

# This exception is raised when a bad value is attempted to be converted to
# a date or time.
class Mongoid::Errors::InvalidTime < Mongoid::Errors::MongoidError
  # Create the new invalid date error.
  #
  # _@param_ `value` — The value that was attempted.
  #
  # Create the new invalid date error.
  # ```ruby
  # InvalidTime.new("this is not a time")
  # ```
  def initialize: (Object value) -> void
end

Mongoid::Errors::Mongoid::Errors::InvalidTime::BASE_KEY: untyped

# This error is raised when trying to create a field that conflicts with
# an already defined method.
class Mongoid::Errors::InvalidField < Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # _@param_ `klass` — The document class.
  #
  # _@param_ `name` — The method name.
  #
  # Create the error.
  # ```ruby
  # InvalidField.new(person, :crazy_method_name)
  # ```
  def initialize: (Class klass, Symbol name) -> void

  # Get the queryable of the method.
  #
  # _@param_ `klass` — The document class.
  #
  # _@param_ `name` — The method name.
  #
  # _@return_ — The originating class or module.
  #
  # Get the originating class or module.
  # ```ruby
  # error.queryable(Person, :crazy_method_name)
  # ```
  def origin: (Class klass, Symbol name) -> (Class | Module)

  # Get the location of the method.
  #
  # _@param_ `klass` — The document class.
  #
  # _@param_ `name` — The method name.
  #
  # _@return_ — The location of the method.
  #
  # Get the location of the method on the filesystem.
  # ```ruby
  # error.location(Person, :crazy_method_name)
  # ```
  def location: (Class klass, Symbol name) -> ::Array[String | Integer]
end

Mongoid::Errors::Mongoid::Errors::InvalidField::BASE_KEY: untyped

# Raised when an invalid index is defined.
class Mongoid::Errors::InvalidIndex < Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # _@param_ `klass` — The model class.
  #
  # _@param_ `spec` — The invalid specification.
  #
  # _@param_ `options` — The invalid options.
  #
  # Create the error.
  # ```ruby
  # InvalidIndex.new(Band, name: 1)
  # ```
  def initialize: (Class klass, ::Hash[untyped, untyped] spec, ::Hash[untyped, untyped] options) -> void
end

Mongoid::Errors::Mongoid::Errors::InvalidIndex::BASE_KEY: untyped

# Raised when invalid query is passed to an embedded matcher, or an
# invalid query fragment is passed to the query builder (Criteria object).
class Mongoid::Errors::InvalidQuery < Mongoid::Errors::MongoidError
  # Create the new invalid query error.
  def initialize: (untyped msg) -> void

  # Stringifies the argument using #inspect and truncates the result to
  # about 100 characters.
  #
  # _@param_ `expr` — An expression to stringify and truncate.
  def self.truncate_expr: (Object expr) -> untyped
end

Mongoid::Errors::Mongoid::Errors::InvalidQuery::BASE_KEY: untyped

# This error is raised when defining a scope of an invalid type.
class Mongoid::Errors::InvalidScope < Mongoid::Errors::MongoidError
  # Create the error.
  #
  # _@param_ `klass` — The model class.
  #
  # _@param_ `value` — The attempted scope value.
  #
  # Create the error.
  # ```ruby
  # InvalidScope.new(Band, {})
  # ```
  def initialize: (Class klass, Object value) -> void
end

Mongoid::Errors::Mongoid::Errors::InvalidScope::BASE_KEY: untyped

# This error is raised when trying to set an attribute with an invalid value.
# For example when try to set an Array value to a Hash attribute.
class Mongoid::Errors::InvalidValue < Mongoid::Errors::MongoidError
  def initialize: (untyped field_class, untyped value_class) -> void
end

Mongoid::Errors::Mongoid::Errors::InvalidValue::BASE_KEY: untyped

# Default parent Mongoid error for all custom errors. This handles the base
# key for the translations and provides the convenience method for
# translating the messages.
class Mongoid::Errors::MongoidError < StandardError
  # Compose the message.
  #
  # _@return_ — The composed message.
  #
  # Create the message
  # ```ruby
  # error.compose_message
  # ```
  def compose_message: (untyped key, ?untyped attributes) -> String

  # Given the key of the specific error and the options hash, translate the
  # message.
  #
  # _@param_ `key` — The key of the error in the locales.
  #
  # _@param_ `options` — The objects to pass to create the message.
  #
  # _@return_ — A localized error message string.
  #
  # Translate the message.
  # ```ruby
  # error.translate("errors", :key => value)
  # ```
  def translate: (String key, ::Hash[untyped, untyped] options) -> String

  # Create the problem.
  #
  # _@param_ `key` — The error key.
  #
  # _@param_ `attributes` — The attributes to interpolate.
  #
  # _@return_ — The problem.
  #
  # Create the problem.
  # ```ruby
  # error.problem("error", {})
  # ```
  def translate_problem: (String | Symbol key, ::Hash[untyped, untyped] attributes) -> String

  # Create the summary.
  #
  # _@param_ `key` — The error key.
  #
  # _@param_ `attributes` — The attributes to interpolate.
  #
  # _@return_ — The summary.
  #
  # Create the summary.
  # ```ruby
  # error.summary("error", {})
  # ```
  def translate_summary: (String | Symbol key, ::Hash[untyped, untyped] attributes) -> String

  # Create the resolution.
  #
  # _@param_ `key` — The error key.
  #
  # _@param_ `attributes` — The attributes to interpolate.
  #
  # _@return_ — The resolution.
  #
  # Create the resolution.
  # ```ruby
  # error.resolution("error", {})
  # ```
  def translate_resolution: (String | Symbol key, ::Hash[untyped, untyped] attributes) -> String
end

Mongoid::Errors::Mongoid::Errors::MongoidError::BASE_KEY: untyped

# This error is raised when trying to instantiate a model object from the value in
# the '_type' field of a document and the class doesn't exist.
class Mongoid::Errors::UnknownModel < Mongoid::Errors::MongoidError
  # Returns the value of attribute problem.
  #
  # Returns the value of attribute summary.
  #
  # Returns the value of attribute resolution.
  #
  # Create the new error.
  #
  # _@param_ `klass` — The model class.
  #
  # _@param_ `value` — The value used to determine the (invalid) class.
  #
  # Instantiate the error.
  # ```ruby
  # UnknownModel.new('InvalidClass', "invalid_class")
  # ```
  def initialize: () -> untyped
                | () -> untyped
                | () -> untyped
                | (String klass, String value) -> void
end

Mongoid::Errors::Mongoid::Errors::UnknownModel::BASE_KEY: untyped

# Raised when trying to load configuration with no RACK_ENV set
class Mongoid::Errors::NoEnvironment < Mongoid::Errors::MongoidError
  # Create the new no environment error.
  #
  # Create the new no environment error.
  # ```ruby
  # NoEnvironment.new
  # ```
  def initialize: () -> void
end

Mongoid::Errors::Mongoid::Errors::NoEnvironment::BASE_KEY: untyped

# Raised when invalid options are passed to an association macro.
class Mongoid::Errors::InvalidOptions < Mongoid::Errors::MongoidError
  # Instantiate the options error.
  #
  # _@param_ `name` — The name of the association.
  #
  # _@param_ `invalid` — The invalid option.
  #
  # _@param_ `valid` — The allowed options.
  #
  # Create the error.
  # ```ruby
  # InvalidOptions.new(:name, :polymorphic, [ :as ])
  # ```
  def initialize: (Symbol name, Symbol invalid, ::Array[Symbol] valid) -> void
end

Mongoid::Errors::Mongoid::Errors::InvalidOptions::BASE_KEY: untyped

# This error is raised when trying to reference an embedded document from
# a document in another collection that is not its parent.
#
# @example An illegal reference to an embedded document.
#   class Post
#     include Mongoid::Document
#     references_many :addresses
#   end
#
#   class Address
#     include Mongoid::Document
#     embedded_in :person
#     referenced_in :post
#   end
#
# @since 2.0.0
class Mongoid::Errors::MixedRelations < Mongoid::Errors::MongoidError
  def initialize: (untyped root_klass, untyped embedded_klass) -> void
end

Mongoid::Errors::Mongoid::Errors::MixedRelations::BASE_KEY: untyped

# This error is raised when a client is configured without hosts.
class Mongoid::Errors::NoClientHosts < Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # _@param_ `name` — The db config key.
  #
  # _@param_ `config` — The hash configuration options.
  #
  # Create the new error.
  # ```ruby
  # NoClientHosts.new(:default, {}})
  # ```
  def initialize: (Symbol | String name, ::Hash[untyped, untyped] config) -> void
end

Mongoid::Errors::Mongoid::Errors::NoClientHosts::BASE_KEY: untyped

# This error is raised when trying to create a scope with an name already
# taken by another scope or method
#
# @example Create the error.
#   ScopeOverwrite.new(Person,'teenies')
class Mongoid::Errors::ScopeOverwrite < Mongoid::Errors::MongoidError
  def initialize: (untyped model_name, untyped scope_name) -> void
end

Mongoid::Errors::Mongoid::Errors::ScopeOverwrite::BASE_KEY: untyped

# This error is raised when an invalid value is passed to an eager
# loading query.
class Mongoid::Errors::InvalidIncludes < Mongoid::Errors::MongoidError
  # Initialize the error.
  #
  # _@param_ `klass` — The model class.
  #
  # _@param_ `args` — The arguments passed to the includes.
  #
  # Initialize the error.
  # ```ruby
  # InvalidIncludes.new(Band, [ :members ])
  # ```
  def initialize: (Class klass, ::Array[Object] args) -> void
end

Mongoid::Errors::Mongoid::Errors::InvalidIncludes::BASE_KEY: untyped

# This error is raised when trying to create an association that conflicts with
# an already defined method.
#
# @since 6.0.0
class Mongoid::Errors::InvalidRelation < Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # _@param_ `klass` — The document class.
  #
  # _@param_ `name` — The method name.
  #
  # Create the error.
  # ```ruby
  # InvalidRelation.new(person, :crazy_relation_name)
  # ```
  def initialize: (Class klass, Symbol name) -> void

  # Get the queryable of the method.
  #
  # _@param_ `klass` — The document class.
  #
  # _@param_ `name` — The method name.
  #
  # _@return_ — The originating class or module.
  #
  # Get the originating class or module.
  # ```ruby
  # error.queryable(Person, :crazy_method_name)
  # ```
  def origin: (Class klass, Symbol name) -> (Class | Module)

  # Get the location of the association definition.
  #
  # _@param_ `klass` — The document class.
  #
  # _@param_ `name` — The method name.
  #
  # _@return_ — The location of the method.
  #
  # Get the location of the method on the filesystem.
  # ```ruby
  # error.location(Person, :crazy_method_name)
  # ```
  def location: (Class klass, Symbol name) -> ::Array[String | Integer]
end

Mongoid::Errors::Mongoid::Errors::InvalidRelation::BASE_KEY: untyped

# This error is raised when attempting to create a new client that does
# not have a named configuration.
class Mongoid::Errors::NoClientConfig < Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # _@param_ `name` — The name of the client.
  #
  # Create the error.
  # ```ruby
  # NoClientConfig.new(:analytics)
  # ```
  def initialize: (String | Symbol name) -> void
end

Mongoid::Errors::Mongoid::Errors::NoClientConfig::BASE_KEY: untyped

# Raised when attempting to call create or create! through a
# references_many when the parent document has not been saved. This
# prevents the child from getting presisted and immediately being orphaned.
class Mongoid::Errors::UnsavedDocument < Mongoid::Errors::MongoidError
  def initialize: (untyped base, untyped document) -> void
end

Mongoid::Errors::Mongoid::Errors::UnsavedDocument::BASE_KEY: untyped

# Raised when no inverse_of definition can be found when needed.
class Mongoid::Errors::InverseNotFound < Mongoid::Errors::MongoidError
  def initialize: (Class base, Symbol name, Class klass, Symbol inverse) -> void
end

Mongoid::Errors::Mongoid::Errors::InverseNotFound::BASE_KEY: untyped

# This error is raised when no clients exists in the database
# configuration.
class Mongoid::Errors::NoClientsConfig < Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # Create the error.
  # ```ruby
  # NoClientsConfig.new
  # ```
  def initialize: () -> void
end

Mongoid::Errors::Mongoid::Errors::NoClientsConfig::BASE_KEY: untyped

# This error is raised when a default client is not defined.
class Mongoid::Errors::NoDefaultClient < Mongoid::Errors::MongoidError
  # Create the new error with the defined client names.
  #
  # _@param_ `keys` — The defined clients.
  #
  # Create the new error.
  # ```ruby
  # NoDefaultClient.new([ :analytics ])
  # ```
  def initialize: (::Array[Symbol] keys) -> void
end

Mongoid::Errors::Mongoid::Errors::NoDefaultClient::BASE_KEY: untyped

# Raised when attempting to persist a document that was loaded from the
# database with partial fields.
#
# @since 4.0.0
class Mongoid::Errors::ReadonlyDocument < Mongoid::Errors::MongoidError
  # Instnatiate the exception.
  #
  # _@param_ `klass` — The document class.
  #
  # Create the error.
  # ```ruby
  # ReadonlyDocument.new(Band)
  # ```
  def initialize: (Class klass) -> void
end

Mongoid::Errors::Mongoid::Errors::ReadonlyDocument::BASE_KEY: untyped

# This error is raised when trying to set a value in Mongoid that is not
# already set with dynamic attributes or the field is not defined.
class Mongoid::Errors::UnknownAttribute < Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # _@param_ `klass` — The model class.
  #
  # _@param_ `name` — The name of the attribute.
  #
  # Instantiate the error.
  # ```ruby
  # UnknownAttribute.new(Person, "gender")
  # ```
  def initialize: (Class klass, String | Symbol name) -> void
end

Mongoid::Errors::Mongoid::Errors::UnknownAttribute::BASE_KEY: untyped

# This error is raised when calling #save! or .create! on a model when one
# of the callbacks returns false.
class Mongoid::Errors::DeleteRestriction < Mongoid::Errors::MongoidError
  # Create the new callbacks error.
  #
  # _@param_ `document`
  #
  # _@param_ `association`
  #
  # Create the new callbacks error.
  # ```ruby
  # Callbacks.new(Post, :create!)
  # ```
  def initialize: (Class document, untyped relation) -> void
end

Mongoid::Errors::Mongoid::Errors::DeleteRestriction::BASE_KEY: untyped

# Raised when querying the database for a document by a specific id or by
# set of attributes which does not exist. If multiple ids were passed then
# it will display all of those.
class Mongoid::Errors::DocumentNotFound < Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # _@param_ `klass` — The model class.
  #
  # _@param_ `params` — The attributes or ids.
  #
  # _@param_ `unmatched` — The unmatched ids, if appropriate
  #
  # Create the error.
  # ```ruby
  # DocumentNotFound.new(Person, ["1", "2"])
  # ```
  #
  # Create the error with attributes instead of ids
  # ```ruby
  # DocumentNotFound.new(Person, :ssn => "1234", :name => "Helen")
  # ```
  def initialize: (Class klass, ::Hash[untyped, untyped] | ::Array[untyped] | Object params, ?::Array[untyped]? unmatched) -> void

  # Get the string to display the document params that were unmatched.
  #
  # _@param_ `unmatched` — The ids that did not match.
  #
  # _@return_ — The missing string.
  #
  # Get the missing string.
  # ```ruby
  # error.missing(1)
  # ```
  def missing: (Object | ::Array[untyped] unmatched) -> String

  # Get the string to display the document params that were searched for.
  #
  # _@param_ `params` — The ids that were searched for.
  #
  # _@return_ — The searched string.
  #
  # Get the searched string.
  # ```ruby
  # error.searched(1)
  # ```
  def searched: (Object | ::Array[untyped] params) -> String

  # Get the total number of expected documents.
  #
  # _@param_ `params` — What was searched for.
  #
  # _@return_ — The total number.
  #
  # Get the total.
  # ```ruby
  # error.total([ 1, 2, 3 ])
  # ```
  def total: (Object | ::Array[untyped] params) -> Integer

  # Create the problem.
  #
  # _@return_ — The problem.
  #
  # Create the problem.
  # ```ruby
  # error.problem
  # ```
  def message_key: (untyped params) -> String
end

Mongoid::Errors::Mongoid::Errors::DocumentNotFound::BASE_KEY: untyped

# This error is raised when trying to access a Mongo::Collection from an
# embedded document.
#
# @example Create the error.
#   InvalidCollection.new(Address)
class Mongoid::Errors::InvalidCollection < Mongoid::Errors::MongoidError
  # Returns the value of attribute klass.
  #
  # Returns the value of attribute params.
  def initialize: () -> untyped
                | () -> untyped
                | (untyped klass) -> void
end

Mongoid::Errors::Mongoid::Errors::InvalidCollection::BASE_KEY: untyped

# This error is raised when a client is configured without a database.
class Mongoid::Errors::NoClientDatabase < Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # _@param_ `name` — The db config key.
  #
  # _@param_ `config` — The hash configuration options.
  #
  # Create the new error.
  # ```ruby
  # NoClientDatabase.new(:default, {}})
  # ```
  def initialize: (Symbol | String name, ::Hash[untyped, untyped] config) -> void
end

Mongoid::Errors::Mongoid::Errors::NoClientDatabase::BASE_KEY: untyped

# This error is raised when attempting the change the value of a readonly
# attribute after the document has been persisted.
class Mongoid::Errors::ReadonlyAttribute < Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # _@param_ `name` — The name of the attribute.
  #
  # _@param_ `value` — The attempted set value.
  #
  # Create the new error.
  # ```ruby
  # ReadonlyAttribute.new(:title, "mr")
  # ```
  def initialize: (Symbol | String name, Object value) -> void
end

Mongoid::Errors::Mongoid::Errors::ReadonlyAttribute::BASE_KEY: untyped

# This error is raised when a session is attempted to be used with a model whose client cannot use it, if
#   sessions are nested, or if the mongodb deployment doesn't support sessions.
#
# @since 6.4.0
class Mongoid::Errors::InvalidSessionUse < Mongoid::Errors::MongoidError
  # Create the error.
  #
  # _@param_ `error_type` — The type of session misuse.
  #
  # Create the error.
  # ```ruby
  # InvalidSessionUse.new(:invalid_session_use)
  # ```
  def initialize: (Symbol error_type) -> void
end

Mongoid::Errors::Mongoid::Errors::InvalidSessionUse::BASE_KEY: untyped

# This error is raised when trying to create a field that has an invalid
# option.
class Mongoid::Errors::InvalidFieldOption < Mongoid::Errors::MongoidError
  def initialize: (Class klass, Symbol name, Symbol option, ::Array[Symbol] valid) -> void
end

Mongoid::Errors::Mongoid::Errors::InvalidFieldOption::BASE_KEY: untyped

# Raised when executing a map/reduce without specifying the output
# location.
class Mongoid::Errors::NoMapReduceOutput < Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # _@param_ `command` — The map/reduce command.
  #
  # Create the new error.
  # ```ruby
  # NoMapReduceOutput.new({ map: "" })
  # ```
  def initialize: (::Hash[untyped, untyped] command) -> void
end

Mongoid::Errors::Mongoid::Errors::NoMapReduceOutput::BASE_KEY: untyped

# This error is raised when a bad configuration option is attempted to be
# set.
class Mongoid::Errors::InvalidConfigOption < Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # _@param_ `name` — The attempted config option name.
  #
  # Create the new error.
  # ```ruby
  # InvalidConfigOption.new(:name, [ :option ])
  # ```
  def initialize: (Symbol | String name) -> void
end

Mongoid::Errors::Mongoid::Errors::InvalidConfigOption::BASE_KEY: untyped

# This error is raised in case of an ambigous association.
#
# @example An ambigous association.
#   class Person
#     include Mongoid::Document
#
#     has_many :invitations, inverse_of: :person
#     has_many :referred_invitations, class_name: "Invitation", inverse_of: :referred_by
#   end
#
#   class Invitation
#     include Mongoid::Document
#
#     belongs_to :person
#     belongs_to :referred_by, class_name: "Person"
#   end
class Mongoid::Errors::AmbiguousRelationship < Mongoid::Errors::MongoidError
  def initialize: (Class klass, Class inverse, Symbol name, ::Array[Symbol] candidates) -> void
end

Mongoid::Errors::Mongoid::Errors::AmbiguousRelationship::BASE_KEY: untyped

# Raised when attempting to destroy a document that had destory callbacks
# return false.
#
# @since 4.0.0
class Mongoid::Errors::DocumentNotDestroyed < Mongoid::Errors::MongoidError
  # Instnatiate the exception.
  #
  # _@param_ `id` — The document id.
  #
  # _@param_ `klass` — The document class.
  #
  # Create the error.
  # ```ruby
  # DocumentNotDestroyed.new(Band)
  # ```
  def initialize: (Object id, Class klass) -> void
end

Mongoid::Errors::Mongoid::Errors::DocumentNotDestroyed::BASE_KEY: untyped

# Raised when invalid field-level operator is passed to an
# embedded matcher.
class Mongoid::Errors::InvalidFieldOperator < Mongoid::Errors::InvalidQuery
  # Creates the exception.
  #
  # _@param_ `operator` — The operator that was used.
  def initialize: (String operator) -> void
end

Mongoid::Errors::Mongoid::Errors::InvalidFieldOperator::VALID_OPERATORS: untyped

Mongoid::Errors::Mongoid::Errors::InvalidFieldOperator::BASE_KEY: untyped

# Raised when calling store_in in a sub-class of Mongoid::Document
class Mongoid::Errors::InvalidStorageParent < Mongoid::Errors::MongoidError
  # _@return_ — The operator that was used.
  #
  # Create the new error.
  #
  # _@param_ `klass` — The model class.
  #
  # Create the new error.
  # ```ruby
  # InvalidStorageParent.new(Person)
  # ```
  def initialize: () -> String
                | (Class klass) -> void
end

Mongoid::Errors::Mongoid::Errors::InvalidStorageParent::BASE_KEY: untyped

# Raised when Javascript criteria selector is passed for embedded document.
class Mongoid::Errors::UnsupportedJavascript < Mongoid::Errors::MongoidError
  # Create the new error caused by using Javascript in embedded document criteria selector.
  #
  # _@param_ `klass` — The embedded document class.
  #
  # _@param_ `javascript` — The javascript expression.
  #
  # Create the error.
  # ```ruby
  # UnsupportedJavascriptSelector.new(Album, "this.name == '101'")
  # ```
  def initialize: (Class klass, String javascript) -> void
end

Mongoid::Errors::Mongoid::Errors::UnsupportedJavascript::BASE_KEY: untyped

# Raised when an option provided for an association is invalid.
class Mongoid::Errors::InvalidRelationOption < Mongoid::Errors::MongoidError
  def initialize: (Class klass, String | Symbol name, Symbol option, ::Array[Symbol] valid_options) -> void
end

Mongoid::Errors::Mongoid::Errors::InvalidRelationOption::BASE_KEY: untyped

# Raised when options provided to :store_in are invalid.
class Mongoid::Errors::InvalidStorageOptions < Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # _@param_ `klass` — The model class.
  #
  # _@param_ `options` — The provided options.
  #
  # Create the new error.
  # ```ruby
  # InvalidStorageOptions.new(Person, invalid_option: 'name')
  # ```
  def initialize: (Class klass, ::Hash[untyped, untyped] | String | Symbol options) -> void
end

Mongoid::Errors::Mongoid::Errors::InvalidStorageOptions::BASE_KEY: untyped

# This error is raised when a method on Criteria is given a nil argument.
class Mongoid::Errors::CriteriaArgumentRequired < Mongoid::Errors::MongoidError
  # Creates the new exception instance.
  def initialize: (untyped query_method) -> void
end

Mongoid::Errors::Mongoid::Errors::CriteriaArgumentRequired::BASE_KEY: untyped

# This error is raised when an invalid strategy is defined for an association dependency.
class Mongoid::Errors::InvalidDependentStrategy < Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # _@param_ `association` — The association for which this dependency is defined.
  #
  # _@param_ `invalid_strategy` — The attempted invalid strategy.
  #
  # _@param_ `valid_strategies` — The valid strategies.
  #
  # Create the new error.
  # ```ruby
  # InvalidDependentStrategy.new(association, invalid_strategy, valid_strategies)
  # ```
  def initialize: (Mongoid::Association association, Symbol | String invalid_strategy, ::Array[Symbol] valid_strategies) -> void
end

Mongoid::Errors::Mongoid::Errors::InvalidDependentStrategy::BASE_KEY: untyped

# Raised when invalid options are used to create a persistence context.
#
# @since 6.0.0
class Mongoid::Errors::InvalidPersistenceOption < Mongoid::Errors::MongoidError
  # Instantiate the persistence context option error.
  #
  # _@param_ `invalid` — The invalid option.
  #
  # _@param_ `valid` — The allowed options.
  #
  # Create the error.
  # ```ruby
  # InvalidPersistenceOption.new(:invalid_option, [ :connect_timeout, :database ])
  # ```
  def initialize: (Symbol invalid, ::Array[Symbol] valid) -> void
end

Mongoid::Errors::Mongoid::Errors::InvalidPersistenceOption::BASE_KEY: untyped

# This error is raised when a client configuration contains both a uri and
# other standard options.
class Mongoid::Errors::MixedClientConfiguration < Mongoid::Errors::MongoidError
  # Initialize the error.
  #
  # _@param_ `name` — The name of the client config.
  #
  # _@param_ `config` — The configuration options.
  #
  # Initialize the error.
  # ```ruby
  # MixedClientConfiguration.new(:name, {})
  # ```
  def initialize: (Symbol name, ::Hash[untyped, untyped] config) -> void
end

Mongoid::Errors::Mongoid::Errors::MixedClientConfiguration::BASE_KEY: untyped

# Raised when invalid field-level operator is passed to the $elemMatch
# embedded matcher.
class Mongoid::Errors::InvalidElemMatchOperator < Mongoid::Errors::InvalidQuery
  # Creates the exception.
  #
  # _@param_ `operator` — The operator that was used.
  def initialize: (String operator) -> void
end

Mongoid::Errors::Mongoid::Errors::InvalidElemMatchOperator::VALID_OPERATORS: untyped

Mongoid::Errors::Mongoid::Errors::InvalidElemMatchOperator::BASE_KEY: untyped

# Raised when invalid expression-level operator is passed to an
# embedded matcher.
class Mongoid::Errors::InvalidExpressionOperator < Mongoid::Errors::InvalidQuery
  # _@return_ — The operator that was used.
  #
  # Creates the exception.
  #
  # _@param_ `operator` — The operator that was used.
  def initialize: () -> String
                | (String operator) -> void
end

Mongoid::Errors::Mongoid::Errors::InvalidExpressionOperator::BASE_KEY: untyped

# Creates the exception raised when trying to set or get the 
# discriminator key on a child class.
#
# @param [ String ] class_name The class name.
# @param [ String ] operator The class' superclass.
#
# @api private
class Mongoid::Errors::InvalidDiscriminatorKeyTarget < Mongoid::Errors::MongoidError
  # _@return_ — The operator that was used.
  def initialize: () -> String
                | (untyped class_name, untyped superclass) -> void
end

Mongoid::Errors::Mongoid::Errors::InvalidDiscriminatorKeyTarget::BASE_KEY: untyped

class Mongoid::Errors::InvalidEstimatedCountCriteria < Mongoid::Errors::MongoidError
  # Creates the exception raised when trying to call estimated_count
  # on a filtered criteria.
  #
  # _@param_ `class_name` — The klass of the criteria used to call estimated count.
  def initialize: (String class_name) -> void
end

Mongoid::Errors::Mongoid::Errors::InvalidEstimatedCountCriteria::BASE_KEY: untyped

# Raised when trying to set a polymorphic "references in" association to a
# model with multiple "references many/one" associations pointing to that
# first model.
#
# @example Invalid setting of a polymorphic association.
#   class Face
#     include Mongoid::Document
#
#     has_one :left_eye, class_name: "Eye", as: :eyeable
#     has_one :right_eye, class_name: "Eye", as: :eyeable
#   end
#
#   class Eye
#     include Mongoid::Document
#
#     belongs_to :eyeable, polymorphic: true
#   end
#
#   eye = Eye.new
#   face = Face.new
#   eye.eyeable = face # Raises error
class Mongoid::Errors::InvalidSetPolymorphicRelation < Mongoid::Errors::MongoidError
  # Create the new invalid set polymorphic association error.
  #
  # Create the error.
  # ```ruby
  # InvalidSetPolymorphicRelation.new
  # ```
  def initialize: (untyped name, untyped klass, untyped other_klass) -> void
end

Mongoid::Errors::Mongoid::Errors::InvalidSetPolymorphicRelation::BASE_KEY: untyped

# This error is raised when attempting to do a query with a
# collation on documents in memory.
class Mongoid::Errors::InMemoryCollationNotSupported < Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # Create the new unsupported collation error.
  # ```ruby
  # InMemoryCollationNotSupported.new
  # ```
  def initialize: () -> void
end

Mongoid::Errors::Mongoid::Errors::InMemoryCollationNotSupported::BASE_KEY: untyped

# This error is raised when trying to create set nested records above the
# specified :limit
#
# @example Create the error.
#   TooManyNestedAttributeRecords.new('association', limit)
class Mongoid::Errors::TooManyNestedAttributeRecords < Mongoid::Errors::MongoidError
  def initialize: (untyped association, untyped limit) -> void
end

Mongoid::Errors::Mongoid::Errors::TooManyNestedAttributeRecords::BASE_KEY: untyped

# This error is raised when metadata could not be found when defining
# nested attributes, or the name was incorrect.
class Mongoid::Errors::NestedAttributesMetadataNotFound < Mongoid::Errors::MongoidError
  # Create the new metadata error.
  #
  # _@param_ `klass` — The class of the document.
  #
  # _@param_ `name` — The name of the association
  #
  # Create the new metadata error.
  # ```ruby
  # NestedAttributesMetadataNotFound.new(klass, name)
  # ```
  def initialize: (Class klass, Symbol | String name) -> void
end

Mongoid::Errors::Mongoid::Errors::NestedAttributesMetadataNotFound::BASE_KEY: untyped

class Mongoid::Boolean
  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # _@return_ — The object mongoized.
  #
  # Mongoize the object.
  # ```ruby
  # Boolean.mongoize("123.11")
  # ```
  def self.mongoize: (untyped object) -> String
end

class Mongoid::StringifiedSymbol
  # Convert the object from its mongo friendly ruby type to this type.
  #
  # _@param_ `object` — The object to demongoize.
  #
  # _@return_ — The object.
  #
  # Demongoize the object.
  # ```ruby
  # Symbol.demongoize(object)
  # ```
  def self.demongoize: (Object object) -> Symbol

  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # _@param_ `object` — The object to mongoize.
  #
  # _@return_ — The object mongoized.
  #
  # Mongoize the object.
  # ```ruby
  # Symbol.mongoize("123.11")
  # ```
  def self.mongoize: (Object object) -> Symbol

  def self.evolve: (untyped object) -> untyped
end

# Object encapsulating logic for setting/getting a collection and database name
# and a client with particular options to use when persisting models.
#
# @since 6.0.0
class Mongoid::PersistenceContext
  extend Forwardable

  # Initialize the persistence context object.
  #
  # _@param_ `object` — The class or model instance for which a persistence context should be created.
  #
  # _@param_ `opts` — The persistence context options.
  #
  # Create a new persistence context.
  # ```ruby
  # PersistenceContext.new(model, collection: 'other')
  # ```
  def initialize: (Object object, ?::Hash[untyped, untyped] opts) -> void

  # sord warn - Mongo::Collection wasn't able to be resolved to a constant in this project
  # Get the collection for this persistence context.
  #
  # _@param_ `parent` — The parent object whose collection name is used instead of this persistence context's collection name.
  #
  # _@return_ — The collection for this persistence
  # context.
  #
  # Get the collection for this persistence context.
  # ```ruby
  # context.collection
  # ```
  def collection: (?Object? parent) -> Mongo::Collection

  # Get the collection name for this persistence context.
  #
  # _@return_ — The collection name for this persistence
  # context.
  #
  # Get the collection name for this persistence context.
  # ```ruby
  # context.collection_name
  # ```
  def collection_name: () -> String

  # Get the database name for this persistence context.
  #
  # _@return_ — The database name for this persistence
  # context.
  #
  # Get the database name for this persistence context.
  # ```ruby
  # context.database_name
  # ```
  def database_name: () -> String

  # sord warn - Mongo::Client wasn't able to be resolved to a constant in this project
  # Get the client for this persistence context.
  #
  # _@return_ — The client for this persistence
  # context.
  #
  # Get the client for this persistence context.
  # ```ruby
  # context.client
  # ```
  def client: () -> ::Client

  def client_name: () -> untyped

  # Determine if this persistence context is equal to another.
  #
  # _@param_ `other` — The object to be compared with this one.
  #
  # _@return_ — Whether the two persistence contexts are equal.
  #
  # Compare two persistence contexts.
  # ```ruby
  # context == other_context
  # ```
  def ==: (Object other) -> bool

  def set_options!: (untyped opts) -> untyped

  def __evaluate__: (untyped name) -> untyped

  def client_options: () -> untyped

  def database_name_option: () -> untyped

  # Set the persistence context for a particular class or model instance.
  #
  # If there already is a persistence context set, options in the existing
  # context are combined with options given to the set call.
  #
  # _@param_ `object` — The class or model instance.
  #
  # _@param_ `options_or_context` — The persistence options or a persistence context object.
  #
  # _@return_ — The persistence context for the object.
  #
  # Set the persistence context for a class or model instance.
  # ```ruby
  # PersistenceContext.set(model)
  # ```
  def self.set: (Object object, ::Hash[untyped, untyped] | Mongoid::PersistenceContext options_or_context) -> Mongoid::PersistenceContext

  # Get the persistence context for a particular class or model instance.
  #
  # _@param_ `object` — The class or model instance.
  #
  # _@return_ — The persistence context for the object.
  #
  # Get the persistence context for a class or model instance.
  # ```ruby
  # PersistenceContext.get(model)
  # ```
  def self.get: (Object object) -> Mongoid::PersistenceContext

  # sord warn - Mongo::Cluster wasn't able to be resolved to a constant in this project
  # Clear the persistence context for a particular class or model instance.
  #
  # _@param_ `object` — The class or model instance.
  #
  # _@param_ `cluster` — The original cluster before this context was used.
  #
  # _@param_ `original_context` — The original persistence context that was set before this context was used.
  #
  # Clear the persistence context for a class or model instance.
  # ```ruby
  # PersistenceContext.clear(model)
  # ```
  def self.clear: (Class | Object object, ?Mongo::Cluster? cluster, ?Mongoid::PersistenceContext? original_context) -> untyped
end

Mongoid::PersistenceContext::EXTRA_OPTIONS: untyped

Mongoid::PersistenceContext::VALID_OPTIONS: untyped

module Mongoid::Generators
end

class Mongoid::Generators::Base
  # The options defining this persistence context.
  #
  # _@return_ — The persistence context options.
  def self.source_root: () -> ::Hash[untyped, untyped]
                      | () -> untyped
end

class Mongoid::Generators::ModelGenerator < Mongoid::Generators::Base
  def create_model_file: () -> untyped
end

class Mongoid::Generators::ConfigGenerator
  def self.source_root: () -> untyped

  def app_name: () -> untyped

  def create_config_file: () -> untyped
end

module Mongoid::Railties
end

module Mongoid::Railties::ControllerRuntime
end

# This extension mimics the Rails' internal method to
# measure ActiveRecord runtime during request processing.
# It appends MongoDB runtime value (`mongoid_runtime`) into payload
# of instrumentation event `process_action.action_controller`.
module Mongoid::Railties::Mongoid::Railties::ControllerRuntime::ControllerExtension
  extend ActiveSupport::Concern

  # Reset the runtime before each action.
  def process_action: (untyped action, *untyped args) -> untyped

  # Override to collect the measurements.
  def cleanup_view_runtime: () -> untyped

  # Add the measurement to the instrumentation event payload.
  def append_info_to_payload: (untyped payload) -> untyped
end

module Mongoid::Railties::Mongoid::Railties::ControllerRuntime::Mongoid::Railties::Mongoid::Railties::ControllerRuntime::ControllerExtension::ClassMethods
  # Append MongoDB runtime information to ActionController runtime
  # log message.
  def log_process_action: (untyped payload) -> untyped
end

# The Collector of MongoDB runtime metric, that subscribes to Mongo
# driver command monitoring. Stores the value within a thread-local
# variable to provide correct accounting when an application issues
# MongoDB operations from background threads.
class Mongoid::Railties::Mongoid::Railties::ControllerRuntime::Collector
  def started: (untyped _) -> untyped

  def _completed: (untyped e) -> untyped

  def self.runtime: () -> untyped

  def self.runtime=: (untyped value) -> untyped

  def self.reset_runtime: () -> untyped
end

Mongoid::Railties::Mongoid::Railties::ControllerRuntime::Mongoid::Railties::Mongoid::Railties::ControllerRuntime::Collector::VARIABLE_NAME: untyped

module Rails
end

module Rails::Mongoid
  extend Rails::Mongoid

  # sord warn - Application wasn't able to be resolved to a constant in this project
  # Use the application configuration to get every model and require it, so
  # that indexing and inheritance work in both development and production
  # with the same results.
  #
  # _@param_ `app` — The rails application.
  #
  # Load all the application models.
  # ```ruby
  # Rails::Mongoid.load_models(app)
  # ```
  def load_models: (Application app) -> untyped

  # sord warn - Application wasn't able to be resolved to a constant in this project
  # Conditionally calls `Rails::Mongoid.load_models(app)` if the
  # `::Mongoid.preload_models` is `true`.
  #
  # _@param_ `app` — The rails application.
  def preload_models: (Application app) -> untyped

  # I don't want to mock out kernel for unit testing purposes, so added this
  # method as a convenience.
  #
  # _@param_ `file` — The base filename.
  #
  # Load the model.
  # ```ruby
  # Mongoid.load_model("/mongoid/behavior")
  # ```
  def load_model: (String file) -> untyped

  # sord warn - Application wasn't able to be resolved to a constant in this project
  # Use the application configuration to get every model and require it, so
  # that indexing and inheritance work in both development and production
  # with the same results.
  #
  # _@param_ `app` — The rails application.
  #
  # Load all the application models.
  # ```ruby
  # Rails::Mongoid.load_models(app)
  # ```
  def self.load_models: (Application app) -> untyped

  # sord warn - Application wasn't able to be resolved to a constant in this project
  # Conditionally calls `Rails::Mongoid.load_models(app)` if the
  # `::Mongoid.preload_models` is `true`.
  #
  # _@param_ `app` — The rails application.
  def self.preload_models: (Application app) -> untyped

  # I don't want to mock out kernel for unit testing purposes, so added this
  # method as a convenience.
  #
  # _@param_ `file` — The base filename.
  #
  # Load the model.
  # ```ruby
  # Mongoid.load_model("/mongoid/behavior")
  # ```
  def self.load_model: (String file) -> untyped
end

# Hooks Mongoid into Rails 3 and higher.
#
# @since 2.0.0
class Rails::Rails::Mongoid::Railtie
  # Mapping of rescued exceptions to HTTP responses
  #
  # @ return [Hash] rescued responses
  #
  # ```ruby
  # railtie.rescue_responses
  # ```
  def self.rescue_responses: () -> untyped

  # Rails runs all initializers first before getting into any generator
  # code, so we have no way in the intitializer to know if we are
  # generating a mongoid.yml. So instead of failing, we catch all the
  # errors and print them out.
  def handle_configuration_error: (untyped e) -> untyped
end

module Rails::Generators
end

class Rails::Rails::Generators::GeneratedAttribute
  def type_class: () -> untyped
end
